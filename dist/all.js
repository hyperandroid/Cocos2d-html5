/**
 * License: see license.txt file.
 */
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
 * @name cc
 * @namespace
 */
/**
 * Namespace for Action related objects.
 * @name action
 * @namespace
 * @memberOf cc
 */
/**
 * Namespace for math related stuff: vector, matrix, color, etc.
 * @name math
 * @namespace
 * @memberOf cc
 */
/**
 * Namespace for path related stuff: Segment, SegmentLine, SegmentBezier, etc.
 * @name path
 * @namespace
 * @memberOf cc.math
 */
/**
 * Namespace for Localization messages and utilities.
 * @name locale
 * @namespace
 * @memberOf cc
 */
/**
 * Namespace for Scene transitions.
 * @name transition
 * @namespace
 * @memberOf cc
 */
/**
 * Debug object.
 * @name Debug
 * @memberOf cc
 * @namespace
 */
/**
 * Namespace for nodes.
 * @name node
 * @namespace
 * @memberOf cc
 */
/**
 * Namespace for Sprite stuff
 * @name sprite
 * @namespace
 * @memberOf cc.node
 */
/**
 * Namespace for utilities.
 * @name util
 * @namespace
 * @memberOf cc
 */
/**
 * Namespace for render related objects.
 * @name render
 * @namespace
 * @memberOf cc
 */
/**
 * Namespace for renderer shader related objects.
 * @name shader
 * @namespace
 * @memberOf cc.render
 */
/**
 * Namespace for system plugins. Plugins are optional pieces of code.
 * @name plugin
 * @namespace
 * @memberOf cc
 */
/**
 * Namespace for resources management.
 * @name loader
 * @namespace
 * @memberOf cc.plugin
 */
/**
 * Namespace for in-game assets.
 * @name asset
 * @namespace
 * @memberOf cc.plugin
 */
/**
 * Namespace for texture related things like TexturePacker, etc.
 * @name texture
 * @namespace
 * @memberOf cc.plugin
 */
/**
 * Namespace for audio related objects.
 * @name audio
 * @memberOf cc.plugin
 * @namespace
 */
/**
 * Namespace for automatic node layout.
 * @name layout
 * @memberOf cc.plugin
 * @namespace
 */
/**
 * Namespace for input subsytem.
 * @name input
 * @namespace
 * @memberOf cc
 */
/**
 * Namespace for game subsytem.
 * @name game
 * @namespace
 * @memberOf cc
 */
/**
 * Namespace for widgets: buttons, labels, etc.
 * @name widget
 * @namespace
 * @memberOf cc
 */
var cc;
(function (cc) {
    (function () {
        console.log('%c', 'padding:140px 150px;line-height:300px;background:url(http://files.cocos2d-x.org/images/orgsite/logo.png) no-repeat;');
    })();
    (function () {
        var frameTime = 1000 / 60;
        var lastTime = new Date().getTime();
        var stTime = function (callback) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, frameTime - (currTime - lastTime));
            var id = window.setTimeout(function () {
                callback();
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
        var ctTime = function (id) {
            clearTimeout(id);
        };
        var win = window;
        win.requestAnimFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || stTime;
        win.cancelAnimationFrame = win.cancelAnimationFrame || win.cancelRequestAnimationFrame || win.msCancelRequestAnimationFrame || win.mozCancelRequestAnimationFrame || win.oCancelRequestAnimationFrame || win.webkitCancelRequestAnimationFrame || win.msCancelAnimationFrame || win.mozCancelAnimationFrame || win.webkitCancelAnimationFrame || win.oCancelAnimationFrame || ctTime;
    })();
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
var cc;
(function (cc) {
    var Debug;
    (function (Debug) {
        "use strict";
        /**
         * Runtime debug level.
         * if DEBUG, a error message will throw an exception.
         * in RELEASE, the exception is not thrown.
         *
         * @tsenum cc.Debug.RuntimeDebugLevel
         */
        (function (RuntimeDebugLevel) {
            RuntimeDebugLevel[RuntimeDebugLevel["DEBUG"] = 0] = "DEBUG";
            RuntimeDebugLevel[RuntimeDebugLevel["RELEASE"] = 1] = "RELEASE";
        })(Debug.RuntimeDebugLevel || (Debug.RuntimeDebugLevel = {}));
        var RuntimeDebugLevel = Debug.RuntimeDebugLevel;
        var enabled = true;
        function EnableConsole(b) {
            enabled = b;
        }
        Debug.EnableConsole = EnableConsole;
        /**
         * Current Runtime debug level. DEBUG by default.
         * @member cc.Debug.DEBUG_LEVEL
         * @type {RuntimeDebugLevel}
         */
        Debug.DEBUG_LEVEL = 0 /* DEBUG */;
        /**
         * Debug message levels.
         *
         * @tsenum cc.Debug.DebugLevel
         */
        (function (DebugLevel) {
            DebugLevel[DebugLevel["Info"] = 0] = "Info";
            DebugLevel[DebugLevel["Warning"] = 1] = "Warning";
            DebugLevel[DebugLevel["Error"] = 2] = "Error";
        })(Debug.DebugLevel || (Debug.DebugLevel = {}));
        var DebugLevel = Debug.DebugLevel;
        var __consoleDecoration = [
            "",
            "background: orange; color: #000",
            "background: #a00; color: #fff",
        ];
        var __defaultDecoration = "background: #fff; color: #000";
        /**
         * Show a message in the console.
         * @method cc.Debug.debug
         * @param level {cc.Debug.RuntimeDebugLevel} debug level criticism
         * @param msg {string} message to show
         * @param rest {Array<any>} other parameters to show in console.
         */
        function debug(level, msg, rest) {
            if (!enabled) {
                return;
            }
            console.log("%c%s:%c %s", __consoleDecoration[level], DebugLevel[level], __defaultDecoration, msg);
            if (rest.length) {
                console.log(rest);
            }
            if (level === 2 /* Error */ && Debug.DEBUG_LEVEL === 0 /* DEBUG */) {
                throw msg;
            }
        }
        Debug.debug = debug;
        /**
         * Show an error message.
         * @method cc.Debug.error
         * @param msg {string} error message.
         * @param rest {Array<any>} other elements to show in console.
         */
        function error(msg) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            cc.Debug.debug(2 /* Error */, msg, rest);
        }
        Debug.error = error;
        /**
         * Show a warning message.
         * @method cc.Debug.warn
         * @param msg {string} error message.
         * @param rest {Array<any>} other elements to show in console.
         */
        function warn(msg) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            cc.Debug.debug(1 /* Warning */, msg, rest);
        }
        Debug.warn = warn;
        /**
         * Show an info message.
         * @method cc.Debug.info
         * @param msg {string} error message.
         * @param rest {Array<any>} other elements to show in console.
         */
        function info(msg) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            cc.Debug.debug(0 /* Info */, msg, rest);
        }
        Debug.info = info;
    })(Debug = cc.Debug || (cc.Debug = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
var cc;
(function (cc) {
    var locale;
    (function (locale) {
        "use strict";
        //////////// Nodes
        /**
         * Calling removeFromParent and the Node has no parent.
         * @member cc.locale.NODE_WARN_REMOVEFROMPARENT_WITH_NO_PARENT
         * @type {string}
         */
        locale.NODE_WARN_REMOVEFROMPARENT_WITH_NO_PARENT = "Calling removeFromParent and the Node has no parent.";
        /**
         * Invalid pattern for naming.
         * @member cc.locale.ERR_NODE_NAME_INVALID
         * @type {string}
         */
        locale.ERR_NODE_NAME_INVALID = "Node name invalid. Must match [A-Za-z0-9_]+";
        /**
         * Invalid pattern for a call to <code>node.enumerateChildren</code>.
         * @member cc.locale.MSG_WRONG_ENUMERATE_PATTERN
         * @type {string}
         */
        locale.MSG_WRONG_ENUMERATE_PATTERN = "Wrongly defined search pattern path";
        /**
         * A call to <code>node.enumerateChildren</code> goes beyond root node.
         * @member cc.locale.MSG_ENUMERATE_UNDERFLOW
         * @type {string}
         */
        locale.MSG_ENUMERATE_UNDERFLOW = "Enumerate path underflow. Trying to go above root node.";
        /**
         * Trying to add a node with parent to another node.
         * @member cc.locale.MSG_ERROR_NODE_WITH_PARENT
         * @type {string}
         */
        locale.MSG_ERROR_NODE_WITH_PARENT = "A node added as child has already a parent.";
        /**
         * A call to <code>director.runScene</code> is made in an already running scene.
         * @member cc.locale.ERR_RUNNING_ALREADY_EXISTING_SCENE
         * @type {string}
         */
        locale.ERR_RUNNING_ALREADY_EXISTING_SCENE = "runScene trying to run already existing Scene.";
        /**
         * A call to <code>director.popScene</code> to an empty director.
         * @member cc.locale.ERR_DIRECTOR_POPSCENE_UNDERFLOW
         * @type {string}
         */
        locale.ERR_DIRECTOR_POPSCENE_UNDERFLOW = "Director popScene underflow.";
        /**
         * A call to <code>director.startAnimation</code> to a director in RUNNING state.
         * @member cc.locale.WARN_START_ANIMATION_ON_RUNNING_DIRECTOR
         * @type {string}
         */
        locale.WARN_START_ANIMATION_ON_RUNNING_DIRECTOR = "Starting animation on a running director.";
        locale.WARN_NODE_ATTRIBUTE_DOES_NOT_EXIST = "Attribute does not exist in Node object.";
        locale.WARN_DEPRECATED_SETBLENDFUNC = "Deprecated call. Use setCompositeOperation instead.";
        //////////// Path tracing
        /**
         * A call to an empty path.getCurrentTracePosition.
         * @member cc.locale.ERR_TRACER_EMPTY
         * @type {string}
         */
        locale.WARN_TRACER_EMPTY = "Path not initialized so no current trace position. Defaulting to (0,0).";
        /**
         * A tracing operation (lineTo, quadraticTo, etc.) is being performed in a closed SubPath.
         * @member cc.locale.WARN_TRACE_ON_CLOSED_SUBPATH
         * @type {string}
         */
        locale.WARN_TRACE_ON_CLOSED_SUBPATH = "Tracing on a closed SubPath.";
        /**
         * A closePath call is performed on an empty SubPath. No previous tracing happened on it.
         * @member cc.locale.WARN_CLOSE_EMPTY_SUBPATH
         * @type {string}
         */
        locale.WARN_CLOSE_EMPTY_SUBPATH = "Closing empty SubPath.";
        /**
         * A moveTo call is made to a SubPath with segments.
         * @member cc.locale.WARN_MOVETO_IN_NON_EMPTY_SUBPATH
         * @type {string}
         */
        locale.WARN_MOVETO_IN_NON_EMPTY_SUBPATH = "MoveTo in non empty SubPath.";
        /**
         * A getStartingPoint call is made to an empty SubPath.
         * @member cc.locale.ERR_SUBPATH_NOT_STARTED
         * @type {string}
         */
        locale.ERR_SUBPATH_NOT_STARTED = "getStartingPoint called in an empty path.";
        ///////////// Sprites
        /**
         * An operation is made in a SpriteFrame that has no associated texture.
         * @member cc.locale.ERR_SPRITE_FRAME_NO_TEXTURE
         * @type {string}
         */
        locale.ERR_SPRITE_FRAME_NO_TEXTURE = "SpriteFrame w/o Texture.";
        /**
         * Trying to create a new Sprite with wrong SpriteInitializer data.
         * @member cc.locale.ERR_SPRITE_CONSTRUCTOR_PARAM_ERROR
         * @type {string}
         */
        locale.ERR_SPRITE_CONSTRUCTOR_PARAM_ERROR = "No suitable SpriteInitializer to Sprite constructor.";
        /**
         * Calling Sprite constructor with V3 signature.
         * @member cc.locale.WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL
         * @type {string}
         */
        locale.WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL = "Sprite constructor call deprecated.";
        /**
         * Trying to create a add a SpriteFrame with an existing name in cache.
         * @member cc.locale.WARN_SPRITEFRAME_CREATING_SUBFRAME_WITH_EXISTING_NAME
         * @type {string}
         */
        locale.WARN_SPRITEFRAME_CREATING_SUBFRAME_WITH_EXISTING_NAME = "Adding a SpriteFrame with existing name in cache.";
        locale.SPRITEFRAME_WARN_TEXTURE_NOT_WEBGL_INITIALIZED = "Lazily initializing a webgl texture (at draw time).";
        ////////////// Resources
        /**
         * Loaded a resource of unknown type.
         * @member cc.locale.WARN_RESOURCE_OF_UNKNOWN_TYPE
         * @type {string}
         */
        locale.WARN_RESOURCE_OF_UNKNOWN_TYPE = "Loaded resource of unkown type.";
        locale.ASSETMANAGER_WARN_SPRITEFRAME_NOT_FOUND = "SpriteFrame with id not found.";
        locale.ERR_FONT_GLYPTH_NOT_IN_FRAME = "A glitph definition is not in Atlas Spriteframe area.";
        ////////////// Input
        locale.INPUT_WARN_WRONG_ROOT_NODE = "Adding a path to the wrong root node.";
        ////////////// Loader
        locale.LOADER_JSON_PARSE_ERROR = "JSON parse error while loading resource.";
        locale.WARN_FULLSCREEN_ERROR = "Full screen mode error.";
        ////////////// audio
        locale.ERR_SOUND_POOL_EMPTY = "Can't play, sound pool is empty.";
    })(locale = cc.locale || (cc.locale = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
var cc;
(function (cc) {
    var math;
    (function (math) {
        "use strict";
        /**
         * @class cc.math.Color
         * @classdesc
         *
         * A color is represented by 4 components: RGBA encapsulated in a Float32Array.
         * <br>
         * Internally, Color components are stored as normalized color values 0..1
         * <br>
         * This object has cache capabilities for internal color string representation so calling repeatedly
         * <code>getFillStyle</code>, <code>getHexRGB</code> and <code>getHexRGBA</code> will always be fast.
         */
        var Color = (function () {
            /**
             * Instantiate a color.
             * @method cc.math.Color#constructor
             * @param r {number} 0..1
             * @param g {number} 0..1
             * @param b {number} 0..1
             * @param a {number} 0..1
             */
            function Color(r, g, b, a) {
                if (r === void 0) { r = 1; }
                if (g === void 0) { g = 1; }
                if (b === void 0) { b = 1; }
                if (a === void 0) { a = 1; }
                /**
                 * Should rebuild canvas string representation cache ?
                 * @member cc.math.Color#_dirty
                 * @type {boolean}
                 * @private
                 */
                this._dirty = true;
                /**
                 * Should rebuild hex string representation cache ?
                 * @member cc.math.Color#_dirtyHex
                 * @type {boolean}
                 * @private
                 */
                this._dirtyHex = true;
                this._color = new Float32Array(4);
                this._color[0] = r;
                this._color[1] = g;
                this._color[2] = b;
                this._color[3] = a;
            }
            /**
             * Get the color's RGB representation.
             * @method cc.math.Color#getHexRGB
             * @returns {string} "#RRGGBB" color representation
             */
            Color.prototype.getHexRGB = function () {
                if (this._dirtyHex) {
                    this.__calculateHexStyle();
                }
                return this._hexRGB;
            };
            /**
             * Get the color's RGB representation.
             * @method cc.math.Color#getHexRGBA
             * @returns {string} "#RRGGBBAA" color representation
             */
            Color.prototype.getHexRGBA = function () {
                if (this._dirtyHex) {
                    this.__calculateHexStyle();
                }
                return this._hexRGBA;
            };
            /**
             * Internal helper to calculate hex string color representation.
             * @method cc.math.Color#__calculateHexStyle
             * @private
             */
            Color.prototype.__calculateHexStyle = function () {
                var r = ((255 * this._color[0]) >> 0).toString(16).toUpperCase();
                var g = ((255 * this._color[1]) >> 0).toString(16).toUpperCase();
                var b = ((255 * this._color[2]) >> 0).toString(16).toUpperCase();
                this._hexRGB = "#" + (r.length < 2 ? "0" : "") + r + (g.length < 2 ? "0" : "") + g + (b.length < 2 ? "0" : "") + b;
                var a = ((255 * this._color[3]) >> 0).toString(16).toUpperCase();
                this._hexRGBA = this._hexRGB + (a.length < 2 ? "0" : "") + a;
            };
            /**
             * Internal helper to calculate canvas string color representation.
             * @method cc.math.Color#__calculateFillStyle
             * @private
             */
            Color.prototype.__calculateFillStyle = function () {
                this._fillStyle = "rgba(" + ((this._color[0] * 255) >> 0) + "," + ((this._color[1] * 255) >> 0) + "," + ((this._color[2] * 255) >> 0) + "," + this._color[3] + ")";
                this._dirty = false;
            };
            /**
             * Get the color's canvas string representation.
             * If color changed, the string will be recalculated.
             * @method cc.math.Color#getFillStyle
             * @returns {string}
             */
            Color.prototype.getFillStyle = function () {
                if (this._dirty) {
                    this.__calculateFillStyle();
                }
                return this._fillStyle;
            };
            Object.defineProperty(Color.prototype, "r", {
                /**
                 * Get red color component.
                 * @name cc.math.Color#get:r
                 * @type {number}
                 */
                get: function () {
                    return this._color[0];
                },
                /**
                 * Set red color component.
                 * @name cc.math.Color#set:r
                 * @param v {number} red component. Should be in the range 0..1
                 */
                set: function (v) {
                    this._color[0] = v;
                    this._dirty = true;
                    this._dirtyHex = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "g", {
                /**
                 * Get green color component.
                 * @name cc.math.Color#get:g
                 * @type {number}
                 */
                get: function () {
                    return this._color[1];
                },
                /**
                 * Set green color component.
                 * @name cc.math.Color#set:g
                 * @param v {number} green component. Should be in the range 0..1
                 */
                set: function (v) {
                    this._color[1] = v;
                    this._dirty = true;
                    this._dirtyHex = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "b", {
                /**
                 * Get blue color component.
                 * @name cc.math.Color#get:b
                 * @type {number}
                 */
                get: function () {
                    return this._color[2];
                },
                /**
                 * Set blue color component.
                 * @name cc.math.Color#set:b
                 * @param v {number} blue component. Should be in the range 0..1
                 */
                set: function (v) {
                    this._color[2] = v;
                    this._dirty = true;
                    this._dirtyHex = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "a", {
                /**
                 * Get alpha color component.
                 * @name cc.math.Color#get:a
                 * @type {number}
                 */
                get: function () {
                    return this._color[3];
                },
                /**
                 * Set alpha color component.
                 * @name cc.math.Color#set:a
                 * @param v {number} alpha component. Should be in the range 0..1
                 */
                set: function (v) {
                    this._color[3] = v;
                    this._dirty = true;
                    this._dirtyHex = true;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Crate a Color instance from r,g,b,a or string or RGBAColor
             * @method cc.math.Color.createFromRGBA
             * @param r {cc.math.RGBAColor | string | number} if number, red color component. otherwise, color
             *      representation in string or cc.math.RGBAColor
             * @param g {number=} Color green component,
             * @param b {number=} Color blue component,
             * @param a {number=} Color alpha component,
             * @returns {cc.math.Color}
             */
            Color.createFromRGBA = function (r, g, b, a) {
                if (typeof r === "object") {
                    var c = r;
                    return new Color(c.r / 255, c.g / 255, c.b / 255, c.a / 255);
                }
                else if (typeof r === "number") {
                    return new Color(r / 255, g / 255, b / 255, a / 255);
                }
                else if (typeof r === "string") {
                    return Color.fromStringToColor(r);
                }
                return Color.WHITE;
            };
            /**
             * Parse a color of the from rgb(rrr,ggg,bbb) or rgba(rrr,ggg,bbb,a)
             * This method assumes the color parameter starts with rgb or rgba
             * @method cc.math.Color.fromRGBStringToColor
             * @param color {string}
             */
            Color.fromRGBStringToColor = function (color) {
                color = color.toLowerCase();
                var skip = 4;
                if (color.indexOf("rgba") === 0) {
                    skip = 5;
                }
                color = color.substring(skip, color.length - 1);
                var colors = color.split(",");
                var c;
                if (colors.length === 3) {
                    c = new Color(parseInt(colors[0]) / 255, parseInt(colors[1]) / 255, parseInt(colors[2]) / 255);
                }
                else {
                    c = new Color(parseInt(colors[0]) / 255, parseInt(colors[1]) / 255, parseInt(colors[2]) / 255, parseInt(colors[3]));
                }
                return c;
            };
            /**
             * Parse a CSS color. If the color is not recognizable will return MAGENTA;
             * @method cc.math.Color.fromStringToColor
             * @param hex {string} of the form RGB, RGBA, RRGGBB, RRGGBBAA, #RGB, #RGBA, #RRGGBB, #RRGGBBAA, rgb(rrr,ggg,bbb), rgba(rrr,ggg,bbb,a)
             * @returns {cc.math.Color}
             */
            Color.fromStringToColor = function (hex) {
                hex = hex.toLowerCase();
                if (hex.indexOf("rgb") === 0 || hex.indexOf("rgba") === 0) {
                    return Color.fromRGBStringToColor(hex);
                }
                if (hex.charAt(0) === "#") {
                    hex = hex.substring(1);
                }
                if (hex.length !== 3 && hex.length !== 4 && hex.length !== 6 && hex.length !== 8) {
                    return Color.MAGENTA;
                }
                var r, g, b, a;
                if (hex.length < 6) {
                    r = parseInt(hex.charAt(0), 16);
                    g = parseInt(hex.charAt(1), 16);
                    b = parseInt(hex.charAt(2), 16);
                    if (hex.length === 4) {
                        a = parseInt(hex.charAt(3), 16);
                    }
                    else {
                        a = 15;
                    }
                    return new Color(r / 15, g / 15, b / 15, a / 15);
                }
                else {
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                    // ALPHA
                    if (hex.length === 8) {
                        a = parseInt(hex.substring(6, 8), 16);
                    }
                    else {
                        a = 255;
                    }
                    return new Color(r / 255.0, g / 255.0, b / 255.0, a / 255.0);
                }
            };
            /**
             * Shamelessly ripped from: http://beesbuzz.biz/code/hsv_color_transforms.php
             * Thanks for the awesome code.
             *
             * Convert a color value based on HSV parameters.
             *
             * @param c {cc.math.Color}
             * @param H {number} angle
             * @param S {number}
             * @param V {number}
             * @returns {cc.math.Color} modified color.
             */
            Color.HSV = function (c, H, S, V) {
                var VSU = V * S * Math.cos(H * Math.PI / 180);
                var VSW = V * S * Math.sin(H * Math.PI / 180);
                var r = (.299 * V + .701 * VSU + .168 * VSW) * c.r + (.587 * V - .587 * VSU + .330 * VSW) * c.g + (.114 * V - .114 * VSU - .497 * VSW) * c.b;
                var g = (.299 * V - .299 * VSU - .328 * VSW) * c.r + (.587 * V + .413 * VSU + .035 * VSW) * c.g + (.114 * V - .114 * VSU + .292 * VSW) * c.b;
                var b = (.299 * V - .3 * VSU + 1.25 * VSW) * c.r + (.587 * V - .588 * VSU - 1.05 * VSW) * c.g + (.114 * V + .886 * VSU - .203 * VSW) * c.b;
                c.r = r;
                c.g = g;
                c.b = b;
                return c;
            };
            /**
             * Transparent black color.
             * @member cc.math.Color.TRANSPARENT_BLACK
             * @type {cc.math.Color}
             */
            Color.TRANSPARENT_BLACK = new Color(0, 0, 0, 0);
            /**
             * Opaque black color.
             * @member cc.math.Color.BLACK
             * @type {cc.math.Color}
             */
            Color.BLACK = new Color(0, 0, 0, 1.0);
            /**
             * Opaque red color.
             * @member cc.math.Color.RED
             * @type {cc.math.Color}
             */
            Color.RED = new Color(1.0, 0, 0, 1.0);
            /**
             * Opaque green color.
             * @member cc.math.Color.GREEN
             * @type {cc.math.Color}
             */
            Color.GREEN = new Color(0, 1.0, 0, 1.0);
            /**
             * Opaque blue color.
             * @member cc.math.Color.BLUE
             * @type {cc.math.Color}
             */
            Color.BLUE = new Color(0, 0, 1.0, 1.0);
            /**
             * Opaque white color.
             * @member cc.math.Color.WHITE
             * @type {cc.math.Color}
             */
            Color.WHITE = new Color(1.0, 1.0, 1.0, 1.0);
            /**
             * Opaque magenta color.
             * @member cc.math.Color.MAGENTA
             * @type {cc.math.Color}
             */
            Color.MAGENTA = new Color(1.0, 0, 1.0, 1.0);
            /**
             * Opaque yellow color.
             * @member cc.math.Color.YELLOW
             * @type {cc.math.Color}
             */
            Color.YELLOW = new Color(1.0, 1.0, 0, 1.0);
            /**
             * Opaque cyan color.
             * @member cc.math.Color.CYAN
             * @type {cc.math.Color}
             */
            Color.CYAN = new Color(0, 1.0, 1.0, 1.0);
            return Color;
        })();
        math.Color = Color;
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        "use strict";
        var __m0 = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        /**
         * @class cc.math.Matrix3
         *
         * @classdesc
         *
         * Affine transformation matrix Object.
         * <br>
         * The Matrix3 <strong>IS NOT</strong> a general purpose matrix calculation package. Do not use for anything else than affine
         * transformation purposes inside the Cocos2D HTML5 engine.
         */
        var Matrix3 = (function () {
            function Matrix3() {
            }
            /**
             * Build a new Matrix3 object.
             * @method cc.math.Matrix3#constructor
             */
            Matrix3.create = function () {
                var matrix = new Float32Array(9);
                Matrix3.identity(matrix);
                return matrix;
            };
            /**
             * Turn the matrix to identity.
             * @method cc.math.Matrix3.identity
             * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
             * @returns {cc.math.Matrix3}
             */
            Matrix3.identity = function (matrix) {
                matrix[0] = 1.0;
                matrix[1] = 0.0;
                matrix[2] = 0.0;
                matrix[3] = 0.0;
                matrix[4] = 1.0;
                matrix[5] = 0.0;
                matrix[6] = 0.0;
                matrix[7] = 0.0;
                matrix[8] = 1.0;
            };
            Matrix3.translateBy = function (matrix, dtx, dty) {
                var a = matrix[0];
                var b = matrix[1];
                var c = matrix[3];
                var d = matrix[4];
                var tx = matrix[2];
                var ty = matrix[5];
                matrix[2] = a * dtx + b * dty + tx;
                matrix[5] = c * dtx + d * dty + ty;
            };
            Matrix3.scaleBy = function (matrix, sx, sy) {
                matrix[0] *= sx;
                matrix[1] *= sy;
                matrix[3] *= sx;
                matrix[4] *= sy;
            };
            Matrix3.rotateBy = function (matrix, angle) {
                cc.math.Matrix3.setRotate(__m0, angle);
                cc.math.Matrix3.multiply(matrix, __m0);
            };
            /**
             * Copy a source to a destination matrix
             * @method cc.math.Matrix#copy
             * @param source {Float32Array} matrix coefficients. horizontal vectors.
             * @param destination {Float32Array} matrix coefficients. horizontal vectors.
             */
            Matrix3.copy = function (source, destination) {
                destination.set(source);
            };
            Matrix3.set = function (m, a, b, c, d, tx, ty) {
                m[0] = a;
                m[1] = b;
                m[2] = tx;
                m[3] = c;
                m[4] = d;
                m[5] = ty;
                m[6] = 0;
                m[7] = 0;
                m[8] = 1;
            };
            /**
             * Given a node, calculate a resulting matrix for position, scale and rotate.
             * @method cc.math.Matrix3.setTransformAll
             * @param mm {Float32Array} matrix coefficients. horizontal vectors.
             * @param node {cc.node.Node} a cc.node.Node instance
             */
            Matrix3.setTransformAll = function (mm, node) {
                var c, s, _m00, _m01, _m10, _m11;
                var m00, m01, m02, m10, m11, m12;
                m00 = 1.0;
                m01 = 0.0;
                m10 = 0.0;
                m11 = 1.0;
                var cs = node._contentSize;
                m02 = node.x - node._positionAnchor.x * cs.width;
                m12 = node.y - node._positionAnchor.y * cs.height;
                var rx = node._transformationAnchor.x * cs.width;
                var ry = node._transformationAnchor.y * cs.height;
                m02 += m00 * rx + m01 * ry;
                m12 += m10 * rx + m11 * ry;
                var angle = -node.rotationAngle * Math.PI / 180.0;
                c = Math.cos(angle);
                s = Math.sin(angle);
                _m00 = m00;
                _m01 = m01;
                _m10 = m10;
                _m11 = m11;
                m00 = _m00 * c + _m01 * s;
                m01 = -_m00 * s + _m01 * c;
                m10 = _m10 * c + _m11 * s;
                m11 = -_m10 * s + _m11 * c;
                m00 = m00 * node.scaleX;
                m01 = m01 * node.scaleY;
                m10 = m10 * node.scaleX;
                m11 = m11 * node.scaleY;
                m02 += -m00 * rx - m01 * ry;
                m12 += -m10 * rx - m11 * ry;
                mm[0] = m00;
                mm[1] = m01;
                mm[3] = m10;
                mm[4] = m11;
                mm[2] = m02;
                mm[5] = m12;
            };
            /**
             * Given a node, calculate a resulting matrix for position and scale.
             * @method cc.math.Matrix3.setTransformScale
             * @param mm {Float32Array} matrix coefficients. horizontal vectors.
             * @param node {cc.node.Node} a cc.node.Node instance
             */
            Matrix3.setTransformScale = function (mm, node) {
                var m00, m01, m02, m10, m11, m12;
                m00 = 1.0;
                m01 = 0.0;
                m10 = 0.0;
                m11 = 1.0;
                var cs = node._contentSize;
                m02 = node.x - node._positionAnchor.x * cs.width;
                m12 = node.y - node._positionAnchor.y * cs.height;
                var rx = node._transformationAnchor.x * cs.width;
                var ry = node._transformationAnchor.y * cs.height;
                m02 += m00 * rx + m01 * ry;
                m12 += m10 * rx + m11 * ry;
                m00 = m00 * node.scaleX;
                m01 = m01 * node.scaleY;
                m10 = m10 * node.scaleX;
                m11 = m11 * node.scaleY;
                m02 += -m00 * rx - m01 * ry;
                m12 += -m10 * rx - m11 * ry;
                mm[0] = m00;
                mm[1] = m01;
                mm[3] = m10;
                mm[4] = m11;
                mm[2] = m02;
                mm[5] = m12;
            };
            /**
             * Given a node, calculate a resulting matrix for position.
             * @method cc.math.Matrix3.setTransformTranslate
             * @param mm {Float32Array} matrix coefficients. horizontal vectors.
             * @param node {cc.node.Node} a cc.node.Node instance
             */
            Matrix3.setTransformTranslate = function (mm, node) {
                var pa = node._positionAnchor;
                var cs = node._contentSize;
                var x = node.x - pa.x * cs.width;
                var y = node.y - pa.y * cs.height;
                mm[2] = x;
                mm[5] = y;
                mm[0] = 1.0;
                mm[1] = 0.0;
                mm[3] = 0.0;
                mm[4] = 1.0;
                mm[6] = 0.0;
                mm[7] = 0.0;
                mm[8] = 1.0;
            };
            /**
             * Multiply matrix m0 by matrix m1. modify m0.
             * <br>
             * Both matrices must be Matrix3 instances.
             * @method cc.math.Matrix3.multiply
             * @param m0 {Float32Array} matrix coefficients. horizontal vectors.
             * @param m1 {Float32Array} matrix coefficients. horizontal vectors.
             */
            Matrix3.multiply = function (m0, m1) {
                var mm0 = m1[0];
                var mm1 = m1[1];
                var mm2 = m1[2];
                var mm3 = m1[3];
                var mm4 = m1[4];
                var mm5 = m1[5];
                var tm0 = m0[0];
                var tm1 = m0[1];
                var tm2 = m0[2];
                m0[0] = tm0 * mm0 + tm1 * mm3;
                m0[1] = tm0 * mm1 + tm1 * mm4;
                m0[2] = tm0 * mm2 + tm1 * mm5 + tm2;
                var tm3 = m0[3];
                var tm4 = m0[4];
                var tm5 = m0[5];
                m0[3] = tm3 * mm0 + tm4 * mm3;
                m0[4] = tm3 * mm1 + tm4 * mm4;
                m0[5] = tm3 * mm2 + tm4 * mm5 + tm5;
                m0[6] = 0;
                m0[7] = 0;
                m0[8] = 1;
            };
            Matrix3.premultiply = function (m1, m0) {
                var mm0 = m1[0];
                var mm1 = m1[1];
                var mm2 = m1[2];
                var mm3 = m1[3];
                var mm4 = m1[4];
                var mm5 = m1[5];
                var tm0 = m0[0];
                var tm1 = m0[1];
                var tm2 = m0[2];
                __m0[0] = tm0 * mm0 + tm1 * mm3;
                __m0[1] = tm0 * mm1 + tm1 * mm4;
                __m0[2] = tm0 * mm2 + tm1 * mm5 + tm2;
                var tm3 = m0[3];
                var tm4 = m0[4];
                var tm5 = m0[5];
                __m0[3] = tm3 * mm0 + tm4 * mm3;
                __m0[4] = tm3 * mm1 + tm4 * mm4;
                __m0[5] = tm3 * mm2 + tm4 * mm5 + tm5;
                __m0[6] = 0;
                __m0[7] = 0;
                __m0[8] = 1;
                cc.math.Matrix3.copy(__m0, m1);
            };
            /**
             * Transform a point by the matrix.
             * <br>
             * The point will be overwritten by the resulting point.
             * @method cc.math.Matrix3.transformPoint
             * @param tm {Float32Array} matrix coefficients. horizontal vectors.
             * @param point {cc.math.Point} Point or Vector to transform.
             */
            Matrix3.transformPoint = function (tm, point) {
                var x;
                var y;
                x = point.x;
                y = point.y;
                point.x = x * tm[0] + y * tm[1] + tm[2];
                point.y = x * tm[3] + y * tm[4] + tm[5];
                return point;
            };
            /**
             * Set transformation coefficients for a RenderingContext.
             * @method cc.math.Matrix3.setRenderingContextTransform
             * @param mm {Float32Array} matrix coefficients. horizontal vectors.
             * @param ctx {cc.render.RenderingContext} a rendering context.
             */
            Matrix3.setRenderingContextTransform = function (mm, ctx) {
                // TODO: set optional clamping capabilities. old mobile browsers.
                ctx.setTransform(mm[0], mm[3], mm[1], mm[4], mm[2], mm[5]);
            };
            /**
             * Set the matrix as follows
             * [ a b x ]
             * | c d y |
             * [ 0 0 1 ]
             * @method cc.math.Matrix3.setTransform
             * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
             * @param a {number}
             * @param b {number}
             * @param c {number}
             * @param d {number}
             * @param tx {number}
             * @param ty {number}
             */
            Matrix3.setTransform = function (matrix, a, b, c, d, tx, ty) {
                matrix[0] = a;
                matrix[3] = b;
                matrix[1] = c;
                matrix[4] = d;
                matrix[2] = tx;
                matrix[5] = ty;
                matrix[6] = 0;
                matrix[7] = 0;
                matrix[8] = 1;
            };
            /**
             * Concatenate the matrix with another matrix build of the coefficients set as parameters.
             * @method cc.math.Matrix3.transform
             * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
             * @param a {number}
             * @param b {number}
             * @param c {number}
             * @param d {number}
             * @param tx {number}
             * @param ty {number}
             */
            Matrix3.transform = function (matrix, a, b, c, d, tx, ty) {
                Matrix3.setTransform(_workingMatrix, a, b, c, d, tx, ty);
                Matrix3.multiply(matrix, _workingMatrix);
            };
            /**
             * Make the matrix a translation matrix.
             * @method cc.math.Matrix3.setTranslate
             * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
             * @param x {number}
             * @param y {number}
             * @returns {cc.math.Matrix3} the same matrix.
             */
            Matrix3.setTranslate = function (matrix, x, y) {
                Matrix3.identity(matrix);
                matrix[2] = x;
                matrix[5] = y;
            };
            /**
             * Make the matrix a rotation matrix.
             * @method cc.math.Matrix3.setRotate
             * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
             * @param angle {number} angle in radians.
             * @returns {cc.math.Matrix3} the same matrix.
             */
            Matrix3.setRotate = function (matrix, angle) {
                Matrix3.identity(matrix);
                matrix[0] = Math.cos(angle);
                matrix[1] = -Math.sin(angle);
                matrix[3] = Math.sin(angle);
                matrix[4] = Math.cos(angle);
            };
            /**
             * Make the matrix a scale matrix.
             * @method cc.math.Matrix3.setScale
             * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
             * @param x
             * @param y
             * @returns {cc.math.Matrix3}
             */
            Matrix3.setScale = function (matrix, x, y) {
                Matrix3.identity(matrix);
                matrix[0] = x;
                matrix[4] = y;
            };
            Matrix3.inverse = function (matrix, res) {
                var m00 = matrix[0];
                var m01 = matrix[1];
                var m02 = matrix[2];
                var m10 = matrix[3];
                var m11 = matrix[4];
                var m12 = matrix[5];
                var m20 = matrix[6];
                var m21 = matrix[7];
                var m22 = matrix[8];
                var determinant = m00 * (m11 * m22 - m21 * m12) - m10 * (m01 * m22 - m21 * m02) + m20 * (m01 * m12 - m11 * m02);
                if (determinant === 0) {
                    return Matrix3.identity(Matrix3.IDENTITY);
                }
                determinant = 1 / determinant;
                res[0] = (m11 * m22 - m12 * m21) * determinant;
                res[1] = (m02 * m21 - m01 * m22) * determinant;
                res[2] = (m01 * m12 - m02 * m11) * determinant;
                res[3] = (m12 * m20 - m10 * m22) * determinant;
                res[4] = (m00 * m22 - m02 * m20) * determinant;
                res[5] = (m02 * m10 - m00 * m12) * determinant;
                res[6] = (m10 * m21 - m11 * m20) * determinant;
                res[7] = (m01 * m20 - m00 * m21) * determinant;
                res[8] = (m00 * m11 - m01 * m10) * determinant;
            };
            /**
             * An identity Matrix3 static instance.
             * @member cc.math.Matrix3.IDENTITY
             * @type {cc.math.Matrix3}
             */
            Matrix3.IDENTITY = Matrix3.create();
            return Matrix3;
        })();
        math.Matrix3 = Matrix3;
        /**
         * Spare working matrix.
         * @member cc.math.Matrix3._workingMatrix
         * @type {cc.math.Matrix3}
         * @private
         */
        var _workingMatrix = cc.math.Matrix3.create();
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
var cc;
(function (cc) {
    var math;
    (function (math) {
        var Matrix4 = (function () {
            function Matrix4() {
                this._matrix = new Float32Array(16);
            }
            return Matrix4;
        })();
        math.Matrix4 = Matrix4;
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
var cc;
(function (cc) {
    var math;
    (function (math) {
        "use strict";
        /**
         * @class cc.math.Vector
         * @classdesc
         *
         * Object represents a 2D or 3D vector.
         */
        var Vector = (function () {
            /**
             * Point x coordinate.
             * @member cc.math.Vector#x
             * @type {number}
             */
            /**
             * Point y coordinate.
             * @member cc.math.Vector#y
             * @type {number}
             */
            /**
             * Point z coordinate.
             * @member cc.math.Vector#z
             * @type {number}
             */
            /**
             * @method cc.math.Vector#constructor
             * @param x {number} vector x coordinate
             * @param y {number} vector y coordinate
             * @param z {number} vector z coordinate. if not set zero by default.
             */
            function Vector(x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                this.x = x;
                this.y = y;
                this.z = z;
            }
            /**
             * Set a Vector with new values.
             *
             * @method cc.math.Vector#set
             * @param x {number} vector x coordinate
             * @param y {number} vector y coordinate
             * @param z {number=} vector z coordinate. if not set zero by default.
             * @returns {cc.math.Vector}
             */
            Vector.prototype.set = function (x, y) {
                this.x = x;
                this.y = y;
                this.z = 0;
                return this;
            };
            /**
             * get the vector length.
             * @returns {number}
             */
            Vector.prototype.length = function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            };
            /**
             * get the vector angle.
             * @returns {number}
             */
            Vector.prototype.angle = function () {
                return Math.atan2(this.y, this.x);
            };
            Vector.prototype.normalize = function () {
                var l = this.length();
                this.x /= l;
                this.y /= l;
                return this;
            };
            /**
             * Calculate distance from the vector to another vector.
             * @param v {cc.math.Vector}
             * @returns {number}
             */
            Vector.prototype.distance = function (v) {
                return Vector.distance(this, v);
            };
            /**
             * Substract a vector from this vector.
             * @param v {cc.math.Vector}
             */
            Vector.prototype.sub = function (v) {
                this.x -= v.x;
                this.y -= v.y;
                return this;
            };
            /**
             * Add a vector from this vector.
             * @param v {cc.math.Vector}
             */
            Vector.prototype.add = function (v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            };
            /**
             * Multiply the vector by a scalar.
             * @param v {number}
             * @returns {cc.math.Vector}
             */
            Vector.prototype.mult = function (v) {
                this.x *= v;
                this.y *= v;
                this.z *= v;
                return this;
            };
            Vector.add = function (v0, v1) {
                return new Vector(v1.x + v0.x, v1.y + v0.y);
            };
            /**
             * Create a Vector with the substraction of two vectors.
             * @param v0 {cc.math.Vector}
             * @param v1 {cc.math.Vector}
             * @returns {Vector}
             */
            Vector.sub = function (v0, v1) {
                return new Vector(v1.x - v0.x, v1.y - v0.y);
            };
            /**
             * Calculate the distance between two vectors
             * @param v0 {cc.math.Vector}
             * @param v1 {cc.math.Vector}
             * @returns {number} distance between vectors.
             */
            Vector.distance = function (v0, v1) {
                var dx = v1.x - v0.x;
                var dy = v1.y - v0.y;
                return Math.sqrt(dx * dx + dy * dy);
            };
            Vector.angleWith = function (p0, p1) {
                var x = p1.x - p0.x;
                var y = p1.y - p0.y;
                return Math.atan2(y, x);
            };
            Vector.middlePoint = function (p0, p1) {
                var x = (p1.x + p0.x) / 2;
                var y = (p1.y + p0.y) / 2;
                return new Vector(x, y);
            };
            /**
             * Compare the vector with another vector for equality.
             * @param v {cc.math.Vector}
             * @returns {boolean}
             */
            Vector.prototype.equals = function (v) {
                return this.x === v.x && this.y === v.y;
            };
            /**
             * Create a new Vetor copy of this vector.
             * @returns {cc.math.Vector}
             */
            Vector.prototype.clone = function () {
                return new Vector(this.x, this.y, this.z);
            };
            return Vector;
        })();
        math.Vector = Vector;
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./Point.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        "use strict";
        /**
         * @class cc.math.Rectangle
         * @classdesc
         *
         * Rectangle Object.
         */
        var Rectangle = (function () {
            /**
             * Left-top x coordinate
             * @member cc.math.Rectangle#x
             * @type {number}
             */
            /**
             * Left-top y coordinate
             * @member cc.math.Rectangle#y
             * @type {number}
             */
            /**
             * Rectangle width
             * @member cc.math.Rectangle#w
             * @type {number}
             */
            /**
             * Rectangle height
             * @member cc.math.Rectangle#h
             * @type {number}
             */
            /**
             * Build a new Rectangle instance.
             * @method cc.math.Rectangle#constructor
             * @param x {number=} 'left' corner x coordinate.
             * @param y {number=} 'left' corner y coordinate.
             * @param w {number=} rectangle width.
             * @param h {number=} rectangle height.
             */
            function Rectangle(x, y, w, h) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (w === void 0) { w = 0; }
                if (h === void 0) { h = 0; }
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                /**
                 * 'right' corner x coord.
                 * @member cc.math.Rectangle#x1
                 * @type {number}
                 */
                this.x1 = 0;
                /**
                 * 'right' corner y coord.
                 * @member cc.math.Rectangle#y1
                 * @type {number}
                 */
                this.y1 = 0;
                this.set(x, y, w, h);
            }
            /**
             * Overwrite the rectangle's coordinates with new values.
             * @method cc.math.Rectangle#set
             * @param x {number} rectangle position x coordinate
             * @param y {number} rectangle position y coordinate
             * @param w {number} rectangle width
             * @param h {number} rectangle height
             * @returns {cc.math.Rectangle} the rectangle instance.
             */
            Rectangle.prototype.set = function (x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.x1 = x + w;
                this.y1 = y + h;
                return this;
            };
            /**
             * Get whether a Rectangle intersects with this rectangle.
             * @method cc.math.Rectangle#intersects
             * @param r {cc.math.Rectangle}
             * @returns {*}
             */
            Rectangle.prototype.intersectsWith = function (r) {
                return this.intersects(r.x, r.y, r.w, r.h);
            };
            /**
             * Gets whether a rectangle of given dimension is inside the rectangle.
             * @method cc.math.Rectangle#intersects
             * @param x {number|Rectangle}
             * @param y {number}
             * @param w {number}
             * @param h {number}
             * @returns {boolean}
             */
            Rectangle.prototype.intersects = function (x, y, w, h) {
                if (this.x1 < x) {
                    return false;
                }
                if (this.y1 < y) {
                    return false;
                }
                if (this.x >= x + w) {
                    return false;
                }
                if (this.y >= y + h) {
                    return false;
                }
                return true;
            };
            /**
             * Normalize the rectangle's dimension with the given width and height.
             * @param w {number}
             * @param h {number}
             * @returns {cc.math.Rectangle} reference to this.
             */
            Rectangle.prototype.normalizeBy = function (w, h) {
                this.x /= w;
                this.y /= h;
                this.x1 /= w;
                this.y1 /= h;
                this.w /= w;
                this.h /= h;
                return this;
            };
            /**
             * Set the Rectangle with zero size.
             * @method cc.math.Rectangle#setEmpty
             */
            Rectangle.prototype.setEmpty = function () {
                this.x = 0;
                this.y = 0;
                this.x1 = 0;
                this.y1 = 0;
                this.w = 0;
                this.h = 0;
            };
            Rectangle.prototype.translate = function (x, y) {
                this.x += x;
                this.y += y;
                this.x1 += x;
                this.y1 += y;
                return this;
            };
            /**
             * Test whether the Rectangle is empty, eg either its width or height is zero.
             * @method cc.math.Rectangle#isEmpty
             * @returns {boolean}
             */
            Rectangle.prototype.isEmpty = function () {
                return this.w === 0 || this.h === 0;
            };
            /**
             * Intersect this rectangle with the parameter Rectangle.
             * @param r {cc.math.Rectangle}
             * @return {cc.math.Rectangle} reference to this.
             */
            Rectangle.prototype.intersectWith = function (r) {
                if (this.intersectsWith(r)) {
                    if (this.x < r.x) {
                        this.w -= r.x - this.x;
                        this.x = r.x;
                    }
                    if (this.y < r.y) {
                        this.h -= r.y - this.y;
                        this.y = r.y;
                    }
                    if (this.w > r.w) {
                        this.w = r.w;
                    }
                    if (this.h > r.h) {
                        this.h = r.h;
                    }
                    this.x1 = this.x + this.w;
                    this.y1 = this.y + this.h;
                }
                else {
                    this.setEmpty();
                }
                return this;
            };
            Rectangle.prototype.contains = function (x, y) {
                var tx;
                var ty;
                if (typeof x !== "number") {
                    var v = x;
                    tx = v.x;
                    ty = v.y;
                }
                else {
                    tx = x;
                    ty = y;
                }
                return tx >= this.x && ty >= this.y && tx < this.x1 && ty < this.y1;
            };
            Object.defineProperty(Rectangle.prototype, "width", {
                get: function () {
                    return this.w;
                },
                set: function (w) {
                    this.w = w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "height", {
                get: function () {
                    return this.h;
                },
                set: function (h) {
                    this.h = h;
                },
                enumerable: true,
                configurable: true
            });
            return Rectangle;
        })();
        math.Rectangle = Rectangle;
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
var cc;
(function (cc) {
    var math;
    (function (math) {
        /**
         * @class cc.math.Dimension
         * @classdesc
         *
         * This Class is for dimension definition.
         */
        var Dimension = (function () {
            /**
             * Dimension width.
             * @member cc.math.Dimension#width
             * @type {number}
             * @public
             */
            /**
             * Dimension height.
             * @member cc.math.Dimension#height
             * @type {number}
             * @public
             */
            /**
             * Build a new Dimension instance.
             * @method cc.math.Dimension#constructor
             * @param width {number}
             * @param height {number}
             */
            function Dimension(width, height) {
                if (width === void 0) { width = 0; }
                if (height === void 0) { height = 0; }
                this.width = width;
                this.height = height;
            }
            /**
             * Set the dimension.
             * @param w {any}
             * @param h {number}
             * @returns {cc.math.Dimension}
             */
            Dimension.prototype.set = function (w, h) {
                if (typeof w === 'number') {
                    this.width = w;
                    this.height = h;
                }
                else {
                    var d = w;
                    this.width = d.width;
                    this.height = d.height;
                }
                return this;
            };
            Dimension.prototype.clone = function () {
                return new Dimension(this.width, this.height);
            };
            return Dimension;
        })();
        math.Dimension = Dimension;
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * Created by ibon on 11/20/14.
 */
/// <reference path="../Point.ts"/>
/// <reference path="../Matrix3.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../locale/Locale.ts"/>
/// <reference path="./ContainerSegment.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var path;
        (function (path) {
            var Vector = cc.math.Vector;
            var Matrix3 = cc.math.Matrix3;
            path.DEFAULT_TRACE_LENGTH = 50;
            var __v0 = new Vector();
            var __v1 = new Vector();
            /**
             * Calculate a vector based on a distance and a matrix.
             * @param distance
             * @param matrix
             * @returns {Vector}
             */
            function getDistanceVector(distance, matrix) {
                __v0.set(0, 0);
                __v1.set(distance, 0);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                    Matrix3.transformPoint(matrix, __v1);
                }
                return __v1.sub(__v0);
            }
            path.getDistanceVector = getDistanceVector;
        })(path = math.path || (math.path = {}));
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var path;
        (function (path) {
            var Vector = cc.math.Vector;
            var __v = new Vector();
            /**
             *
             * @class cc.math.path.SegmentLine
             * @implements cc.math.path.Segment
             * @classdesc
             *
             * Objects of this type represent a line segment.
             * Line segments are added to a Path by calling <code>path.lineTo(x,y)</code>.
             *
             */
            var SegmentLine = (function () {
                /**
                 * Build a new SegmentLine instance.
                 * @method cc.math.path.SegmentLine#constructor
                 * @param data {SegmentLineInitializer=}
                 */
                function SegmentLine(data) {
                    /**
                     * Parent Segment. An instance of <code>ContainerSegment</code>
                     * @member cc.math.path.SegmentLine
                     * @type {cc.math.path.Segment}
                     * @private
                     */
                    this._parent = null;
                    /**
                     * The line segment length.
                     * @member cc.math.path.SegmentLine#_length
                     * @type {number}
                     * @private
                     */
                    this._length = 0;
                    this._dirty = true;
                    if (data) {
                        this.initialize(data.start, data.end);
                    }
                }
                /**
                 * Get the Segment's parent Segment.
                 * @method cc.math.path.SegmentLine#getParent
                 * @returns {cc.math.path.Segment}
                 */
                SegmentLine.prototype.getParent = function () {
                    return this._parent;
                };
                /**
                 * Set the Segment's parent Segment.
                 * @method cc.math.path.SegmentLine#setParent
                 * @param s {cc.math.path.Segment}
                 */
                SegmentLine.prototype.setParent = function (s) {
                    this._parent = s;
                };
                /**
                 * Initialize this segment points.
                 * This method takes the supplied point references, does not build new points.
                 * @method cc.math.path.SegmentLine#setPoints
                 * @param start {cc.math.Point} start line point.
                 * @param end {cc.math.Point} end line point.
                 */
                SegmentLine.prototype.initialize = function (start, end) {
                    this._start = new Vector(start.x, start.y);
                    this._end = new Vector(end.x, end.y);
                    this.__calculateLength();
                };
                SegmentLine.prototype.__calculateLength = function () {
                    this._length = Math.sqrt((this._start.x - this._end.x) * (this._start.x - this._end.x) + (this._start.y - this._end.y) * (this._start.y - this._end.y));
                    this._dirty = false;
                };
                /**
                 * Get the line length.
                 * @override
                 * @method cc.math.path.SegmentLine#getLength
                 * @returns {number}
                 */
                SegmentLine.prototype.getLength = function () {
                    return this._length;
                };
                /**
                 * Sample some points on the line segment.
                 * This implementation only samples two points, initial and final.
                 * It returns the points that conform the line, if they are changed, the line will be changed as well.
                 * @method cc.math.path.SegmentLine#trace
                 * @param numPoints {number=} number of points traced on the segment.
                 * @param dstArray {Array<cc.math.Vector>=} array where to add the traced points.
                 * @returns {Array<Vector>} returns the supplied array of points, or a new array of points if not set.
                 */
                SegmentLine.prototype.trace = function (dstArray, numPoints) {
                    dstArray = dstArray || [];
                    dstArray.push(this._start);
                    dstArray.push(this._end);
                    return dstArray;
                };
                /**
                 * Get a point on the line at the given proportional position.
                 * @param normalizedPos {number} value in the range 0..1
                 * @param out {cc.math.Vector=} optional out point. if not set, an internal spare point will be used.
                 * @returns {cc.math.Vector} a point on the segment at the given position. This point should be copied,
                 * successive calls to getValue will return the same point instance.
                 */
                SegmentLine.prototype.getValueAt = function (normalizedPos, out) {
                    out = out || new cc.math.Vector();
                    out.x = (this._end.x - this._start.x) * normalizedPos + this._start.x;
                    out.y = (this._end.y - this._start.y) * normalizedPos + this._start.y;
                    return out;
                };
                /**
                 * Get the Segment's starting point.
                 * It returns the original starting Point reference, not a copy of it.
                 * @returns {cc.math.Vector}
                 */
                SegmentLine.prototype.getStartingPoint = function () {
                    return this._start;
                };
                /**
                 * Get the Segment's ending point.
                 * It returns the original starting Point reference, not a copy of it.
                 * @returns {cc.math.Vector}
                 */
                SegmentLine.prototype.getEndingPoint = function () {
                    return this._end;
                };
                /**
                 * Make a clone of the segment.
                 * @method cc.math.path.SegmentLine#clone
                 * @returns {cc.math.path.Segment}
                 */
                SegmentLine.prototype.clone = function () {
                    var sl = new SegmentLine({
                        start: {
                            x: this._start.x,
                            y: this._start.y
                        },
                        end: {
                            x: this._end.x,
                            y: this._end.y
                        }
                    });
                    sl._length = this._length;
                    return this;
                };
                /**
                 * Add this Segment control points to the array.
                 * If the array is not set, a new one will be created.
                 * The actual Segment points are added, so modifying them means modifying the path.
                 * @method cc.math.path.SegmentLine#getControlPoints
                 * @param arr {Array<cc.math.Vector>}
                 * @returns {Array<cc.math.Vector>}
                 */
                SegmentLine.prototype.getControlPoints = function (arr) {
                    arr = arr || [];
                    arr.push(this._start);
                    arr.push(this._end);
                    return arr;
                };
                /**
                 * Mark the Segment dirty.
                 * No action for lines.
                 * @methodcc.math.path.SegmentLine#setDirty
                 */
                /**
                 * Mark the Segment dirty.
                 * No action for Arcs.
                 * @method cc.math.path.ContainerSegment#setDirty
                 */
                SegmentLine.prototype.setDirty = function (d) {
                    this._dirty = d;
                    var p = this._parent;
                    while (p) {
                        p.setDirty(d);
                        p = p._parent;
                    }
                };
                SegmentLine.prototype.paint = function (ctx) {
                    ctx.beginPath();
                    ctx.moveTo(this._start.x, this._start.y);
                    ctx.lineTo(this._end.x, this._end.y);
                    ctx.stroke();
                };
                return SegmentLine;
            })();
            path.SegmentLine = SegmentLine;
        })(path = math.path || (math.path = {}));
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../Point.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var path;
        (function (path) {
            "use strict";
            var Vector = cc.math.Vector;
            /**
             *
             * Original source:
             * http://www.antigrain.com/research/adaptive_bezier/index.html
             *
             */
            /**
             * Recursion limit to calculate curve.
             * @type {number}
             */
            var curve_recursion_limit = 8;
            /**
             * 0.2 when stroking is on lines > 1px in width.
             * You set it in radians. The less this value is the more accurate will be the approximation at sharp turns.
             * But 0 means that we don't consider angle conditions at all.
             * @type {number}
             */
            var m_angle_tolerance = 0.2;
            /**
             * should not exceed 10-15 degrees (in radians)
             * @type {number}
             */
            var m_cusp_limit = 15 * Math.PI / 180;
            /**
             * worlModelView scale factor. (1 by default)
             * @type {number}
             */
            var m_approximation_scale = 1;
            /**
             * colinearity threshold.
             * @type {number}
             */
            var curve_collinearity_epsilon = 0.001;
            /**
             *
             * @type {number}
             */
            var curve_angle_tolerance_epsilon = 0;
            /**
             * calculated by m_approximation_scale
             * @type {number}
             */
            var m_distance_tolerance = 0.0001;
            function __recursive_bezier(points, x1, y1, x2, y2, x3, y3, x4, y4, level) {
                if (level > curve_recursion_limit) {
                    return;
                }
                // Calculate all the mid-points of the line segments
                //----------------------
                var x12 = (x1 + x2) / 2;
                var y12 = (y1 + y2) / 2;
                var x23 = (x2 + x3) / 2;
                var y23 = (y2 + y3) / 2;
                var x34 = (x3 + x4) / 2;
                var y34 = (y3 + y4) / 2;
                var x123 = (x12 + x23) / 2;
                var y123 = (y12 + y23) / 2;
                var x234 = (x23 + x34) / 2;
                var y234 = (y23 + y34) / 2;
                var x1234 = (x123 + x234) / 2;
                var y1234 = (y123 + y234) / 2;
                if (level > 0) {
                    // Try to approximate the full cubic curve by a single straight line
                    //------------------
                    var dx = x4 - x1;
                    var dy = y4 - y1;
                    var d2 = Math.abs(((x2 - x4) * dy - (y2 - y4) * dx));
                    var d3 = Math.abs(((x3 - x4) * dy - (y3 - y4) * dx));
                    var da1, da2;
                    if (d2 > curve_collinearity_epsilon && d3 > curve_collinearity_epsilon) {
                        // Regular care
                        //-----------------
                        if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance * (dx * dx + dy * dy)) {
                            // If the curvature doesn't exceed the distance_tolerance value
                            // we tend to finish subdivisions.
                            //----------------------
                            if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
                                points.push(new Vector(x1234, y1234));
                                return;
                            }
                            // Angle & Cusp Condition
                            //----------------------
                            var a23 = Math.atan2(y3 - y2, x3 - x2);
                            da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
                            da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
                            if (da1 >= Math.PI)
                                da1 = 2 * Math.PI - da1;
                            if (da2 >= Math.PI)
                                da2 = 2 * Math.PI - da2;
                            if (da1 + da2 < m_angle_tolerance) {
                                // Finally we can stop the recursion
                                //----------------------
                                points.push(new Vector(x1234, y1234));
                                return;
                            }
                            if (m_cusp_limit !== 0.0) {
                                if (da1 > m_cusp_limit) {
                                    points.push(new Vector(x2, y2));
                                    return;
                                }
                                if (da2 > m_cusp_limit) {
                                    points.push(new Vector(x3, y3));
                                    return;
                                }
                            }
                        }
                    }
                    else {
                        if (d2 > curve_collinearity_epsilon) {
                            // p1,p3,p4 are collinear, p2 is considerable
                            //----------------------
                            if (d2 * d2 <= m_distance_tolerance * (dx * dx + dy * dy)) {
                                if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
                                    points.push(new Vector(x1234, y1234));
                                    return;
                                }
                                // Angle Condition
                                //----------------------
                                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
                                if (da1 >= Math.PI)
                                    da1 = 2 * Math.PI - da1;
                                if (da1 < m_angle_tolerance) {
                                    points.push(new Vector(x2, y2));
                                    points.push(new Vector(x3, y3));
                                    return;
                                }
                                if (m_cusp_limit !== 0.0) {
                                    if (da1 > m_cusp_limit) {
                                        points.push(new Vector(x2, y2));
                                        return;
                                    }
                                }
                            }
                        }
                        else if (d3 > curve_collinearity_epsilon) {
                            // p1,p2,p4 are collinear, p3 is considerable
                            //----------------------
                            if (d3 * d3 <= m_distance_tolerance * (dx * dx + dy * dy)) {
                                if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
                                    points.push(new Vector(x1234, y1234));
                                    return;
                                }
                                // Angle Condition
                                //----------------------
                                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
                                if (da1 >= Math.PI)
                                    da1 = 2 * Math.PI - da1;
                                if (da1 < m_angle_tolerance) {
                                    points.push(new Vector(x2, y2));
                                    points.push(new Vector(x3, y3));
                                    return;
                                }
                                if (m_cusp_limit !== 0.0) {
                                    if (da1 > m_cusp_limit) {
                                        points.push(new Vector(x3, y3));
                                        return;
                                    }
                                }
                            }
                        }
                        else {
                            // Collinear case
                            //-----------------
                            dx = x1234 - (x1 + x4) / 2;
                            dy = y1234 - (y1 + y4) / 2;
                            if (dx * dx + dy * dy <= m_distance_tolerance) {
                                points.push(new Vector(x1234, y1234));
                                return;
                            }
                        }
                    }
                }
                // Continue subdivision
                //----------------------
                __recursive_bezier(points, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1);
                __recursive_bezier(points, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1);
            }
            /**
             *
             * @param p0 {cc.math.Vector}
             * @param cp0 {cc.math.Vector}
             * @param cp1 {cc.math.Vector}
             * @param p1 {cc.math.Vector}
             * @param points {Array<cc.math.Vector>=}
             *
             * @static
             */
            function traceBezier(p0, cp0, cp1, p1, m_points) {
                var x1 = p0.x;
                var y1 = p0.y;
                var x2 = cp0.x;
                var y2 = cp0.y;
                var x3 = cp1.x;
                var y3 = cp1.y;
                var x4 = p1.x;
                var y4 = p1.y;
                var m_points = m_points || [];
                m_distance_tolerance = 0.5 / m_approximation_scale;
                m_distance_tolerance *= m_distance_tolerance;
                m_points.push(new Vector(x1, y1));
                __recursive_bezier(m_points, x1, y1, x2, y2, x3, y3, x4, y4, 0);
                m_points.push(new Vector(x4, y4));
                return m_points;
            }
            path.traceBezier = traceBezier;
            /**
             *
             * @param p0 {cc.math.Vector}
             * @param cp0 {cc.math.Vector}
             * @param p1 {cc.math.Vector}
             * @param m_points {Array<cc.math.Vector>=}
             * @static
             */
            function traceQuadratic(p0, cp0, p1, m_points) {
                var x1 = p0.x;
                var y1 = p0.y;
                var x2 = cp0.x;
                var y2 = cp0.y;
                var x3 = p1.x;
                var y3 = p1.y;
                m_points = m_points || [];
                m_distance_tolerance = 0.5 / m_approximation_scale;
                m_distance_tolerance *= m_distance_tolerance;
                m_points.push(new Vector(x1, y1));
                __recursive_quadratic(m_points, x1, y1, x2, y2, x3, y3, 0);
                m_points.push(new Vector(x3, y3));
                return m_points;
            }
            path.traceQuadratic = traceQuadratic;
            /**
             *
             * @param x1 {number}
             * @param y1 {number}
             * @param x2 {number}
             * @param y2 {number}
             * @param x3 {number}
             * @param y3 {number}
             * @param level {number}
             * @private
             * @static
             */
            function __recursive_quadratic(points, x1, y1, x2, y2, x3, y3, level) {
                if (level > curve_recursion_limit) {
                    return;
                }
                // Calculate all the mid-points of the line segments
                //----------------------
                var x12 = (x1 + x2) / 2;
                var y12 = (y1 + y2) / 2;
                var x23 = (x2 + x3) / 2;
                var y23 = (y2 + y3) / 2;
                var x123 = (x12 + x23) / 2;
                var y123 = (y12 + y23) / 2;
                var dx = x3 - x1;
                var dy = y3 - y1;
                var d = Math.abs(((x2 - x3) * dy - (y2 - y3) * dx));
                if (d > curve_collinearity_epsilon) {
                    // Regular care
                    //-----------------
                    if (d * d <= m_distance_tolerance * (dx * dx + dy * dy)) {
                        // If the curvature doesn't exceed the distance_tolerance value
                        // we tend to finish subdivisions.
                        //----------------------
                        if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(new Vector(x123, y123));
                            return;
                        }
                        // Angle & Cusp Condition
                        //----------------------
                        var da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
                        if (da >= Math.PI)
                            da = 2 * Math.PI - da;
                        if (da < m_angle_tolerance) {
                            // Finally we can stop the recursion
                            //----------------------
                            points.push(new Vector(x123, y123));
                            return;
                        }
                    }
                }
                else {
                    // Collinear case
                    //-----------------
                    dx = x123 - (x1 + x3) / 2;
                    dy = y123 - (y1 + y3) / 2;
                    if (dx * dx + dy * dy <= m_distance_tolerance) {
                        points.push(new Vector(x123, y123));
                        return;
                    }
                }
                // Continue subdivision
                //----------------------
                __recursive_quadratic(points, x1, y1, x12, y12, x123, y123, level + 1);
                __recursive_quadratic(points, x123, y123, x23, y23, x3, y3, level + 1);
            }
        })(path = math.path || (math.path = {}));
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="./BezierTracer.ts"/>
/// <reference path="../Path.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var path;
        (function (path) {
            var Vector = cc.math.Vector;
            var __v0 = new Vector();
            /**
             * @class cc.math.path.SegmentQuadratic
             * @implements cc.math.path.Segment
             * @classdesc
             *
             * This Object is a Quadratic Bezier Segment.
             * <p>
             *     It is composed of two points and a tension control point. Internally, the Segment can cache its contour.
             * <p>
             *     The contour can be of two different types:
             *     + directly traced over the curve. Leaves points at different distances on the curve.
             *     + equi-distant on the curve. Internally traces the points as in the other type, but then creates a polyline
             *       path with the points, and samples the resulting path at regular intervals. This transforms the curve into
             *       a polyline, which is faster for most calculations, but could not be as smooth as the other type.
             * <p>
             * By default, the curve is calculated with the first type, directly tracing on the curve
             *
             */
            var SegmentQuadratic = (function () {
                /**
                 * Create a new Quadratic Segment instance.
                 * @param data {cc.math.path.SegmentQuadraticInitializer=}
                 */
                function SegmentQuadratic(data) {
                    /**
                     * Start quadratic curve point.
                     * @member cc.math.path.SegmentQuadratic#_p0
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._p0 = null;
                    /**
                     * Quadratic curve control point.
                     * @member cc.math.path.SegmentQuadratic#_cp0
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._cp0 = null;
                    /**
                     * End quadratic curve point.
                     * @member cc.math.path.SegmentQuadratic#_p1
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._p1 = null;
                    /**
                     * Internal flag for cache validity.
                     * @member cc.math.path.SegmentQuadratic#_dirty
                     * @type {boolean}
                     * @private
                     */
                    this._dirty = true;
                    /**
                     * Parent segment.
                     * @member cc.math.path.SegmentQuadratic#_parent
                     * @type {cc.math.path.Segment}
                     * @private
                     */
                    this._parent = null;
                    /**
                     * Segment length. It is approximately calculated by subdividing the curve.
                     * @member cc.math.path.SegmentQuadratic#_length
                     * @type {number}
                     * @private
                     */
                    this._length = 0;
                    if (data) {
                        this.initialize(data.p0, data.p1, data.p2);
                    }
                }
                /**
                 * Initialize the Segment with the supplied points.
                 * @param p0 {cc.math.Point} start curve point.
                 * @param p1 {cc.math.Point} curve control point.
                 * @param p2 {cc.math.Point} end curve point}
                 */
                SegmentQuadratic.prototype.initialize = function (p0, p1, p2) {
                    this._p0 = new Vector(p0.x, p0.y);
                    this._cp0 = new Vector(p1.x, p1.y);
                    this._p1 = new Vector(p2.x, p2.y);
                    this.__calculateLength();
                    this._dirty = false;
                };
                SegmentQuadratic.prototype.__calculateLength = function () {
                    var points = this.trace(null, cc.math.path.DEFAULT_TRACE_LENGTH);
                    // calculate distance
                    this._length = 0;
                    for (var i = 0; i < points.length - 1; i++) {
                        this._length += points[i].distance(points[i + 1]);
                    }
                    this._dirty = false;
                };
                /**
                 * Get the Segment's parent Segment.
                 * @method cc.math.path.SegmentQuadratic#getParent
                 * @returns {cc.math.path.Segment}
                 */
                SegmentQuadratic.prototype.getParent = function () {
                    return this._parent;
                };
                /**
                 * Set the Segment's parent Segment.
                 * @method cc.math.path.SegmentQuadratic#setParent
                 * @param s {cc.math.path.Segment}
                 */
                SegmentQuadratic.prototype.setParent = function (s) {
                    this._parent = s;
                };
                /**
                 * Get the Segment length.
                 * @override
                 * @method cc.math.path.SegmentQuadratic#getLength
                 * @returns {number}
                 */
                SegmentQuadratic.prototype.getLength = function () {
                    if (this._dirty) {
                        this.__calculateLength();
                    }
                    return this._length;
                };
                /**
                 * Sample some points on the segment. It will return either the sampled contour, or the flattened version of it.
                 * It returns the points that conform the Segment contour, if they are changed, the contour will be changed as well.
                 * @method cc.math.path.SegmentQuadratic#trace
                 * @param numPoints {number=} number of points traced on the segment.
                 * @param dstArray {Array<cc.math.Vector>=} array where to add the traced points.
                 * @returns {Array<Vector>} returns the supplied array of points, or a new array of points if not set.
                 */
                SegmentQuadratic.prototype.trace = function (dstArray, numPoints) {
                    dstArray = dstArray || [];
                    cc.math.path.traceQuadratic(this._p0, this._cp0, this._p1, dstArray);
                    return dstArray;
                };
                /**
                 * Get a point on the Segment at the given proportional position.
                 * + If the segment is flattened, the value will be calculated from the internally cached curve contour.
                 * + If not, if will be calculated by solving the curve.
                 * The first is faster, but could be inaccurate for curves with a los number of flattened cached points.
                 * @param normalizedPos {number} value in the range 0..1
                 * @param out {cc.math.Vector=} optional out point. if not set, an internal spare point will be used.
                 * @returns {cc.math.Vector} a point on the segment at the given position. This point should be copied,
                 * successive calls to getValue will return the same point instance.
                 */
                SegmentQuadratic.prototype.getValueAt = function (normalizedPos, out) {
                    // no out point, use a spare internal one. WARNING, will be continuously reused.
                    out = out || new cc.math.Vector();
                    // fix normalization values, just in case.
                    if (normalizedPos > 1 || normalizedPos < -1) {
                        normalizedPos %= 1;
                    }
                    if (normalizedPos < 0) {
                        normalizedPos += 1;
                    }
                    if (normalizedPos === 1) {
                        out.set(this._p1.x, this._p1.y);
                    }
                    else if (normalizedPos === 0) {
                        out.set(this._p0.x, this._p0.y);
                    }
                    else {
                        var t1 = 1 - normalizedPos;
                        var t = normalizedPos;
                        // solve quadratic
                        out.x = SegmentQuadratic.solve(this._p0.x, this._cp0.x, this._p1.x, t, t1);
                        out.y = SegmentQuadratic.solve(this._p0.y, this._cp0.y, this._p1.y, t, t1);
                    }
                    return out;
                };
                SegmentQuadratic.solve = function (v0, cv0, v1, t, t1) {
                    return t1 * t1 * v0 + 2 * t1 * t * cv0 + t * t * v1;
                };
                /**
                 * Get the Segment's starting point.
                 * It returns the original starting Point reference, not a copy of it.
                 * @returns {cc.math.Vector}
                 */
                SegmentQuadratic.prototype.getStartingPoint = function () {
                    return this._p0;
                };
                /**
                 * Get the Segment's ending point.
                 * It returns the original starting Point reference, not a copy of it.
                 * @returns {cc.math.Vector}
                 */
                SegmentQuadratic.prototype.getEndingPoint = function () {
                    return this._p1;
                };
                /**
                 * Make a clone of the segment.
                 * @method cc.math.path.SegmentQuadratic#clone
                 * @returns {cc.math.path.Segment}
                 */
                SegmentQuadratic.prototype.clone = function () {
                    var segment = new SegmentQuadratic({
                        p0: {
                            x: this._p0.x,
                            y: this._p0.y
                        },
                        p1: {
                            x: this._cp0.x,
                            y: this._cp0.y
                        },
                        p2: {
                            x: this._p1.x,
                            y: this._p1.y
                        }
                    });
                    segment._length = this._length;
                    return segment;
                };
                /**
                 * Add this Segment control points to the array.
                 * If the array is not set, a new one will be created.
                 * The actual Segment points are added, so modifying them means modifying the path.
                 * @method cc.math.path.SegmentQuadratic#getControlPoints
                 * @param arr {Array<cc.math.Vector>}
                 * @returns {Array<cc.math.Vector>}
                 */
                SegmentQuadratic.prototype.getControlPoints = function (arr) {
                    arr = arr || [];
                    arr.push(this._p0);
                    arr.push(this._cp0);
                    arr.push(this._p1);
                    return arr;
                };
                /**
                 * Mark the quadratic as dirty. Mark internal polilyne info as invalid.
                 * @methodcc.math.path.SegmentBezier#setDirty
                 */
                /**
                 * Mark the Segment dirty.
                 * No action for Arcs.
                 * @method cc.math.path.ContainerSegment#setDirty
                 */
                SegmentQuadratic.prototype.setDirty = function (d) {
                    this._dirty = d;
                    var p = this._parent;
                    while (p) {
                        p.setDirty(d);
                        p = p._parent;
                    }
                };
                SegmentQuadratic.prototype.paint = function (ctx) {
                };
                return SegmentQuadratic;
            })();
            path.SegmentQuadratic = SegmentQuadratic;
        })(path = math.path || (math.path = {}));
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="./BezierTracer.ts"/>
/// <reference path="../Path.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var path;
        (function (path) {
            var Vector = cc.math.Vector;
            var __v0 = new Vector();
            /**
             * @class cc.math.path.SegmentBezier
             * @implements cc.math.path.Segment
             * @classdesc
             *
             * This Object is a Cubic Bezier Segment.
             * <p>
             *     It is composed of two points and a two tension control points. Internally, the Segment can cache its contour.
             * <p>
             *     The contour can be of two different types:
             *     + directly traced over the curve. Leaves points at different distances on the curve.
             *     + equi-distant on the curve. Internally traces the points as in the other type, but then creates a polyline
             *       path with the points, and samples the resulting path at regular intervals. This transforms the curve into
             *       a polyline, which is faster for most calculations, but could not be as smooth as the other type.
             * <p>
             * By default, the curve is calculated with the first type, directly tracing on the curve
             *
             */
            var SegmentBezier = (function () {
                /**
                 * Create a new Cubic Segment instance.
                 * @param data {cc.math.path.SegmentBezierInitializer=}
                 */
                function SegmentBezier(data) {
                    /**
                     * Start Cubic curve point.
                     * @member cc.math.path.SegmentBezier#_p0
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._p0 = null;
                    /**
                     * First Cubic curve control point.
                     * @member cc.math.path.SegmentBezier#_cp0
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._cp0 = null;
                    /**
                     * Second Cubic curve control point.
                     * @member cc.math.path.SegmentBezier#_cp1
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._cp1 = null;
                    /**
                     * End Cubic curve point.
                     * @member cc.math.path.SegmentBezier#_p1
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._p1 = null;
                    /**
                     * Internal flag for cache validity.
                     * @member cc.math.path.SegmentBezier#_dirty
                     * @type {boolean}
                     * @private
                     */
                    this._dirty = true;
                    /**
                     * Parent segment.
                     * @member cc.math.path.SegmentBezier#_parent
                     * @type {cc.math.path.Segment}
                     * @private
                     */
                    this._parent = null;
                    /**
                     * Segment length. It is approximately calculated by subdividing the curve.
                     * @member cc.math.path.SegmentBezier#_length
                     * @type {number}
                     * @private
                     */
                    this._length = 0;
                    if (data) {
                        this.initialize(data.p0, data.p1, data.p2, data.p3);
                    }
                }
                /**
                 * Initialize the Segment with the supplied points.
                 * @param p0 {cc.math.Point} start curve point.
                 * @param p1 {cc.math.Point} first curve control point.
                 * @param p2 {cc.math.Point} second curve control point.
                 * @param p3 {cc.math.Point} end curve point}
                 */
                SegmentBezier.prototype.initialize = function (p0, p1, p2, p3) {
                    this._p0 = new Vector(p0.x, p0.y);
                    this._cp0 = new Vector(p1.x, p1.y);
                    this._cp1 = new Vector(p2.x, p2.y);
                    this._p1 = new Vector(p3.x, p3.y);
                    this._dirty = false;
                    this.__calculateLength();
                };
                SegmentBezier.prototype.__calculateLength = function () {
                    var points = this.trace(null, cc.math.path.DEFAULT_TRACE_LENGTH);
                    // calculate distance
                    this._length = 0;
                    for (var i = 0; i < points.length - 1; i++) {
                        this._length += points[i].distance(points[i + 1]);
                    }
                    this._dirty = false;
                };
                /**
                 * Get the Segment's parent Segment.
                 * @method cc.math.path.SegmentBezier#getParent
                 * @returns {cc.math.path.Segment}
                 */
                SegmentBezier.prototype.getParent = function () {
                    return this._parent;
                };
                /**
                 * Set the Segment's parent Segment.
                 * @method cc.math.path.SegmentBezier#setParent
                 * @param s {cc.math.path.Segment}
                 */
                SegmentBezier.prototype.setParent = function (s) {
                    this._parent = s;
                };
                /**
                 * Get the Segment length.
                 * @override
                 * @method cc.math.path.SegmentBezier#getLength
                 * @returns {number}
                 */
                SegmentBezier.prototype.getLength = function () {
                    if (this._dirty) {
                        this.__calculateLength();
                    }
                    return this._length;
                };
                /**
                 * Sample some points on the segment. It will return either the sampled contour, or the flattened version of it.
                 * It returns the points that conform the Segment contour, if they are changed, the contour will be changed as well.
                 * @method cc.math.path.SegmentBezier#trace
                 * @param numPoints {number=} number of points traced on the segment.
                 * @param dstArray {Array<cc.math.Vector>=} array where to add the traced points.
                 * @returns {Array<Vector>} returns the supplied array of points, or a new array of points if not set.
                 */
                SegmentBezier.prototype.trace = function (dstArray, numPoints) {
                    dstArray = dstArray || [];
                    cc.math.path.traceBezier(this._p0, this._cp0, this._cp1, this._p1, dstArray);
                    return dstArray;
                };
                /**
                 * Get a point on the Segment at the given proportional position.
                 * + If the segment is flattened, the value will be calculated from the internally cached curve contour.
                 * + If not, if will be calculated by solving the curve.
                 * The first is faster, but could be inaccurate for curves with a los number of flattened cached points.
                 * For this kind of segment, the first method is way faster.
                 * @param normalizedPos {number} value in the range 0..1
                 * @param out {cc.math.Vector=} optional out point. if not set, an internal spare point will be used.
                 * @returns {cc.math.Vector} a point on the segment at the given position. This point should be copied,
                 * successive calls to getValue will return the same point instance.
                 */
                SegmentBezier.prototype.getValueAt = function (normalizedPos, out) {
                    // no out point, use a spare internal one. WARNING, will be continuously reused.
                    out = out || new cc.math.Vector();
                    // fix normalization values, just in case.
                    if (normalizedPos > 1 || normalizedPos < -1) {
                        normalizedPos %= 1;
                    }
                    if (normalizedPos < 0) {
                        normalizedPos += 1;
                    }
                    if (normalizedPos === 1) {
                        out.set(this._p1.x, this._p1.y);
                    }
                    else if (normalizedPos === 0) {
                        out.set(this._p0.x, this._p0.y);
                    }
                    else {
                        var t = normalizedPos;
                        var t2 = t * t;
                        var t3 = t * t2;
                        // solve cubic bezier for nomalized time.
                        out.x = SegmentBezier.solve(this._p0.x, this._cp0.x, this._cp1.x, this._p1.x, t, t2, t3);
                        out.y = SegmentBezier.solve(this._p0.y, this._cp0.y, this._cp1.y, this._p1.y, t, t2, t3);
                    }
                    return out;
                };
                /**
                 * Solve a Bezier for the given t.
                 * @method cc.math.path.SegmentBezier.solve
                 * @param v0 {number} point 0
                 * @param vc0 {number} control point 0
                 * @param cv1 {number} control point 1
                 * @param v1 {number} point 1
                 * @param t {number} normalized 0..1 value.
                 * @param t2 {number} square normalized 0..1 value.
                 * @param t3 {number} cubic normalized 0..1 value.
                 * @returns {number}
                 */
                SegmentBezier.solve = function (v0, vc0, cv1, v1, t, t2, t3) {
                    return (v0 + t * (-v0 * 3 + t * (3 * v0 - v0 * t))) + t * (3 * vc0 + t * (-6 * vc0 + vc0 * 3 * t)) + t2 * (cv1 * 3 - cv1 * 3 * t) + t3 * v1;
                };
                /**
                 * Get the Segment's starting point.
                 * It returns the original starting Point reference, not a copy of it.
                 * @returns {cc.math.Vector}
                 */
                SegmentBezier.prototype.getStartingPoint = function () {
                    return this._p0;
                };
                /**
                 * Get the Segment's ending point.
                 * It returns the original starting Point reference, not a copy of it.
                 * @returns {cc.math.Vector}
                 */
                SegmentBezier.prototype.getEndingPoint = function () {
                    return this._p1;
                };
                /**
                 * Make a clone of the segment.
                 * @method cc.math.path.SegmentBezier#clone
                 * @returns {cc.math.path.Segment}
                 */
                SegmentBezier.prototype.clone = function () {
                    var segment = new SegmentBezier({
                        p0: {
                            x: this._p0.x,
                            y: this._p0.y
                        },
                        p1: {
                            x: this._cp0.x,
                            y: this._cp0.y
                        },
                        p2: {
                            x: this._cp1.x,
                            y: this._cp1.y
                        },
                        p3: {
                            x: this._p1.x,
                            y: this._p1.y
                        }
                    });
                    segment._length = this._length;
                    return segment;
                };
                /**
                 * Add this Segment control points to the array.
                 * If the array is not set, a new one will be created.
                 * The actual Segment points are added, so modifying them means modifying the path.
                 * @method cc.math.path.SegmentBezier#getControlPoints
                 * @param arr {Array<cc.math.Vector>}
                 * @returns {Array<cc.math.Vector>}
                 */
                SegmentBezier.prototype.getControlPoints = function (arr) {
                    arr = arr || [];
                    arr.push(this._p0);
                    arr.push(this._cp0);
                    arr.push(this._cp1);
                    arr.push(this._p1);
                    return arr;
                };
                /**
                 * Mark the bezier as dirty. Mark internal polilyne info as invalid.
                 * @methodcc.math.path.SegmentBezier#setDirty
                 */
                /**
                 * Mark the Segment dirty.
                 * No action for Arcs.
                 * @method cc.math.path.ContainerSegment#setDirty
                 */
                SegmentBezier.prototype.setDirty = function (d) {
                    this._dirty = d;
                    var p = this._parent;
                    while (p) {
                        p.setDirty(d);
                        p = p._parent;
                    }
                };
                SegmentBezier.prototype.paint = function (ctx) {
                };
                return SegmentBezier;
            })();
            path.SegmentBezier = SegmentBezier;
        })(path = math.path || (math.path = {}));
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * Created by ibon on 11/23/14.
 */
/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var path;
        (function (path) {
            var Vector = cc.math.Vector;
            var __v0 = new Vector();
            /**
             * @class cc.math.path.SegmentArc
             * @implements cc.math.path.Segment
             * @classdesc
             *
             * This Segment represents a circle's arc.
             * The arc is defined by a position, a radius and two angles. It also specified how the angles should be traversed
             * clock or counter clock wisely.
             * The arc will be the minimum angle between the start and end angles.
             *
             */
            var SegmentArc = (function () {
                /**
                 * Build a new SegmentArc instance.
                 * @method cc.math.path.SegmentArc#constructor
                 * @param data {cc.math.path.SegmentArcInitializer=} optional arc initialization data.
                 */
                function SegmentArc(data) {
                    this._dirty = true;
                    /**
                     * Cached arc starting point.
                     * @member cc.math.path.SegmentArc#_startingPoint
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._startingPoint = null;
                    /**
                     * Cached arc ending point.
                     * @member cc.math.path.SegmentArc#_endingPoint
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._endingPoint = null;
                    /**
                     * Cached Segment length value.
                     * @member cc.math.path.SegmentArc#_length
                     * @type {number}
                     * @private
                     */
                    this._length = 0;
                    this.initialize(data);
                }
                /**
                 * Initialize the Arc Segment with data.
                 * @method cc.math.path.SegmentArc#initialize
                 * @param data {cc.math.path.SegmentArcInitializer}
                 */
                SegmentArc.prototype.initialize = function (data) {
                    this._x = data.x;
                    this._y = data.y;
                    this._radius = data.radius;
                    this._startAngle = data.startAngle;
                    this._endAngle = data.endAngle;
                    this._ccw = data.ccw;
                    if (!this._ccw && this._endAngle <= this._startAngle) {
                        this._endAngle += 2 * Math.PI;
                    }
                    else if (this._ccw && this._startAngle <= this._endAngle) {
                        this._startAngle += 2 * Math.PI;
                    }
                    var s = this.getValueAt(0);
                    this._startingPoint = new Vector();
                    this._startingPoint.x = s.x;
                    this._startingPoint.y = s.y;
                    s = this.getValueAt(1);
                    this._endingPoint = new Vector();
                    this._endingPoint.x = s.x;
                    this._endingPoint.y = s.y;
                    this.__calculateLength();
                };
                SegmentArc.prototype.__calculateLength = function () {
                    this._length = Math.abs(this._radius * (this._endAngle - this._startAngle));
                    this._dirty = false;
                };
                /**
                 * Return the Segment's starting point reference. It is the stored one, not a copy.
                 * @method cc.math.path.SegmentArc#getStartingPoint
                 * @returns {cc.math.Vector}
                 */
                SegmentArc.prototype.getStartingPoint = function () {
                    return this._startingPoint;
                };
                /**
                 * Return the Segment's ending point reference. It is the stored one, not a copy.
                 * @method cc.math.path.SegmentArc#getEndingPoint
                 * @returns {cc.math.Vector}
                 */
                SegmentArc.prototype.getEndingPoint = function () {
                    return this._endingPoint;
                };
                /**
                 * Get the Segment's arc length.
                 * @method cc.math.path.SegmentArc#getLength
                 * @returns {number}
                 */
                SegmentArc.prototype.getLength = function () {
                    if (this._dirty) {
                        this.__calculateLength();
                    }
                    return this._length;
                };
                /**
                 * Get a Point in the Arc.
                 * @method cc.math.path.SegmentArc#getValueAt
                 * @param v {number} Position in path. 0= startingPoint, 1= endingPoint
                 * @param out {cc.math.Vector=} an optional out Point. If not set, an internal spare point will be returned.
                 * @returns {cc.math.Vector}
                 */
                SegmentArc.prototype.getValueAt = function (v, out) {
                    var diffAngle = (this._endAngle - this._startAngle) * v;
                    out = out || new cc.math.Vector();
                    out.x = this._x + this._radius * Math.cos(this._startAngle + diffAngle);
                    out.y = this._y + this._radius * Math.sin(this._startAngle + diffAngle);
                    return out;
                };
                /**
                 * Sample some points in the Segment.
                 * @method cc.math.path.SegmentArc#trace
                 * @param numPoints {number=} Number of points. if not set, cc.math.path.DEFAULT_TRACE_LENGTH points will be traced.
                 * @param dstArray {Array<cc.math.Vector>=} optional output array of points. If not set, a new one will be created.
                 * @returns {Array<Vector>} An array where the traced points have been added.
                 */
                SegmentArc.prototype.trace = function (dstArray, numPoints) {
                    numPoints = numPoints || cc.math.path.DEFAULT_TRACE_LENGTH;
                    dstArray = dstArray || [];
                    if (this._startAngle === this._endAngle || this._radius === 0) {
                        return dstArray;
                    }
                    for (var i = 0; i < numPoints; i++) {
                        dstArray.push(this.getValueAt(i / numPoints, new Vector()));
                    }
                    return dstArray;
                };
                /**
                 * Get the Segment's parent Segment.
                 * @method cc.math.path.SegmentArc#getParent
                 * @returns {cc.math.path.Segment}
                 */
                SegmentArc.prototype.getParent = function () {
                    return this._parent;
                };
                /**
                 * Set the Segment's parent Segment.
                 * @method cc.math.path.SegmentArc#setParent
                 * @param s {cc.math.path.Segment}
                 */
                SegmentArc.prototype.setParent = function (s) {
                    this._parent = s;
                };
                /**
                 * Make a clone of the segment.
                 * @method cc.math.path.SegmentArc#clone
                 * @returns {cc.math.path.Segment}
                 */
                SegmentArc.prototype.clone = function () {
                    return new SegmentArc({
                        x: this._x,
                        y: this._y,
                        radius: this._radius,
                        startAngle: this._startAngle,
                        endAngle: this._endAngle,
                        ccw: this._ccw
                    });
                };
                /**
                 * Add the Segment control points to the array.
                 * If the array is not set, a new one will be created.
                 * The actual Segment points are added, so modifying them means modifying the path.
                 * Arc segments have no control points.
                 * @method cc.math.path.SegmentArc#getControlPoints
                 * @param arr {Array<cc.math.Vector>}
                 * @returns {Array<cc.math.Vector>}
                 */
                SegmentArc.prototype.getControlPoints = function (arr) {
                    arr = arr || [];
                    return arr;
                };
                /**
                 * Mark the Segment dirty.
                 * No action for Arcs.
                 * @method cc.math.path.ContainerSegment#setDirty
                 */
                SegmentArc.prototype.setDirty = function (d) {
                    this._dirty = d;
                    var p = this._parent;
                    while (p) {
                        p.setDirty(d);
                        p = p._parent;
                    }
                };
                SegmentArc.prototype.paint = function (ctx) {
                };
                return SegmentArc;
            })();
            path.SegmentArc = SegmentArc;
        })(path = math.path || (math.path = {}));
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="../Path.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var path;
        (function (path) {
            var Vector = cc.math.Vector;
            var __v0 = new Vector();
            /**
             * @class cc.math.path.SegmentCardinalSpline
             * @implements cc.math.path.Segment
             * @classdesc
             *
             * This Object is a Quadratic Bezier Segment.
             * <p>
             *     It is composed of two points and a tension control point. Internally, the Segment can cache its contour.
             * <p>
             *     The contour can be of two different types:
             *     + directly traced over the curve. Leaves points at different distances on the curve.
             *     + equi-distant on the curve. Internally traces the points as in the other type, but then creates a polyline
             *       path with the points, and samples the resulting path at regular intervals. This transforms the curve into
             *       a polyline, which is faster for most calculations, but could not be as smooth as the other type.
             * <p>
             * By default, the curve is calculated with the first type, directly tracing on the curve
             *
             */
            var SegmentCardinalSpline = (function () {
                /**
                 * Create a new Quadratic Segment instance.
                 * @param data {cc.math.path.SegmentCardinalSplineInitializer=}
                 */
                function SegmentCardinalSpline(data) {
                    /**
                     * Start Cubic curve point.
                     * @member cc.math.path.SegmentCardinalSpline#_p0
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._p0 = null;
                    /**
                     * First Cubic curve control point.
                     * @member cc.math.path.SegmentCardinalSpline#_cp0
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._cp0 = null;
                    /**
                     * Second Cubic curve control point.
                     * @member cc.math.path.SegmentCardinalSpline#_cp1
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._cp1 = null;
                    /**
                     * End Cubic curve point.
                     * @member cc.math.path.SegmentCardinalSpline#_p1
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._p1 = null;
                    this._tension = .5;
                    /**
                     * Internal flag for cache validity.
                     * @member cc.math.path.SegmentCardinalSpline#_dirty
                     * @type {boolean}
                     * @private
                     */
                    this._dirty = true;
                    /**
                     * Parent segment.
                     * @member cc.math.path.SegmentCardinalSpline#_parent
                     * @type {cc.math.path.Segment}
                     * @private
                     */
                    this._parent = null;
                    /**
                     * Segment length. It is approximately calculated by subdividing the curve.
                     * @member cc.math.path.SegmentCardinalSpline#_length
                     * @type {number}
                     * @private
                     */
                    this._length = 0;
                    /**
                     * Whether the Quadratic is internally treated as a polyline.
                     * @member cc.math.path.SegmentCardinalSpline#_flattened
                     * @type {boolean}
                     * @private
                     */
                    this._flattened = false;
                    /**
                     * A cache of points on the curve. This is approximation with which the length is calculated.
                     * @member cc.math.path.SegmentCardinalSpline#_cachedContourPoints
                     * @type {Array<cc.math.Vector>}
                     * @private
                     */
                    this._cachedContourPoints = null;
                    if (data) {
                        this.initialize(data.p0, data.cp0, data.cp1, data.p1, data.tension);
                    }
                }
                /**
                 * Initialize the Segment with the supplied points.
                 * @param p0 {cc.math.Point}
                 * @param cp0 {cc.math.Point}
                 * @param cp1 {cc.math.Point}
                 * @param p1 {cc.math.Point}
                 * @param tension {number}
                 */
                SegmentCardinalSpline.prototype.initialize = function (p0, cp0, cp1, p1, tension) {
                    this._tension = typeof tension === "undefined" ? 0.5 : tension;
                    this._p0 = new Vector(p0.x, p0.y);
                    this._cp0 = new Vector(cp0.x, cp0.y);
                    this._cp1 = new Vector(cp1.x, cp1.y);
                    this._p1 = new Vector(p1.x, p1.y);
                    this.__calculateLength();
                    this._dirty = false;
                };
                /**
                 * Set Segment tension. By default it is 0.5
                 * Setting a different tension will mark the segment as dirty, nulling all internal caches.
                 * @param t {number}
                 */
                SegmentCardinalSpline.prototype.setTension = function (t) {
                    if (t !== this._tension) {
                        this._tension = t;
                        this.__calculateLength();
                        if (this._parent) {
                            this._parent.setDirty(true);
                        }
                    }
                };
                SegmentCardinalSpline.prototype.__calculateLength = function () {
                    var points = this.trace(null, cc.math.path.DEFAULT_TRACE_LENGTH);
                    // calculate distance
                    this._length = 0;
                    for (var i = 0; i < points.length - 1; i++) {
                        this._length += points[i].distance(points[i + 1]);
                    }
                    this._dirty = false;
                };
                /**
                 * Get the Segment's parent Segment.
                 * @method cc.math.path.SegmentCardinalSpline#getParent
                 * @returns {cc.math.path.Segment}
                 */
                SegmentCardinalSpline.prototype.getParent = function () {
                    return this._parent;
                };
                /**
                 * Set the Segment's parent Segment.
                 * @method cc.math.path.SegmentCardinalSpline#setParent
                 * @param s {cc.math.path.Segment}
                 */
                SegmentCardinalSpline.prototype.setParent = function (s) {
                    this._parent = s;
                };
                /**
                 * Get the Segment length.
                 * @override
                 * @method cc.math.path.SegmentCardinalSpline#getLength
                 * @returns {number}
                 */
                SegmentCardinalSpline.prototype.getLength = function () {
                    if (this._dirty) {
                        this.__calculateLength();
                    }
                    return this._length;
                };
                /**
                 * Sample some points on the segment. It will return either the sampled contour, or the flattened version of it.
                 * It returns the points that conform the Segment contour, if they are changed, the contour will be changed as well.
                 * @method cc.math.path.SegmentCardinalSpline#trace
                 * @param numPoints {number=} number of points traced on the segment.
                 * @param dstArray {Array<cc.math.Vector>=} array where to add the traced points.
                 * @returns {Array<Vector>} returns the supplied array of points, or a new array of points if not set.
                 */
                SegmentCardinalSpline.prototype.trace = function (dstArray, numPoints) {
                    numPoints = numPoints || cc.math.path.DEFAULT_TRACE_LENGTH;
                    dstArray = dstArray || [];
                    for (var i = 0; i <= numPoints; i++) {
                        dstArray.push(this.getValueAt(i / numPoints));
                    }
                    return dstArray;
                };
                /**
                 * Get a point on the Segment at the given proportional position.
                 * + If the segment is flattened, the value will be calculated from the internally cached curve contour.
                 * + If not, if will be calculated by solving the curve.
                 * The first is faster, but could be inaccurate for curves with a los number of flattened cached points.
                 * @param normalizedPos {number} value in the range 0..1
                 * @param out {cc.math.Vector=} optional out point. if not set, an internal spare point will be used.
                 * @returns {cc.math.Vector} a point on the segment at the given position. This point should be copied,
                 * successive calls to getValue will return the same point instance.
                 */
                SegmentCardinalSpline.prototype.getValueAt = function (normalizedPos, out) {
                    // no out point, use a spare internal one. WARNING, will be continuously reused.
                    out = out || new cc.math.Vector();
                    // fix normalization values, just in case.
                    if (normalizedPos > 1 || normalizedPos < -1) {
                        normalizedPos %= 1;
                    }
                    if (normalizedPos < 0) {
                        normalizedPos += 1;
                    }
                    if (normalizedPos === 1) {
                        var lp = this.getEndingPoint();
                        out.set(lp.x, lp.y);
                    }
                    else if (normalizedPos === 0) {
                        var fp_ = this.getStartingPoint();
                        out.set(fp_.x, fp_.y);
                    }
                    else {
                        var t = normalizedPos;
                        var t2 = t * t;
                        var t3 = t2 * t;
                        var s = (1.0 - this._tension) / 2.0;
                        var b1 = s * ((-t3 + (2.0 * t2)) - t); // s(-t3 + 2 t2 - t)P1
                        var b2 = s * (-t3 + t2) + (2.0 * t3 - 3.0 * t2 + 1.0); // s(-t3 + t2)P2 + (2 t3 - 3 t2 + 1)P2
                        var b3 = s * (t3 - 2.0 * t2 + t) + (-2.0 * t3 + 3.0 * t2); // s(t3 - 2 t2 + t)P3 + (-2 t3 + 3 t2)P3
                        var b4 = s * (t3 - t2); // s(t3 - t2)P4
                        out.x = this._p0.x * b1 + this._cp0.x * b2 + this._cp1.x * b3 + this._p1.x * b4;
                        out.y = this._p0.y * b1 + this._cp0.y * b2 + this._cp1.y * b3 + this._p1.y * b4;
                    }
                    return out;
                };
                /**
                 * Get the Segment's starting point.
                 * It returns the original starting Point reference, not a copy of it.
                 * @returns {cc.math.Vector}
                 */
                SegmentCardinalSpline.prototype.getStartingPoint = function () {
                    return this._cp0;
                };
                /**
                 * Get the Segment's ending point.
                 * It returns the original starting Point reference, not a copy of it.
                 * @returns {cc.math.Vector}
                 */
                SegmentCardinalSpline.prototype.getEndingPoint = function () {
                    return this._cp1;
                };
                /**
                 * Make a clone of the segment.
                 * @method cc.math.path.SegmentCardinalSpline#clone
                 * @returns {cc.math.path.Segment}
                 */
                SegmentCardinalSpline.prototype.clone = function () {
                    var segment = new SegmentCardinalSpline({
                        p0: this._p0,
                        cp0: this._cp0,
                        cp1: this._cp1,
                        p1: this._p1,
                        tension: this._tension
                    });
                    segment._length = this._length;
                    return segment;
                };
                /**
                 * Add this Segment control points to the array.
                 * If the array is not set, a new one will be created.
                 * The actual Segment points are added, so modifying them means modifying the path.
                 * @method cc.math.path.SegmentCardinalSpline#getControlPoints
                 * @param arr {Array<cc.math.Vector>}
                 * @returns {Array<cc.math.Vector>}
                 */
                SegmentCardinalSpline.prototype.getControlPoints = function (arr) {
                    arr = arr || [];
                    arr.push(this._p0);
                    arr.push(this._cp0);
                    arr.push(this._cp1);
                    arr.push(this._p1);
                    return arr;
                };
                /**
                 * Mark the quadratic as dirty. Mark internal polilyne info as invalid.
                 * @methodcc.math.path.SegmentCardinalSpline#setDirty
                 */
                /**
                 * Mark the Segment dirty.
                 * No action for Arcs.
                 * @method cc.math.path.ContainerSegment#setDirty
                 */
                SegmentCardinalSpline.prototype.setDirty = function (d) {
                    this._dirty = d;
                    var p = this._parent;
                    while (p) {
                        p.setDirty(d);
                        p = p._parent;
                    }
                };
                SegmentCardinalSpline.prototype.paint = function (ctx) {
                    var c = this.trace(null, 50);
                    ctx.beginPath();
                    ctx.moveTo(c[0].x, c[0].y);
                    for (var i = 1; i < c.length; i++) {
                        ctx.lineTo(c[i].x, c[i].y);
                    }
                    ctx.stroke();
                };
                return SegmentCardinalSpline;
            })();
            path.SegmentCardinalSpline = SegmentCardinalSpline;
        })(path = math.path || (math.path = {}));
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * Created by ibon on 11/22/14.
 */
/// <reference path="./Segment.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var path;
        (function (path) {
            var __v0 = new math.Vector();
            /**
             * @class cc.math.path.ContainerSegment
             * @implements cc.math.path.Segment
             * @classdesc
             *
             * This object is the base for all Container segments. Container Segments are Path and SubPath, that is, Segments
             * that are build of a collection of Segment objects.
             *
             */
            var ContainerSegment = (function () {
                function ContainerSegment() {
                    /**
                     * Parent Segment. An instance of <code>ContainerSegment</code>
                     * @member cc.math.path.SegmentLine
                     * @type {cc.math.path.Segment}
                     * @private
                     */
                    this._parent = null;
                    /**
                     * The path length
                     * @member cc.math.path.ContainerSegment#_length
                     * @type {number}
                     * @private
                     */
                    this._length = 0;
                    /**
                     * The path segments. Any of the segments can be another path.
                     * @member cc.math.path.ContainerSegment#_segments
                     * @type {Array<cc.math.path.ContainerSegment.Segment>}
                     * @private
                     */
                    this._segments = [];
                    /**
                     * Mark this ContainerSegment as dirty.
                     * Dirty means length must be recalculated.
                     * @member cc.math.path.ContainerSegment#_dirty
                     * @type {boolean}
                     * @private
                     */
                    this._dirty = true;
                }
                /**
                 * Get ContainerSegment's all segments lengths.
                 * @returns {number}
                 */
                ContainerSegment.prototype.getLength = function () {
                    if (this._dirty) {
                        this.__calculateLength();
                    }
                    return this._length;
                };
                ContainerSegment.prototype.__calculateLength = function () {
                    var length = 0;
                    for (var i = 0; i < this._segments.length; i++) {
                        length += this._segments[i].getLength();
                    }
                    this._dirty = false;
                    this._length = length;
                    return this._length;
                };
                /**
                 * Get a Point on the ContainerSegment at a position proportional to normalizedPos.
                 * If there's no Point in the path for the normalized position, the result of calling
                 * <code>getStartingPoint</code> or <code>getEndingPoint</code> is returned.
                 * This is consistent since a value for normalizedPos of 1 means end
                 * of the path and a value of 0 the start of it.
                 * @param normalizedPos {number} Normalized value between 0..1
                 * @param out {cc.math.Vector=} out point. if not set, an internal spare point value will be used.
                 * @returns {cc.math.Vector}
                 */
                ContainerSegment.prototype.getValueAt = function (normalizedPos, out) {
                    if (this._dirty) {
                        this.__calculateLength();
                        this._dirty = false;
                    }
                    out = out || new cc.math.Vector();
                    // BUGBUG change for binary search
                    var pos = normalizedPos * this._length;
                    var search = 0;
                    for (var i = 0; i < this._segments.length; i++) {
                        if (pos >= search && pos < search + this._segments[i].getLength()) {
                            search = pos - search;
                            search /= this._segments[i].getLength();
                            return this._segments[i].getValueAt(search, out);
                        }
                        else {
                            search += this._segments[i].getLength();
                        }
                    }
                    var ep = this.getEndingPoint();
                    return out.set(ep.x, ep.y);
                    //cc.Debug.error( locale.ERR_PATH_GETVALUEAT_HAS_NO_VALUE );
                };
                /**
                 * Get sample points on the ContainerSegment.
                 * @param numPoints {number=} number of points to sample. If not set, ContainerSegment.DEFAULT_TRACE will be used.
                 * @param dstArray {Array<cc.math.Vector>=}
                 * @returns {Array<cc.math.Vector>} the supplied array or a newly created one with the traced points .
                 */
                ContainerSegment.prototype.trace = function (dstArray, numPoints) {
                    dstArray = dstArray || [];
                    numPoints = numPoints || cc.math.path.DEFAULT_TRACE_LENGTH;
                    for (var i = 0; i <= numPoints; i++) {
                        dstArray.push(this.getValueAt(i / numPoints, new math.Vector()));
                    }
                    return dstArray;
                };
                /**
                 * @see {cc.math.path.Segment#getStartingPoint}
                 * @returns {cc.math.Vector}
                 */
                ContainerSegment.prototype.getStartingPoint = function () {
                    return null;
                };
                /**
                 * @see {cc.math.path.Segment#getEndingPoint}
                 * @returns {cc.math.Vector}
                 */
                ContainerSegment.prototype.getEndingPoint = function () {
                    return null;
                };
                /**
                 * Get the Segment's parent Segment.
                 * @returns {cc.math.path.Segment}
                 */
                ContainerSegment.prototype.getParent = function () {
                    return this._parent;
                };
                /**
                 * Set the Segment's parent Segment.
                 * @method cc.math.path.ContainerSegment#setParent
                 * @param s {cc.math.path.Segment}
                 */
                ContainerSegment.prototype.setParent = function (s) {
                    this._parent = s;
                };
                /**
                 * Make a clone of the segment. It will clone all contained segments.
                 * ContainerSegments are not allowed to exist by themselves except in the form of Path or SubPath, so cloning
                 * one of them will throw an error.
                 * @method cc.math.path.ContainerSegment#clone
                 * @returns {cc.math.path.Segment}
                 */
                ContainerSegment.prototype.clone = function () {
                    throw "ContainerSegments can't clone.";
                };
                /**
                 * Add this Segment control points to the array.
                 * If the array is not set, a new one will be created.
                 * The actual Segment points are added, so modifying them means modifying the path.
                 * @method cc.math.path.ContainerSegment#getControlPoints
                 * @param arr {Array<cc.math.Vector>}
                 * @returns {Array<cc.math.Vector>}
                 */
                ContainerSegment.prototype.getControlPoints = function (arr) {
                    arr = arr || [];
                    for (var i = 0; i < this._segments.length; i++) {
                        this._segments[i].getControlPoints(arr);
                    }
                    return arr;
                };
                /**
                 * Mark a Segment and all its SubSegments are dirty whatever that means.
                 * @methodcc.math.path.ContainerSegment#setDirty
                 */
                /**
                 * Mark the Segment dirty.
                 * No action for Arcs.
                 * @method cc.math.path.ContainerSegment#setDirty
                 */
                ContainerSegment.prototype.setDirty = function (b) {
                    this._dirty = b;
                    var p = this._parent;
                    while (p) {
                        p.setDirty(b);
                        p = p._parent;
                    }
                };
                ContainerSegment.prototype.paint = function (ctx) {
                };
                return ContainerSegment;
            })();
            path.ContainerSegment = ContainerSegment;
        })(path = math.path || (math.path = {}));
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./SegmentLine.ts"/>
/// <reference path="./SegmentArc.ts"/>
/// <reference path="./SegmentCardinalSpline.ts"/>
/// <reference path="./SegmentQuadratic.ts"/>
/// <reference path="./SegmentBezier.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../locale/Locale.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var path;
        (function (path) {
            var Vector = cc.math.Vector;
            var SegmentLine = cc.math.path.SegmentLine;
            var SegmentArc = cc.math.path.SegmentArc;
            var ContainerSegment = cc.math.path.ContainerSegment;
            /**
             * @class cc.math.path.SubPath
             * @extends cc.math.path.ContainerSegment
             * @classdesc
             *
             * A Subpath is an open or closed Collection of chained Segments.
             * A Segment will share its starting Point with the previous Segment's
             * last Point (or the initial movedTo point) and the final Point with the next Segment's starting Point.
             *
             * A SubPath is considered empty when it has no segments.
             * The length of the SubPath will be the lengths of all its Segments.
             * The results from a call to <code>getValueAt</code> will be proportional to all the Segments it contains.
             * The result from a call to <code>trace</code> will be points proportional to all the Segments it contains.
             * The result from a call to <code>getStartingPoint</code> will be the starting point of the first segment.
             *
             * A SubPath can be closed. When it is in this state, no new Segments can be added to it.
             *
             */
            var SubPath = (function (_super) {
                __extends(SubPath, _super);
                /**
                 * Build a new SubPath instance.
                 * @method cc.math.path.SubPath#constructor
                 */
                function SubPath() {
                    _super.call(this);
                    /**
                     * Path current tracing point. When adding segments to the path, this is the reference point.
                     * @member cc.math.path.SubPath#_currentPoint
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._currentPoint = null;
                    /**
                     * Is the path closed ? If so, more path tracing operations will require to build anothe SubPath.
                     * @member cc.math.path.SubPath#_closed
                     * @type {boolean}
                     * @private
                     */
                    this._closed = false;
                }
                /**
                 * Whether the SubPath is closed.
                 * @returns {boolean}
                 */
                SubPath.prototype.isClosed = function () {
                    return this._closed;
                };
                /**
                 * Test whether the SubPath is empty, that is, tracing info has not been set yet.
                 * @returns {boolean}
                 */
                SubPath.prototype.isEmpty = function () {
                    return this._currentPoint === null;
                };
                /**
                 * Number of Segments contained in this SubPath.
                 * If a Segment is actually another Path, it will count 1 segment.
                 * @returns {number}
                 */
                SubPath.prototype.numSegments = function () {
                    return this._segments.length;
                };
                /**
                 * Add a Segment to the SubPath and set the Segment's parent as the SubPath.
                 * @param s {cc.math.path.Segment}
                 */
                SubPath.prototype.addSegment = function (s) {
                    s.setParent(this);
                    this._segments.push(s);
                };
                /**
                 * Clear all sub-path data, and revert to the original path object status.
                 * Make sure this path is not another's path segment.
                 *
                 * @method cc.math.path.SubPath#beginPath
                 */
                SubPath.prototype.beginPath = function () {
                    this._segments = [];
                    this._length = 0;
                    this._currentPoint = null;
                    this._closed = false;
                    return this;
                };
                /**
                 * Move the current path tracer to a position.
                 *
                 * @method cc.math.path.SubPath#moveTo
                 * @param x {number}
                 * @param y {number}
                 */
                SubPath.prototype.moveTo = function (x, y) {
                    if (this._closed) {
                        cc.Debug.warn(cc.locale.WARN_MOVETO_IN_NON_EMPTY_SUBPATH);
                        return;
                    }
                    if (null === this._currentPoint) {
                        this._currentPoint = new Vector();
                    }
                    if (this.numSegments() === 0) {
                        this._currentPoint.x = x;
                        this._currentPoint.y = y;
                    }
                    return this;
                };
                /**
                 * Add a line to the current path.
                 * If the current path is not initialized, in will be initialized from 0,0 and a line added.
                 *
                 * @method cc.math.path.SubPath#lineTo
                 * @param x {number}
                 * @param y {number}
                 */
                SubPath.prototype.lineTo = function (x, y) {
                    if (this._closed) {
                        cc.Debug.warn(cc.locale.WARN_TRACE_ON_CLOSED_SUBPATH, "lineTo");
                        return;
                    }
                    if (this.isEmpty()) {
                        this._currentPoint = new Vector();
                    }
                    else {
                        this.addSegment(new SegmentLine({
                            start: {
                                x: this._currentPoint.x,
                                y: this._currentPoint.y
                            },
                            end: {
                                x: x,
                                y: y
                            }
                        }));
                    }
                    this._currentPoint.x = x;
                    this._currentPoint.y = y;
                    return this;
                };
                /**
                 * Add an arc to the SubPath.
                 * An arc is defined by a position, a radius, an start and an end angle and how to traverse from the start to
                 * the end angle, eg clock or counter clock wisely.
                 * The arc will be the minimum angle between start and end angles.
                 * Though not strictly necessary, this method expects the difference between startAngle and endAngle
                 * to be <= 2*Math.PI
                 * @see {cc.math.path.SegmentArc}
                 * @method cc.math.path.SubPath#arc
                 * @param x {number}
                 * @param y {number}
                 * @param radius {number}
                 * @param startAngle {number} radians
                 * @param endAngle {number} radians
                 * @param anticlockwise
                 * @param addLineTo {boolean} When adding an arc to a Path, if any SubPath is present a line must be added
                 *  to the current SubPath. If true add a line from the current SubPath point to the starting point on the arc.
                 * @returns {cc.math.path.SubPath}
                 */
                SubPath.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise, addLineTo) {
                    if (this._closed) {
                        cc.Debug.warn(cc.locale.WARN_TRACE_ON_CLOSED_SUBPATH, "ClosePath");
                        return;
                    }
                    var segment = new SegmentArc({
                        x: x,
                        y: y,
                        radius: radius,
                        startAngle: startAngle,
                        endAngle: endAngle,
                        ccw: anticlockwise
                    });
                    if (addLineTo) {
                        var sp = segment.getStartingPoint();
                        this.addSegment(new SegmentLine({
                            start: {
                                x: this._currentPoint.x,
                                y: this._currentPoint.y
                            },
                            end: {
                                x: sp.x,
                                y: sp.y
                            }
                        }));
                    }
                    this.addSegment(segment);
                    var fp = segment.getEndingPoint();
                    this._currentPoint.set(fp.x, fp.y);
                    this._dirty = true;
                    return this;
                };
                /**
                 * Close the SubPath.
                 * If the SubPath was already closed, in DEBUG mode will show a console message. In either case, nothing happens.
                 * If the SubPath is empty
                 * @returns {cc.math.path.SubPath}
                 */
                SubPath.prototype.closePath = function () {
                    if (this._closed) {
                        cc.Debug.warn(cc.locale.WARN_TRACE_ON_CLOSED_SUBPATH, "ClosePath");
                        return;
                    }
                    if (this.isEmpty()) {
                        cc.Debug.warn(cc.locale.WARN_CLOSE_EMPTY_SUBPATH, "ClosePath");
                        return;
                    }
                    var p = this.getStartingPoint();
                    var segment = new SegmentLine({
                        start: { x: this._currentPoint.x, y: this._currentPoint.y },
                        end: { x: p.x, y: p.y }
                    });
                    this.addSegment(segment);
                    this._currentPoint = segment.getEndingPoint();
                    this._closed = true;
                    this._dirty = true;
                    return this;
                };
                /**
                 * Get the SubPath's starting point.
                 * It will return the original SubPath starting point, not a copy of it.
                 * If this SubPath is empty (no points) an error is thrown if in DEBUG mode.
                 * @returns {cc.math.Vector}
                 */
                SubPath.prototype.getStartingPoint = function () {
                    if (!this.isEmpty()) {
                        return this._segments.length ? this._segments[0].getStartingPoint() : this._currentPoint;
                    }
                    cc.Debug.error(cc.locale.ERR_SUBPATH_NOT_STARTED, "getStartingPoint");
                };
                /**
                 * Get the SubPath's ending point.
                 * It will return the original SubPath ending point, not a copy of it.
                 * If this SubPath is empty (no points) an error is thrown if in DEBUG mode.
                 * @returns {cc.math.Vector}
                 */
                SubPath.prototype.getEndingPoint = function () {
                    if (!this.isEmpty()) {
                        return this._segments.length ? this._segments[this._segments.length - 1].getEndingPoint() : this._currentPoint;
                    }
                    cc.Debug.error(cc.locale.ERR_SUBPATH_NOT_STARTED, "getEndingPoint");
                };
                SubPath.prototype.clone = function () {
                    var sp = new SubPath();
                    sp._closed = this._closed;
                    for (var i = 0; i < this._segments.length; i++) {
                        sp._segments.push(this._segments[i].clone());
                    }
                    sp._length = this._length;
                    sp._currentPoint = this._currentPoint.clone();
                    return sp;
                };
                SubPath.prototype.quadraticTo = function (x0, y0, x1, y1) {
                    if (this._closed) {
                        cc.Debug.warn(cc.locale.WARN_TRACE_ON_CLOSED_SUBPATH, "lineTo");
                        return this;
                    }
                    this.addSegment(new cc.math.path.SegmentQuadratic({
                        p0: { x: this._currentPoint.x, y: this._currentPoint.y },
                        p1: { x: x0, y: y0 },
                        p2: { x: x1, y: y1 }
                    }));
                    this._currentPoint.x = x1;
                    this._currentPoint.y = y1;
                    return this;
                };
                SubPath.prototype.bezierTo = function (x0, y0, x1, y1, x2, y2) {
                    if (this._closed) {
                        cc.Debug.warn(cc.locale.WARN_TRACE_ON_CLOSED_SUBPATH, "lineTo");
                        return this;
                    }
                    this.addSegment(new cc.math.path.SegmentBezier({
                        p0: { x: this._currentPoint.x, y: this._currentPoint.y },
                        p1: { x: x0, y: y0 },
                        p2: { x: x1, y: y1 },
                        p3: { x: x2, y: y2 }
                    }));
                    this._currentPoint.x = x2;
                    this._currentPoint.y = y2;
                    return this;
                };
                SubPath.prototype.catmullRomTo = function (x0, y0, x1, y1, x2, y2, tension) {
                    if (this._closed) {
                        cc.Debug.warn(cc.locale.WARN_TRACE_ON_CLOSED_SUBPATH, "lineTo");
                        return this;
                    }
                    this.addSegment(new cc.math.path.SegmentCardinalSpline({
                        p0: {
                            x: this._currentPoint.x,
                            y: this._currentPoint.y
                        },
                        cp0: {
                            x: x0,
                            y: y0
                        },
                        cp1: {
                            x: x1,
                            y: y1
                        },
                        p1: {
                            x: x2,
                            y: y2
                        },
                        tension: tension
                    }));
                    this._currentPoint.x = x0;
                    this._currentPoint.y = y0;
                    return this;
                };
                SubPath.prototype.paint = function (ctx) {
                    ctx.beginPath();
                    for (var i = 0; i < this._segments.length; i++) {
                        this._segments[i].paint(ctx);
                    }
                    ctx.stroke();
                };
                return SubPath;
            })(ContainerSegment);
            path.SubPath = SubPath;
        })(path = math.path || (math.path = {}));
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./path/Segment.ts"/>
/// <reference path="./path/ContainerSegment.ts"/>
/// <reference path="./path/SubPath.ts"/>
/// <reference path="./Point.ts"/>
/// <reference path="./Matrix3.ts"/>
/// <reference path="../util/Debug.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var SubPath = cc.math.path.SubPath;
        var ContainerSegment = cc.math.path.ContainerSegment;
        var Vector = cc.math.Vector;
        var Matrix3 = cc.math.Matrix3;
        var __v0 = new Vector();
        var __v1 = new Vector();
        var __v2 = new Vector();
        var __v3 = new Vector();
        var __m0 = new Float32Array([1.0, 0, 0, 0, 1.0, 0, 0, 0, 1.0]);
        var __m1 = new Float32Array([1.0, 0, 0, 0, 1.0, 0, 0, 0, 1.0]);
        /**
         *
         * @class cc.math.Path
         * @extends cc.math.path.ContainerSegment
         * @classdesc
         *
         * This class represents a Path Object.
         * By definition a Path is a collection of Segment objects. These segments are SubPath objects or other Paths.
         * Polimorphically a Path is a Segment itself, so complete paths can be added to another SubPath or Path as a Segment.
         *
         * A path has tracing capabilities. It differentiates from a SubPath in a few aspects:
         *  + a Path may have a cache of the stroke it represents.
         *  + a Path may have a cache of the fill it represents.
         *  + when tracing a Path, the Segments added are transformed by a transformation matrix.
         *  + a path represents an aggregation of Subpaths (contours)
         */
        var Path = (function (_super) {
            __extends(Path, _super);
            /**
             * Build a new Path instance.
             * @method cc.math.Path#constructor
             */
            function Path() {
                _super.call(this);
                /**
                 * Path current sub path to add segments to. Initially, the current sub-path is the path itself.
                 * As new sub-paths are created, _currentSubPath will point to that last sub-path.
                 * @member cc.math.Path#_currentSubPath
                 * @type {null}
                 * @private
                 */
                this._currentSubPath = null;
            }
            /**
             * Get the Path's number of SubPaths.
             * @returns {number}
             */
            Path.prototype.numSubPaths = function () {
                return this._segments.length;
            };
            Path.prototype.__newSubPath = function () {
                var subpath = new SubPath();
                this._segments.push(subpath);
                subpath._parent = this;
                this._currentSubPath = subpath;
            };
            /**
             * Test whether this Path is empty, ie has no sub paths.
             * @returns {boolean}
             */
            Path.prototype.isEmpty = function () {
                return this._segments.length === 0;
            };
            /**
             *
             * Make sure the path has a valid sub-path to trace segments on.
             *
             * If the Path has no current sub-path,
             *   a new sub-path is created and its tracer initialized to 0,0.
             * else
             *   if the current sub-path is closed
             *     a new sub-path is created and its tracer initialized to the current sub-path tracer position
             *   endif
             * endif
             *
             * @param x {number=}
             * @param y {number=}
             * @private
             */
            Path.prototype.__ensureSubPath = function (x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (this.isEmpty()) {
                    this.__newSubPath();
                    this._currentSubPath.moveTo(x, y);
                }
            };
            Path.prototype.__chainSubPathIfCurrentIsClosed = function () {
                if (this._currentSubPath.isClosed()) {
                    var pt = this._currentSubPath._currentPoint;
                    this.__newSubPath();
                    this._currentSubPath.moveTo(pt.x, pt.y);
                }
            };
            /**
             * Get the Path current position for tracing.
             * This point corresponds to the tracing position of the current SubPath.
             * @returns {cc.math.Point}
             */
            Path.prototype.getCurrentTracePosition = function () {
                if (this._currentSubPath === null) {
                    cc.Debug.warn(cc.locale.WARN_TRACER_EMPTY, "getCurrentTracePosition");
                    return { x: 0, y: 0 };
                }
                return this._currentSubPath._currentPoint;
            };
            /**
             * Get the Path starting point.
             * It corresponds to the starting point of the first segment it contains, regardless of its type.
             * If there's no current SubPath, an empty Point (0,0) is returned.
             * @returns {*}
             */
            Path.prototype.getStartingPoint = function () {
                if (this._currentSubPath === null) {
                    cc.Debug.warn(cc.locale.WARN_TRACER_EMPTY, "getStartingPoint");
                    return __v0.set(0, 0);
                }
                return this._currentSubPath.getStartingPoint();
            };
            /**
             * Get the Path ending point.
             * It corresponds to the ending point of the last segment it contains, regardless of its type.
             * If there's no current SubPath, an empty Point (0,0) is returned.
             * @returns {*}
             */
            Path.prototype.getEndingPoint = function () {
                if (this._currentSubPath === null) {
                    cc.Debug.warn(cc.locale.WARN_TRACER_EMPTY, "getEndingPoint");
                    return __v0.set(0, 0);
                }
                return this._segments[this._segments.length - 1].getEndingPoint();
            };
            /**
             * Create a poli-line path from a set of Points.
             * If no points, or an empty array is passed, no Path is built and returns null.
             * @param points {Array<cc.math.Vector>}
             * @returns {cc.math.Path} Newly created path or null if the path can't be created.
             * @static
             */
            Path.createFromPoints = function (points) {
                if (!points || points.length === 0) {
                    return null;
                }
                var closedPath = points[0].equals(points[points.length - 1]);
                var path = new Path();
                path.beginPath();
                path.moveTo(points[0].x, points[0].y);
                for (var i = 1; i < (closedPath ? points.length - 1 : points.length); i++) {
                    path.lineTo(points[i].x, points[i].y);
                }
                if (closedPath) {
                    path.closePath();
                }
                return path;
            };
            /**
             * Clear all sub-path data, and revert to the original path object status.
             * Make sure this path is not another's path segment.
             *
             * @method cc.math.Path#beginPath
             */
            Path.prototype.beginPath = function () {
                this._segments = [];
                this._length = 0;
                this._currentSubPath = null;
                this._dirty = true;
                return this;
            };
            Path.prototype.quadraticTo = function (x1, y1, x2, y2, matrix) {
                __v0.set(x1, y1);
                __v1.set(x2, y2);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                    Matrix3.transformPoint(matrix, __v1);
                }
                this.__ensureSubPath();
                this._currentSubPath.quadraticTo(__v0.x, __v0.y, __v1.x, __v1.y);
                return this;
            };
            Path.prototype.bezierTo = function (x0, y0, x1, y1, x2, y2, matrix) {
                __v0.set(x0, y0);
                __v1.set(x1, y1);
                __v2.set(x2, y2);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                    Matrix3.transformPoint(matrix, __v1);
                    Matrix3.transformPoint(matrix, __v2);
                }
                this.__ensureSubPath();
                this._currentSubPath.bezierTo(__v0.x, __v0.y, __v1.x, __v1.y, __v2.x, __v2.y);
                return this;
            };
            Path.prototype.catmullRomTo = function (p0) {
                var rest = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    rest[_i - 1] = arguments[_i];
                }
                if (typeof p0 === "number ") {
                    // assume a catmullromTo segment call with 6 numbers and an optional matrix
                    if (arguments.length < 6) {
                        // not enough arguments
                        return;
                    }
                    this.__catmullRomTo(p0, rest[0], rest[1], rest[2], rest[3], rest[4], tension, arguments.length > 6 ? rest[5] : null);
                }
                else if (Array.isArray(p0)) {
                    var points = p0;
                    var closed = rest[0];
                    var tension = rest[1];
                    var matrix = arguments.length > 3 ? rest[2] : null;
                    // create a collection of catmullrom segments.
                    // copy array.
                    points = points.slice(0);
                    if (closed) {
                        points.unshift(points[points.length - 1]);
                        points.push(points[1]);
                        points.push(points[2]);
                    }
                    else {
                        points.unshift(points[0]);
                        points.push(points[points.length - 1]);
                    }
                    this.moveTo(points[0].x, points[0].y, matrix);
                    for (var i = 1; i < points.length - 2; i++) {
                        this.__catmullRomTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, points[i + 2].x, points[i + 2].y, tension, matrix);
                    }
                }
                else {
                    console.log("invalid signature Path.catmullRomTo");
                }
                return this;
            };
            /**
             * Add a catmull rom (cardinal spline
             * @param cp0x {number}
             * @param cp0y {number}
             * @param cp1x {number}
             * @param cp1y {number}
             * @param p1x {number}
             * @param p1y {number}
             * @param matrix {Float32Array}
             */
            Path.prototype.__catmullRomTo = function (cp0x, cp0y, cp1x, cp1y, p1x, p1y, tension, matrix) {
                __v0.set(cp0x, cp0y);
                __v1.set(cp1x, cp1y);
                __v2.set(p1x, p1y);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                    Matrix3.transformPoint(matrix, __v1);
                    Matrix3.transformPoint(matrix, __v2);
                }
                this.__ensureSubPath();
                this._currentSubPath.catmullRomTo(__v0.x, __v0.y, __v1.x, __v1.y, __v2.x, __v2.y, tension);
            };
            /**
             * Close the current SubPath.
             *
             * @returns {cc.math.Path}
             */
            Path.prototype.closePath = function () {
                this._currentSubPath.closePath();
                this._dirty = true;
                return this;
            };
            /**
             * Move the current path tracer to a position.
             * If the current sub-path is not started,
             *   set this point as the sub-path start point.
             * else
             *   if there are segments,
             *      create a new sub-path
             *   else
             *      set sub-path starting point to the new location
             * endif
             *
             * @method cc.math.Path#moveTo
             * @param x {number}
             * @param y {number}
             * @param matrix {cc.math.Float32Array=}
             */
            Path.prototype.moveTo = function (x, y, matrix) {
                if (matrix) {
                    __v0.set(x, y);
                    Matrix3.transformPoint(matrix, __v0);
                    x = __v0.x;
                    y = __v0.y;
                }
                this.__ensureSubPath(x, y);
                this._currentSubPath.moveTo(x, y);
                return this;
            };
            /**
             * Add a line to the current path.
             * If there's no current SubPath,
             * If the current path is not initialized, in will be initialized from 0,0 and a line added.
             *
             * @method cc.math.Path#lineTo
             * @param x {number}
             * @param y {number}
             * @param matrix {Float32Array=}
             */
            Path.prototype.lineTo = function (x, y, matrix) {
                if (matrix) {
                    __v0.set(x, y);
                    Matrix3.transformPoint(matrix, __v0);
                    x = __v0.x;
                    y = __v0.y;
                }
                this.__ensureSubPath(x, y);
                this.__chainSubPathIfCurrentIsClosed();
                this._currentSubPath.lineTo(x, y);
                this._dirty = true;
                return this;
            };
            /**
             * Create a rect as a new SubPath. The rect has 4 segments which conform the rect.
             * It also created a new SubPath movedTo (x,y).
             * @param x {number}
             * @param y {number}
             * @param w {number}
             * @param h {number}
             * @param matrix {Float32Array=} transformation matrix.
             * @returns {cc.math.Path}
             */
            Path.prototype.rect = function (x, y, w, h, matrix) {
                this.__ensureSubPath();
                // may reuse the current subpath ? (nosegments, and not empty)
                if (this._currentSubPath.numSegments() !== 0) {
                    this.__newSubPath();
                }
                __v0.set(x, y);
                __v1.set(x + w, y);
                __v2.set(x + w, y + h);
                __v3.set(x, y + h);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                    Matrix3.transformPoint(matrix, __v1);
                    Matrix3.transformPoint(matrix, __v2);
                    Matrix3.transformPoint(matrix, __v3);
                }
                this.moveTo(__v0.x, __v0.y);
                this.lineTo(__v1.x, __v1.y);
                this.lineTo(__v2.x, __v2.y);
                this.lineTo(__v3.x, __v3.y);
                this.closePath();
                this.__newSubPath();
                this._currentSubPath.moveTo(__v0.x, __v0.y);
                this._dirty = true;
                return this;
            };
            /**
             * Create an arc segment and add it to the current SubPath.
             * If a SubPath exists, a straight line to (x,y) is added.
             * if the angle difference is > 2PI the angle will be clampled to 2PI. The angle difference will be
             * endAngle - startAngle if anticlockwise is false, and startAngle - endAngle otherwise.
             * In this implementation if the radius is < 0, the radius will be set to 0.
             * If the radius is 0 or the diffangle is 0, no arc is added.
             *
             * @param x {number}
             * @param y {number}
             * @param radius {number}
             * @param startAngle {number}
             * @param endAngle {number}
             * @param anticlockwise {boolean} arc draw direction
             * @param matrix {Float32Array}
             */
            Path.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise, matrix) {
                var addLine = false;
                // transform position (center) based on transformation
                __v0.set(x, y);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                }
                x = __v0.x;
                y = __v0.y;
                // ensure a valid subpath to add the segment to exists.
                this.__ensureSubPath(x, y);
                // flag add a straight line from the last trace point to the start of the arc (if apply)
                if (this._currentSubPath.numSegments()) {
                    addLine = true;
                }
                // correct angles. always get the smallest angle on the arc.
                var diffAngle = (endAngle - startAngle);
                if (diffAngle > 2 * Math.PI) {
                    diffAngle = 2 * Math.PI;
                }
                else if (diffAngle < -2 * Math.PI) {
                    diffAngle = -2 * Math.PI;
                }
                // if there's no difference between start and end angles, this will be a single point arc.
                if ((-.0001 < diffAngle && diffAngle < .0001)) {
                    // bugbug should i add a line if flag addLine says so ?
                    return this;
                }
                this.__chainSubPathIfCurrentIsClosed();
                // calculate radius based on transformation. the new radius is a segment of radius size transformed
                // by the current matrix.
                radius = cc.math.path.getDistanceVector(radius, matrix).length();
                // if radius < something visible, do nothing
                if (radius <= 0.1) {
                    this.__ensureSubPath(x, y);
                    return this;
                }
                // calculate start angle based on current matrix
                if (matrix) {
                    Matrix3.copy(__m0, matrix);
                    Matrix3.setRotate(__m1, startAngle);
                    Matrix3.multiply(__m0, __m1);
                    startAngle = cc.math.path.getDistanceVector(1, matrix).angle();
                }
                this._currentSubPath.arc(x, y, radius, startAngle, startAngle + diffAngle, anticlockwise, addLine);
                this._dirty = true;
                return this;
            };
            Path.prototype.clone = function () {
                var path = new Path();
                for (var i = 0; i < this._segments.length; i++) {
                    path._segments.push(this._segments[i].clone());
                }
                path._currentSubPath = path._segments[path._segments.length - 1];
                path._length = this._length;
                return path;
            };
            Path.prototype.paint = function (ctx) {
                for (var i = 0; i < this._segments.length; i++) {
                    this._segments[i].paint(ctx);
                }
            };
            Path.prototype.getStrokeGeometry = function () {
                return [];
            };
            return Path;
        })(ContainerSegment);
        math.Path = Path;
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../math/Point.ts"/>
/// <reference path="../math/Rectangle.ts"/>
/// <reference path="../math/Dimension.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../util/util.ts"/>
/// <reference path="../util/Debug.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../action/SchedulerQueue.ts"/>
/// <reference path="../action/ActionChainContext.ts"/>
/// <reference path="./Scene.ts"/>
var cc;
(function (cc) {
    var node;
    (function (_node) {
        _node.DEFAULT_ANCHOR_POSITION = new cc.math.Vector(0, 0);
        _node.DEFAULT_ANCHOR_TRANSFORMATION = new cc.math.Vector(0.5, 0.5);
        "use strict";
        var Vector = cc.math.Vector;
        var Rectangle = cc.math.Rectangle;
        var Dimension = cc.math.Dimension;
        var Matrix3 = cc.math.Matrix3;
        var Color = cc.math.Color;
        var RADIANS = Math.PI / 180;
        /**
         * Node flag values.
         * Instead of managing several boolean properties they are grouped in a number value.
         * @tsenum cc.node.NodeDirtyFlags
         */
        (function (NodeDirtyFlags) {
            NodeDirtyFlags[NodeDirtyFlags["NONE"] = 0x0000] = "NONE";
            NodeDirtyFlags[NodeDirtyFlags["CHILDREN_SORT"] = 0x0001] = "CHILDREN_SORT";
            NodeDirtyFlags[NodeDirtyFlags["TRANSFORMATION_DIRTY"] = 0x0002] = "TRANSFORMATION_DIRTY";
            NodeDirtyFlags[NodeDirtyFlags["REQUEST_TRANSFORM"] = 0x0004] = "REQUEST_TRANSFORM";
            NodeDirtyFlags[NodeDirtyFlags["VISIBLE"] = 0x0008] = "VISIBLE";
            NodeDirtyFlags[NodeDirtyFlags["INVERSE_MATRIX"] = 0x0010] = "INVERSE_MATRIX";
            NodeDirtyFlags[NodeDirtyFlags["PAUSED"] = 0x0020] = "PAUSED";
            NodeDirtyFlags[NodeDirtyFlags["EVENTS_ENABLED"] = 0x0040] = "EVENTS_ENABLED";
            NodeDirtyFlags[NodeDirtyFlags["EVENTS_PRIORITY_ENABLED"] = 0x0080] = "EVENTS_PRIORITY_ENABLED";
            NodeDirtyFlags[NodeDirtyFlags["COMPOSITE_ON"] = 0x0100] = "COMPOSITE_ON";
            NodeDirtyFlags[NodeDirtyFlags["GLOBAL_ALPHA"] = 0x0200] = "GLOBAL_ALPHA";
            NodeDirtyFlags[NodeDirtyFlags["AABB_DIRTY"] = 0x0400] = "AABB_DIRTY";
        })(_node.NodeDirtyFlags || (_node.NodeDirtyFlags = {}));
        var NodeDirtyFlags = _node.NodeDirtyFlags;
        /**
         * Index sequence variable for node's OrderOfArrival.
         * @type {number}
         * @private
         */
        var _OrderOfArrival = 0;
        var DEFAULT_COLOR = new Color(1, 1, 1, 1);
        var __p0 = new cc.math.Vector();
        /**
         * @class cc.node.Node
         * @classdesc
         *
         * Node is the base class for all Cocos2d HTML5 elements that are screen entities.
         *
         * A Node is composed by a dimension, and some properties like position, rotation and scale, and a collection of
         * children.
         * Children are divided into two groups: children that are behind the node (z-index<0) and children that are
         * in front of the node (z-index>=0).
         * These transformation properties are hierarchically applied to its children, meaning that if a node is rotated,
         * all its children will show rotated as well.
         * A node can have input routed to it, has drawing capabilities, and can have a collection of actions predefined
         * to be applied to it.
         *
         */
        var Node = (function () {
            /**
             * Create a new Node object.
             * @method cc.node.Node#constructor
             */
            function Node() {
                /**
                 * Hierarchy dependent nodes.
                 * @member cc.node.Node#_children
                 * @type {Array<cc.node.Node>}
                 * @private
                 */
                this._children = [];
                /**
                 * This node's parent node.
                 * <br>
                 * Don't set directly.
                 * @member cc.node.Node#_parent
                 * @type {cc.node.Node}
                 * @private
                 */
                this._parent = null;
                /**
                 * This node's position.
                 * @member cc.node.Node#_position
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._position = new Vector();
                /**
                 * Node's position anchor.
                 * The anchor is normalized, meaning 1 to be node's width or height.
                 * @member cc.node.Node#_positionAnchor
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._positionAnchor = _node.DEFAULT_ANCHOR_POSITION.clone();
                /**
                 * Node's rotation angles for x and y.
                 * @member cc.node.Node#_rotation
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._rotation = new Vector(0.0, 0.0);
                /**
                 * Node's scale coeficients.
                 * @member cc.node.Node#_scale
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._scale = new Vector(0.0, 0.0);
                /**
                 * Node's skew values.
                 * @member cc.node.Node#_skew
                 * @type {cc.math.Vector}
                 * @private
                 */
                //_skew:Vector = new Vector(0, 0);
                /**
                 * Node's transformation anchor. Scale and rotation will be around this anchor value.
                 * @member cc.node.Node#_transformationAnchor
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._transformationAnchor = _node.DEFAULT_ANCHOR_TRANSFORMATION.clone();
                /**
                 * Node's local transformation matrix.
                 * @member cc.node.Node#_modelViewMatrix
                 * @type {Float32Array}
                 * @private
                 */
                this._modelViewMatrix = Matrix3.create();
                /**
                 * Node's global transformation matrix.
                 * @member cc.node.Node#_worldModelViewMatrix
                 * @type {Float32Array}
                 * @private
                 */
                this._worldModelViewMatrix = Matrix3.create();
                /**
                 * Node's inverse global transformation matrix.
                 * @member cc.node.Node#_worldModelViewMatrixI
                 * @type {Float32Array}
                 * @private
                 */
                this._worldModelViewMatrixI = Matrix3.create();
                /**
                 * Node's color. This color, when drawing images, will be set as tint color.
                 * Tinting will only be enabled in webgl renderers though.
                 * @member cc.node.Node#_color
                 * @type {cc.math.Color}
                 * @private
                 */
                this._color = DEFAULT_COLOR;
                /**
                 * opacity value. full opaque by default. opacity values go from 0 full transparent to 1 full opaque.
                 * @member cc.node.Node#_alpha
                 * @type {number}
                 * @private
                 */
                this._alpha = 1;
                /**
                 * Compound parent cascade alpha value.
                 * @member cc.node.Node#_frameAlpha
                 * @type {number}
                 * @private
                 */
                this._frameAlpha = 1;
                /**
                 * Node's dimension.
                 * @member cc.node.Node#_contentSize
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._contentSize = new Dimension();
                /**
                 * Node's z-index values.
                 * Nodes with a less than zero z-index will be drawn first, then its parent, and then nodes with a greater or
                 * equal than zero z-index value.
                 * @member cc.node.Node#_localZOrder
                 * @type {number}
                 * @private
                 */
                this._localZOrder = 0;
                /**
                 * Node's order of arrival to the parent node.
                 * When sorting a node's children, first, the z-index is taken into account. But nodes with the same z-index
                 * will then be sorted by the order of arrival.
                 * The order of arrival is by default set incrementally, but the developer has the option to modify it anytime.
                 * @member cc.node.Node#_orderOfArrival
                 * @type {number}
                 * @private
                 */
                this._orderOfArrival = 0;
                /**
                 * internal flag that indicates if the node is rotated (false) or not (true).
                 * @member cc.node.Node#_isAA
                 * @type {boolean}
                 * @private
                 */
                this._isAA = false;
                /**
                 * Axis aligned bounding box.
                 * @member cc.node.Node#_AABB
                 * @type {cc.math.Rectangle}
                 * @private
                 */
                this._AABB = new Rectangle();
                /**
                 * Bounding Box. May overlap _AABB
                 * @member cc.node.Node#_BBVertices
                 * @type {Array<cc.math.Vector>}
                 * @private
                 */
                this._BBVertices = [{ x: 0.0, y: 0.0 }, { x: 0.0, y: 0.0 }, { x: 0.0, y: 0.0 }, { x: 0.0, y: 0.0 }];
                /**
                 * Node tag. Only for backwards compatibility.
                 * @member cc.node.Node#_tag
                 * @type {any}
                 * @private
                 * @deprecated
                 */
                this._tag = null;
                /**
                 * Node name.
                 * @member cc.node.Node#_name
                 * @type {string}
                 * @private
                 */
                this._name = "";
                /**
                 * Internal integer value with some flags that affect a node.
                 * Values for this flags variable are defined in cc.node.NodeDirtyFlags.
                 * Never set this value manually.
                 * @member cc.node.Node#_flags
                 * @type {number}
                 * @private
                 */
                this._flags = 0;
                /**
                 * Scene this node is running in.
                 * @member cc.node.Node#_scene
                 * @type {cc.node.Scene}
                 * @private
                 */
                this._scene = null;
                /**
                 * When no scene is yet set, this array holds Node's actions.
                 * @member cc.node.Node#_actionsToSchedule
                 * @type {Array<cc.node.Action>}
                 * @private
                 */
                this._actionsToSchedule = [];
                /**
                 * When no scene is yet set, this array holds Node's scheduled tasks.
                 * @member cc.node.Node#_tasksToSchedule
                 * @type {Array<cc.node.Action>}
                 * @private
                 */
                this._tasksToSchedule = [];
                /**
                 * Node x position.
                 * @member cc.node.Node#x
                 * @type {number}
                 */
                this.x = 0.0;
                /**
                 * Node y position.
                 * @member cc.node.Node#y
                 * @type {number}
                 */
                this.y = 0.0;
                /**
                 * Node scale X.
                 * @member cc.node.Node#scaleX
                 * @type {number}
                 */
                this.scaleX = 1.0;
                /**
                 * Node scale Y.
                 * @member cc.node.Node#scaleY
                 * @type {number}
                 */
                this.scaleY = 1.0;
                /**
                 * Node rotation angle in degrees.
                 * @member cc.node.Node#rotationAngle
                 * @type {number}
                 */
                this.rotationAngle = 0.0;
                this._compositeOperation = 0 /* source_over */;
                this._inputEvents = {};
                this._flags = 4 /* REQUEST_TRANSFORM */ | 8 /* VISIBLE */ | 1024 /* AABB_DIRTY */;
                // for backwards compatibility, nodes with zero dimension are shown. Not in v4, where everything must have
                // dimension.
                if (cc.__BACKWARDS_COMPATIBILITY__) {
                    this._contentSize.set(1, 1);
                }
            }
            /**
             * Internal flag check for sorting children nodes.
             * @method cc.node.Node#__childrenMustSort
             * @returns {boolean}
             * @private
             */
            Node.prototype.__childrenMustSort = function () {
                return this._children.length > 1 && (this._flags & 1 /* CHILDREN_SORT */) !== 0;
            };
            /**
             * Clear a flag. To avoid managing several different boolean members we pack all of them in a number value.
             * Flag values are {@link cc.node.NodeDirtyFlags}
             * @method cc.node.Node#__clearFlag
             * @param f {number} a flag value.
             * @private
             */
            Node.prototype.__clearFlag = function (f) {
                this._flags &= ~f;
            };
            /**
             * Set a flag. To avoid managing several different boolean members we pack all of them in a number value.
             * Flag values are {@link cc.node.NodeDirtyFlags}
             * @method cc.node.Node#__clearFlag
             * @param f {number} a flag value.
             * @private
             */
            Node.prototype.__setFlag = function (f) {
                this._flags |= f;
            };
            /**
             * Return whether a flag is set.
             * @method cc.node.Node#__isFlagSet
             * @param f {number}
             * @returns {boolean}
             * @private
             */
            Node.prototype.__isFlagSet = function (f) {
                return (this._flags & f) !== 0;
            };
            /**
             * Enable or disable a flag.
             * @method cc.node.Node#__setFlagValue
             * @param f {number}
             * @param enable {boolean} true to enable, false to disable.
             * @private
             */
            Node.prototype.__setFlagValue = function (f, enable) {
                if (enable) {
                    this._flags |= f;
                }
                else {
                    this._flags &= ~f;
                }
            };
            Node.prototype.isGlobalAlpha = function () {
                return this.__isFlagSet(512 /* GLOBAL_ALPHA */);
            };
            Node.prototype.setGlobalAlpha = function (b) {
                this.__setFlagValue(512 /* GLOBAL_ALPHA */, b);
            };
            /**
             * Set the node composite operation (or blending mode).
             * blending modes available are defined in the cc.render.CompositeOperation enumeration.
             * Pass null to disable custom blending mode, and apply the currently set one.
             * @method cc.node.Node.setCompositeOperation
             * @param o {cc.render.CompositeOperation}
             */
            Node.prototype.setCompositeOperation = function (o) {
                if (o !== null) {
                    this._compositeOperation = o;
                    this.__setFlag(256 /* COMPOSITE_ON */);
                }
                else {
                    this.__clearFlag(256 /* COMPOSITE_ON */);
                }
            };
            /**
             * Set this node position in parent's coordinate space.
             * @method cc.node.Node#setPosition
             * @param x {number} x position.
             * @param y {number} y position.
             * @returns {cc.node.Node}
             */
            Node.prototype.setPosition = function (x, y) {
                this.x = x;
                this.y = y;
                return this;
            };
            /**
             * Set this node's rotation angle
             * @method cc.node.Node#setRotation
             * @param x {number} rotation angle in degrees.
             * @returns {cc.node.Node}
             */
            Node.prototype.setRotation = function (x) {
                this.rotationAngle = x;
                return this;
            };
            /**
             * Set this node's scale.
             * If y parameter is not set, the scale will be the same for both axis.
             * @method cc.node.Node#setScale
             * @param x {number} scale for x axis
             * @param y {number=} optional scale for y axis. If not set, x scale will be set for y axis.
             * @returns {cc.node.Node}
             */
            Node.prototype.setScale = function (x, y) {
                this.scaleX = x;
                this.scaleY = typeof y === "undefined" ? x : y;
                return this;
            };
            /**
             * Set the Node X axis scale value.
             * @param s {number} default scale is 1.
             * @returns {cc.node.Node}
             */
            Node.prototype.setScaleX = function (s) {
                this.scaleX = s;
                return this;
            };
            /**
             * Set the Node Y axis scale value.
             * @param s {number} default scale is 1.
             * @returns {cc.node.Node}
             */
            Node.prototype.setScaleY = function (s) {
                this.scaleY = s;
                return this;
            };
            /**
             * Gets node's parent. The parent is another Node. Some specialized node types like <code>Scene</code> and
             * <code>Director</code> don't have a parent.
             * @method cc.node.Node#getParent
             * @returns {Node} value will be null if no parent, and a Node instance otherwise.
             */
            Node.prototype.getParent = function () {
                return this._parent;
            };
            /**
             * Sets node's parent.
             * <br>
             * Never call directly.
             * @method cc.node.Node#__setParent
             * @param node {cc.node.Node}
             * @returns {cc.node.Node}
             * @private
             */
            Node.prototype.__setParent = function (node) {
                this._parent = node;
                this.__setFlag(4 /* REQUEST_TRANSFORM */);
                return this;
            };
            /**
             * Set node's positional anchor.
             * <li>By default the node will be position anchored at 0,0.
             * <li>The position anchor is a normalized value. This means it must be set with values between 0 and 1.
             * <li>Calling this method with 0,0 will means the node will be positioned relative to top-left corner.
             * <li>Calling with 0.5, 0.5, means the node will be positioned relative to its center regardless of its size.
             * @method cc.node.Node#setPositionAnchor
             * @param x {number}
             * @param y {number}
             * @returns {cc.node.Node}
             */
            Node.prototype.setPositionAnchor = function (x, y) {
                this._positionAnchor.set(x, y);
                this.__setFlag(4 /* REQUEST_TRANSFORM */);
                return this;
            };
            /**
             * Set node's positional and transformational anchors.
             * <li>By default the node will be position anchored at 0,0.
             * <li>The anchor is a normalized value. This means it must be set with values between 0 and 1.
             * <li>Calling this method with 0,0 will means the node will be positioned relative to top-left corner.
             * <li>Calling with 0.5, 0.5, means the node will be positioned relative to its center regardless of its size.
             * <li>This method is deprecated in favor of setTransformationAnchor and setPositionAnchor.
             * @method cc.node.Node#setAnchorPoint
             * @param x {number}
             * @param y {number}
             * @returns {cc.node.Node}
             * @deprecated
             */
            Node.prototype.setAnchorPoint = function (x, y) {
                this.__setFlag(4 /* REQUEST_TRANSFORM */);
                this.setTransformationAnchor(x, y);
                return this.setPositionAnchor(x, y);
            };
            /**
             * Set node's transformation anchor.
             * By default the node will be transformed (scale/rotate) by the node's center.
             * @method cc.node.Node#setTransformationAnchor
             * @param x {number}
             * @param y {number}
             * @returns {cc.node.Node}
             */
            Node.prototype.setTransformationAnchor = function (x, y) {
                this._transformationAnchor.set(x, y);
                this.__setFlag(4 /* REQUEST_TRANSFORM */);
                return this;
            };
            /**
             * Set this node's tag.
             * @method cc.node.Node#setTag
             * @param t {object}
             * @returns {cc.node.Node}
             */
            Node.prototype.setTag = function (t) {
                this._tag = t;
                return this;
            };
            /**
             * Set Node opacity. Opacity is alpha value.
             * backwards compatible method. use setAlpha or alpha get/set.
             * @param v {number} value in the range 0..255
             * @deprecated
             * @returns {cc.node.Node}
             */
            Node.prototype.setOpacity = function (v) {
                this.setAlpha(v / 255.0);
                return this;
            };
            Object.defineProperty(Node.prototype, "alpha", {
                /**
                 * Get node's transparency value.
                 * Transparency values are from 0 to 1.
                 * @name cc.node.Node#get:alpha
                 * @returns {number}
                 */
                get: function () {
                    return this.getAlpha();
                },
                /**
                 * Setter for node's alpha (transparency) value.
                 * Alpha values are from 0 to 1.
                 * @name cc.node.Node#set:alpha
                 * @param a {number}
                 */
                set: function (a) {
                    this.setAlpha(a);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "opacity", {
                /**
                 * Get node's transparency value.
                 * Transparency values are from 0 to 1.
                 * @name cc.node.Node#get:opacity
                 * @returns {number}
                 */
                get: function () {
                    return (this.getAlpha() * 255.0) | 0;
                },
                /**
                 * Setter for node's alpha (transparency) value.
                 * Alpha values are from 0 to 1.
                 * @name cc.node.Node#set:opacity
                 * @param a {number}
                 */
                set: function (a) {
                    this.setOpacity(a);
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Set node's transparency  value.
             * @method cc.node.Node#setAlpha
             * @param a {number} value from 0 to 1.
             * @returns {cc.node.Node}
             */
            Node.prototype.setAlpha = function (a) {
                this._alpha = a;
                return this;
            };
            /**
             * Get node's transparency value.
             * Transparency values are from 0 to 1.
             * @method cc.node.Node#getAlpha
             * @returns {number}
             */
            Node.prototype.getAlpha = function () {
                return this._alpha;
            };
            /**
             * Set node's color.
             * <br>
             * Color components are values between 0 and 1.
             * 0 means no color, 1 means full color component.
             *
             *
             * The color, will be Node's color, but for a Sprite, it will be the image's tint color.
             * Tint colors modify visual appearance of the node paint pixels.
             * The tint result is the pixel color multiplied by the tint color.
             * The final tint color will be: [color.red, color.green, color.blue, node.alpha]
             * The default color is solid white, which leaves pixel values unmodified.
             *
             * Alpha color modification comes by calling the opacity/alpha methods.
             *
             * @method cc.node.Node#setColor
             * @param r {number} value between 0 and 1 or a Color object instance.
             * @param g {number} between 0 and 1
             * @param b {number} between 0 and 1
             * @returns {cc.node.Node}
             */
            Node.prototype.setColor = function (r, g, b) {
                if (this._color === DEFAULT_COLOR) {
                    this._color = new Color(r, g, b);
                }
                else {
                    this._color._color[0] = r;
                    this._color._color[1] = g;
                    this._color._color[2] = b;
                }
                return this;
            };
            /**
             * Set this node's content size.
             * @method cc.node.Node#setContentSize
             * @param w {number} node width
             * @param h {number} node height
             * @returns {cc.node.Node}
             */
            Node.prototype.setContentSize = function (w, h) {
                this._contentSize.width = w;
                this._contentSize.height = h;
                this.__setFlag(4 /* REQUEST_TRANSFORM */);
                return this;
            };
            /**
             * Set node's local and global transformation matrices.
             * The matrices may not change.
             * <br>
             * Do not call directly
             * @method cc.node.Node#__setTransform
             * @returns {cc.node.Node}
             * @private
             */
            Node.prototype.__setTransform = function () {
                this.__setLocalTransform();
                this.__setWorldTransform();
                if (this.__isFlagSet(2 /* TRANSFORMATION_DIRTY */)) {
                    this.__setFlag(16 /* INVERSE_MATRIX */);
                    this.__setFlag(1024 /* AABB_DIRTY */);
                }
                return this;
            };
            /**
             * Set the Node local transformation matrix as rotation. Slowest method.
             * @method cc.node.Node#__setLocalTransformRotate
             * @private
             */
            Node.prototype.__setLocalTransformRotate = function () {
                Matrix3.setTransformAll(this._modelViewMatrix, this);
                this.__setFlag(2 /* TRANSFORMATION_DIRTY */);
                this._position.x = this.x;
                this._position.y = this.y;
                this._scale.x = this.scaleX;
                this._scale.y = this.scaleY;
                this._rotation.x = this.rotationAngle;
            };
            /**
             * Set the Node local transformation matrix as scale.
             * @method cc.node.Node#__setLocalTransformScale
             * @private
             */
            Node.prototype.__setLocalTransformScale = function () {
                Matrix3.setTransformScale(this._modelViewMatrix, this);
                this.__setFlag(2 /* TRANSFORMATION_DIRTY */);
                this._position.x = this.x;
                this._position.y = this.y;
                this._scale.x = this.scaleX;
                this._scale.y = this.scaleY;
            };
            /**
             * Set node's local transformation matrix.
             * This method is very specific and calls different code based on the transformation type that has
             * been detected.
             * @method cc.node.Node#__setLocalTransform
             * @private
             */
            Node.prototype.__setLocalTransform = function () {
                if (this._rotation.x !== this.rotationAngle || (this.rotationAngle % 360) !== 0 || this.__isFlagSet(4 /* REQUEST_TRANSFORM */)) {
                    this.__setLocalTransformRotate();
                }
                else if (this.scaleX !== this._scale.x || this._scale.y !== this.scaleY || this._scale.x !== 1 || this._scale.y !== 1) {
                    this.__setLocalTransformScale();
                }
                else if (this.x !== this._position.x || this.y !== this._position.y) {
                    var mm = this._modelViewMatrix;
                    var pa = this._positionAnchor;
                    var cs = this._contentSize;
                    var x = this.x - pa.x * cs.width;
                    var y = this.y - pa.y * cs.height;
                    mm[2] = x;
                    mm[5] = y;
                    mm[0] = 1.0;
                    mm[1] = 0.0;
                    mm[3] = 0.0;
                    mm[4] = 1.0;
                    mm[6] = 0.0;
                    mm[7] = 0.0;
                    mm[8] = 1.0;
                    this._position.x = this.x;
                    this._position.y = this.y;
                    this.__setFlag(2 /* TRANSFORMATION_DIRTY */);
                }
            };
            /**
             * Set node's global transformation when the node is not axis aligned.
             * @method cc.node.Node#__setWorldTransformNotAA
             * @private
             */
            Node.prototype.__setWorldTransformNotAA = function () {
                var mm;
                var mmm = this._worldModelViewMatrix;
                var pmm = this._parent._worldModelViewMatrix;
                mmm[0] = pmm[0];
                mmm[1] = pmm[1];
                mmm[2] = pmm[2];
                mmm[3] = pmm[3];
                mmm[4] = pmm[4];
                mmm[5] = pmm[5];
                if (this._isAA) {
                    mm = this._modelViewMatrix;
                    mmm[2] += (mm[2] * mmm[0]);
                    mmm[5] += (mm[5] * mmm[4]);
                }
                else {
                    Matrix3.multiply(this._worldModelViewMatrix, this._modelViewMatrix);
                }
            };
            /**
             * Set node's world transformation when the node is Axis Aligned.
             * An axis aligned Node means that the node, and all its ancestors are axis aligned.
             * @method cc.node.Node#__setWorldTransformAA
             * @private
             */
            Node.prototype.__setWorldTransformAA = function (px, py) {
                var wmm = this._worldModelViewMatrix;
                var mmm = this._modelViewMatrix;
                wmm[0] = mmm[0];
                wmm[1] = mmm[1];
                wmm[2] = mmm[2] + px;
                wmm[3] = mmm[3];
                wmm[4] = mmm[4];
                wmm[5] = mmm[5] + py;
                this._isAA = (this._rotation.x % 360.0) === 0.0;
            };
            /**
             * Calculate node's global transformation matrix.
             * @method cc.node.Node#__setWorldTransform
             * @private
             */
            Node.prototype.__setWorldTransform = function () {
                var condition = this.__isFlagSet(2 /* TRANSFORMATION_DIRTY */);
                var isAA = (this._rotation.x % 360.0) === 0.0;
                var px = 0;
                var py = 0;
                if (this._parent) {
                    condition = condition || this._parent.__isFlagSet(2 /* TRANSFORMATION_DIRTY */);
                    isAA = isAA && this._parent._isAA;
                }
                if (condition) {
                    this._isAA = isAA;
                    if (this._parent) {
                        px = this._parent._worldModelViewMatrix[2];
                        py = this._parent._worldModelViewMatrix[5];
                    }
                    if (isAA) {
                        this.__setWorldTransformAA(px, py);
                    }
                    else {
                        this.__setWorldTransformNotAA();
                    }
                    this.__setFlagValue(2 /* TRANSFORMATION_DIRTY */, condition);
                }
            };
            Node.prototype.getInverseWorldModelViewMatrix = function () {
                if (this.__isFlagSet(16 /* INVERSE_MATRIX */)) {
                    Matrix3.inverse(this._worldModelViewMatrix, this._worldModelViewMatrixI);
                    this.__clearFlag(16 /* INVERSE_MATRIX */);
                }
                return this._worldModelViewMatrixI;
            };
            /**
             * Visit a node.
             * The process of visiting implies several different steps and is only performed for visible nodes:
             *
             * <li>Calculate (if needed) local and global transformation matrices
             * <li>Prune the node if not showing on screen.
             * <li>Perform children sort.
             * <li>Visit children with z-index < 0
             * <li>Draw this node
             * <li>Visit children with z-index >= 0
             * <li>Reset transformation dirtiness
             *
             * @method cc.node.Node#visit
             * @param ctx {cc.render.RenderingContext}
             */
            Node.prototype.visit = function (ctx) {
                if (!this.isVisible()) {
                    return;
                }
                this.__clearFlag(2 /* TRANSFORMATION_DIRTY */);
                this.__setTransform();
                //if (this.__AABBIntersectsScreen(ctx) || true) {
                if (this.__childrenMustSort()) {
                    this.__sortChildren();
                }
                this.__setAlphaImpl();
                var index = 0;
                for (index = 0; index < this._children.length; index++) {
                    var child = this._children[index];
                    if (child._localZOrder < 0) {
                        child.visit(ctx);
                    }
                    else {
                        break;
                    }
                }
                this.__draw(ctx);
                for (; index < this._children.length; index++) {
                    var child = this._children[index];
                    child.visit(ctx);
                }
                //}
                this.__clearFlag(4 /* REQUEST_TRANSFORM */);
            };
            Node.prototype.__setAlphaImpl = function () {
                if (!this._parent) {
                    this._frameAlpha = this._alpha;
                }
                else {
                    this._frameAlpha = this._parent._frameAlpha * this._alpha;
                }
            };
            /**
             * Calculate if a node is in screen bounds.
             * @param ctx {cc.render.RenderingContext}
             * @method cc.node.Node#__AABBIntersectsScreen
             * @returns {boolean} the node is in screen or not.
             * @private
             */
            Node.prototype.__AABBIntersectsScreen = function (ctx) {
                this.calculateBoundingBox();
                return this._AABB.intersects(0, 0, ctx.getWidth(), ctx.getHeight());
            };
            /**
             * Calculate a node's Bounding box when the node is not axis aligned.
             * @method cc.node.Node#__calculateNAABBVertices
             * @private
             */
            Node.prototype.__calculateNAABBVertices = function () {
                var vv = this._BBVertices;
                var _w = this._contentSize.width;
                var _h = this._contentSize.height;
                // way chepaer to work on properties than vv[0].set
                var v = vv[0];
                v.x = 0;
                v.y = 0;
                this.convertToWorldSpace(v);
                v = vv[1];
                v.x = _w;
                v.y = 0;
                this.convertToWorldSpace(v);
                v = vv[2];
                v.x = _w;
                v.y = _h;
                this.convertToWorldSpace(v);
                v = vv[3];
                v.x = 0;
                v.y = _h;
                this.convertToWorldSpace(v);
            };
            /**
             * Calculate a node's bounding box when the node is axis aligned.
             * @method cc.node.Node#__calculateAABBVertices
             * @private
             */
            Node.prototype.__calculateAABBVertices = function () {
                var vv = this._BBVertices;
                var x, y, w, h;
                var mm = this._worldModelViewMatrix;
                x = mm[2];
                y = mm[5];
                w = this._contentSize.width * mm[0];
                h = this._contentSize.height * mm[4];
                // cheaper than calling set on vectors.
                var v;
                v = vv[0];
                v.x = x;
                v.y = y;
                v = vv[1];
                v.x = x + w;
                v.y = y;
                v = vv[2];
                v.x = x + w;
                v.y = y + h;
                v = vv[3];
                v.x = x;
                v.y = y + h;
            };
            /**
             * Calculate a node's bounding box.
             * @method cc.node.Node#__calculateBoundingBox
             * @returns {cc.node.Node}
             * @private
             */
            Node.prototype.calculateBoundingBox = function () {
                if (!this.__isFlagSet(1024 /* AABB_DIRTY */)) {
                    return this._AABB;
                }
                var verts = this._BBVertices;
                if (this._isAA) {
                    this.__calculateAABBVertices();
                }
                else {
                    this.__calculateNAABBVertices();
                }
                var xmin = Number.MAX_VALUE;
                var ymin = Number.MAX_VALUE;
                var xmax = -Number.MAX_VALUE;
                var ymax = -Number.MAX_VALUE;
                // way faster to do comparison chain than Math.min chain
                var v = verts[0];
                if (v.x < xmin) {
                    xmin = v.x;
                }
                if (v.x > xmax) {
                    xmax = v.x;
                }
                if (v.y < ymin) {
                    ymin = v.y;
                }
                if (v.y > ymax) {
                    ymax = v.y;
                }
                var v = verts[1];
                if (v.x < xmin) {
                    xmin = v.x;
                }
                if (v.x > xmax) {
                    xmax = v.x;
                }
                if (v.y < ymin) {
                    ymin = v.y;
                }
                if (v.y > ymax) {
                    ymax = v.y;
                }
                var v = verts[2];
                if (v.x < xmin) {
                    xmin = v.x;
                }
                if (v.x > xmax) {
                    xmax = v.x;
                }
                if (v.y < ymin) {
                    ymin = v.y;
                }
                if (v.y > ymax) {
                    ymax = v.y;
                }
                var v = verts[3];
                if (v.x < xmin) {
                    xmin = v.x;
                }
                if (v.x > xmax) {
                    xmax = v.x;
                }
                if (v.y < ymin) {
                    ymin = v.y;
                }
                if (v.y > ymax) {
                    ymax = v.y;
                }
                // faster set properties than call.
                var aa = this._AABB;
                aa.x = xmin;
                aa.y = ymin;
                aa.w = xmax - xmin;
                aa.h = ymax - ymin;
                this.__clearFlag(1024 /* AABB_DIRTY */);
                return this._AABB;
            };
            /**
             * Convert a coordinate to world (screen) space.
             * @method cc.node.Node#convertToWorldSpace
             * @param p {Vector}
             */
            Node.prototype.convertToWorldSpace = function (p) {
                Matrix3.transformPoint(this._worldModelViewMatrix, p);
            };
            /**
             * Draw a node.
             * @method cc.node.Node#__draw
             * @param ctx {cc.render.RenderingContext}
             * @private
             */
            Node.prototype.__draw = function (ctx) {
                Matrix3.setRenderingContextTransform(this._worldModelViewMatrix, ctx);
                var compositeSet = this.__isFlagSet(256 /* COMPOSITE_ON */);
                var prevComposite = ctx.getCompositeOperation();
                compositeSet = compositeSet && this._compositeOperation !== prevComposite;
                if (compositeSet) {
                    ctx.setCompositeOperation(this._compositeOperation);
                }
                this.draw(ctx);
                if (compositeSet) {
                    ctx.setCompositeOperation(prevComposite);
                }
            };
            /**
             * Get the node scene reference.
             * Each node belongs to an scene, which is held in this variable. Scenes have scheduling capabilities
             * and director references.
             * @method cc.node.Node#getScene
             * @returns {cc.node.Scene}
             */
            Node.prototype.getScene = function () {
                return this._scene;
            };
            /**
             * Get the path of nodes to the top node, normally a <code>cc.node.Director</node> object.
             * @method cc.node.Node#getPathToRoot
             * @returns {Array<cc.node.Node>}
             */
            Node.prototype.getPathToRoot = function () {
                var node = this;
                var ret = [];
                do {
                    ret.push(node);
                    node = node.getParent();
                } while (node);
                return ret;
            };
            /**
             * Get the path of nodes to the cc.node.Scene containing this Node.
             * This method is called by <code>cc.node.Node#enableEventsForNode</code> because
             * the input manager captures input based on a Scene.
             * @method cc.node.Node#getPathToScene
             * @returns {Array<cc.node.Node>}
             */
            Node.prototype.getPathToScene = function () {
                if (!this._scene) {
                    return [];
                }
                var node = this;
                var ret = [];
                do {
                    ret.push(node);
                    if (node === this._scene) {
                        break;
                    }
                    node = node.getParent();
                } while (node !== null);
                return ret;
            };
            /**
             * Register a callback for an event type.
             * @method cc.node.Node#addEventListener
             * @param event {string} event name: mouseup, mousedown, mousemove, mousedrag, mouseover, mouseout, doubleclick
             * @param callback {function} a callback function that will receive an InputManager.Event object.
             */
            Node.prototype.addEventListener = function (event, callback) {
                this._inputEvents[event] = callback;
                return this;
            };
            /**
             * Notify an event callback based on the event type.
             * @method cc.node.Node#notifyEvent
             * @param e {cc.event.InputManagerEvent}
             * @returns {boolean} whether the event must bubble.
             */
            Node.prototype.notifyEvent = function (e) {
                var callback = this._inputEvents[e.type];
                if (e.type === "touchstart") {
                    if (!callback) {
                        callback = this._inputEvents["mousedown"];
                    }
                }
                else if (e.type === "touchend") {
                    if (!callback) {
                        callback = this._inputEvents["mouseup"];
                    }
                }
                else if (e.type === "touchmove") {
                    if (!callback) {
                        callback = this._inputEvents["mousedrag"];
                    }
                }
                else if (e.type === "touchover") {
                    if (!callback) {
                        callback = this._inputEvents["mouseover"];
                    }
                }
                else if (e.type === "touchout") {
                    if (!callback) {
                        callback = this._inputEvents["mouseout"];
                    }
                }
                if (callback) {
                    return callback(e);
                }
                return false;
            };
            /**
             * Get a point in screen space turned into local node space.
             * When nodes are axis aligned, this is trivial, but for transformed nodes this method is needed.
             * The point will be modified.
             * See input demos.
             * @method cc.node.Node#getScreenPointInLocalSpace
             * @param p {cc.math.Vector}
             */
            Node.prototype.getScreenPointInLocalSpace = function (p) {
                var matrix = this.getInverseWorldModelViewMatrix();
                cc.math.Matrix3.transformPoint(matrix, p);
            };
            /**
             * Get a point in local Node space turned into screen space.
             * When nodes are axis aligned, this is trivial, but for transformed nodes this method is needed.
             * The point will be modified.
             * See input demos.
             * @method cc.node.Node#getLocalPointInScreenSpace
             * @param p {cc.math.Vector}
             */
            Node.prototype.getLocalPointInScreenSpace = function (p) {
                cc.math.Matrix3.transformPoint(this._worldModelViewMatrix, p);
            };
            /**
             * Get a point in local Node space turned into another Node's local space.
             * When nodes are axis aligned, this is trivial, but for transformed nodes this method is needed.
             * The point will be modified.
             * See input demos.
             * @method cc.node.Node#getLocalPointInNodeSpace
             * @param p {cc.math.Vector}
             */
            Node.prototype.getLocalPointInNodeSpace = function (p, node) {
                this.getLocalPointInScreenSpace(p);
                node.getScreenPointInLocalSpace(p);
            };
            /**
             * Get whether a point in screen space lies in the Node's bounds.
             * When nodes are axis aligned, this is trivial, but for transformed nodes this method is needed.
             * See input demos.
             * @method cc.node.Node#isScreenPointInNode
             * @param p {cc.math.Vector}
             */
            Node.prototype.isScreenPointInNode = function (p) {
                if (!this.isVisible()) {
                    return false;
                }
                this.getScreenPointInLocalSpace(p);
                return p.x >= 0 && p.y >= 0 && p.x < this._contentSize.width && p.y < this._contentSize.height;
            };
            /**
             * Add a child node to this node.
             * The Node is added immediately and the array of children nodes is flagged for sort at the next call to
             * the <code>visit</code> method.
             *
             * @method cc.node.Node#addChild
             * @param node {cc.node.Node} a Node to add as child.
             * @param localZOrder {number=} an optional zIndex for the Node. If set, this value will overwrite the Node's
             *   previous localZOrder value.
             *
             * @returns {cc.node.Node}
             *
             * @see {cc.node.Node#visit}
             */
            Node.prototype.addChild = function (node, localZOrder) {
                if (arguments.length > 2) {
                    this.__legacyAddChild.apply(this, Array.prototype.slice.call(arguments));
                    return this;
                }
                if (node._parent) {
                    cc.Debug.error(cc.locale.MSG_ERROR_NODE_WITH_PARENT);
                }
                node._orderOfArrival = _OrderOfArrival++;
                node._parent = this;
                if (typeof localZOrder !== "undefined") {
                    node._localZOrder = localZOrder;
                }
                // there are some nodes to compare index with
                if (this._children.length > 0) {
                    // node with smaller zindex than the first child.
                    if (node._localZOrder < this._children[0]._localZOrder) {
                        // add node from the head.
                        this._children.unshift(node);
                    }
                    else if (node._localZOrder >= this._children[this._children.length - 1]._localZOrder) {
                        // node with same localzorder than the last one. add and no sort since orderofarrival is bigger.
                        this._children.push(node);
                    }
                    else {
                        // just add the children and mark for sort
                        this.__setFlag(1 /* CHILDREN_SORT */);
                        this._children.push(node);
                    }
                }
                else {
                    // first child, just add.
                    this._children.push(node);
                }
                // add scheduled actions and tasks
                if (this.getScene() !== null) {
                    node.setScene(this.getScene());
                }
                // PENDING: running behavior, onEnter and onEnterTransitionDidFinish
                return this;
            };
            Node.prototype.__legacyAddChild = function (child, localZOrder, tag) {
                localZOrder = localZOrder === undefined ? child._localZOrder : localZOrder;
                var name, setTag = false;
                if (typeof tag === "undefined") {
                    tag = undefined;
                    name = child._name;
                }
                else if (typeof tag === 'string') {
                    name = tag;
                    tag = undefined;
                }
                else if (typeof tag === "number") {
                    setTag = true;
                    name = "";
                }
                if (!this._children)
                    this._children = [];
                this._children.push(child);
                child._localZOrder = localZOrder;
                if (setTag)
                    child.setTag(tag);
                else
                    child.setName(name);
                child._parent = this;
                child._orderOfArrival = _OrderOfArrival++;
                // add scheduled actions and tasks
                if (this.getScene() !== null) {
                    child.setScene(this.getScene());
                }
                this.__setFlag(1 /* CHILDREN_SORT */);
            };
            /**
             * Change a node's z-index.
             * <br>
             * This will schedule a children sort on next visit call.
             * A call to this method with set orderOfArrival no a new value.
             * @method cc.node.Node#reorderChild
             * @param node {cc.node.Node}
             * @param localZOrder
             */
            Node.prototype.reorderChild = function (node, localZOrder) {
                this.__setFlag(1 /* CHILDREN_SORT */);
                node._orderOfArrival = _OrderOfArrival++;
                node._localZOrder = localZOrder;
            };
            /**
             * Sort a node's children.
             * Children are sorted based on zOrder and orderOfArrival.
             * @method cc.node.Node#__sortChildren
             * @private
             */
            Node.prototype.__sortChildren = function () {
                this._children.sort(function (n0, n1) {
                    if (n0._localZOrder < n1._localZOrder) {
                        return -1;
                    }
                    else if (n0._localZOrder > n1._localZOrder) {
                        return 1;
                    }
                    return n0._orderOfArrival < n1._orderOfArrival ? -1 : 1;
                });
                this.__clearFlag(1 /* CHILDREN_SORT */);
            };
            /**
             * Remove a child from a node.
             * @method cc.node.Node#removeChild
             * @param node {cc.node.Node} node to remove
             * @param cleanup {boolean=} should clean up ?
             */
            Node.prototype.removeChild = function (node, cleanup) {
                var index = this._children.indexOf(node);
                if (index >= 0) {
                    // PENDING: call onExit() if node is running
                    if (cleanup) {
                        // do cleanup of actions and/or scheduled callbacks
                        this.stopAllActions();
                        this.unscheduleAllCallbacks();
                    }
                    this._children.splice(index, 1);
                    node._parent = null;
                    node._scene = this._scene;
                }
                return this;
            };
            /**
             * Remove the node from its parent.
             * @method cc.node.Node#removeFromParent
             * @param cleanup {boolean} if true, all node's scheduled callbacks will be removed too.
             * @returns {cc.node.Node}
             */
            Node.prototype.removeFromParent = function (cleanup) {
                if (!this._parent) {
                    cc.Debug.warn(cc.locale.NODE_WARN_REMOVEFROMPARENT_WITH_NO_PARENT);
                    return;
                }
                this._parent.removeChild(this, cleanup);
                if (cleanup) {
                    this.cleanup();
                }
                return this;
            };
            /**
             * Remove all Node's child nodes.
             * @method cc.node.Node#removeAllChildren
             * @returns {cc.node.Node}
             */
            Node.prototype.removeAllChildren = function (cleanup) {
                for (var i = 0; i < this._children.length; i++) {
                    this._children[i]._parent = null;
                }
                this._children = [];
                // PENDING unschedule actions.
                return this;
            };
            /**
             * Get the node's children list.
             * @method cc.node.Node#getChildren
             * @returns {Array<cc.node.Node>}
             */
            Node.prototype.getChildren = function () {
                return this._children;
            };
            /**
             * Get a node's root node.
             * A node's root node normally will be a Scene type node.
             * @method cc.node.Node#getRootNode
             * @returns {cc.node.Node}
             */
            Node.prototype.getRootNode = function () {
                var node = this;
                while (node._parent) {
                    node = node._parent;
                }
                return node;
            };
            /**
             * Enumerate al children of a node that matches a pattern.
             * If a pattern starts with // the search will be recursively performed from the root node. It is only legal
             *  to define // at the beginning of the pattern.
             * If a pattern starts with / the search will be performed from the root node.
             *
             * The pattern accepts the wildcard symbol '*' meaning any value will match.
             * The pattern accepts the symbol '..' meaning it references a node's parent.
             *
             * Example patterns:
             *
             * <li><b>//*</b> . This pattern will get all descendant nodes from a node.
             * <li><b>/child0/grandchild1</b> . This pattern will get all grandchildren of a node with name grandchild1 that have
             * a parent node with name child0.
             * <li><b>/*\/grandchild0</b> . This pattern will get all grandchildren of a node which have the name grandchild0.
             *
             * @method cc.node.Node#enumerateChildren
             * @param patternName {string} a search pattern. Patterns are composed of regular expressions separated by slash / characters.
             * @param callback {EnumerateCallback} a callback function invoked for each node that matches the pattern.
             */
            Node.prototype.enumerateChildren = function (patternName, callback) {
                // no string patternName, nothing to check for.
                if (typeof patternName !== "string") {
                    return;
                }
                var node = this;
                var recursive = false;
                if (patternName.indexOf("//") === 0) {
                    recursive = true;
                    patternName = patternName.substr(2);
                    node = this.getRootNode();
                }
                if (patternName.indexOf("//") !== -1) {
                    cc.Debug.error(cc.locale.MSG_WRONG_ENUMERATE_PATTERN);
                }
                patternName = cc.util.fromPosixRegularExpression(patternName);
                while (patternName.indexOf("/") === 0) {
                    node = this.getRootNode();
                    patternName = patternName.substr(1);
                }
                var orgPatternData = [];
                var patterns = patternName.split("/");
                for (var i = 0; i < patterns.length; i++) {
                    var pattern = patterns[i];
                    if (pattern === "*") {
                        pattern = ".*";
                    }
                    orgPatternData.push(new RegExp(pattern));
                }
                node.__enumerateChildrenImpl(orgPatternData, orgPatternData, callback, recursive);
            };
            /**
             * Do the actual enumeration.
             * @method cc.node.Node#__enumerateChildrenImpl
             * @param orgPatternData {Array<RegExp>}
             * @param patternData {Array<RegExp>
             * @param callback {EnumerateCallback} callback function executed for each node that matches the pattern.
             * @param recursive {boolean} is this a recursive enumeration ?
             * @private
             */
            Node.prototype.__enumerateChildrenImpl = function (orgPatternData, patternData, callback, recursive) {
                // reached the end of a path
                if (!patternData.length) {
                    callback(this);
                    if (recursive) {
                        this.__enumerateChildrenImpl(orgPatternData, orgPatternData, callback, recursive);
                    }
                    return;
                }
                else if (patternData[0].toString() === "/../") {
                    if (!this._parent) {
                        cc.Debug.error(cc.locale.MSG_ENUMERATE_UNDERFLOW);
                    }
                    else {
                        this._parent.__enumerateChildrenImpl(orgPatternData, patternData.slice(1, patternData.length), callback, recursive);
                    }
                    return;
                }
                for (var i = 0; i < this._children.length; i++) {
                    var child = this._children[i];
                    // the current pattern path is ok.
                    if (patternData[0].test(child._name)) {
                        child.__enumerateChildrenImpl(orgPatternData, patternData.slice(1, patternData.length), callback, recursive);
                    }
                    else {
                        // current path is not ok, but if recursive, apply whole pattern path from this node.
                        if (recursive) {
                            child.__enumerateChildrenImpl(orgPatternData, orgPatternData, callback, recursive);
                        }
                    }
                }
            };
            /**
             * Draw a node.
             * Override this method to draw.
             * Draw like a boss w/o worrying of current affine transformation matrix.
             * @method cc.node.Node#draw
             * @param ctx {cc.render.RenderingContext} a rendering context, either canvas or webgl.
             */
            Node.prototype.draw = function (ctx) {
                if (this._color !== DEFAULT_COLOR) {
                    ctx.setGlobalAlpha(this._frameAlpha);
                    ctx.setTintColor(cc.math.Color.WHITE);
                    ctx.setFillStyleColor(this._color);
                    ctx.fillRect(0, 0, this._contentSize.width, this._contentSize.height);
                }
            };
            /**
             * Set this node's name. Suitable for identifying and enumerateChildren.
             * @method cc.node.Node#setName
             * @param name {string} must be composed of [A-Za-z0-9_]+ characters.
             * @returns {cc.node.Node}
             */
            Node.prototype.setName = function (name) {
                if (!/[A-Za-z0-9_]+/.test(name)) {
                    cc.Debug.error(cc.locale.ERR_NODE_NAME_INVALID);
                }
                this._name = name;
                return this;
            };
            Node.prototype.startActionChain = function () {
                return new cc.action.ActionChainContext(this);
            };
            /**
             * Schedule an action to run.
             * By the time an action is meant to be scheduled for running in a Node, there may not yet be a
             * <code>Director</code> or <code>Scene</code>. This method saves locally the actions which will be
             * scheduled in a scene's <code>ActionManager</code> later.
             * @method cc.node.Node#runAction
             * @param action {cc.action.Action}
             * @returns {cc.node.Node}
             */
            Node.prototype.runAction = function (action) {
                if (this._scene) {
                    this._scene.scheduleActionForNode(this, action);
                }
                else {
                    this._actionsToSchedule.push(action);
                }
                return this;
            };
            /**
             * Stop a Node action with the given tag.
             * @method cc.node.Node#stopActionByTag
             * @param tag {string} action tag.
             * @returns {cc.node.Node}
             */
            Node.prototype.stopActionByTag = function (tag) {
                if (this._scene) {
                    this._scene.stopNodeActionByTag(this, tag);
                }
                return this;
            };
            Node.prototype.stopAllActions = function () {
                if (this._scene) {
                    this._scene.stopActionsForNode(this);
                }
                else {
                    this._actionsToSchedule = [];
                }
                return this;
            };
            /**
             * Set Node's Scene and allow for buffered Actions to be scheduled.
             * This method is called when <code>scene.onEnter</code> is called.
             * @method cc.node.Node#setScene
             * @param scene {cc.node.Scene}
             */
            Node.prototype.setScene = function (scene) {
                if (!scene) {
                    return;
                }
                this._scene = scene;
                for (var i = 0; i < this._actionsToSchedule.length; i++) {
                    scene.scheduleActionForNode(this, this._actionsToSchedule[i]);
                }
                this._actionsToSchedule = [];
                for (var i = 0; i < this._tasksToSchedule.length; i++) {
                    scene.scheduleTask(this._tasksToSchedule[i]);
                }
                this._tasksToSchedule = [];
                if (this.__isFlagSet(64 /* EVENTS_ENABLED */)) {
                    this.__clearFlag(64 /* EVENTS_ENABLED */);
                    this._scene.enableEventsForNode(this);
                }
                if (this.__isFlagSet(128 /* EVENTS_PRIORITY_ENABLED */)) {
                    this.__clearFlag(128 /* EVENTS_PRIORITY_ENABLED */);
                    this._scene.enablePriorityEventsForNode(this);
                }
                for (var i = 0; i < this._children.length; i++) {
                    this._children[i].setScene(scene);
                }
            };
            Node.prototype.enableEvents = function (enable) {
                if (this._scene) {
                    this._scene.enableEventsForNode(this);
                }
                else {
                    this.__setFlag(64 /* EVENTS_ENABLED */);
                }
                return this;
            };
            Node.prototype.enablePriorityEvents = function (enable, priority) {
                this._inputEvents.priorityEventValue = priority;
                if (this._scene) {
                    this._scene.enablePriorityEventsForNode(this);
                }
                else {
                    this.__setFlag(128 /* EVENTS_PRIORITY_ENABLED */);
                }
                return this;
            };
            Node.prototype.getInputPriority = function () {
                return this._inputEvents.priorityEventValue;
            };
            /**
             * Set the node's visibility.
             * @method cc.node.Node#setVisible
             * @param v {boolean}
             */
            Node.prototype.setVisible = function (v) {
                if (v !== this.__isFlagSet(8 /* VISIBLE */)) {
                    if (v) {
                        this.__setFlag(8 /* VISIBLE */);
                    }
                    else {
                        this.__clearFlag(8 /* VISIBLE */);
                    }
                    this.__setFlag(2 /* TRANSFORMATION_DIRTY */);
                }
            };
            Node.prototype.isVisible = function () {
                return this.__isFlagSet(8 /* VISIBLE */);
            };
            Node.prototype.cleanup = function () {
                this.stopAllActions();
                this.unscheduleAllCallbacks();
                for (var i = 0; i < this._children.length; i++) {
                    this._children[i].cleanup();
                }
            };
            /////////////// SCHEDULER METHODS START ////////////////
            /**
             * This method is here for only for backwards compatibility purposes.
             * it exists for historical reasons. Comes from Cocos2d iphone v2.
             * It is called when a call to scheduleUpdate is made.
             * @method cc.node.Node#update
             * @param delta {number}
             * @deprecated
             */
            Node.prototype.update = function (delta) {
            };
            /**
             * Schedule a update call with the given priority. <code>scheduleUpdate</code>,
             * <code>scheduleUpdateWithPriority</code> and <code>unscheduleUpdate</code>
             * methods are just for backwards compatibility.
             * @deprecated
             * @method cc.node.Node#scheduleUpdateWithPriority.
             * @param priority {number}
             */
            Node.prototype.scheduleUpdateWithPriority = function (priority) {
                var task = cc.action.SchedulerQueue.createSchedulerTask(this, this.update, 0, Number.MAX_VALUE, 0);
                task._priority = priority;
                this.__scheduleImpl(task);
            };
            /**
             * Schedule a task to per frame call update for this node.
             * <code>scheduleUpdate</code>,
             * <code>scheduleUpdateWithPriority</code> and <code>unscheduleUpdate</code>
             * methods are just for backwards compatibility.
             * @method cc.node.Node#scheduleUpdate
             * @deprecated
             */
            Node.prototype.scheduleUpdate = function () {
                var task = cc.action.SchedulerQueue.createSchedulerTask(this, this.update, 0, Number.MAX_VALUE, 0);
                this.__scheduleImpl(task);
            };
            Node.prototype.__scheduleImpl = function (task) {
                if (this._scene) {
                    this._scene.scheduleTask(task);
                }
                else {
                    this._tasksToSchedule.push(task);
                }
            };
            /**
             * Unschedule all update callbacks for this node.
             * <code>scheduleUpdate</code>,
             * <code>scheduleUpdateWithPriority</code> and <code>unscheduleUpdate</code>
             * methods are just for backwards compatibility.
             * @method cc.node.Node#unscheduleUpate
             */
            Node.prototype.unscheduleUpate = function () {
                if (this._scene) {
                    this._scene.unscheduleCallbackForTarget(this, this.update);
                }
            };
            /**
             * Schedule a task for the node.
             * This node will be passed as target to the specified callback function.
             * If already exist a task in the scheduler for the same pair of node and callback, the task will be updated
             * with the new data.
             * @method cc.node.Node#schedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to invoke
             * @param interval {number} repeat interval time. the task will be fired every this amount of milliseconds.
             * @param repeat {number=} number of repetitions. if not set, infinite will be used.
             * @param delay {number=} wait this millis before firing the task.
             */
            Node.prototype.schedule = function (callback_fn, interval, repeat, delay) {
                var task = cc.action.SchedulerQueue.createSchedulerTask(this, callback_fn, interval, repeat, delay);
                if (this._scene) {
                    this._scene.scheduleTask(task);
                }
                else {
                    this._tasksToSchedule.push(task);
                }
            };
            /**
             * Schedule a single shot task. Will fired only once.
             * @method cc.node.Node#scheduleOnce
             * @param callback_fn {cc.action.SchedulerTaskCallback} scheduler callback.
             * @param delay {number} milliseconds to wait before firing the task.
             * @returns {cc.node.Node}
             */
            Node.prototype.scheduleOnce = function (callback_fn, delay) {
                this.schedule(callback_fn, 0.0, 0, delay);
            };
            /**
             * Unschedule a task for the node.
             * @method cc.node.Node#unschedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to unschedule.
             */
            Node.prototype.unschedule = function (callback_fn) {
                if (!callback_fn)
                    return;
                if (this._scene) {
                    this._scene.unscheduleCallbackForTarget(this, callback_fn);
                }
            };
            /**
             * Unschedule all tasks for the node.
             * @method cc.node.Node#unscheduleAllCallbacks
             */
            Node.prototype.unscheduleAllCallbacks = function () {
                if (this._scene) {
                    this._scene.unscheduleAllCallbacks(this);
                }
                else {
                    this._tasksToSchedule = [];
                }
            };
            /**
             * Resumes all scheduled tasks and actions.
             * This method is called internally by onEnter
             * @method cc.node.Node#resume
             */
            Node.prototype.resume = function () {
                if (this._scene) {
                    this._scene.resumeTarget(this);
                }
                // PENDING: implement
                //cc.eventManager.resumeTarget(this);
            };
            /**
             * Pauses all scheduled selectors and actions.
             * This method is called internally by onExit.
             * @method cc.node.Node#pause
             *
             */
            Node.prototype.pause = function () {
                if (this._scene) {
                    this._scene.pauseTarget(this);
                }
                // PENDING: implement
                //cc.eventManager.pauseTarget(this);
            };
            /**
             * V3 compatible method call.
             * The preferred and more powerful way of setting a node's composite operation will be
             * <code>setCompositeOperation</code>.
             *
             * @deprecated
             * @param src_o { number|{src:number, dst:number} } webgl blending source operation or an object with
             *   webgl blending source and destination operations.
             * @param dst {number} webgl blending destination operation.
             *
             * @returns {number} a cc.render.CompositeOperation enumeration value.
             */
            Node.prototype.setBlendFunc = function (src_o, dst) {
                cc.Debug.warn(cc.locale.WARN_DEPRECATED_SETBLENDFUNC);
                var src;
                if (typeof dst === "undefined") {
                    dst = src_o.dst;
                    src = src_o.src;
                }
                else {
                    src = src_o;
                }
                if ((src === cc.SRC_ALPHA && dst === cc.ONE)) {
                    this.setCompositeOperation(11 /* lighter */);
                }
                else if ((src === cc.ONE && dst === cc.ONE)) {
                    this.setCompositeOperation(14 /* add */);
                }
                else if (src === cc.ZERO && dst === cc.SRC_ALPHA) {
                    this.setCompositeOperation(5 /* destination_in */);
                }
                else if (src === cc.ZERO && dst === cc.ONE_MINUS_SRC_ALPHA) {
                    this.setCompositeOperation(6 /* destination_out */);
                }
                else {
                    this.setCompositeOperation(0 /* source_over */);
                }
            };
            /////////////// SCHEDULER METHODS END ////////////////
            /**
             * Set a bunch of properties for the node.
             * If a property does exists in Node, a warning is emitted and nothing will happen.
             * Only for backwards compatibility.
             * @deprecated
             * @method cc.node.Node#attr
             * @param properties {any} Collection of key/value pairs.
             * @returns {cc.node.Node}
             */
            Node.prototype.attr = function (properties) {
                for (var property in properties) {
                    if (properties.hasOwnProperty(property)) {
                        var value = properties[property];
                        this[property] = value;
                    }
                }
                return this;
            };
            Object.defineProperty(Node.prototype, "width", {
                get: function () {
                    return this._contentSize.width;
                },
                /**
                 * @deprecated
                 * @method cc.node.Node#set:width
                 * @param v {number}
                 */
                set: function (v) {
                    this._contentSize.width = v;
                    this.__setFlag(4 /* REQUEST_TRANSFORM */);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "height", {
                get: function () {
                    return this._contentSize.height;
                },
                /**
                 * @deprecated
                 * @method cc.node.Node#set:height
                 * @param v {number}
                 */
                set: function (v) {
                    this._contentSize.height = v;
                    this.__setFlag(4 /* REQUEST_TRANSFORM */);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "color", {
                /**
                 * @deprecated
                 * @method cc.node.Node#set:color
                 * @param v {cc.math.Color}
                 */
                set: function (v) {
                    this.setColor(v._color[0], v._color[1], v._color[2]);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "rotation", {
                get: function () {
                    return this.rotationAngle;
                },
                /**
                 * @deprecated
                 * @method cc.node.Node#set:rotation
                 * @param angle_in_deg {number}
                 */
                set: function (angle_in_deg) {
                    this.rotationAngle = angle_in_deg;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "visible", {
                get: function () {
                    return this.isVisible();
                },
                /**
                 * @deprecated
                 * @method cc.node.Node#set:visible
                 * @param v {boolean}
                 */
                set: function (v) {
                    this.setVisible(v);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "anchorX", {
                set: function (a) {
                    this._positionAnchor.x = a;
                    this._transformationAnchor.x = a;
                    this.__setFlag(4 /* REQUEST_TRANSFORM */);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "anchorY", {
                set: function (a) {
                    this._positionAnchor.y = a;
                    this._transformationAnchor.y = a;
                    this.__setFlag(4 /* REQUEST_TRANSFORM */);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "scale", {
                set: function (s) {
                    this.scaleX = s;
                    this.scaleY = s;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "parent", {
                get: function () {
                    return this._parent;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "children", {
                get: function () {
                    return this._children;
                },
                enumerable: true,
                configurable: true
            });
            return Node;
        })();
        _node.Node = Node;
    })(node = cc.node || (cc.node = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./TimeInterpolator.ts"/>
/// <reference path="./ActionManager.ts"/>
/// <reference path="./ActionChainContext.ts"/>
var cc;
(function (cc) {
    var action;
    (function (_action) {
        /**
         * This value is a time unit divisor constant.
         * CocosJS expects all time units to be in seconds, hence the default value of 1000.
         * But you could easily change time unit values to milliseconds, changing this value to 1, and setting all
         * actions/scheduler time units in millis.
         *
         * @member cc.action.TIMEUNITS
         * @type {number}
         */
        _action.TIMEUNITS = 1000;
        var SECONDS = 1000;
        var MILLISECONDS = 1;
        /**
         * Change time units on actions, schedulers, etc to seconds.
         * This is the default type.
         * @name setTimeReferenceInSeconds
         * @memberof cc.action
         */
        function setTimeReferenceInSeconds() {
            cc.action.TIMEUNITS = SECONDS;
        }
        _action.setTimeReferenceInSeconds = setTimeReferenceInSeconds;
        /**
         * Change time units on actions, schedulers, etc to milliseconds.
         * @name setTimeReferenceInMillis
         * @memberof cc.action
         */
        function setTimeReferenceInMillis() {
            cc.action.TIMEUNITS = MILLISECONDS;
        }
        _action.setTimeReferenceInMillis = setTimeReferenceInMillis;
        "use strict";
        /**
         * Callback definition for Action Apply event.
         * @memberOf cc.action
         * @callback ActionCallbackApplicationCallback
         * @param action {cc.action.Action} Executed Action.
         * @param target: {object} target the Action applied to.
         * @param value: {Object} Current target property value set.
         */
        /**
         * Callback definition for Action Start, End, Pause and Resume events.
         * @memberOf cc.action
         * @callback ActionCallbackStartOrEndOrPauseOrResumeCallback
         * @param action {cc.action.Action} Executed Action.
         * @param target: {object} target the Action applied to.
         */
        /**
         * Callback definition for Action Repeat event.
         * @memberOf cc.action
         * @callback ActionCallbackRepeatCallback
         * @param action {cc.action.Action} Executed Action.
         * @param target: {object} target the Action applied to.
         * @param repetitionCount {number} Current repetition count.
         */
        /**
         * Action internal states.
         * <br>
         * Status diagram is:
         *
         * <pre>
         *
         * CREATED ---> RUNNING ---> PAUSED <---> RESUMED
         *    ^          |  ^                           |
         *    |          |  |                           |
         *    |          |  +---------------------------+
         *    |          v
         *    +------> ENDED
         *
         * </pre>
         *
         * @tsenum cc.action.ActionStates
         */
        (function (ActionStates) {
            ActionStates[ActionStates["PAUSED"] = 1] = "PAUSED";
            ActionStates[ActionStates["RUNNING"] = 2] = "RUNNING";
            ActionStates[ActionStates["CREATED"] = 3] = "CREATED";
            ActionStates[ActionStates["ENDED"] = 4] = "ENDED";
            ActionStates[ActionStates["RESUMED"] = 5] = "RESUMED";
        })(_action.ActionStates || (_action.ActionStates = {}));
        var ActionStates = _action.ActionStates;
        /**
         *
         *  @class cc.action.Action
         *  @classdesc
         *
         * Actions are scheduled objects that modify an arbitray object's internal state. It could be a node, or any other
         * object type.
         * For example, schedule a rotation from 0 to 360 degrees, scale from to twice a node's size, or a combination of
         * both.
         * <br>
         * cc.action.Action is an abstract class, and won't affect any target. This Class type must be subclassed.
         * <br>
         *
         * Actions are defined by the following elements:
         *
         *  <li>duration. How long the action will take to end.
         *  <li>delay before application. How long the action will take to start applying.
         *  <li>delay after application. How long the action will take to end after it ended modifying node's properties.
         *  <li>lifecycle. An action has callback functions for: start, pause, resume, end and repeat.
         *  <li>speed. An action has speed modifiers. if an action has speed 2, will take twice the time to execute.
         *  <li>interpolators. An action can have modifiers for time application, like easing functions or curve segments.
         *  <li>relativity. An action can be applied relative to a value, instead of absolutely. For example, rotate by an
         *     angle instead of rotate to.
         *  <li>From. Start values for action application.
         *  <li>To. End values for action application.
         *  <li>Reversability: an action can be set to be played backwards. This is accomplished not by modifying the action
         *      but by modifiying the Interpolator that transforms time into property values.
         *
         * Predefined actions exist for the following node's properties:
         *
         *  <li>AlphaAction. Modifies transparency values.
         *  <li>MoveAction. Modifies position by traversing a straight line.
         *  <li>PathAction. Modifies position by traversing a complex path.
         *  <li>RotateAction. Modifies rotation angle.
         *  <li>ScaleAction. Modifies scale.
         *  <li>TintAction. Modifies s color. This action will only have a visible result when the node is rendered
         *      using WebGL.
         *  <li>SequenceAction. Allows for action sequencing and parallelization.
         *  <li>PropertyAction. Allows for modification of an object's arbitrary property. Either deeply nested or not.
         *
         * There are other type of actions that affect or create a mix of different node properties modification like:
         *
         *  <li>BlinkAction
         *  <li>JumpAction
         *
         *  The current V4 action subsystem is a complete rebuild from the ground up. Although backwards compatible with
         *  Cocos2d HTML5's V2 and V3 action system, this new implementation offers the following features:
         *
         *  <li>Consistent Action naming: easeExponentialIn vs easeQuinticActionIn .
         *  <li>Simplification of cc namespace. From 150+ action objects to a few.
         *  <li>Reduced code complexity.
         *  <li>Offer a new more js-ish code convention via chaining of method calls.
         *  <li>Change concept of easing action. Easing is a property of an Action's time.
         *  <li>Reduce overly class-extension hierarchy from version 2 and 3
         *  <li>Full action lifecycle: START, END, PAUSE, RESUME, REPEAT.
         *
         */
        var Action = (function () {
            /**
             * Build an Action instance.
             * This type of objects must augmented.
             * @constructor
             * @method cc.action.Action#constructor
             * @param initilizer {cc.action.ActionInitializer=} a JSON object describing a base Action info.
             */
            function Action(initializer) {
                /**
                 * Delay to start applying the Action.
                 * @member cc.action.Action#_startTime
                 * @type {number}
                 * @private
                 */
                this._startTime = 0;
                /**
                 * Action duration (in seconds). For how long the Action takes to get to the final application result.
                 * @member cc.action.Action#_duration
                 * @type {number}
                 * @private
                 */
                this._duration = 0;
                /**
                 * Currently elapsed time.
                 * @member cc.action.Action#_currentTime
                 * @type {number}
                 * @private
                 */
                this._currentTime = 0;
                /**
                 * Number of repeat times. 1 by default.
                 * @member cc.action.Action#_repeatTimes
                 * @type {number}
                 * @private
                 */
                this._repeatTimes = 1;
                /**
                 * Current repetition count.
                 * @member cc.action.Action#_currentRepeatCount
                 * @type {number}
                 * @private
                 */
                this._currentRepeatCount = 0;
                /**
                 * Action speed. Actual Action duration is: ( (_duration + _delayAfterApplication) * _times) / _speed
                 * @type {number}
                 * @private
                 */
                this._speed = 1;
                /**
                 * An action identifier. Defaults to @see(Action.DEFAULT_TAG).
                 * @member cc.action.Action#_tag
                 * @type {number}
                 * @private
                 */
                this._tag = Action.DEFAULT_TAG;
                /**
                 * Action status.
                 *
                 * Status diagram:
                 *
                 * <pre>
                 *
                 * CREATED ---> RUNNING ---> PAUSED <---> RESUMED
                 *    ^          |  ^                           |
                 *    |          |  |                           |
                 *    |          |  +---------------------------+
                 *    |          v
                 *    +------> ENDED
                 *
                 * </pre>
                 *
                 * @member cc.action.Action#_status
                 * @type {cc.action.ActionStates}
                 * @private
                 */
                this._status = 3 /* CREATED */;
                /**
                 * On start application callback. Called when the Action is first executed.
                 * @member cc.action.Action#_onStart
                 * @type {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
                 * @private
                 */
                this._onStart = null;
                /**
                 * On end application callback. Fired each time the Action ends applying.
                 * This callback may not be called if _repeatTimes is set too high or is playing forever.
                 * @member cc.action.Action#_onEnd
                 * @type {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
                 * @private
                 */
                this._onEnd = null;
                /**
                 * On repeat application callback. Fired each time the action is repeated.
                 * @member cc.action.Action#_onRepeat
                 * @type {cc.action.ActionCallbackRepeatCallback}
                 * @private
                 */
                this._onRepeat = null;
                /**
                 * On application callback. Fired each time the action is applied. this callback can be called many times
                 * during the action life cycle.
                 * @member cc.action.Action#_onApply
                 * @type {cc.action.ActionCallbackApplicationCallback}
                 * @private
                 */
                this._onApply = null;
                /**
                 * On pause callback. Fired each time the action is paused. this callback can be called many times
                 * during the action life cycle.
                 * @member cc.action.Action#_onPause
                 * @type {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
                 * @private
                 */
                this._onPause = null;
                /**
                 * On resume callback. Fired each time the action is resumed. this callback can be called many times
                 * during the action life cycle.
                 * @member cc.action.Action#_onResume
                 * @type { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
                 * @private
                 */
                this._onResume = null;
                /**
                 * Interpolation/Ease function application
                 * @member cc.action.Action#_interpolator
                 * @type {cc.action.TimeInterpolator}
                 * @private
                 */
                this._interpolator = null;
                /**
                 * if the from values for an Action have not been set, a call to __setInitialValues with
                 * the target as parameter to have them set.
                 * @member cc.action.Action#_fromValuesSet
                 * @type {boolean}
                 * @private
                 */
                this._fromValuesSet = false;
                /**
                 * Flag for executing onStart callback. Do not use or modify.
                 * @member cc.action.Action#_firstExecution
                 * @type {boolean}
                 * @private
                 */
                this._firstExecution = true;
                /**
                 * This delay will be applied after each application.
                 * @member cc.action.Action#_delayAfterApplication
                 * @type {number}
                 * @private
                 */
                this._delayAfterApplication = 0;
                /**
                 * This delay will be applied before each application.
                 * @member cc.action.Action#_delayBeforeApplication
                 * @type {number}
                 * @private
                 */
                this._delayBeforeApplication = 0;
                /**
                 * Action owner ie the ActionManager this Action executes in.
                 * @member cc.action.Action#_owner
                 * @type {cc.action.ActionManager}
                 * @private
                 */
                //_owner:ActionManager = null;
                /**
                 * Reference for a chained action. Do not use or modify.
                 * @member cc.action.Action#_chainAction
                 * @type {cc.action.Action}
                 * @private
                 */
                this._chainAction = null;
                /**
                 * If true, the actions must be ActionBy variations.
                 * @member cc.action.Action#_relativeAction
                 * @type {boolean}
                 * @private
                 */
                this._relativeAction = false;
                /**
                 * Is the action reversed ?
                 * A reversed action will be applied from end to begin.
                 * @member cc.action.Action#_reversedTime
                 * @type {boolean}
                 * @private
                 */
                this._reversedTime = false;
                /**
                 * If this Action belongs to a SequenceAction this variable will be its parent sequence.
                 * @member cc.action.Action#_parentSequence
                 * @type {cc.action.SequenceAction}
                 * @private
                 */
                this._parentSequence = null;
                /**
                 * Is the action reversed ?
                 * This happens by a call to reverse() or setReversed()
                 * @member cc.action.Action#_reversed
                 * @type {boolean}
                 * @private
                 */
                this._reversed = false;
                /**
                 * When a call to node.startActionChain() is made, an ActionChainContext object is created. It is a fachade
                 * for chainable api. apart from that, does nothing to the Action.
                 * @member cc.action.Action#_chainContext
                 * @type {cc.action.ActionChainContext}
                 * @private
                 */
                this._chainContext = null;
                if (initializer) {
                    this.__createFromInitializer(initializer);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.Action#__createFromInitializer
             * @param initializer {cc.action.ActionInitializer}
             * @private
             */
            Action.prototype.__createFromInitializer = function (initializer) {
                if (typeof initializer !== "undefined") {
                    if (typeof initializer.relative !== 'undefined') {
                        this.setRelative(initializer.relative);
                    }
                    if (typeof initializer.duration !== 'undefined') {
                        this.setDuration(initializer.duration);
                    }
                    if (typeof initializer.delayBefore !== 'undefined') {
                        this.setDelay(initializer.delayBefore);
                    }
                    if (typeof initializer.delayAfter !== 'undefined') {
                        this.setDelayAfterApplication(initializer.delayAfter);
                    }
                    if (typeof initializer.interpolator !== "undefined") {
                        this.setInterpolator(cc.action.ParseInterpolator(initializer.interpolator));
                    }
                    if (typeof initializer.from !== "undefined") {
                        if (this.from) {
                            this.from(initializer.from);
                        }
                    }
                    if (typeof initializer.to !== "undefined") {
                        if (this.to) {
                            this.to(initializer.to);
                        }
                    }
                    if (typeof initializer.repeatTimes !== "undefined") {
                        this.setRepeatTimes(initializer.repeatTimes);
                    }
                    if (typeof initializer.reversed !== "undefined") {
                        this._reversed = initializer.reversed;
                    }
                }
            };
            /**
             * Set an arbitrary tag for an Action.
             * @method cc.action.Action#setTag
             * @param tag {string} a string composed only of [A-Za-z0-9_-]
             * @returns {cc.action.Action}
             */
            Action.prototype.setTag = function (tag) {
                this._tag = tag;
                return this;
            };
            /**
             * Update an Action's target object.
             * This function must be overriden by Action subclass Objects.
             * @method cc.action.Action#update
             * @param normalizedTime {number} value between 0 and 1.
             * @param target {any} object instance the action will be applied for.
             *
             * @returns {Object} a value descriptive for the action type. For example, ScaleAction will return an object with
             * the scale applied, and MoveAction a <code>cc.math.Vector</code> with object's set position.
             */
            Action.prototype.update = function (normalizedTime, target) {
            };
            /**
             * Set an Action's duration. Duration is in milliseconds.
             * @method cc.action.Action#setDuration
             * @param duration {number}
             */
            Action.prototype.setDuration = function (duration) {
                this._duration = duration * _action.TIMEUNITS;
                this.__updateDuration();
                return this;
            };
            /**
             * Set an action's pre application delay.
             * An action will take this milliseconds to start applying values in a target.
             * @method cc.action.Action#setDelay
             * @param d {number} milliseconds.
             * @returns {cc.action.Action}
             */
            Action.prototype.setDelay = function (d) {
                this._delayBeforeApplication = d * _action.TIMEUNITS;
                this.__updateDuration();
                return this;
            };
            /**
             * Update this Action's duration.
             * This must be done when a sub Action is updated or when delay times or duration itself have changed.
             * @method cc.action.Action#__updateDuration
             * @private
             */
            Action.prototype.__updateDuration = function () {
                this._startTime = this._delayBeforeApplication + (this._chainAction ? this._chainAction._startTime + this._chainAction.getDuration() : 0);
                if (this._parentSequence) {
                    this._parentSequence.__updateDuration();
                }
            };
            /**
             * Restart an action's application.
             * Status gets back to CREATED.
             * First execution set to true.
             * Application times count set to 0.
             * @method cc.action.Action#restart
             * @returns {cc.action.Action}
             */
            Action.prototype.restart = function () {
                this._firstExecution = true;
                this._currentRepeatCount = 0;
                this._status = 3 /* CREATED */;
                this._currentTime = 0;
                return this;
            };
            /**
             * Get an action's current State.
             * @method cc.action.Action#getStatus
             * @returns {cc.action.ActionStates}
             */
            Action.prototype.getStatus = function () {
                return this._status;
            };
            /**
             * Get an action's application speed.
             * Speed values modify an action duration.
             * A speed value of 2 will make the action to take twice the time to execute.
             * @method cc.action.Action#getSpeed
             * @returns {number}
             */
            Action.prototype.getSpeed = function () {
                return this._speed;
            };
            /**
             * Set an action's application speed.
             * @method cc.action.Action#setSpeed
             * @param speed {number}
             * @returns {cc.action.Action}
             */
            Action.prototype.setSpeed = function (speed) {
                this._speed = speed;
                return this;
            };
            /**
             * Make this action repeat a finite number of timer.
             * 0 repeatTimes means repeat forerver.
             * @method cc.action.Action#setRepeatTimes
             * @param repeatTimes {number}
             * @param obj {RepeatTimesOptions}
             * @return Action
             */
            Action.prototype.setRepeatTimes = function (repeatTimes, obj) {
                this._repeatTimes = repeatTimes;
                this._delayAfterApplication = (obj && obj.withDelay * _action.TIMEUNITS) || 0;
                return this;
            };
            /**
             * Set this action to apply forever.
             * @method cc.action.Action#setRepeatForever
             * @param obj {RepeatTimesOptions}
             * @returns {cc.action.Action}
             */
            Action.prototype.setRepeatForever = function (obj) {
                return this.setRepeatTimes(Number.MAX_VALUE, obj);
            };
            /**
             *
             * @method cc.action.Action#repeatForever
             * @deprecated
             * @returns {Action}
             */
            Action.prototype.repeatForever = function () {
                return this.setRepeatForever();
            };
            /**
             * Register a callback notification function fired whenever the Action starts applying.
             * @method cc.action.Action#onStart
             * @param callback { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
             * @returns {cc.action.Action}
             */
            Action.prototype.onStart = function (callback) {
                this._onStart = callback;
                return this;
            };
            /**
             * Register a callback notification function fired whenever the action expires applying.
             * If repeats forever, will never be called.
             * @method cc.action.Action#onEnd
             * @param callback { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
             * @return Action
             */
            Action.prototype.onEnd = function (callback) {
                this._onEnd = callback;
                return this;
            };
            /**
             * Register a callback notification function fired whenever the action repeats.
             * BUGBUG if setRepeatForever is not fired.
             * @method cc.action.Action#onRepeat
             * @param callback { cc.action.ActionCallbackRepeatCallback }
             * @return Action
             */
            Action.prototype.onRepeat = function (callback) {
                this._onRepeat = callback;
                return this;
            };
            /**
             * Register a callback notification function fired whenever the action applies.
             * The action applies once per frame, and allows for getting values that have been set on the target.
             * @method cc.action.Action#onApply
             * @param callback { cc.action.ActionCallbackApplicationCallback }
             * @return Action
             */
            Action.prototype.onApply = function (callback) {
                this._onApply = callback;
                return this;
            };
            /**
             * Register a callback notification function fired whenever the action is paused.
             * @method cc.action.Action#onPause
             * @param callback { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
             * @return Action
             */
            Action.prototype.onPause = function (callback) {
                this._onPause = callback;
                return this;
            };
            /**
             * Register a callback notification function fired whenever the action is resumed, that it, exits the
             * paused state.
             * @method cc.action.Action#onResume
             * @param callback { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
             * @return Action
             */
            Action.prototype.onResume = function (callback) {
                this._onResume = callback;
                return this;
            };
            /**
             * Pause this action.
             * @method cc.action.Action#pause
             * @param target {object=}
             * @returns Action
             */
            Action.prototype.pause = function (target) {
                this._status = 1 /* PAUSED */;
                if (this._onPause) {
                    this._onPause(this, target);
                }
                return this;
            };
            /**
             * Resume this action.
             * @method cc.action.Action#resume
             * @returns Action
             */
            Action.prototype.resume = function () {
                if (this._status === 1 /* PAUSED */) {
                    this._status = 5 /* RESUMED */;
                }
                return this;
            };
            /**
             * Get time to wait after action application to repeat.
             * This time will be spent even if repeat count is 1.
             * @method cc.action.Action#getDelayAfterApplication
             * @returns {number}
             */
            Action.prototype.getDelayAfterApplication = function () {
                return this._delayAfterApplication;
            };
            /**
             * Set time to wait after action application to repeat.
             * This time will be spent even if repeat count is 1.
             * @method cc.action.Action#setDelayAfterApplication
             * @param d {number} milliseconds to wait after application.
             * @returns {cc.action.Action}
             */
            Action.prototype.setDelayAfterApplication = function (d) {
                this._delayAfterApplication = d * _action.TIMEUNITS;
                return this;
            };
            /**
             * Get this action's delay time to start applying.
             * @method cc.action.Action#getDelay
             * @returns {number}
             */
            Action.prototype.getDelay = function () {
                return this._startTime;
            };
            /**
             * Changes default interpolator to another instance of @link{cc.action.TimeInterpolator}.
             * @method cc.action.Action#setInterpolator
             * @param interpolator {cc.action.TimeInterpolator}
             * @returns Action
             */
            Action.prototype.setInterpolator = function (interpolator) {
                this._interpolator = interpolator;
                return this;
            };
            /**
             * Convert time into a normalized value in the range of the application duration.
             * The values will converted, so that 0 will be just after starting each repetition,
             * and 1 will be just the end of the Action, or the end of each repetition.
             * @method cc.action.Action#__normalizeTime
             * @param time {number}
             * @private
             */
            Action.prototype.__normalizeTime = function (time) {
                // still, initial delay time has not elapsed.
                if (time < this._startTime) {
                    time = 0;
                }
                else {
                    time = time - this._startTime;
                    if (time >= this.getDuration()) {
                        time = 1;
                    }
                    else {
                        time %= this.getOneRepetitionDuration();
                        // time is in duration range
                        if (time < this._duration) {
                            time /= this._duration;
                        }
                        else {
                            // time is in _delayAfterApplicationRange
                            time = 1;
                        }
                    }
                }
                if (this._reversedTime) {
                    time = 1 - time;
                }
                if (!this._interpolator) {
                    return time;
                }
                return this._interpolator(time);
            };
            /**
             * Get whole action duration. Takes into account action speed, duration, delayAfterApplication and repetition times.
             * @method cc.action.Action#getDuration
             * @returns {number}
             */
            Action.prototype.getDuration = function () {
                return this.getOneRepetitionDuration() * this._repeatTimes;
            };
            /**
             * Calculate one repetition duration.
             * @method cc.action.Action#getOneRepetitionDuration
             * @returns {number}
             */
            Action.prototype.getOneRepetitionDuration = function () {
                return (this._duration + this._delayAfterApplication);
            };
            /**
             * Chekcs whether the action is applicable.
             * In case it gets out of scene time, and has not been tagged as expired, the action is expired and observers
             * are notified about that fact.
             * @method cc.action.Action#__isActionApplicable
             * @param time {number} the scene time to check the action against.
             * @return {boolean} whether the action is applicable.
             */
            Action.prototype.__isActionApplicable = function (time) {
                // not correct status
                if (this._status === 1 /* PAUSED */ || this._status === 4 /* ENDED */) {
                    return false;
                }
                // still not in time
                return this._repeatTimes === Number.MAX_VALUE || (time >= this._startTime && time < this._startTime + this.getDuration());
            };
            /**
             * This method must no be called directly.
             * The director loop will call this method in order to apply target actions.
             * @method cc.action.Action#step
             * @param delta {number} elapsed time since last application.
             * @param target {object}  target object the action is being applied to.
             */
            Action.prototype.step = function (delta, target) {
                delta *= cc.action.TIMEUNITS;
                this._currentTime += delta * this._speed;
                this.__stepImpl(delta, this._currentTime, target);
            };
            /**
             * Actual step implementation.
             * @method cc.action.Action#__stepImpl
             * @param delta {number} elapsed time since last application.
             * @param time {number} Action accumulated time.
             * @param target {object} target to apply action to.
             * @private
             */
            Action.prototype.__stepImpl = function (delta, time, target) {
                // if an action is not ended, it has the chance of updating value
                if (this._status !== 4 /* ENDED */) {
                    // actions can be paused w/o even been started.
                    if (this._status === 5 /* RESUMED */) {
                        if (this._onResume) {
                            this._onResume(this, target);
                        }
                    }
                    // if the action is not ended, but can be executed due to time
                    if (this.__isActionApplicable(time)) {
                        this.__actionApply(time, target);
                    }
                    else {
                        // if the action is expired, ie, current time is beyong the start and duration
                        if (time >= this._startTime + this.getDuration()) {
                            // apply for final state anyway
                            this.__actionApply(time, target);
                            // set the action as ENDED
                            this.stop(target);
                        }
                    }
                }
            };
            /**
             * When an action is in time, and able to be applied to a target, this method does all the necessary steps.
             * Do not call directly.
             * @method cc.action.Action#__actionApply
             * @param time {number} current action's application time.
             * @param target {object} target node.
             * @private
             */
            Action.prototype.__actionApply = function (time, target) {
                // manage first execution. it gives the chance to the Action of initializing with the target node
                if (this._firstExecution) {
                    // callback for onStart. only once. from now on, the action is not first_execution
                    if (this._onStart) {
                        this._onStart(this, target);
                    }
                    this._firstExecution = false;
                    // initialize with the target before updating its values.
                    this.initWithTarget(target);
                }
                // current status RUNNING
                this._status = 2 /* RUNNING */;
                // normalize the time, transform current time to a value in the range 0..1 proportionally to the
                // action length, start time, etc. it also applies the easing (if any).
                var ntime = this.__normalizeTime(time);
                // update target
                var v = this.update(ntime, target);
                // application callback. called each time the node has changed properties.
                if (this._onApply) {
                    this._onApply(this, target, v);
                }
                this.__checkRepetition(time, target);
            };
            /**
             * Do code specific for checking action repetition and callback invocation when it makes sense.
             * @method cc.action.Action#__checkRepetition
             * @param time {number} current action application time .
             * @param target {object} target object the action is being applied to.
             * @private
             */
            Action.prototype.__checkRepetition = function (time, target) {
                // if this is a repeating action
                if (this._repeatTimes !== 1) {
                    // calculate current repetition value
                    var repeatIndex = ((time - this._startTime) / this.getOneRepetitionDuration()) >> 0;
                    // if changed
                    if (repeatIndex !== this._currentRepeatCount) {
                        if (repeatIndex > this._repeatTimes) {
                            repeatIndex = this._repeatTimes;
                        }
                        this._currentRepeatCount = repeatIndex;
                        // callback about repetition
                        if (this._onRepeat) {
                            this._onRepeat(this, target, repeatIndex);
                        }
                    }
                }
            };
            /**
             * Pass in the target node this action will act on.
             * This method must be overriden by each action type.
             * @method cc.action.Action#initWithTarget
             * @param target {object}
             */
            Action.prototype.initWithTarget = function (target) {
            };
            /**
             * Solve Action first application values.
             * Must be overriden.
             * @method cc.action.Action#solveInitialValues
             * @param target {object}
             */
            Action.prototype.solveInitialValues = function (target) {
            };
            /**
             * End this action immediately. Will call onEnd callback if set.
             * @method cc.action.Action#stop
             * @param target {object=}
             */
            Action.prototype.stop = function (target) {
                this._status = 4 /* ENDED */;
                if (this._onEnd) {
                    this._onEnd(this, target);
                }
            };
            /**
             * Is this action finished ?
             * @method cc.action.Action#isFinished
             * @returns {boolean}
             */
            Action.prototype.isFinished = function () {
                return this._status === 4 /* ENDED */;
            };
            /**
             * Is this action paused ?
             * @method cc.action.Action#isPaused
             * @returns {boolean}
             */
            Action.prototype.isPaused = function () {
                return this._status === 1 /* PAUSED */;
            };
            /**
             * Set origin values for the action.
             * This method MUST be overriden and called from the override function.
             * @method cc.action.Action#from
             * @param obj {Object} any object necessary for the action initialization.
             * @returns {cc.action.Action}
             */
            Action.prototype.from = function (obj) {
                this._fromValuesSet = true;
                return this;
            };
            /**
             * Set destination values for the action.
             * @method cc.action.Action#to
             * @param obj {Object} any object necessary for the action initialization.
             * @returns {cc.action.Action}
             */
            Action.prototype.to = function (obj) {
                return this;
            };
            /**
             * Shortcut method for setting an action's duration, delay and easing function.
             * @method cc.action.Action#timeInfo
             * @param delay {number} milliseconds to wait for action start.
             * @param duration {number} milliseconds of this action application.
             * @param interpolator {cc.action.TimeInterpolator} a time interpolator interface object.
             * @returns {cc.action.Action}
             */
            Action.prototype.timeInfo = function (delay, duration, interpolator) {
                this._duration = duration * _action.TIMEUNITS;
                this.setDelay(delay);
                if (typeof interpolator !== "undefined") {
                    this._interpolator = interpolator;
                }
                return this;
            };
            /**
             * This method will make actions to be applied relatively instead of absolutely.
             * For example, moveBy will add the position to the current node's position instead of traversing through the
             * path.
             * @method cc.action.Action#setRelative
             * @param relative {boolean} make this action to behave as moveBy
             * @returns {cc.action.MoveAction}
             */
            Action.prototype.setRelative = function (relative) {
                this._relativeAction = relative;
                return this;
            };
            /**
             * @deprecated This method is deprecated because of its semantics. Use createReversed() instead.
             * @method cc.action.Action#reverse
             * @see {cc.action.Action#createReversed}
             */
            Action.prototype.reverse = function () {
                return this.createReversed();
            };
            /**
             * Create a new Action which is the reverse of this one.
             * A reverse Action is expected to be the inverse of what it was. In example, getting back from a path,
             * or rotating in the other direction.
             * In this new implementation, a reverse action is just inverting the TimeInterpolation value.
             * @method cc.action.Action#createReversed
             * @returns {cc.action.Action}
             */
            Action.prototype.createReversed = function () {
                var action = this.clone();
                return action.setReversed();
            };
            /**
             * Set an action to be its reversed action.
             * This method does not create any new action.
             * @method cc.action.Action#setReversed
             * @returns {cc.action.Action}
             */
            Action.prototype.setReversed = function () {
                this._reversed = !this._reversed;
                if (this._interpolator) {
                    this._interpolator = this._interpolator.reverse();
                }
                else {
                    this._interpolator = _action.Interpolator.Linear(true, false);
                }
                return this;
            };
            /**
             * Make the actual cloning implementation.
             * This method must be overriden by each action type.
             * @method cc.action.Action#__cloneImpl
             * @returns {cc.action.Action}
             * @private
             */
            Action.prototype.__cloneImpl = function () {
                var copy = new Action();
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Create a copy of an action.
             * @method cc.action.Action#clone
             * @returns {cc.action.Action}
             */
            Action.prototype.clone = function () {
                return this.__cloneImpl();
            };
            /**
             * Is action relative.
             * In V2 and V3 language, a relative action corresponds to ActionBy types.
             * Non relative actions are ActionTo types.
             * @method cc.action.Action#isRelative
             * @returns {boolean}
             */
            Action.prototype.isRelative = function () {
                return this._relativeAction;
            };
            /**
             * Copy generic properties when cloning an Action.
             * Action event Callbacks are copied as well.
             * @method cc.action.Action#__genericCloneProperties
             * @param copy {cc.action.Action}
             * @private
             */
            Action.prototype.__genericCloneProperties = function (copy) {
                copy.setInterpolator(this._interpolator).setReversedTime(this._reversedTime).setSpeed(this.getSpeed()).setRepeatTimes(this._repeatTimes).setRelative(this._relativeAction);
                copy._startTime = this._startTime;
                copy._duration = this._duration;
                copy._delayAfterApplication = this._delayAfterApplication;
                // explictly copy callbacks this way. Sequence overwrites onRepeat.
                copy._onStart = this._onStart;
                copy._onEnd = this._onEnd;
                copy._onApply = this._onApply;
                copy._onRepeat = this._onRepeat;
                copy._onPause = this._onPause;
                copy._onResume = this._onResume;
                copy._reversed = this._reversed;
            };
            /**
             * Backward compatible call.
             * @method cc.action.Action#easing
             * @param i {cc.action.Interpolator} an interpolator/easing function.
             * @returns {cc.action.Action}
             */
            Action.prototype.easing = function (i) {
                this.setInterpolator(i);
                return this;
            };
            /**
             * Backward compatible call.
             * @method cc.action.Action#speed
             * @param speed
             * @returns {cc.action.Action}
             * @deprecated Use setSpeed(speed)
             */
            Action.prototype.speed = function (speed) {
                this._speed *= speed;
                return this;
            };
            /**
             * Is time applied in inverse order ?
             * @method cc.action.Action#isReversedTime
             * @returns {boolean}
             */
            Action.prototype.isReversedTime = function () {
                return this._reversedTime;
            };
            /**
             * Set this action's time to be applied inversely.
             * @method cc.action.Action#setReversedTime
             * @param b {boolean} reverse time ?
             * @returns {cc.action.Action}
             */
            Action.prototype.setReversedTime = function (b) {
                this._reversedTime = b;
                return this;
            };
            /**
             * This method is called from a SequenceAction object. It clears current action status info so that it can
             * be restarted.
             * @method cc.action.Action#__recursivelySetCreatedStatus
             * @param target {any}
             * @private
             */
            Action.prototype.__recursivelySetCreatedStatus = function (target) {
                if (this._status !== 4 /* ENDED */) {
                    this.update(this._reversed ? 0 : 1, target);
                }
                this._currentTime = 0;
                this._status = 3 /* CREATED */;
                this._firstExecution = true;
            };
            /**
             * Apply this action in a pingpong way.
             * @method cc.action.Action#pingpong
             */
            Action.prototype.pingpong = function () {
                this.setInterpolator(cc.action.Interpolator.Linear(this._reversed, true));
            };
            /**
             * Build an initializer object out of the Action current state and info.
             * Every Action type must override and super.call this method.
             * @method cc.action.Action#getInitializer
             * @returns {cc.action.ActionInitializer}
             */
            Action.prototype.getInitializer = function () {
                var obj = {};
                if (this._delayBeforeApplication) {
                    obj.delayBefore = this._delayBeforeApplication / cc.action.TIMEUNITS;
                }
                if (this._delayAfterApplication) {
                    obj.delayAfter = this._delayAfterApplication / cc.action.TIMEUNITS;
                }
                obj.duration = this._duration / cc.action.TIMEUNITS;
                obj.relative = this._relativeAction;
                if (this._repeatTimes !== 1) {
                    obj.repeatTimes = this._repeatTimes;
                }
                if (this._interpolator) {
                    obj.interpolator = this._interpolator.getInitializer();
                }
                obj.reversed = this._reversed;
                return obj;
            };
            /**
             * Default tag value.
             * @member cc.action.Action#DEFAULT_TAG
             * @type {string}
             * @static
             */
            Action.DEFAULT_TAG = "";
            return Action;
        })();
        _action.Action = Action;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
var cc;
(function (cc) {
    var action;
    (function (action) {
        "use strict";
        /**
         *
         * This function creates a new TimeIntepolator object from a JSON object.
         * It can be the result of serializing an interpolator.
         *
         * @name ParseInterpolator
         * @memberOf cc.action
         * @param ii {cc.action.InterpolatorInitializer}
         * @returns {cc.action.TimeInterpolator}
         * @constructor
         */
        function ParseInterpolator(ii) {
            if (ii.type === "EaseIn" || ii.type === "EaseOut" || ii.type === "EaseInOut") {
                return cc.action.Interpolator[ii.type](ii.exponent, ii.inverse, ii.pingpong);
            }
            else if (ii.type === "ElasticIn" || ii.type === "ElasticOut" || ii.type === "ElasticInOut") {
                return cc.action.Interpolator[ii.type](ii.period, ii.inverse, ii.pingpong);
            }
            else {
                return cc.action.Interpolator[ii.type](ii.inverse, ii.pingpong);
            }
        }
        action.ParseInterpolator = ParseInterpolator;
        function calcTime(time, inverse, pingpong) {
            if (pingpong) {
                if (time < 0.5) {
                    time *= 2;
                }
                else {
                    time = 1 - (time - 0.5) * 2;
                }
            }
            if (inverse) {
                time = 1 - time;
            }
            return time;
        }
        function bounceTime(time1) {
            if (time1 < 1 / 2.75) {
                return 7.5625 * time1 * time1;
            }
            else if (time1 < 2 / 2.75) {
                time1 -= 1.5 / 2.75;
                return 7.5625 * time1 * time1 + 0.75;
            }
            else if (time1 < 2.5 / 2.75) {
                time1 -= 2.25 / 2.75;
                return 7.5625 * time1 * time1 + 0.9375;
            }
            time1 -= 2.625 / 2.75;
            return 7.5625 * time1 * time1 + 0.984375;
        }
        /**
         * @class cc.action.Interpolator
         *
         * @classdesc
         * Interpolators are functions used to modify a normalized value, commonly an action current time relative to
         * the action's duration.
         * <br>
         * The achieved effect is pretty interesting for animations, from slow acceleration to bounces, elastic behaviors,
         * etc. All interpolators are the same object types, and have same capabilities
         *   <li>inverse {boolean}: make the interpolator apply inversely (time applies from 1 to 0)
         *   <li>pingpong {boolean}: the interpolator will apply half the time non-inverse and the other half of the time
         *       inversely. This is suitable for effects that apply and de-apply. I.e. zoom from scale 1 to 2, and back from
         *       2 to 1. In previous API, two actions were needed for such effects.
         * <br>
         * Some of the interpolators are easing functions, quadratic bezier curves, etc.
         * <br>
         * In V2 and V3 API, interpolators were cc.easing actions, and in V4, they have been turned into an action
         * attribute.
         * <br>
         * An interpolator is set for an action by calling <code>action.setInterpolator</code>.
         */
        var Interpolator = (function () {
            function Interpolator() {
            }
            /**
             * Build a linear interpolator.
             * @method cc.action.Interpolator.Linear
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {cc.action.TimeInterpolator}
             */
            Interpolator.Linear = function (inverse, pingpong) {
                var fn = function LinearImpl(time) {
                    return calcTime(time, inverse, pingpong);
                };
                fn.reverse = function () {
                    return Interpolator.Linear(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "Linear",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an ease-in interpolator.
             * @param exponent {number} exponent
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseIn
             */
            Interpolator.EaseIn = function (exponent, inverse, pingpong) {
                var fn = function EaseInImpl(time) {
                    return Math.pow(calcTime(time, inverse, pingpong), exponent);
                };
                fn.reverse = function () {
                    return Interpolator.EaseIn(exponent, !inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseIn",
                        inverse: inverse,
                        pingpong: pingpong,
                        exponent: exponent
                    };
                };
                return fn;
            };
            /**
             * Build an ease-out interpolator.
             * @param exponent {number} exponent
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseOut
             */
            Interpolator.EaseOut = function (exponent, inverse, pingpong) {
                var fn = function EaseOutImpl(time) {
                    return 1 - Math.pow(1 - calcTime(time, inverse, pingpong), exponent);
                };
                fn.reverse = function () {
                    return Interpolator.EaseOut(exponent, !inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseOut",
                        inverse: inverse,
                        pingpong: pingpong,
                        exponent: exponent
                    };
                };
                return fn;
            };
            /**
             * Build an ease-in-out interpolator.
             * @param exponent {number} exponent
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseInOut
             */
            Interpolator.EaseInOut = function (exponent, inverse, pingpong) {
                var fn = function EaseInOutImpl(time) {
                    time = calcTime(time, inverse, pingpong);
                    if (time * 2 < 1) {
                        return Math.pow(time * 2, exponent) / 2;
                    }
                    return 1 - Math.abs(Math.pow(time * 2 - 2, exponent)) / 2;
                };
                fn.reverse = function () {
                    return Interpolator.EaseInOut(exponent, !inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseInOut",
                        inverse: inverse,
                        pingpong: pingpong,
                        exponent: exponent
                    };
                };
                return fn;
            };
            /**
             * Build an exponential-in interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialIn
             */
            Interpolator.EaseExponentialIn = function (inverse, pingpong) {
                var fn = function EaseInImpl(time) {
                    time = calcTime(time, inverse, pingpong);
                    return time === 0 ? 0 : Math.pow(2, 10 * (time - 1));
                };
                fn.reverse = function () {
                    return Interpolator.EaseExponentialIn(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseExponentialIn",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an exponential-out interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialOut
             */
            Interpolator.EaseExponentialOut = function (inverse, pingpong) {
                var fn = function EaseOutImpl(time) {
                    time = calcTime(time, inverse, pingpong);
                    return time === 1 ? 1 : 1 - Math.pow(2, -10 * time);
                };
                fn.reverse = function () {
                    return Interpolator.EaseExponentialOut(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseExponentialOut",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an exponential-in-out interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialInOut
             */
            Interpolator.EaseExponentialInOut = function (inverse, pingpong) {
                var fn = function EaseInOutImpl(time) {
                    var dt = calcTime(time, inverse, pingpong);
                    dt *= 2;
                    if (dt < 1) {
                        return 0.5 * Math.pow(2, 10 * (dt - 1));
                    }
                    else {
                        return 0.5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
                    }
                };
                fn.reverse = function () {
                    return Interpolator.EaseExponentialInOut(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseExponentialInOut",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an sine-in interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialIn
             */
            Interpolator.EaseSineIn = function (inverse, pingpong) {
                var fn = function EaseSineInImpl(time) {
                    time = calcTime(time, inverse, pingpong);
                    return time === 0 || time === 1 ? time : 1 - Math.cos(time * Math.PI / 2);
                };
                fn.reverse = function () {
                    return Interpolator.EaseSineIn(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseSineIn",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an sine-out interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialOut
             */
            Interpolator.EaseSineOut = function (inverse, pingpong) {
                var fn = function EaseSineOutImpl(time) {
                    time = calcTime(time, inverse, pingpong);
                    return time === 1 || time === 0 ? time : Math.sin(time * Math.PI / 2);
                };
                fn.reverse = function () {
                    return Interpolator.EaseSineOut(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseSineOut",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an sine-inout interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialOut
             */
            Interpolator.EaseSineInOut = function (inverse, pingpong) {
                var fn = function EaseSineInOutImpl(time) {
                    var dt = calcTime(time, inverse, pingpong);
                    return dt === 0 || dt === 1 ? dt : -0.5 * (Math.cos(Math.PI * dt) - 1);
                };
                fn.reverse = function () {
                    return Interpolator.EaseSineInOut(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseSineInOut",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an EaseElasticIn interpolator.
             * @param period {number=}
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialIn
             */
            Interpolator.EaseElasticIn = function (period, inverse, pingpong) {
                var fn = function EaseElasticInImpl(time) {
                    period = typeof period === 'undefined' ? 0.3 : period;
                    var dt = calcTime(time, inverse, pingpong);
                    if (dt === 0 || dt === 1) {
                        return dt;
                    }
                    else {
                        var s = period / 4;
                        dt = dt - 1;
                        return -Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / period);
                    }
                };
                fn.reverse = function () {
                    return Interpolator.EaseElasticIn(period, !inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseElasticIn",
                        inverse: inverse,
                        pingpong: pingpong,
                        period: period
                    };
                };
                return fn;
            };
            /**
             * Build an EaseElasticOut interpolator.
             * @param period {number=}
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialOut
             */
            Interpolator.EaseElasticOut = function (period, inverse, pingpong) {
                var fn = function EaseElasticOutImpl(time) {
                    period = typeof period === 'undefined' ? 0.3 : period;
                    var dt = calcTime(time, inverse, pingpong);
                    if (dt === 0 || dt == 1) {
                        return dt;
                    }
                    else {
                        var s = period / 4;
                        return Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / period) + 1;
                    }
                };
                fn.reverse = function () {
                    return Interpolator.EaseElasticOut(period, !inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseElasticOut",
                        inverse: inverse,
                        pingpong: pingpong,
                        period: period
                    };
                };
                return fn;
            };
            /**
             * Build an EaseElasticInOut interpolator.
             * @param period {number=}
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialOut
             */
            Interpolator.EaseElasticInOut = function (period, inverse, pingpong) {
                var fn = function EaseElasticInOutImpl(time) {
                    period = typeof period === 'undefined' ? 0.3 : period;
                    var dt = calcTime(time, inverse, pingpong);
                    if (dt === 0 || dt == 1) {
                        return dt;
                    }
                    else {
                        dt = dt * 2;
                        var s = period / 4;
                        dt = dt - 1;
                        if (dt < 0)
                            return -0.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / period);
                        else
                            return Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / period) * 0.5 + 1;
                    }
                };
                fn.reverse = function () {
                    return Interpolator.EaseElasticInOut(period, !inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseElasticInOut",
                        inverse: inverse,
                        pingpong: pingpong,
                        period: period
                    };
                };
                return fn;
            };
            /**
             * Build an EaseBounceIn interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialIn
             */
            Interpolator.EaseBounceIn = function (inverse, pingpong) {
                var fn = function EaseBounceInImpl(time) {
                    var dt = calcTime(time, inverse, pingpong);
                    return 1 - bounceTime(1 - dt);
                };
                fn.reverse = function () {
                    return Interpolator.EaseBounceIn(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseBounceIn",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an EaseBounceOut interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialOut
             */
            Interpolator.EaseBounceOut = function (inverse, pingpong) {
                var fn = function EaseBounceOutImpl(time) {
                    return bounceTime(calcTime(time, inverse, pingpong));
                };
                fn.reverse = function () {
                    return Interpolator.EaseBounceOut(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseBounceOut",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an EaseBounceInOut interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialOut
             */
            Interpolator.EaseBounceInOut = function (inverse, pingpong) {
                var fn = function EaseBounceInOutImpl(time) {
                    var dt = calcTime(time, inverse, pingpong);
                    if (dt < 0.5) {
                        dt = dt * 2;
                        return (1 - bounceTime(1 - dt)) * 0.5;
                    }
                    else {
                        return bounceTime(dt * 2 - 1) * 0.5 + 0.5;
                    }
                };
                fn.reverse = function () {
                    return Interpolator.EaseBounceInOut(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseBounceInOut",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an EaseBackIn interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialIn
             */
            Interpolator.EaseBackIn = function (inverse, pingpong) {
                var fn = function EaseBackInImpl(time) {
                    var dt = calcTime(time, inverse, pingpong);
                    var overshoot = 1.70158;
                    return dt === 0 || dt === 1 ? dt : dt * dt * ((overshoot + 1) * dt - overshoot);
                };
                fn.reverse = function () {
                    return Interpolator.EaseBackIn(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseBackIn",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an EaseBackOut interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialOut
             */
            Interpolator.EaseBackOut = function (inverse, pingpong) {
                var fn = function EaseBackOutImpl(time) {
                    var dt = calcTime(time, inverse, pingpong);
                    var overshoot = 1.70158;
                    dt = dt - 1;
                    return 1 + dt * dt * ((overshoot + 1) * dt + overshoot);
                };
                fn.reverse = function () {
                    return Interpolator.EaseBackOut(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseBackOut",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            /**
             * Build an EaseBackInOut interpolator.
             * @param inverse {boolean=}
             * @param pingpong {boolean=}
             * @returns {TimeInterpolator}
             * @method cc.action.Interpolator.EaseExponentialOut
             */
            Interpolator.EaseBackInOut = function (inverse, pingpong) {
                var fn = function EaseBounceInOutImpl(time) {
                    var dt = calcTime(time, inverse, pingpong);
                    var overshoot = 1.70158;
                    dt = dt * 2;
                    if (dt < 1) {
                        return (dt * dt * ((overshoot + 1) * dt - overshoot)) / 2;
                    }
                    else {
                        dt = dt - 2;
                        return 1 + (dt * dt * ((overshoot + 1) * dt + overshoot)) / 2;
                    }
                };
                fn.reverse = function () {
                    return Interpolator.EaseBackInOut(!inverse, pingpong);
                };
                fn.getInitializer = function () {
                    return {
                        type: "EaseBackInOut",
                        inverse: inverse,
                        pingpong: pingpong
                    };
                };
                return fn;
            };
            return Interpolator;
        })();
        action.Interpolator = Interpolator;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>
"use strict";
var cc;
(function (cc) {
    var action;
    (function (action) {
        var Action = cc.action.Action;
        /**
         * @class cc.action.AlphaAction
         * @extends cc.action.Action
         * @classdesc
         *
         * This action applies to a node's transparency.
         * <br>
         * Transparency values are defined by a number between 0 (fully transparent) and 1 (fully opaque).
         */
        var AlphaAction = (function (_super) {
            __extends(AlphaAction, _super);
            /**
             * AlphaAction constructor.
             * @method cc.action.AlphaAction#constructor
             * @param data {cc.action.AlphaActionInitializer=}
             */
            function AlphaAction(data) {
                _super.call(this);
                /**
                 * When the action is initialized with a target, this value is the original transparency value.
                 * @member cc.action.AlphaAction#_originalAlpha
                 * @type {number}
                 * @private
                 */
                this._originalAlpha = 0;
                /**
                 * Action start alpha.
                 * @member cc.action.AlphaAction#_startAlpha
                 * @type {number}
                 * @private
                 */
                this._startAlpha = 0;
                /**
                 * Action end alpha.
                 * @member cc.action.AlphaAction#_endAlpha
                 * @type {number}
                 * @private
                 */
                this._endAlpha = 0;
                if (data) {
                    this.__createFromInitializer(data);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.AlphaAction#__createFromInitializer
             * @param data {cc.action.AlphaActionInitializer}
             * @private
             */
            AlphaAction.prototype.__createFromInitializer = function (data) {
                _super.prototype.__createFromInitializer.call(this, data);
                if (typeof data !== "undefined") {
                    this._startAlpha = data.to;
                    this._endAlpha = data.from;
                }
            };
            /**
             * Update target Node's transparency.
             * {@link cc.action.Action#update}
             * @method cc.action.AlphaAction#update
             * @override
             * @return {number} Applied transparency value.
             */
            AlphaAction.prototype.update = function (delta, node) {
                var r = this._startAlpha + delta * (this._endAlpha - this._startAlpha);
                if (this._relativeAction) {
                    r += this._originalAlpha;
                    if (this._reversed) {
                        r -= this._endAlpha;
                    }
                }
                node._alpha = r;
                return r;
            };
            /**
             * Capture before-application Node's property values.
             * {@link cc.action.Action#solveInitialValues}
             * @method cc.action.AlphaAction#solveInitialValues
             * @override
             */
            AlphaAction.prototype.solveInitialValues = function (node) {
                if (this._relativeAction && !this._fromValuesSet) {
                    this._startAlpha = 0;
                }
                else if (!this._fromValuesSet) {
                    this._startAlpha = node._alpha;
                }
            };
            /**
             * {@link cc.action.Action#initWithTarget}
             * @method cc.action.AlphaAction#initWithTarget
             * @override
             */
            AlphaAction.prototype.initWithTarget = function (node) {
                this._originalAlpha = node._alpha;
                this.solveInitialValues(node);
            };
            /**
             * {@link cc.action.Action#from}
             * @method cc.action.AlphaAction#from
             * @override
             */
            AlphaAction.prototype.from = function (alpha) {
                _super.prototype.from.call(this, alpha);
                this._startAlpha = alpha;
                return this;
            };
            /**
             * {@link cc.action.Action#to}
             * @method cc.action.AlphaAction#to
             * @override
             */
            AlphaAction.prototype.to = function (alpha) {
                this._endAlpha = alpha;
                return this;
            };
            /**
             * {@link cc.action.Action#__cloneImpl}
             * @method cc.action.AlphaAction#__cloneImpl
             * @override
             */
            AlphaAction.prototype.__cloneImpl = function () {
                var copy = new AlphaAction();
                copy.to(this._endAlpha);
                if (this._fromValuesSet) {
                    copy.from(this._startAlpha);
                }
                copy._originalAlpha = this._originalAlpha;
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Serialize the action current definition.
             * @method cc.action.AlphaAction#getInitializer
             * @returns {cc.action.AlphaActionInitializer}
             */
            AlphaAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                if (this._fromValuesSet) {
                    init.from = this._startAlpha;
                }
                init.to = this._endAlpha;
                init.type = "AlphaAction";
                return init;
            };
            return AlphaAction;
        })(Action);
        action.AlphaAction = AlphaAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>
var cc;
(function (cc) {
    var action;
    (function (action) {
        "use strict";
        var Action = cc.action.Action;
        var __moveActionUpdateValue = { x: 0, y: 0 };
        /**
         * @class cc.action.MoveAction
         * @extends cc.action.Action
         * @classdesc
         * This action applies to a node's position.
         * The action will traverse a line path.
         */
        var MoveAction = (function (_super) {
            __extends(MoveAction, _super);
            /**
             * Build a new MoveAction
             * @method cc.action.MoveAction#constructor
             * @param data {cc.action.MoveActionInitializer=}
             */
            function MoveAction(data) {
                _super.call(this);
                /**
                 * Node's original x position.
                 * @member cc.action.MoveAction#_originalX
                 * @type {number}
                 * @private
                 */
                this._originalX = 0;
                /**
                 * Node's original y position.
                 * @member cc.action.MoveAction#_originalX
                 * @type {number}
                 * @private
                 */
                this._originalY = 0;
                /**
                 * Action initial X
                 * @member cc.action.MoveAction#_x0
                 * @type {number}
                 * @private
                 */
                this._x0 = 0;
                /**
                 * Action initial Y
                 * @member cc.action.MoveAction#_y0
                 * @type {number}
                 * @private
                 */
                this._y0 = 0;
                /**
                 * Action final X
                 * @member cc.action.MoveAction#_x1
                 * @type {number}
                 * @private
                 */
                this._x1 = 0;
                /**
                 * Action final Y
                 * @member cc.action.MoveAction#_y1
                 * @type {number}
                 * @private
                 */
                this._y1 = 0;
                if (data) {
                    this.__createFromInitializer(data);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.MoveAction#__createFromInitializer
             * @param initializer {cc.action.MoveActionInitializer}
             * @private
             */
            MoveAction.prototype.__createFromInitializer = function (initializer) {
                _super.prototype.__createFromInitializer.call(this, initializer);
            };
            /**
             * Update target Node's position.
             * {@link cc.action.Action#update}
             * @method cc.action.MoveAction#update
             * @override
             * @return {cc.math.Point} new Node position.
             */
            MoveAction.prototype.update = function (delta, node) {
                var x = this._x0 + delta * (this._x1 - this._x0);
                var y = this._y0 + delta * (this._y1 - this._y0);
                if (this._relativeAction) {
                    x += this._originalX;
                    y += this._originalY;
                    if (this._reversed) {
                        x -= this._x1;
                        y -= this._y1;
                    }
                }
                node.setPosition(x, y);
                __moveActionUpdateValue.x = x;
                __moveActionUpdateValue.y = y;
                return __moveActionUpdateValue;
            };
            /**
             * Capture before-application Node's property values.
             * {@link cc.action.Action#solveInitialValues}
             * @method cc.action.MoveAction#solveInitialValues
             * @override
             */
            MoveAction.prototype.solveInitialValues = function (node) {
                if (this._relativeAction && !this._fromValuesSet) {
                    this._x0 = 0;
                    this._y0 = 0;
                }
                else if (!this._fromValuesSet) {
                    this._x0 = node.x;
                    this._y0 = node.y;
                }
            };
            /**
             * {@link cc.action.Action#initWithTarget}
             * @method cc.action.MoveAction#initWithTarget
             * @override
             */
            MoveAction.prototype.initWithTarget = function (node) {
                this._originalX = node.x;
                this._originalY = node.y;
                this.solveInitialValues(node);
            };
            /**
             * {@link cc.action.Action#from}
             * @method cc.action.MoveAction#from
             * @override
             */
            MoveAction.prototype.from = function (point) {
                _super.prototype.from.call(this, point);
                this._x0 = point.x;
                this._y0 = point.y;
                return this;
            };
            /**
             * {@link cc.action.Action#to}
             * @method cc.action.MoveAction#to
             * @override
             */
            MoveAction.prototype.to = function (point) {
                this._x1 = point.x;
                this._y1 = point.y;
                return this;
            };
            /**
             * {@link cc.action.Action#__cloneImpl}
             * @method cc.action.MoveAction#__cloneImpl
             * @override
             */
            MoveAction.prototype.__cloneImpl = function () {
                var copy = new MoveAction().to({ x: this._x1, y: this._y1 });
                if (this._fromValuesSet) {
                    copy.from({ x: this._x0, y: this._y0 });
                }
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Serialize the action current definition.
             * @method cc.action.MoveAction#getInitializer
             * @returns {cc.action.MoveActionInitializer}
             */
            MoveAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                if (this._fromValuesSet) {
                    init.from = { x: this._x0, y: this._y0 };
                }
                init.to = { x: this._x1, y: this._y1 };
                init.type = "MoveAction";
                return init;
            };
            return MoveAction;
        })(Action);
        action.MoveAction = MoveAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="../action/Action.ts"/>
var cc;
(function (cc) {
    var action;
    (function (action) {
        "use strict";
        var Action = cc.action.Action;
        /**
         * @class cc.action.PropertyInfo
         * @classdesc
         *
         * Internal helper Object to store a property information.
         * It stores:
         * <li>a property name, for example 'x' or 'p0.x'
         * <li>the property path. For example ['x'] or ['p0','x']
         * <li>original property value for a target object
         *
         * It is responsible for setting and getting the deep property path values too.
         *
         * Referenced properties MUST be numeric.
         */
        var PropertyInfo = (function () {
            /**
             * Property name.
             * @member cc.action.PropertyInfo#_property
             * @type {string}
             * @private
             */
            /**
             * Property start value.
             * @member cc.action.PropertyInfo#_start
             * @type {number}
             * @private
             */
            /**
             * Property end value.
             * @member cc.action.PropertyInfo#_end
             * @type {number}
             * @private
             */
            /**
             *
             * @param _property {string} property name.
             * @param _start {number} start value.
             * @param _end {number=} end value.
             */
            function PropertyInfo(_property, _start, _end) {
                this._property = _property;
                this._start = _start;
                this._end = _end;
                /**
                 * Property Units. For example, when the property is not a numeric value but something like '250px'.
                 * @member cc.action.PropertyInfo#_units
                 * @type {string}
                 * @private
                 */
                this._units = "";
                /**
                 * If the property is a deep property, like 'p0.x' or 'a.b.c.d.value' this property will indicate it.
                 * @member cc.action.PropertyInfo#_nested
                 * @type {boolean}
                 * @private
                 */
                this._nested = false;
                this._nested = _property.indexOf('.') !== -1;
                this._propertyPath = _property.split('.');
            }
            /**
             * Set the property value in a target object
             * @method cc.action.PropertyInfo#setTargetValue
             * @param target {any}
             * @param v {number}
             */
            PropertyInfo.prototype.setTargetValue = function (target, v) {
                var cursor = target;
                for (var i = 0; i < this._propertyPath.length - 1; i++) {
                    if (typeof cursor[this._propertyPath[i]] !== "undefined") {
                        cursor = cursor[this._propertyPath[i]];
                    }
                    else {
                        // error, no deep path found on object
                        return;
                    }
                }
                cursor[this._propertyPath[i]] = v;
            };
            /**
             * Get the property value from a target object
             * @method cc.action.PropertyInfo#getTargetValue
             * @param target {any}
             * @returns {number}
             */
            PropertyInfo.prototype.getTargetValue = function (target) {
                var cursor = target;
                for (var i = 0; i < this._propertyPath.length; i++) {
                    if (typeof cursor[this._propertyPath[i]] !== "undefined") {
                        cursor = cursor[this._propertyPath[i]];
                    }
                    else {
                        // error, no deep path found on object
                        return null;
                    }
                }
                return cursor;
            };
            /**
             * Set PropertyInfo original target value.
             * @param n {number}
             * @returns {cc.action.PropertyInfo}
             */
            PropertyInfo.prototype.setOriginal = function (n) {
                this._original = n;
                return this;
            };
            /**
             * Get property original value in the original target object.
             * @method cc.action.PropertyInfo#getOriginal
             * @returns {number}
             */
            PropertyInfo.prototype.getOriginal = function () {
                return this._original;
            };
            /**
             * Clone the PropertyInfo object.
             * @method cc.action.PropertyInfo#clone
             * @returns {cc.action.PropertyInfo}
             */
            PropertyInfo.prototype.clone = function () {
                return new PropertyInfo(this._property, this._start, this._end);
            };
            /**
             * Get the property path.
             * @method cc.action.PropertyInfo#getPath
             * @returns {string[]}
             */
            PropertyInfo.prototype.getPath = function () {
                return this._propertyPath;
            };
            return PropertyInfo;
        })();
        action.PropertyInfo = PropertyInfo;
        /**
         * @class cc.action.PropertyAction
         * @extends cc.action.Action
         * @classdesc
         *
         * This action applies to any arbitrary Object's properties. Could apply to multiple properties at the same time.
         * AlphaAction and RotateAction fit in the model of a PropertyInfo, but they are complete Actions for the shake of
         * clarity and performance.
         *
         * The properties a PropertyAction will handle must be simple properties, not Objects, only composed of a number and
         * an optional unit.
         *
         * A different set of properties can be specified in a call to <code>from</code> and <code>to</code>. Properties
         * specified not in both <code>from</code> and <code>to</code> at the same time, will get values either 'from' or
         * 'to' values when a call to <code>initWithTarget</code> is made.
         */
        var PropertyAction = (function (_super) {
            __extends(PropertyAction, _super);
            /**
             * PropertyAction constructor.
             * @method cc.action.PropertyAction#constructor
             */
            function PropertyAction(data) {
                _super.call(this);
                this._propertiesInfo = [];
                if (data) {
                    this.__createFromInitializer(data);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.PropertyAction#__createFromInitializer
             * @param data {cc.action.PropertyActionInitializer}
             * @private
             */
            PropertyAction.prototype.__createFromInitializer = function (initializer) {
                _super.prototype.__createFromInitializer.call(this, initializer);
            };
            /**
             * {@link cc.action.Action#initWithTarget}
             * @method cc.action.PropertyAction#initWithTarget
             * @override
             */
            PropertyAction.prototype.initWithTarget = function (node) {
                this.solveInitialValues(node);
            };
            /**
             * Update target Node's properties.
             * {@link cc.action.Action#update}
             * @method cc.action.PropertyAction#update
             * @override
             * @returns {Object} an Object with all the modified properties.
             */
            PropertyAction.prototype.update = function (delta, node) {
                var ret = {};
                for (var i = 0; i < this._propertiesInfo.length; i++) {
                    var pr = this._propertiesInfo[i];
                    var v = pr._start + delta * (pr._end - pr._start);
                    if (this.isRelative()) {
                        v += pr.getOriginal();
                    }
                    pr.setTargetValue(node, v);
                    //node[pr._property] = pr.getValue(v);
                    // register applied values only if theres someone interested.
                    if (this._onApply) {
                        ret[pr._property] = v;
                    }
                }
                return ret;
            };
            /**
             * Capture before-application Node's property values.
             * {@link cc.action.Action#solveInitialValues}
             * @method cc.action.PropertyAction#solveInitialValues
             * @override
             */
            PropertyAction.prototype.solveInitialValues = function (node) {
                for (var i = 0; i < this._propertiesInfo.length; i++) {
                    var pr = this._propertiesInfo[i];
                    if (typeof pr._start === "undefined") {
                        pr._start = pr.getTargetValue(node);
                    }
                    if (typeof pr._end === "undefined") {
                        pr._end = pr.getTargetValue(node);
                    }
                    pr._original = pr.getTargetValue(node);
                }
            };
            /**
             * {@link cc.action.Action#from}
             * @method cc.action.PropertyAction#from
             * @override
             */
            PropertyAction.prototype.from = function (props) {
                this._from = props;
                if (props) {
                    for (var pr in props) {
                        if (props.hasOwnProperty(pr)) {
                            var propertyInfo = new PropertyInfo(pr, props[pr]);
                            this._propertiesInfo.push(propertyInfo);
                        }
                    }
                }
                return this;
            };
            /**
             * {@link cc.action.Action#to}
             * @method cc.action.PropertyAction#to
             * @override
             */
            PropertyAction.prototype.to = function (props) {
                this._to = props;
                var i;
                for (var pr in props) {
                    if (props.hasOwnProperty(pr)) {
                        // if no property set, create a property w/o initial value. will be filled automagically by a call to
                        // __setInitialValues
                        var property = null;
                        for (i = 0; i < this._propertiesInfo.length; i++) {
                            if (this._propertiesInfo[i]._property === pr) {
                                property = this._propertiesInfo[i];
                                break;
                            }
                        }
                        if (!property) {
                            property = new PropertyInfo(pr);
                            this._propertiesInfo.push(property);
                        }
                        property._end = props[pr];
                    }
                }
                return this;
            };
            /**
             * Helper function for cloning this property.
             * @memver cc.action.PropertyAction#__cloneProperties
             * @returns {Array<PropertyInfo>}
             * @private
             */
            PropertyAction.prototype.__cloneProperties = function () {
                var pr = [];
                for (var i = 0; i < this._propertiesInfo.length; i++) {
                    pr.push(this._propertiesInfo[i].clone());
                }
                return pr;
            };
            /**
             * {@link cc.action.Action#__cloneImpl}
             * @method cc.action.PropertyAction#__cloneImpl
             * @override
             */
            PropertyAction.prototype.__cloneImpl = function () {
                var copy = new PropertyAction().to(this.__cloneProperties());
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Serialize the action current definition.
             * @method cc.action.PropertyAction#getInitializer
             * @returns {cc.action.PropertyActionInitializer}
             */
            PropertyAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                if (this._fromValuesSet) {
                    init.from = this._from;
                }
                init.to = this._to;
                init.type = "PropertyAction";
                return init;
            };
            return PropertyAction;
        })(Action);
        action.PropertyAction = PropertyAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>
var cc;
(function (cc) {
    var action;
    (function (action) {
        "use strict";
        var Action = cc.action.Action;
        /**
         * @class cc.action.RotateAction
         * @extends cc.action.Action
         * @classdesc
         *
         * This action applies to a node's rotation angle.
         * The rotation angle is defined in degrees.
         */
        var RotateAction = (function (_super) {
            __extends(RotateAction, _super);
            /**
             * Build a new RotateAction instance.
             * @method cc.action.RotateAction#constructor
             * @param data {cc.action.RotateActionInitializer=}
             */
            function RotateAction(data) {
                _super.call(this);
                /**
                 * Node's original rotation angle.
                 * @member cc.action.RotateAction#_originalAngle
                 * @type {number}
                 * @private
                 */
                this._originalAngle = 0;
                /**
                 * Action start angle
                 * @member cc.action.RotateAction#_startAngle
                 * @type {number}
                 */
                this._startAngle = 0;
                /**
                 * Action end angle
                 * @member cc.action.RotateAction#_endAngle
                 * @type {number}
                 */
                this._endAngle = 360;
                if (data) {
                    this.__createFromInitializer(data);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.RotateAction#__createFromInitializer
             * @param initializer {cc.action.RotateActionInitializer}
             * @private
             */
            RotateAction.prototype.__createFromInitializer = function (initializer) {
                _super.prototype.__createFromInitializer.call(this, initializer);
            };
            /**
             * Update target Node's rotation angle.
             * {@link cc.action.Action#update}
             * @method cc.action.RotateAction#update
             * @override
             * @return {number} new Node rotation angle.
             */
            RotateAction.prototype.update = function (delta, node) {
                var r = this._startAngle + delta * (this._endAngle - this._startAngle);
                if (this._relativeAction) {
                    r += this._originalAngle;
                    if (this._reversed) {
                        r -= this._endAngle;
                    }
                }
                node.rotationAngle = r;
                return r;
            };
            /**
             * Capture before-application Node's rotation angle.
             * {@link cc.action.Action#solveInitialValues}
             * @method cc.action.RotateAction#solveInitialValues
             * @override
             */
            RotateAction.prototype.solveInitialValues = function (node) {
                if (this._relativeAction && !this._fromValuesSet) {
                    this._startAngle = 0;
                    if (this._startAngle === this._endAngle) {
                        this._startAngle = this._originalAngle;
                        this._originalAngle = 0;
                    }
                }
                else if (!this._fromValuesSet) {
                    this._startAngle = node.rotationAngle;
                }
            };
            /**
             * {@link cc.action.Action#initWithTarget}
             * @method cc.action.RotateAction#initWithTarget
             * @override
             */
            RotateAction.prototype.initWithTarget = function (node) {
                this._originalAngle = node.rotationAngle;
                this.solveInitialValues(node);
            };
            /**
             * {@link cc.action.Action#from}
             * @method cc.action.RotateAction#from
             * @override
             */
            RotateAction.prototype.from = function (angle) {
                _super.prototype.from.call(this, angle);
                this._startAngle = angle;
                return this;
            };
            /**
             * {@link cc.action.Action#to}
             * @method cc.action.RotateAction#to
             * @override
             */
            RotateAction.prototype.to = function (angle) {
                this._endAngle = angle;
                return this;
            };
            /**
             * {@link cc.action.Action#__cloneImpl}
             * @method cc.action.RotateAction#__cloneImpl
             * @override
             */
            RotateAction.prototype.__cloneImpl = function () {
                var copy = new RotateAction().to(this._endAngle);
                if (this._fromValuesSet) {
                    copy.from(this._startAngle);
                }
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Serialize the action current definition.
             * @method cc.action.RotateAction#getInitializer
             * @returns {cc.action.RotateActionInitializer}
             */
            RotateAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                if (this._fromValuesSet) {
                    init.from = this._startAngle;
                }
                init.to = this._endAngle;
                init.type = "RotateAction";
                return init;
            };
            return RotateAction;
        })(Action);
        action.RotateAction = RotateAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./Action.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Node.ts"/>
var cc;
(function (cc) {
    var action;
    (function (action) {
        "use strict";
        var Vector = cc.math.Vector;
        var Action = cc.action.Action;
        var __scaleActionUpdateValue = new Vector();
        /**
         * @class cc.action.ScaleAction
         * @extends cc.action.Action
         * @classdesc
         *
         * This action applies to a Node's scale values.
         */
        var ScaleAction = (function (_super) {
            __extends(ScaleAction, _super);
            /**
             * Build a new ScaleAction instance.
             * @param data {cc.action.ScaleActionInitializer=}
             */
            function ScaleAction(data) {
                _super.call(this);
                /**
                 * Node's original x axis scale.
                 * @member cc.action.ScaleAction#_originalScaleX
                 * @type {number}
                 * @private
                 */
                this._originalScaleX = 1;
                /**
                 * Node's original y axis scale.
                 * @member cc.action.ScaleAction#_originalScaleY
                 * @type {number}
                 * @private
                 */
                this._originalScaleY = 1;
                /**
                 * Action start x axis Scale.
                 * @member cc.action.ScaleAction#_scaleX0
                 * @type {number}
                 */
                this._scaleX0 = 1;
                /**
                 * Action start y axis Scale.
                 * @member cc.action.ScaleAction#_scaleY0
                 * @type {number}
                 */
                this._scaleY0 = 1;
                /**
                 * Action end x axis Scale.
                 * @member cc.action.ScaleAction#_scaleX1
                 * @type {number}
                 */
                this._scaleX1 = 1;
                /**
                 * Action end y axis Scale.
                 * @member cc.action.ScaleAction#_scaleY1
                 * @type {number}
                 */
                this._scaleY1 = 1;
                if (data) {
                    this.__createFromInitializer(data);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.ScaleAction#__createFromInitializer
             * @param data {cc.action.ScaleActionInitializer}
             * @private
             */
            ScaleAction.prototype.__createFromInitializer = function (initializer) {
                _super.prototype.__createFromInitializer.call(this, initializer);
            };
            /**
             * Update target Node's scale.
             * {@link cc.action.Action#update}
             * @method cc.action.ScaleAction#update
             * @override
             * @returns {cc.math.Vector} new node's scale values.
             */
            ScaleAction.prototype.update = function (delta, node) {
                var x = this._scaleX0 + delta * (this._scaleX1 - this._scaleX0);
                var y = this._scaleY0 + delta * (this._scaleY1 - this._scaleY0);
                if (this._relativeAction) {
                    x += this._originalScaleX;
                    y += this._originalScaleY;
                    if (this._reversed) {
                        x -= this._scaleX1;
                        y -= this._scaleY1;
                    }
                }
                node.setScale(x, y);
                return __scaleActionUpdateValue.set(x, y);
            };
            /**
             * Capture before-application Node's scale for both axis x and y.
             * {@link cc.action.Action#solveInitialValues}
             * @method cc.action.ScaleAction#solveInitialValues
             * @override
             */
            ScaleAction.prototype.solveInitialValues = function (node) {
                if (this._relativeAction && !this._fromValuesSet) {
                    this._scaleX0 = 0;
                    this._scaleY0 = 0;
                }
                else if (!this._fromValuesSet) {
                    this._scaleX0 = node.scaleX;
                    this._scaleY0 = node.scaleY;
                }
            };
            /**
             * {@link cc.action.Action#initWithTarget}
             * @method cc.action.ScaleAction#initWithTarget
             * @override
             */
            ScaleAction.prototype.initWithTarget = function (node) {
                this._originalScaleX = node.scaleX;
                this._originalScaleY = node.scaleY;
                this.solveInitialValues(node);
            };
            /**
             * {@link cc.action.Action#from}
             * @method cc.action.ScaleAction#from
             * @override
             */
            ScaleAction.prototype.from = function (point) {
                _super.prototype.from.call(this, point);
                this._scaleX0 = point.x;
                this._scaleY0 = point.y;
                return this;
            };
            /**
             * {@link cc.action.Action#to}
             * @method cc.action.ScaleAction#to
             * @override
             */
            ScaleAction.prototype.to = function (point) {
                this._scaleX1 = point.x;
                this._scaleY1 = point.y;
                return this;
            };
            /**
             * {@link cc.action.Action#__cloneImpl}
             * @method cc.action.ScaleAction#__cloneImpl
             * @override
             */
            ScaleAction.prototype.__cloneImpl = function () {
                var copy = new ScaleAction().to({ x: this._scaleX1, y: this._scaleY1 });
                if (this._fromValuesSet) {
                    copy.from({ x: this._scaleX0, y: this._scaleY0 });
                }
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Serialize the action current definition.
             * @method cc.action.ScaleAction#getInitializer
             * @returns {cc.action.ScaleActionInitializer}
             */
            ScaleAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                if (this._fromValuesSet) {
                    init.from = { x: this._scaleX0, y: this._scaleY0 };
                }
                init.to = { x: this._scaleX1, y: this._scaleY1 };
                init.type = "ScaleAction";
                return init;
            };
            return ScaleAction;
        })(Action);
        action.ScaleAction = ScaleAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>
/// <reference path="./MoveAction.ts"/>
/// <reference path="./RotateAction.ts"/>
/// <reference path="./ScaleAction.ts"/>
/// <reference path="./PropertyAction.ts"/>
/// <reference path="./AlphaAction.ts"/>
/// <reference path="./TintAction.ts"/>
var cc;
(function (cc) {
    var action;
    (function (_action) {
        "use strict";
        var Action = cc.action.Action;
        /**
         * @class cc.action.SequenceAction
         * @extends cc.action.Action
         * @classdesc
         *
         * SequenceAction is a collection of either parallel or sequential actions.
         * It is useful for grouping actions in a more convenient way.
         * <br>
         * This action maps to previous API versions' Sequence and Spawn, but internally works in a complete different way.
         * <br>
         * A Sequence, constraints its contained Actions to its own duration. That means that if the Sequence Actions are not
         * well setup relatively to the Sequence timing, Actions could not end playing, or callbacks could not be notified
         * appropriately.
         *
         * <li>Internally, a Sequence does not modify a Node's properties. It just choreographs the time for its children
         *  Actions. Hece there's no need to call <code>from</code> or <code>to</code> methods. This means that setting
         *  a Sequence as relative has no impact.
         * <li>A Sequence can contain other Sequences to the desired nesting level.
         * <li>A repeating ActionSequence will repeat its contained actions.
         * <li>A Sequence, if is sequential=true, will sequentialize contained actions, making one start when the previous one
         * ends. If it is sequential=false, Actions will happen at the same time.
         * <li>By default a Sequence Action will conform its duration to the one resulting of the contained Actions. It will
         * have special heuristics for sequential and not sequential behaviors.
         */
        var SequenceAction = (function (_super) {
            __extends(SequenceAction, _super);
            /**
             * Build a new Sequence action.
             * @method cc.action.SequenceAction#constructor
             * @param data {cc.action.SequenceActionInitializer=}
             */
            function SequenceAction(data) {
                _super.call(this);
                /**
                 * Collection of Sequenced actions.
                 * @member cc.action.SequenceAction#_actions
                 * @type {Array<cc.action.Action>}
                 * @private
                 */
                this._actions = [];
                /**
                 * Configures this action as Sequence or Spawn.
                 * @member cc.action.SequenceAction#_sequential
                 * @type {boolean}
                 */
                this._sequential = true;
                this._prevOnRepeat = null;
                if (typeof data !== "undefined") {
                    this.__createFromInitializer(data);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.SequenceAction#__createFromInitializer
             * @param data {cc.action.SequenceActionInitializer}
             * @private
             */
            SequenceAction.prototype.__createFromInitializer = function (data) {
                _super.prototype.__createFromInitializer.call(this, data);
                if (typeof data.sequential !== "undefined") {
                    this._sequential = data.sequential;
                }
                if (data.actions) {
                    for (var i = 0; i < data.actions.length; i++) {
                        this.addAction(cc.action.ParseAction(data.actions[i]));
                    }
                }
                this._onRepeat = function (action, target, repetitionCount) {
                    var seq = action;
                    seq.recursivelySetCreatedStatus(target);
                    if (seq._prevOnRepeat) {
                        seq._prevOnRepeat(action, target, repetitionCount);
                    }
                };
            };
            /**
             * Set onRepeat callback. This method is overridden since repeating sequences must have a custom onRepeat
             * implementation.
             * @method cc.action.SequenceAction#onRepeat
             * @param callback {cc.action.ActionCallbackRepeatCallback}
             * @returns {cc.action.SequenceAction}
             */
            SequenceAction.prototype.onRepeat = function (callback) {
                this._prevOnRepeat = callback;
                return this;
            };
            /**
             * When a Sequence repeats, it must recursively clear the status of all its children Actions.
             * @method cc.action.SequenceAction#recursivelySetCreatedStatus
             * @param target
             */
            SequenceAction.prototype.recursivelySetCreatedStatus = function (target) {
                for (var i = 0; i < this._actions.length; i++) {
                    this._actions[i].__recursivelySetCreatedStatus(target);
                }
            };
            /**
             * Get the last Action on the sequence.
             * @method cc.action.SequenceAction#getLastAction
             * @returns {cc.action.Action}
             */
            SequenceAction.prototype.getLastAction = function () {
                if (this._actions.length === 0) {
                    return null;
                }
                return this._actions[this._actions.length - 1];
            };
            /**
             * Recursive set created status implementation.
             * @method cc.action.SequenceAction#__recursivelySetCreatedStatus
             * @param target {object}
             * @private
             */
            SequenceAction.prototype.__recursivelySetCreatedStatus = function (target) {
                for (var i = 0; i < this._actions.length; i++) {
                    this._actions[i].__recursivelySetCreatedStatus(target);
                }
                _super.prototype.__recursivelySetCreatedStatus.call(this, target);
            };
            /**
             * When an action is added, or has its duration, start time, or delay modified, the Sequence duration will be
             * recalculated.
             * @method cc.action.SequenceAction#__updateDuration
             * @override
             * @private
             */
            SequenceAction.prototype.__updateDuration = function () {
                if (!this._actions) {
                    return;
                }
                var duration = 0;
                this.__sequentializeStartAndDuration();
                for (var i = 0; i < this._actions.length; i++) {
                    var nd = this._actions[i]._startTime + this._actions[i].getDuration();
                    if (nd > duration) {
                        duration = nd;
                    }
                }
                this._duration = duration;
                _super.prototype.__updateDuration.call(this);
            };
            /**
             * If this sequence has sequential behavior, this method will sequentialize in time all the Actions.
             * @method cc.action.SequenceAction#__sequentializeStartAndDuration
             * @private
             */
            SequenceAction.prototype.__sequentializeStartAndDuration = function () {
                var actions = this._actions;
                if (this._sequential) {
                    for (var i = 0; i < actions.length; i++) {
                        var curr = actions[i];
                        if (i > 0) {
                            var prev = actions[i - 1];
                            curr._startTime = prev.getDuration() + prev._startTime;
                        }
                        else {
                            curr._startTime = 0;
                        }
                    }
                }
            };
            /**
             * Add an Action to the Sequence.
             * <br>
             * Added Actions can be other Sequences.
             * <br>
             * Adding actions triggers upwards recursive duration recalculation.
             * @method cc.action.SequenceAction#addAction
             * @param a {cc.action.Action}
             * @returns {cc.action.SequenceAction}
             */
            SequenceAction.prototype.addAction = function (a) {
                this._actions.push(a);
                a._chainContext = this._chainContext;
                a._parentSequence = this;
                this.__updateDuration();
                return this;
            };
            /**
             * Do Sequence application process.
             * <br>
             * Do not call directly.
             *
             * @param delta {number} elapsed time between frames.
             * @param time {number} absolute Action time.
             * @param node {cc.node.Node} target node.
             * @private
             * @method cc.action.SequenceAction#__stepImpl
             */
            SequenceAction.prototype.__stepImpl = function (delta, time, node) {
                if (this._status !== 4 /* ENDED */) {
                    if (this.__isActionApplicable(time)) {
                        // absolute time for this action relative to its start time.
                        var ntime = (time - this._startTime) % this.getOneRepetitionDuration();
                        for (var i = 0; i < this._actions.length; i++) {
                            var caction = this._actions[i];
                            caction._currentTime = (caction._currentTime + caction._speed * delta) % this.getOneRepetitionDuration();
                            caction.__stepImpl(delta, ntime, node);
                        }
                        _super.prototype.__actionApply.call(this, time, node);
                    }
                    else {
                        // apply all sub-actions for the final state.
                        if (time >= this._startTime + this.getDuration()) {
                            this._status = 4 /* ENDED */;
                            for (var i = 0; i < this._actions.length; i++) {
                                this._actions[i]._currentTime = (this._actions[i]._currentTime + delta);
                                this._actions[i].__stepImpl(1 / cc.action.TIMEUNITS, time, node);
                            }
                            this.__actionApply(time, node);
                            if (this._onEnd) {
                                this._onEnd(this, node);
                            }
                        }
                    }
                }
            };
            /**
             * Internal method to apply children actions to a target Node.
             * @method cc.action.SequenceAction#__actionApply
             * @param time {number} Time relative to the Sequence to apply a child Action at.
             * @param node {cc.node.Node} target Node to apply actions to.
             * @private
             */
            SequenceAction.prototype.__actionApply = function (time, node) {
            };
            /**
             * Clone the Action and all its children Actions.
             * @method cc.action.SequenceAction#__cloneImpl
             * @override
             * @inheritDoc
             */
            SequenceAction.prototype.__cloneImpl = function () {
                var action = new SequenceAction({ sequential: this._sequential });
                this.__genericCloneProperties(action);
                action._prevOnRepeat = this._prevOnRepeat;
                action._duration = 0;
                for (var i = 0; i < this._actions.length; i++) {
                    action.addAction(this._actions[i].clone());
                }
                return action;
            };
            /**
             * Get Sequence's number of actions.
             * @method cc.action.SequenceAction#getNumActions
             * @returns {number}
             */
            SequenceAction.prototype.getNumActions = function () {
                return this._actions.length;
            };
            /**
             * Get action at index.
             * @method cc.action.SequenceAction#getAction
             * @param i {number}
             * @returns {cc.action.Action}
             */
            SequenceAction.prototype.getAction = function (i) {
                return this._actions[i];
            };
            /**
             * @override
             * @inheritDoc
             */
            SequenceAction.prototype.setReversed = function () {
                _super.prototype.setReversed.call(this);
                this._actions = this._actions.reverse();
                for (var i = 0; i < this._actions.length; i++) {
                    this._actions[i].setReversed();
                }
                this.__sequentializeStartAndDuration();
                return this;
            };
            /**
             * Set the Sequence as Sequence (sequential=true) or Spawn (sequential=false).
             * @method cc.action.SequenceAction#setSequential
             * @param b {boolean}
             */
            SequenceAction.prototype.setSequential = function (b) {
                this._sequential = b;
            };
            /**
             * Serialize the action current definition.
             * @method cc.action.SequenceAction#getInitializer
             * @returns {cc.action.SequenceActionInitializer}
             */
            SequenceAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                init.type = "SequenceAction";
                init.sequential = this._sequential;
                init.actions = [];
                for (var i = 0; i < this._actions.length; i++) {
                    init.actions.push(this._actions[i].getInitializer());
                }
                return init;
            };
            return SequenceAction;
        })(Action);
        _action.SequenceAction = SequenceAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="./Action.ts"/>
var cc;
(function (cc) {
    var action;
    (function (action) {
        "use strict";
        var Action = cc.action.Action;
        var __updateRGB = { r: 1, g: 1, b: 1 };
        /**
         * @class cc.action.TintAction
         * @extends cc.action.Action
         * @classdesc
         *
         * This action applies to a Node's color.
         * The tint color is not the actual node's color, it is a multiplicative value for color or texture.
         * Tint components are values between 0 and 1.
         */
        var TintAction = (function (_super) {
            __extends(TintAction, _super);
            /**
             * Build a new TintAction.
             * @method cc.action.TintAction#constructor
             * @param data {cc.action.TintActionInitializer=}
             */
            function TintAction(data) {
                _super.call(this);
                /**
                 * Node's original color.
                 * @member cc.action.TintAction#_originalColor
                 * @type {cc.math.RGBAColor}
                 * @private
                 */
                this._originalColor = { r: 1, g: 1, b: 1 };
                /**
                 * Action start color.
                 * @member cc.action.TintAction#_startColor
                 * @type {cc.math.RGBAColor}
                 */
                this._startColor = { r: 1, g: 1, b: 1 };
                /**
                 * Action end color.
                 * @member cc.action.TintAction#_endColor
                 * @type {cc.math.RGBAColor}
                 */
                this._endColor = { r: 1, g: 1, b: 1 };
                if (data) {
                    this.__createFromInitializer(data);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.TintAction#__createFromInitializer
             * @param data {cc.action.TintActionInitializer}
             * @private
             */
            TintAction.prototype.__createFromInitializer = function (initializer) {
                _super.prototype.__createFromInitializer.call(this, initializer);
            };
            /**
             * Update target Node's tint color.
             * {@link cc.action.Action#update}
             * @method cc.action.TintAction#update
             * @override
             * @returns {cc.math.RGBAColor} new node's tint values.
             */
            TintAction.prototype.update = function (delta, node) {
                var r = this._startColor.r + delta * (this._endColor.r - this._startColor.r);
                var g = this._startColor.g + delta * (this._endColor.g - this._startColor.g);
                var b = this._startColor.b + delta * (this._endColor.b - this._startColor.b);
                if (this._relativeAction) {
                    r += this._originalColor.r;
                    g += this._originalColor.g;
                    b += this._originalColor.b;
                    if (this._reversed) {
                        r -= this._endColor.r;
                        g -= this._endColor.g;
                        b -= this._endColor.b;
                    }
                }
                node.setColor(r, g, b);
                // update returned value only if someone is interested on it.
                if (this._onApply) {
                    __updateRGB.r = r;
                    __updateRGB.g = g;
                    __updateRGB.b = b;
                }
                return __updateRGB;
            };
            /**
             * Capture before-application Node's tint color.
             * {@link cc.action.Action#solveInitialValues}
             * @method cc.action.TintAction#solveInitialValues
             * @override
             */
            TintAction.prototype.solveInitialValues = function (node) {
                if (this._relativeAction && !this._fromValuesSet) {
                    this._startColor.r = 0;
                    this._startColor.g = 0;
                    this._startColor.b = 0;
                }
                else {
                    var color = node._color._color;
                    this._startColor.r = color[0];
                    this._startColor.g = color[1];
                    this._startColor.b = color[2];
                }
            };
            /**
             * {@link cc.action.Action#initWithTarget}
             * @method cc.action.TintAction#initWithTarget
             * @override
             */
            TintAction.prototype.initWithTarget = function (node) {
                var color = node._color._color;
                this._originalColor.r = color[0];
                this._originalColor.g = color[1];
                this._originalColor.b = color[2];
                this.solveInitialValues(node);
            };
            /**
             * {@link cc.action.Action#from}
             * @method cc.action.TintAction#from
             * @override
             */
            TintAction.prototype.from = function (color) {
                _super.prototype.from.call(this, color);
                this._startColor = { r: color.r, g: color.g, b: color.b };
                ;
                return this;
            };
            /**
             * {@link cc.action.Action#to}
             * @method cc.action.TintAction#to
             * @override
             */
            TintAction.prototype.to = function (color) {
                this._endColor = { r: color.r, g: color.g, b: color.b };
                return this;
            };
            /**
             * {@link cc.action.Action#__cloneImpl}
             * @method cc.action.TintAction#__cloneImpl
             * @override
             */
            TintAction.prototype.__cloneImpl = function () {
                var copy = new TintAction();
                copy.to({ r: this._endColor.r, g: this._endColor.g, b: this._endColor.b });
                if (this._fromValuesSet) {
                    copy.from({ r: this._startColor.r, g: this._startColor.g, b: this._startColor.b });
                }
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Serialize the action current definition.
             * @method cc.action.TintAction#getInitializer
             * @returns {cc.action.TintActionInitializer}
             */
            TintAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                if (this._fromValuesSet) {
                    init.from = { r: this._startColor.r, g: this._startColor.g, b: this._startColor.b };
                }
                init.to = { r: this._endColor.r, g: this._endColor.g, b: this._endColor.b };
                init.type = "TintAction";
                return init;
            };
            return TintAction;
        })(Action);
        action.TintAction = TintAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="./Action.ts"/>
/// <reference path="../node/sprite/Animation.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Sprite.ts"/>
var cc;
(function (cc) {
    var action;
    (function (action) {
        var Action = cc.action.Action;
        /**
         * @class cc.action.AnimateAction
         * @extends cc.action.Action
         * @classdesc
         *
         * This action changes Sprite's images in a time basis.
         * <p>
         *     It handles an instance of <code>cc.node.sprite.Animation</code> which is collection of SpriteFrame objects.
         *     Each SpriteFrame references an image and a rect on the image. The action, selects a SpriteFrame on
         *     the Animation based on time keyframing.
         * <p>
         *     Even though an Animation object has control over how many times the animation will be repeated, calling
         *     <code>action.setRepeatTimes(times);</code> or <code>action.setRepeatForever();</code> will override the
         *     Animation value in favor of the newly set one.
         * <p>
         *     Warning. This action expects as its target a @link {cc.node.Sprite} instance and not a @link {cc.node.Node}
         *     like the other actions. The target supplied to this Action must have a <code>setSpriteFrame</code> method
         *     otherwise an undefined error will be thrown.
         *
         *
         *
         * @see {cc.node.sprite.Animation}
         *
         */
        var AnimateAction = (function (_super) {
            __extends(AnimateAction, _super);
            /**
             * Create a new Animate action instance.
             * @method cc.action.AnimateAction#constructor
             * @param data {cc.node.sprite.Animation}
             */
            function AnimateAction(data) {
                _super.call(this);
                /**
                 * Original SpriteFrame for the Action target node.
                 * @member cc.action.AnimateAction#_originalSpriteFrame
                 * @type {cc.node.sprite.SpriteFrame}
                 * @private
                 */
                this._originalSpriteFrame = null;
                /**
                 * Animation.
                 * @member cc.action.AnimateAction#_animation
                 * @type {cc.node.sprite.Animation}
                 * @private
                 */
                this._animation = null;
                if (data) {
                    if (data instanceof cc.node.sprite.Animation) {
                        this.setAnimation(data);
                    }
                    else {
                        this.__createFromInitializer(data);
                    }
                }
            }
            /**
             * Initialize the action with an initializer Object
             * @method cc.action.AnimateAction#__createFromInitializer
             * @param data {cc.action.AnimateActionInitializer}
             */
            AnimateAction.prototype.__createFromInitializer = function (data) {
                _super.prototype.__createFromInitializer.call(this, data);
                this.setAnimation(cc.plugin.asset.AssetManager.getAnimationById(data.animationName));
            };
            /**
             * Set the Animation object instance.
             * @method cc.action.AnimateAction#setAnimation
             * @param data {cc.node.sprite.Animation}
             */
            AnimateAction.prototype.setAnimation = function (data) {
                this._animation = data;
                this.setDuration(0);
                this.setRepeatTimes(data._loops);
                return this;
            };
            /**
             * Set the Animate action duration.
             * Will always fallback to set the Animation duration.
             * @method cc.action.AnimateAction##setDuration
             * @param d
             */
            AnimateAction.prototype.setDuration = function (d) {
                if (this._animation) {
                    _super.prototype.setDuration.call(this, this._animation.getDuration());
                }
                return this;
            };
            /**
             * Update target Node's SpriteFrame.
             * {@link cc.action.Action#update}
             * @method cc.action.AnimateAction#update
             * @override
             * @return {number} Applied transparency value.
             */
            AnimateAction.prototype.update = function (normalizedTime, target) {
                var index = ((normalizedTime * this._animation.getSize()) | 0) % this._animation.getSize();
                if (index >= 0 && index < this._animation.getSize()) {
                    target.setSpriteFrame(this._animation.getSpriteFrameAtIndex(index));
                }
                return index;
            };
            /**
             * Calculate one repetition duration. Must be explictly set for V3 bacwards compatiblity and
             * a call to Animate with an still loading animation. This is messy and wrong, but must be.
             * @method cc.action.AnimateAction#getOneRepetitionDuration
             * @returns {number}
             */
            AnimateAction.prototype.getOneRepetitionDuration = function () {
                return (this._animation.getDuration() + this._delayAfterApplication) * this._speed * cc.action.TIMEUNITS;
            };
            /**
             * This method does nothing.
             * {@link cc.action.Action#solveInitialValues}
             * @method cc.action.AnimateAction#solveInitialValues
             * @override
             */
            AnimateAction.prototype.solveInitialValues = function (node) {
            };
            /**
             * Initialize the action with a target node.
             * {@link cc.action.Action#initWithTarget}
             * @method cc.action.AnimateAction#initWithTarget
             * @override
             */
            AnimateAction.prototype.initWithTarget = function (node) {
                this._originalSpriteFrame = node._spriteFrame;
                this.solveInitialValues(node);
            };
            /**
             * {@link cc.action.Action#to}
             * @method cc.action.AnimateAction#to
             * @override
             */
            AnimateAction.prototype.to = function (a) {
                this.setAnimation(a);
                return this;
            };
            /**
             * Specific clone implementation function
             * {@link cc.action.Action#__cloneImpl}
             * @method cc.action.AnimateAction#__cloneImpl
             * @override
             * @private
             */
            AnimateAction.prototype.__cloneImpl = function () {
                var copy = new AnimateAction();
                copy.to(this._animation.clone());
                copy._originalSpriteFrame = this._originalSpriteFrame;
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Stop the Action. If at Action initialization time a originalSpriteFrame was set, and the Animation specifies
             * restore original frame, the original SpriteFrame is set.
             * @param node
             */
            AnimateAction.prototype.stop = function (node) {
                _super.prototype.stop.call(this, node);
                if (this._animation._restoreOriginalFrame) {
                    node.setSpriteFrame(this._originalSpriteFrame);
                }
            };
            /**
             * Get current action state initializer object.
             * @method cc.action.AnimateAction#getInitializer
             * @returns {cc.action.AnimateActionInitializer}
             */
            AnimateAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                init.type = "AnimateAction";
                init.animationName = this._animation._name;
                return init;
            };
            return AnimateAction;
        })(Action);
        action.AnimateAction = AnimateAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../math/Point.ts"/>
/// <reference path="../math/path/Segment.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>
var cc;
(function (cc) {
    var action;
    (function (action) {
        "use strict";
        var Action = cc.action.Action;
        var __PathActionUpdateValue = { x: 0, y: 0 };
        /**
         * @class cc.action.PathAction
         * @extends cc.action.Action
         * @classdesc
         *
         * This action applies to a node's position.
         * The action will traverse a Segment path which can be a simple line or a complex path built out of a collection
         * of Segments and Paths. When traversing through out a simple linear path, prefer MoveAction in favor of this one.
         *
         * <p>
         *     Warning
         * <p>
         * The behavior for relative PathAction (equivalent for example to BezierBy in CocosJS V3 API) is intuitive: the
         * node will add the resulting traversal path to the Node position.
         * For non relative PathActions (for example, the older V3 BezierTo action) is not that clear:
         * + upon a call to <code>initWithNode</code> the Path points will have substracted the current node position and
         *   the first path point will be 0,0 (like in relative actions).
         * + upon a call to <code>update</code> the Path will be solved, and then will have added the node's position
         *   captured during the call to <code>initWithNode</code>.
         *
         * This means, the absolute PathAction will be treated as a relative action, with a modified path.
         *
         * @see cc.action.MoveAction
         */
        var PathAction = (function (_super) {
            __extends(PathAction, _super);
            /**
             * Build a new PathAction
             * @method cc.action.PathAction#constructor
             * @param data {cc.action.PathActionInitializer=}
             */
            function PathAction(data) {
                _super.call(this);
                /**
                 * Node's original x position.
                 * @member cc.action.PathAction#_originalX
                 * @type {number}
                 * @private
                 */
                this._originalX = 0;
                /**
                 * Node's original y position.
                 * @member cc.action.PathAction#_originalX
                 * @type {number}
                 * @private
                 */
                this._originalY = 0;
                /**
                 * Segment to traverse.
                 * @member cc.action.PathAction#_segment
                 * @type {cc.math.path.Segment}
                 * @private
                 */
                this._segment = null;
                /**
                 * Has the path been adjusted.
                 * @member cc.action.PathAction#_pathAdjusted
                 * @type {boolean}
                 * @private
                 */
                this._pathAdjusted = false;
                /**
                 * Is the target node tangentially rotated while traversing the path ?
                 * @member cc.action.PathAction#_adjustTangentialRotation
                 * @type {boolean}
                 * @private
                 */
                this._adjustTangentialRotation = false;
                /**
                 * If the target node is tangentially rotated, will rotation angles be -PI..PI or constrained to always show
                 * the target vertically not flipped ?
                 * @member cc.action.PathAction#_tangentialRotationFullAngle
                 * @type {boolean}
                 * @private
                 */
                this._tangentialRotationFullAngle = false;
                /**
                 * Tangential rotation must know whether the animation sprite frames are left-to-right drawn or right-to-left.
                 * By default left-to-right is assumed, but in case it is not, this variable must be set to false.
                 * @member cc.action.PathAction#_spriteOrientationLR
                 * @type {boolean}
                 * @private
                 */
                this._spriteOrientationLR = true;
                if (typeof data !== "undefined") {
                    this.__createFromInitializer(data);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.PathAction#__createFromInitializer
             * @param data {cc.action.PathActionInitializer}
             * @private
             */
            PathAction.prototype.__createFromInitializer = function (data) {
                _super.prototype.__createFromInitializer.call(this, data);
                // BUGBUG initializer must have serializable data.
                console.log("Path initializer not yet implemented.");
                this._segment = data.segment;
            };
            /**
             * Update target Node's position.
             * {@link cc.action.Action#update}
             * @method cc.action.PathAction#update
             * @override
             * @return {cc.math.Point} new Node position.
             */
            PathAction.prototype.update = function (delta, node) {
                var pos = this._segment.getValueAt(delta);
                var x = pos.x;
                var xx = x;
                var y = pos.y;
                var yy = y;
                x += this._originalX;
                y += this._originalY;
                //if ( this._relativeAction ) {
                if (this._reversed) {
                    var fp = this._segment.getEndingPoint();
                    x -= fp.x;
                    y -= fp.y;
                }
                //}
                node.setPosition(x, y);
                __PathActionUpdateValue.x = x;
                __PathActionUpdateValue.y = y;
                if (node.setFlippedX && this._adjustTangentialRotation) {
                    var delta2 = delta - .001;
                    if (delta2 >= 0) {
                        var pos2 = this._segment.getValueAt(delta2);
                        var angle = Math.PI - Math.atan2(pos2.y - yy, pos2.x - xx);
                        node.rotationAngle = this.__getTangentialAngle(node, xx > pos2.x, angle);
                    }
                }
                return __PathActionUpdateValue;
            };
            /**
             * Calculate a tangential angle based on the current path position.
             * It the node is a sprite, it will also flip the node if necessary based on the property:
             * _tangentialRotationFullAngle and _spriteOrientationLR
             *
             * @method cc.action.PathAction#__getTangentialAngle
             * @param node {cc.node.Node|cc.node.Sprite}
             * @param lefttoright {boolean}
             * @param angle {number}
             * @returns {number}
             * @private
             */
            PathAction.prototype.__getTangentialAngle = function (node, lefttoright, angle) {
                if (!this._tangentialRotationFullAngle) {
                    if (this._spriteOrientationLR) {
                        if (lefttoright) {
                            node.setFlippedX(false);
                        }
                        else {
                            node.setFlippedX(true);
                            angle += Math.PI;
                        }
                    }
                    else {
                        if (lefttoright) {
                            node.setFlippedX(true);
                            angle -= Math.PI;
                        }
                        else {
                            node.setFlippedX(false);
                        }
                    }
                }
                return angle * 180 / Math.PI;
            };
            /**
             * Restart the action.
             * @method cc.action.PathAction#restart
             * @returns {cc.action.PathAction}
             */
            PathAction.prototype.restart = function () {
                _super.prototype.restart.call(this);
                this._pathAdjusted = false;
                return this;
            };
            /**
             * Capture before-application Node's property values.
             * {@link cc.action.Action#solveInitialValues}
             * @method cc.action.PathAction#solveInitialValues
             * @override
             */
            PathAction.prototype.solveInitialValues = function (node) {
                if (!this.isRelative() && !this._pathAdjusted) {
                    this._pathAdjusted = true;
                    // older Cocos2D implelentation expects the following:
                    // current node position will be the first control point of the Segment.
                    // all other segment points will have node's position substracted.
                    var points = this._segment.getControlPoints();
                    this._segment.setDirty(true);
                    this._segment.getLength();
                    // if tangential rotation is enabled, calculate initial rotation angle.
                    if (this._adjustTangentialRotation && node.setFlippedX) {
                        var pos = this._segment.getValueAt(.001);
                        var xx = pos.x;
                        var yy = pos.y;
                        pos = this._segment.getValueAt(0);
                        var angle = Math.PI - Math.atan2(pos.y - yy, pos.x - xx);
                        node.rotationAngle = this.__getTangentialAngle(node, xx > pos.x, angle);
                    }
                }
            };
            /**
             * {@link cc.action.Action#initWithTarget}
             * @method cc.action.PathAction#initWithTarget
             * @override
             */
            PathAction.prototype.initWithTarget = function (node) {
                if (this.isRelative()) {
                    this._originalX = node.x;
                    this._originalY = node.y;
                }
                else {
                    this._originalX = 0;
                    this._originalY = 0;
                    var points = this._segment.getControlPoints();
                    points[0].x = node.x;
                    points[0].y = node.y;
                }
                this.solveInitialValues(node);
            };
            /**
             * {@link cc.action.Action#from}
             * @method cc.action.PathAction#from
             * @override
             */
            PathAction.prototype.from = function (segment) {
                _super.prototype.from.call(this, segment);
                this._segment = segment;
                return this;
            };
            /**
             * {@link cc.action.Action#to}
             * @method cc.action.PathAction#to
             * @override
             */
            PathAction.prototype.to = function (point) {
                return this;
            };
            /**
             * {@link cc.action.Action#__cloneImpl}
             * @method cc.action.PathAction#__cloneImpl
             * @override
             */
            PathAction.prototype.__cloneImpl = function () {
                var copy = new PathAction();
                copy._segment = this._segment.clone();
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Sets tangential rotation and optionally whether the rotation will be of 360 degrees, or the sprite won't be
             * vertically flipped.
             * @method cc.action.PathAction#adjustRotation
             * @param a {boolean} enable tangential rotation.
             * @param fullAngles {boolean=} allow vertically flipping angles or not.
             * @returns {cc.action.PathAction}
             */
            PathAction.prototype.adjustRotation = function (a, fullAngles) {
                this._adjustTangentialRotation = a;
                this._tangentialRotationFullAngle = typeof fullAngles !== "undefined" ? fullAngles : false;
                return this;
            };
            /**
             * By default, tangential rotation assumes left-to-right sprites.
             * @method cc.action.PathAction#setSpriteOrientationIsLeftToRight
             * @param v {boolean} left-to-right or not.
             * @returns {cc.action.PathAction}
             */
            PathAction.prototype.setSpriteOrientationIsLeftToRight = function (v) {
                this._spriteOrientationLR = v;
                return this;
            };
            /**
             * Serialize the action current definition.
             * @method cc.action.PathAction#getInitializer
             * @returns {cc.action.PathActionInitializer}
             */
            PathAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                init.type = "PathAction";
                // bugbug pathAction can not serialize path object.
                return init;
            };
            return PathAction;
        })(Action);
        action.PathAction = PathAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>
"use strict";
var cc;
(function (cc) {
    var action;
    (function (action) {
        var Action = cc.action.Action;
        var Vector = cc.math.Vector;
        var __v0 = new Vector();
        /**
         * @class cc.action.JumpAction
         * @extends cc.action.Action
         * @classdesc
         *
         * This action applies to a node's position by bouncing up to a given altitude.
         */
        var JumpAction = (function (_super) {
            __extends(JumpAction, _super);
            /**
             * JumpAction constructor.
             * @method cc.action.JumpAction#constructor
             * @param data {cc.action.JumpActionInitializer=}
             */
            function JumpAction(data) {
                _super.call(this);
                /**
                 * Node's original x position.
                 * @member cc.action.MoveAction#_originalX
                 * @type {number}
                 * @private
                 */
                this._originalX = 0;
                /**
                 * Node's original y position.
                 * @member cc.action.JumpAction#_originalX
                 * @type {number}
                 * @private
                 */
                this._originalY = 0;
                /**
                 * Action jump height.
                 * @member cc.action.JumpAction#_amplitude
                 * @type {number}
                 * @private
                 */
                this._amplitude = 80;
                /**
                 * Number of jumps to perform.
                 * @member cc.action.JumpAction#_jumps
                 * @type {number}
                 * @private
                 */
                this._jumps = 1;
                this._jumpTo = null;
                if (data) {
                    this.__createFromInitializer(data);
                }
            }
            /**
             * Initialize the action with an initializer object.
             * @method cc.action.JumpAction#__createFromInitializer
             * @param data {cc.action.JumpActionInitializer}
             * @private
             */
            JumpAction.prototype.__createFromInitializer = function (data) {
                _super.prototype.__createFromInitializer.call(this, data);
                if (typeof data !== "undefined") {
                    this._amplitude = data.amplitude;
                    this._jumps = data.jumps;
                    this._jumpTo = new Vector(data.position.x, data.position.y);
                }
            };
            /**
             * Update target Node's position.
             * {@link cc.action.Action#update}
             * @method cc.action.JumpAction#update
             * @override
             * @return {number} Applied transparency value.
             */
            JumpAction.prototype.update = function (delta, node) {
                var frac = delta * this._jumps % 1.0;
                var y = this._amplitude * 4 * frac * (1 - frac);
                y += this._jumpTo.y * delta;
                var x = this._jumpTo.x * delta;
                x += this._originalX;
                y += this._originalY;
                if (this._relativeAction) {
                    if (this._reversed) {
                        x -= this._jumpTo.x;
                        y -= this._jumpTo.y;
                    }
                }
                node.setPosition(x, y);
                return __v0.set(x, y);
            };
            /**
             * Capture before-application Node's property values.
             * {@link cc.action.Action#solveInitialValues}
             * @method cc.action.JumpAction#solveInitialValues
             * @override
             */
            JumpAction.prototype.solveInitialValues = function (node) {
            };
            /**
             * {@link cc.action.Action#initWithTarget}
             * @method cc.action.JumpAction#initWithTarget
             * @override
             */
            JumpAction.prototype.initWithTarget = function (node) {
                this._originalX = node.x;
                this._originalY = node.y;
                if (!this._relativeAction) {
                    this._jumpTo.x -= this._originalX;
                    this._jumpTo.y -= this._originalY;
                }
                this.solveInitialValues(node);
            };
            /**
             * {@link cc.action.Action#__cloneImpl}
             * @method cc.action.JumpAction#__cloneImpl
             * @override
             */
            JumpAction.prototype.__cloneImpl = function () {
                var copy = new JumpAction();
                copy._amplitude = this._amplitude;
                copy._jumps = this._jumps;
                copy._jumpTo = new Vector(this._jumpTo.x, this._jumpTo.y);
                this.__genericCloneProperties(copy);
                return copy;
            };
            /**
             * Serialize the action current definition.
             * @method cc.action.JumpAction#getInitializer
             * @returns {cc.action.JumpActionInitializer}
             */
            JumpAction.prototype.getInitializer = function () {
                var init = _super.prototype.getInitializer.call(this);
                init.type = "JumpAction";
                init.jumps = this._jumps;
                init.amplitude = this._amplitude;
                init.position = {
                    x: this._jumpTo.x,
                    y: this._jumpTo.y
                };
                return init;
            };
            return JumpAction;
        })(Action);
        action.JumpAction = JumpAction;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./Action.ts"/>
/// <reference path="./SequenceAction.ts"/>
/// <reference path="../node/Node.ts"/>
var cc;
(function (cc) {
    var action;
    (function (__action) {
        "use strict";
        var __index = 0;
        /**
         * @class cc.action.ActionInfo
         * @classdesc
         *
         * This class is the information an <code>ActionManager</code> manages and keeps track of an
         * <code>Action</code> and a <code>Target</code>. It is an internal class for ActionManagers
         * <p>
         * You will have no direct interaction with this class.
         *
         */
        var ActionInfo = (function () {
            function ActionInfo(_actionManager, _target, _action) {
                this._actionManager = _actionManager;
                this._target = _target;
                this._action = _action;
                this._chain = null;
            }
            ActionInfo.prototype.__action = function (bh) {
                //bh.__setOwner(this._actionManager);
                if (this._chain !== null) {
                    bh._chainAction = this._chain._action;
                }
                this._action = bh;
                bh.setTag("tag" + __index++);
                return bh;
            };
            ActionInfo.prototype.action = function (action) {
                var a = this.__action(action);
                /**
                 * When calling this method, there's no explicit action duration set, which solves time chaining whith a previous action.
                 * This naive operation, forces chain solve.
                 * BUGBUG refactor.
                 */
                a.setDelay(a._startTime / cc.action.TIMEUNITS);
                return a;
            };
            ActionInfo.prototype.step = function (elapsedTime) {
                this._action.step(elapsedTime, this._target);
            };
            ActionInfo.prototype.isFinished = function () {
                return this._action.isFinished();
            };
            ActionInfo.prototype.pause = function () {
                this._action.pause(this._target);
            };
            ActionInfo.prototype.resume = function () {
                this._action.resume();
            };
            ActionInfo.prototype.setChain = function (actionInfo) {
                this._chain = actionInfo;
            };
            ActionInfo.prototype.stop = function () {
                this._action.stop(this._target);
            };
            return ActionInfo;
        })();
        __action.ActionInfo = ActionInfo;
        /**
         * @class cc.action.ActionManager
         * @classdesc
         *
         * An <code>ActionManager</code> object manages and handles Actions ({@link cc.action.Action}).
         * Each <code>Scene</code> has an instance for managing its nodes Actions, and each <code>Director</code> has
         * another instance for handling Scene <code>Transitions</code> ({@link cc.transition.Transition}).
         * <br>
         * The ActionManager has a virtual timeline fed by Directors or Scenes.
         * On average, no direct interaction with this class will happen.
         * <br>
         * <p>
         *     ActionManager instances have a scheduler implementation as an Action of type: SchedulerQueue
         */
        var ActionManager = (function () {
            /**
             * Create a new ActionManager instance object.
             * The developer will surely never interact directly with this object.
             * The why to work with it is by calling Node Action/Scheduler methods.
             * @member cc.action.ActionManager#constructor
             */
            function ActionManager() {
                /**
                 * Collection of pairs of Node-Action to execute.
                 * @member cc.action.ActionManager#_actionInfos
                 * @type {Array<cc.action.ActionInfo>}
                 * @private
                 */
                this._actionInfos = [];
                /**
                 * In V4 a scheduler is an Action, integrated in the ActionManager.
                 * This is the SchedulerQueue implementation.
                 * @member cc.action.ActionManager#_scheduler
                 * @type {cc.action.SchedulerQueue}
                 * @private
                 */
                this._scheduler = null;
                this._scheduler = new __action.SchedulerQueue();
                this.scheduleActionForNode(null, this._scheduler);
            }
            /**
             * Get the Scheduler instance.
             * @member cc.action.ActionManager#getScheduler
             * @returns {cc.action.SchedulerQueue}
             */
            ActionManager.prototype.getScheduler = function () {
                return this._scheduler;
            };
            /**
             * Associate a target with an action.
             * This method is useful when you pretend to reuse predefined behavior objects.
             * @method cc.action.ActionManager#scheduleActionForNode
             * @param target {cc.node.Node}
             * @param action {cc.action.Action}
             * @returns {ActionInfo}
             */
            ActionManager.prototype.scheduleActionForNode = function (target, action) {
                var tw = new ActionInfo(this, target);
                tw.action(action);
                this._actionInfos.push(tw);
                return this;
            };
            /**
             * PENDING use binary search.
             * Stop an action for a node with the given tag.
             * @param target {cc.node.Node} node with action.
             * @param tag {string} action tag.
             * @returns {cc.action.ActionManager}
             */
            ActionManager.prototype.stopNodeActionByTag = function (target, tag) {
                for (var i = 0; i < this._actionInfos.length; i++) {
                    if (this._actionInfos[i]._target === target && this._actionInfos[i]._action._tag === tag) {
                        this._actionInfos[i].stop();
                    }
                }
                return this;
            };
            /**
             * Stop the Action objects associated with a target object.
             * @param target
             * @returns {cc.action.ActionManager}
             */
            ActionManager.prototype.stopActionsForNode = function (target) {
                for (var i = 0; i < this._actionInfos.length; i++) {
                    if (this._actionInfos[i]._target === target) {
                        this._actionInfos[i].stop();
                    }
                }
                return this;
            };
            /**
             * Helper method to build a new ActionInfo with basic information.
             * @method cc.action.ActionManager#__newActionInfo
             * @returns {cc.action.ActionInfo}
             * @private
             */
            ActionManager.prototype.__newActionInfo = function () {
                var ai = new ActionInfo(this, this._actionInfos[this._actionInfos.length - 1]._target);
                this._actionInfos.push(ai);
                return ai;
            };
            /**
             * Execute all scheduled Actions in this ActionManager.
             * The elapsed time is translated into the desired game time units.
             * @see cc.action.TIMEUNITS
             * @method cc.action.ActionManager#step
             * @param elapsedTime {number} milliseconds.
             */
            ActionManager.prototype.step = function (elapsedTime) {
                //elapsedTime/= cc.action.TIMEUNITS;
                var i;
                var someActionsFinished = false;
                // prevent that added actions from callbacks from messing around.
                var len = this._actionInfos.length;
                for (i = 0; i < len; i++) {
                    this._actionInfos[i].step(elapsedTime);
                    if (this._actionInfos[i].isFinished()) {
                        someActionsFinished = true;
                    }
                }
                if (someActionsFinished) {
                    var actions = [];
                    for (i = 0; i < this._actionInfos.length; i++) {
                        if (!this._actionInfos[i].isFinished()) {
                            actions.push(this._actionInfos[i]);
                        }
                    }
                    this._actionInfos = actions;
                }
            };
            /**
             * Pause all Actions.
             * @method cc.action.ActionManager#pauseAll
             */
            ActionManager.prototype.pauseAll = function () {
                for (var i = 0; i < this._actionInfos.length; i++) {
                    this._actionInfos[i].pause();
                }
            };
            /**
             * Resume all Paused Actions.
             * @method cc.action.ActionManager#resumeAll
             */
            ActionManager.prototype.resumeAll = function () {
                for (var i = 0; i < this._actionInfos.length; i++) {
                    this._actionInfos[i].resume();
                }
            };
            /**
             * Get the number of scheduled actions (in any state).
             * @method cc.action.ActionManager#getNumActions
             * @returns {number} number of actions.
             */
            ActionManager.prototype.getNumActions = function () {
                return this._actionInfos.length;
            };
            /**
             * Get the number of scheduled actions (in any state) for a target.
             * @method cc.action.ActionManager#getNumActionsForTarget
             * @param target {object} target to check for actions.
             * @returns {number} number of actions for the target.
             */
            ActionManager.prototype.getNumActionsForTarget = function (target) {
                var count = 0;
                for (var i = 0; i < this._actionInfos.length; i++) {
                    if (this._actionInfos[i]._target === target) {
                        count++;
                    }
                }
                return count;
            };
            /**
             * Get the number of scheduled actions (in any state).
             * @method cc.action.ActionManager#getNumActionsForNode
             * @param node {object} target to check for actions.
             * @returns {number} number of actions for the Node.
             *
             * @deprecated use getNumActionsForTarget instead.
             */
            ActionManager.prototype.getNumActionsForNode = function (node) {
                return this.getNumActionsForTarget(node);
            };
            return ActionManager;
        })();
        __action.ActionManager = ActionManager;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="./Action.ts"/>
/// <reference path="../node/Node.ts"/>
var cc;
(function (cc) {
    var action;
    (function (action) {
        var Action = cc.action.Action;
        /**
         * @name SchedulerQueueTaskStatus
         * @memberof cc.action
         * @enum
         * @tsenum
         */
        (function (SchedulerQueueTaskStatus) {
            SchedulerQueueTaskStatus[SchedulerQueueTaskStatus["RUNNING"] = 0] = "RUNNING";
            SchedulerQueueTaskStatus[SchedulerQueueTaskStatus["PAUSED"] = 1] = "PAUSED";
            SchedulerQueueTaskStatus[SchedulerQueueTaskStatus["ENDED"] = 2] = "ENDED";
        })(action.SchedulerQueueTaskStatus || (action.SchedulerQueueTaskStatus = {}));
        var SchedulerQueueTaskStatus = action.SchedulerQueueTaskStatus;
        /**
         * @class cc.action.SchedulerQueueTask
         * @classdesc
         *
         * This object represents a Scheduler task.
         * <p>
         * It holds information for an object and a function on that object, as well as time info such as expected
         * repetitions, delay before time count, and the interval between repetitions.
         * <p>
         * It also holds logic for knowing whether the task should be fired or not.
         * A task is fired by calling a function in the context of a target object ie <code>callback.call(target)</code>.
         * <p>
         *     A task without target, will only invoke the callback function.
         */
        var SchedulerQueueTask = (function () {
            /**
             * Build a new SchedulerQueueTask instance.
             * @method cc.action.SchedulerQueueTask#constructor
             */
            function SchedulerQueueTask() {
                /**
                 * wait this milliseconds before account time.
                 * @member cc.action.SchedulerQueueTask#_startTime
                 * @type {function}
                 * @private
                 */
                this._startTime = 0.0;
                /**
                 * Custom interval call for a Task
                 * @member cc.action.SchedulerQueueTask#_interval
                 * @type {number}
                 * @private
                 */
                this._interval = 0.0;
                /**
                 * Time to wait before counting time.
                 * @member cc.action.SchedulerQueueTask#_delay
                 * @type {number}
                 * @private
                 */
                this._delay = 0.0;
                /**
                 * Internal task state
                 * @member cc.action.SchedulerQueueTask#_status
                 * @see {cc.action.SchedulerQueueTaskStatus}
                 * @type {cc.action.SchedulerQueueTaskStatus}
                 * @private
                 */
                this._status = null;
                /**
                 * Time when the last task repetition was executed.
                 * @member cc.action.SchedulerQueueTask#_prevCallbackNotificationTime
                 * @type {number}
                 * @private
                 */
                this._prevCallbackNotificationTime = 0.0;
                /**
                 * Previous task tick time.
                 * @member cc.action.SchedulerQueueTask#_prevTime
                 * @type {number}
                 * @private
                 */
                this._prevTime = 0.0;
                /**
                 * Task priority.
                 * Tasks are sorted by this value. First in execution will be negative values.
                 * @member cc.action.SchedulerQueueTask#_priority
                 * @type {number}
                 * @private
                 */
                this._priority = 0;
            }
            /**
             * Execute a task.
             * The execution takes into account whether the task repeats and the interval repetition.
             * @method cc.action.SchedulerQueueTask#step
             * @param currentTime {number} current scheduler time
             * @returns {boolean} whether the task must de deleted.
             */
            SchedulerQueueTask.prototype.step = function (currentTime) {
                // marked as ended or is paused ?, do not execute and delete.
                if (this._status === 2 /* ENDED */ || this._status === 1 /* PAUSED */) {
                    return;
                }
                if (currentTime >= this._startTime) {
                    // if repeats and interval is not 0 (fire every frame)
                    if (this._repeat > 0 && this._interval !== 0.0) {
                        this.__stepForRepetition(currentTime);
                    }
                    else {
                        // either repeats with 0 interval, or is a single shot task
                        this.__doCallback(currentTime - this._prevCallbackNotificationTime);
                        this._prevCallbackNotificationTime = currentTime;
                        // single shot tasks must be recycled
                        if (!this._repeat) {
                            this.end();
                        }
                    }
                }
            };
            SchedulerQueueTask.prototype.__stepForRepetition = function (currentTime) {
                // identify whether the task has fired in another interval boundary time
                var shotIndex = ((currentTime - this._startTime) / this._interval) | 0;
                var prevshotIndex = ((this._prevTime - this._startTime) / this._interval) | 0;
                if (shotIndex > prevshotIndex && shotIndex > 0) {
                    //this._prevShotIndex= shotIndex;
                    this.__doCallback(currentTime - this._prevCallbackNotificationTime);
                    this._prevCallbackNotificationTime = currentTime;
                }
                this._prevTime = currentTime;
                // so the task is expired ?
                if (currentTime >= this._startTime + this._interval * this._repeat) {
                    // end the task
                    this.end();
                }
            };
            /**
             * Invoke the callback.
             * If target is specified for the task<br>
             *    the callback is invoked like: callback.call( target, elapsedTime, target )<br>
             * else<br>
             *    the callback is invoked like: callback(elapsedTime, target);
             *
             * @method cc.action.SchedulerQueueTask#__doCallback
             * @param elapsedTime {number} time between two consecutive task fires.
             * @private
             */
            SchedulerQueueTask.prototype.__doCallback = function (elapsedTime) {
                if (null === this._target) {
                    this._callback(elapsedTime, this._target);
                }
                else {
                    this.__doCallCallback(elapsedTime);
                }
            };
            SchedulerQueueTask.prototype.__doCallCallback = function (elapsedTime) {
                this._callback.call(this._target, elapsedTime / cc.action.TIMEUNITS, this._target);
            };
            /**
             * Pause the task. If in this state, the task is not fired.
             * @method cc.action.SchedulerQueueTask#pause
             */
            SchedulerQueueTask.prototype.pause = function () {
                this._status = 1 /* PAUSED */;
            };
            /**
             * Resume the current task.
             * @method cc.action.SchedulerQueueTask#resume
             */
            SchedulerQueueTask.prototype.resume = function () {
                this._status = 0 /* RUNNING */;
            };
            /**
             * End the task. Ending turns the task to be elligible for unscheduling and recycling.
             * @method cc.action.SchedulerQueueTask#end
             */
            SchedulerQueueTask.prototype.end = function () {
                this._status = 2 /* ENDED */;
            };
            /**
             * Whether the task is ended.
             * @method cc.action.SchedulerQueueTask#isEnded
             * @returns {boolean}
             */
            SchedulerQueueTask.prototype.isEnded = function () {
                return this._status === 2 /* ENDED */;
            };
            /**
             * Adjust the task time with the Queue time the task is running in.
             * @method cc.action.SchedulerQueueTask#adjustTime
             * @param time {number}
             */
            SchedulerQueueTask.prototype.adjustTime = function (time) {
                this._startTime = time + (this._delay || 0);
                this._prevCallbackNotificationTime = this._startTime;
            };
            return SchedulerQueueTask;
        })();
        action.SchedulerQueueTask = SchedulerQueueTask;
        /**
         * @class cc.action.SchedulerQueueUpdateTask
         * @classdesc
         * @extends SchedulerQueueTask
         *
         * This object represents a scheduler task which calls the update method for a given Object, does not have to be
         * a <code>cc.node.Node</code> object.
         *
         * This task type extends a <code>cc.action.SchedulerQueueTask</code> object and only calls the update method,
         * that is, there must be a target object (mandatory at construction) and the callback parameter is omitted.
         * <p>
         * This object makes calling <code>cc.node.Node#scheduleUpdate</code> and then changing the update method safe.
         *
         */
        var SchedulerQueueUpdateTask = (function (_super) {
            __extends(SchedulerQueueUpdateTask, _super);
            function SchedulerQueueUpdateTask() {
                _super.call(this);
            }
            SchedulerQueueUpdateTask.prototype.__doCallCallback = function (elapsedTime) {
                this._target.update.call(this._target, elapsedTime / cc.action.TIMEUNITS, this._target);
            };
            return SchedulerQueueUpdateTask;
        })(SchedulerQueueTask);
        action.SchedulerQueueUpdateTask = SchedulerQueueUpdateTask;
        /**
         * @class cc.action.SchedulerQueue
         * @extends cc.action.Action
         * @classdesc
         *
         * <p>
         * A scheduler queue manages a collection of Tasks. The tasks are scheduled for single or multi shot execution and
         * are guaranteed to execute at the closest schedule interval time. Internally, a SchedulerQueue is an Action.
         * <p>
         * A task is composed of a target, a function (which is a function the target object has) and some time data.
         * The scheduler will take no action to control whether the supplied function exists for the target object.
         * <p>
         * If a task already exists with the data supplied to the <code>schedule</code> function the task interval will be
         * updated with the new data supplied.
         * <p>
         * Unscheduled actions are removed in the next tick of execution, but actions that are ended are not executed
         * nonetheless.
         * <p>
         * Tasks scheduled from other task execution, are added and executed in the next tick of execution.
         * <p>
         *     Tasks are kept sorted in ascending priority order. A new task added to the scheduler with a priority
         *     equals to any other task will be added after the existing one.
         *
         * @see {cc.action.Action}
         */
        var SchedulerQueue = (function (_super) {
            __extends(SchedulerQueue, _super);
            /**
             * Build a new SchedulerQueue instance.
             * These objects are managed automatically by scenes and should not need to be built manually.
             * @method cc.action.SchedulerQueue#constructor
             */
            function SchedulerQueue() {
                _super.call(this);
                /**
                 * The collection of scheduled tasks.
                 * @type {Array<cc.action.SchedulerQueueTask>}
                 * @member cc.action.SchedulerQueue#_tasks
                 * @private
                 */
                this._tasks = [];
                this._repeatTimes = Number.MAX_VALUE;
                this._duration = 0;
                this._status = 2 /* RUNNING */;
                this._firstExecution = false;
            }
            /**
             * SchedulerQueue repeats forever by default.
             * @method cc.action.SchedulerAction#setRepeatForever
             * @returns {cc.action.SchedulerQueue}
             */
            SchedulerQueue.prototype.setRepeatForever = function () {
                return this;
            };
            /**
             * SchedulerQueue repeats forever by default.
             * @method cc.action.SchedulerAction#setRepeatTimes
             * @param n {number}
             * @returns {cc.action.SchedulerQueue}
             */
            SchedulerQueue.prototype.setRepeatTimes = function (n) {
                return this;
            };
            /**
             * SchedulerQueue have 0 duration.
             * @method cc.action.SchedulerAction#setDuration
             * @param d {number}
             * @returns {cc.action.SchedulerQueue}
             */
            SchedulerQueue.prototype.setDuration = function (d) {
                return this;
            };
            /**
             * SchedulerQueue can't have time info redefined.
             * @method cc.action.SchedulerAction#timeInfo
             * @param delay {number}
             * @param duration {number}
             * @returns {cc.action.SchedulerQueue}
             */
            SchedulerQueue.prototype.timeInfo = function (delay, duration) {
                return this;
            };
            /**
             * Create a schedulable task.
             *
             * @method cc.action.SchedulerQueue.createSchedulerTask
             *
             * @param target {object} this object will be supplied as context to the callback function.
             * @param callback {cc.action.SchedulerTaskCallback}
             * @param interval {number} interval time to elapse between scheduler calls. Can't be less than 16ms. If the
             *   value is less, it will be fired at every frame anyway.
             * @param repeat {number} multi-shot task. Should this event repeat over time ?
             * @param delay {boolean} schedule the task and wait this time before firing the event.
             */
            SchedulerQueue.createSchedulerTask = function (target, callback, interval, repeat, delay) {
                var task = new SchedulerQueueTask();
                task._target = target;
                task._delay = (delay || 0) * cc.action.TIMEUNITS;
                task._callback = callback;
                task._interval = (interval || 0) * cc.action.TIMEUNITS;
                task._repeat = typeof repeat !== "undefined" ? repeat : Number.MAX_VALUE;
                task._status = 0 /* RUNNING */;
                return task;
            };
            /**
             * Create a schedulable task to call the update method on a cc.node.Node instance.
             * This special factory method prevents errors when calling scheduleUpdate and then changing the update function.
             *
             * @param target {object} this object will be supplied as context to the callback function.
             * @param interval {number} interval time to elapse between scheduler calls. Can't be less than 16ms. If the
             *   value is less, it will be fired at every frame anyway.
             * @param repeat {number} multi-shot task. Should this event repeat over time ?
             * @param delay {boolean} schedule the task and wait this time before firing the event.
             */
            SchedulerQueue.createSchedulerUpdateTask = function (target, interval, repeat, delay) {
                var task = new SchedulerQueueUpdateTask();
                task._target = target;
                task._delay = (delay || 0) * cc.action.TIMEUNITS;
                task._interval = (interval || 0) * cc.action.TIMEUNITS;
                task._repeat = typeof repeat !== "undefined" ? repeat : Number.MAX_VALUE;
                task._status = 0 /* RUNNING */;
                return task;
            };
            /**
             * Schedule a task.
             * @method cc.action.SchedulerQueue#scheduleTask
             * @param target {Object}
             * @param callback {SchedulerTaskCallback}
             * @param interval {number}
             * @param repeat {number}
             * @param delay {number}
             */
            SchedulerQueue.prototype.scheduleTask = function (target, callback, interval, repeat, delay) {
                var worktask = null;
                var task = null;
                // large form
                if (arguments.length > 1) {
                    worktask = SchedulerQueue.createSchedulerTask(target, callback, interval, repeat, delay);
                }
                else {
                    worktask = target;
                }
                task = this.__findTask(worktask._target, worktask._callback);
                if (null === task) {
                    worktask.adjustTime(this._currentTime);
                    this.insertTask(worktask);
                }
                else {
                    task._interval = worktask._interval;
                    // in case it is paused.
                    task._status = 0 /* RUNNING */;
                }
            };
            /**
             * Insert a task in priority order.
             * It uses binary search to find out the correct position.
             * If already exists a task with the same priority, the new task will be inserted after the existing ones.
             * @param task {cc.node.SchedulerQueueTask}
             */
            SchedulerQueue.prototype.insertTask = function (task) {
                // trivial case: empty queue or task priority >= last task in queue's priority
                if (this._tasks.length === 0 || task._priority >= this._tasks[this._tasks.length - 1]._priority) {
                    this._tasks.push(task);
                    return;
                }
                // binay insert
                var left = 0;
                var right = this._tasks.length - 1;
                while (left !== right) {
                    var middle = (right + left) >> 1;
                    var midtask = this._tasks[middle];
                    if (task._priority > midtask._priority) {
                        left = middle + 1;
                    }
                    else if (task._priority < midtask._priority) {
                        right = middle - 1;
                    }
                    else {
                        left += 1;
                    }
                }
                // insert at left position.
                this._tasks.splice(left, 0, task);
            };
            /**
             * Find whether a task composed of a given object and callback already exists.
             * @method cc.action.SchedulerQueue#__findTask
             *
             * @param target {object}
             * @param method {cc.action.SchedulerTaskCallback}
             * @returns {*}
             * @private
             */
            SchedulerQueue.prototype.__findTask = function (target, method) {
                for (var i = 0; i < this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target && task._callback === method) {
                        return task;
                    }
                }
                return null;
            };
            /**
             * Pause all tasks for a given target.
             *
             * @method cc.action.SchedulerQueue#pauseTarget
             * @param target {object}
             */
            SchedulerQueue.prototype.pauseTarget = function (target) {
                for (var i = 0; i < this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target) {
                        task.pause();
                    }
                }
            };
            /**
             * Pause a concrete task for a target.
             * @method cc.action.SchedulerQueue#pauseTask
             * @param target {object}
             * @param callback {cc.action.SchedulerTaskCallback}
             */
            SchedulerQueue.prototype.pauseTask = function (target, callback) {
                for (var i = 0; i < this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target && task._callback === callback) {
                        task.pause();
                        return;
                    }
                }
            };
            /**
             * End a task for a target.
             * @param target {object}
             * @param callback {cc.action.SchedulerTaskCallback}
             */
            SchedulerQueue.prototype.endTask = function (target, callback) {
                for (var i = 0; i < this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target && task._callback === callback) {
                        task.end();
                        return;
                    }
                }
            };
            /**
             * Resume a paused task for a target. If it was not paused, nothing happens.
             * @method cc.action.SchedulerQueue#resumeTask
             * @param target {object}
             * @param callback {cc.action.SchedulerTaskCallback}
             */
            SchedulerQueue.prototype.resumeTask = function (target, callback) {
                for (var i = 0; i < this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target && task._callback === callback) {
                        task.resume();
                        return;
                    }
                }
            };
            /**
             * Resume all tasks for a target.
             * @method cc.action.SchedulerQueue#resumeTarget
             * @param target {object}
             */
            SchedulerQueue.prototype.resumeTarget = function (target) {
                for (var i = 0; i < this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target) {
                        task.resume();
                    }
                }
            };
            /**
             * Remove all tasks for a target.
             * @method cc.action.SchedulerQueue#unscheduleAllCallbacks
             * @param target {object}
             */
            SchedulerQueue.prototype.unscheduleAllCallbacks = function (target) {
                for (var i = 0; i < this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target) {
                        task.end();
                    }
                }
            };
            /**
             * Unschedule a concrete task for a target.
             * Unschedule means set it as ended, w/o further execution.
             * @method cc.action.SchedulerQueue#unscheduleCallbackForTarget
             * @param target {object}
             * @param callback {cc.action.SchedulerTaskCallback}
             */
            SchedulerQueue.prototype.unscheduleCallbackForTarget = function (target, callback) {
                //this.pauseTask(target,callback);
                this.endTask(target, callback);
            };
            /**
             * Action update.
             * Traverse the task list and execute events.
             * @method cc.action.SchedulerQueue#update
             * @param normalizedTime {number} normalized action time.
             * @param target {cc.node.Node} node object for which the action executes. For Scheduler queues, no target exists.
             */
            SchedulerQueue.prototype.update = function (normalizedTime, target) {
                // prevent that tasks schedules from a firing scheduled task be checked during this tick.
                var len = this._tasks.length;
                for (var i = 0; i < len; i++) {
                    this._tasks[i].step(this._currentTime);
                }
                for (var i = len - 1; i >= 0; i -= 1) {
                    if (this._tasks[i].isEnded()) {
                        this._tasks.splice(i, 1);
                    }
                }
            };
            return SchedulerQueue;
        })(Action);
        action.SchedulerQueue = SchedulerQueue;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="./MoveAction.ts"/>
/// <reference path="./JumpAction.ts"/>
/// <reference path="./RotateAction.ts"/>
/// <reference path="./PropertyAction.ts"/>
/// <reference path="./AlphaAction.ts"/>
/// <reference path="./TintAction.ts"/>
/// <reference path="./ScaleAction.ts"/>
/// <reference path="./SequenceAction.ts"/>
/// <reference path="./PathAction.ts"/>
var cc;
(function (cc) {
    var action;
    (function (_action) {
        /**
         * This function parses an Action based on an initializer object.
         * Initializer objects are just JSON objects which could got from a call to action.getInitializer().
         * @name ParseAction
         * @memberOf cc.action
         * @param actionDef {cc.action.ActionInitializer}
         * @returns {cc.action.Action}
         */
        function ParseAction(actionDef) {
            if (cc.action[actionDef.type] !== "undefined") {
                var action = new cc.action[actionDef.type]();
                action.__createFromInitializer(actionDef);
                return action;
            }
            console.log("Error, action initializer w/o type.");
            console.log(JSON.stringify(actionDef, null, 2));
            return null;
        }
        _action.ParseAction = ParseAction;
        /**
         * @class cc.action.ActionChainContext
         * @classdesc
         *
         * An ActionChainContext is an object whose only purpose is offer a chainable Action construction API.
         * It keeps track of the last created action and its type. It is a fachade to the last created action for a Node
         * so that calling the chain context methods will forward calls to such Action.
         * It is expected to execute in the context of a cc.node.Node object only.
         * For example, this object allows for an api call like this:
         *
         * <code>
         *     actionSequence().
         *        setRepeatForever().
         *        onEnd( function() {
         *            console.log("end");
         *        }).
         *        actionRotate().
         *            to(180).
         *            setRelative(true).
         *            setDuration(1).
         *        actionScale().
         *            to( {x:0, y:1 }).
         *            setRelative(true).
         *            setDuration(1.5).
         *        actionScale().
         *            to( {x:1, y:1}).
         *            setRelative(true).
         *            setDuration(1.5).
         *        actionTint().
         *            to( {r: -.5, g: -.5, b: -.5 } ).
         *            setRelative(true).
         *            setDuration( 2).
         *    endSequence();
         * </code>
         *
         */
        var ActionChainContext = (function () {
            /**
             * Node for which the chain actions are being performed.
             * @name _target
             * @memberof cc.action.ActionChainContext
             * @type {cc.node.Node}
             */
            /**
             * Create a new ActionChainContext object instance.
             * @method cc.action.ActionChainContext#constructor
             * @constructor
             * @param _target {cc.node.Node}
             */
            function ActionChainContext(_target) {
                this._target = _target;
                /**
                 * When a call to .then() is made, this property keeps track of the previously built action.
                 * @member cc.action.ActionChainContext#_chainAction
                 * @type {cc.action.Action}
                 * @private
                 */
                this._chainAction = null;
                /**
                 * The current action the chain context methods will forward calls to.
                 * @member cc.action.ActionChainContext#_currentAction
                 * @type {cc.action.Action}
                 * @private
                 */
                this._currentAction = null;
                /**
                 * Stack which tracks how many actionSequence calls have been done.
                 * @member cc.action.ActionChainContext#_sequenceStack
                 * @type {Array<cc.action.SequenceAction>}
                 * @private
                 */
                this._sequenceStack = [];
                /**
                 * Last SequenceAction tracked.
                 * @member cc.action.ActionChainContext#_currentSequence
                 * @type {cc.action.SequenceAction}
                 * @private
                 */
                this._currentSequence = null;
            }
            /**
             * Create an Action from a constructor function.
             * If a new SequenceAction is to be build, it will be pushed to the SequenceAction stack.
             * The resulting action will be set as the current chain context Action so that all context calls will be forwarded
             * to this action.
             * @method cc.action.ActionChainContext#__action
             * @param ctor {object} a constructor function
             * @returns {cc.action.ActionChainContext}
             * @private
             */
            ActionChainContext.prototype.__action = function (ctor) {
                this.action(new ctor());
                if (ctor === cc.action.SequenceAction) {
                    this._sequenceStack.push(this._currentAction);
                    this._currentSequence = this._currentAction;
                }
                return this;
            };
            /**
             * Chain a complete action or an action built form an ActionInitializer object.
             * @method cc.action.ActionChainContext#action
             * @param _currentAction {cc.action.Action|cc.action.ActionInitializer}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.action = function (_currentAction) {
                var currentAction;
                if (_currentAction instanceof cc.action.Action) {
                    currentAction = _currentAction;
                }
                else {
                    currentAction = cc.action.ParseAction(_currentAction);
                }
                if (this._currentSequence) {
                    this._currentSequence.addAction(currentAction);
                }
                else {
                    this._target.runAction(currentAction);
                }
                if (this._chainAction) {
                    currentAction._chainAction = this._chainAction;
                    this._chainAction = null;
                }
                this._currentAction = currentAction;
                currentAction.__updateDuration();
                return this;
            };
            /**
             * Start chaining for a new PathAction.
             * @method cc.action.ActionChainContext#actionPath
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.actionPath = function () {
                return this.__action(cc.action.PathAction);
            };
            /**
             * Start chaining for a new MoveAction.
             * @method cc.action.ActionChainContext#actionMove
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.actionMove = function () {
                return this.__action(cc.action.MoveAction);
            };
            /**
             * Start chaining for a new RotateAction.
             * @method cc.action.ActionChainContext#actionRotate
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.actionRotate = function () {
                return this.__action(cc.action.RotateAction);
            };
            /**
             * Start chaining for a new PropertyAction.
             * @method cc.action.ActionChainContext#actionProperty
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.actionProperty = function () {
                return this.__action(cc.action.PropertyAction);
            };
            /**
             * Start chaining for a new AlphaAction.
             * @method cc.action.ActionChainContext#actionAlpha
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.actionAlpha = function () {
                return this.__action(cc.action.AlphaAction);
            };
            /**
             * Start chaining for a new TintAction.
             * @method cc.action.ActionChainContext#actionTint
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.actionTint = function () {
                return this.__action(cc.action.TintAction);
            };
            /**
             * Start chaining for a new ScaleAction.
             * @method cc.action.ActionChainContext#actionScale
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.actionScale = function () {
                return this.__action(cc.action.ScaleAction);
            };
            /**
             * Start chaining for a new SequenceAction.
             * @method cc.action.ActionChainContext#actionSequence
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.actionSequence = function () {
                return this.__action(cc.action.SequenceAction);
            };
            /**
             * End a Sequence Action context.
             * This will pop the latest Sequence from the stack.
             * If the stack gets empty, actions will be added in the context of the Target node, and not the sequence.
             * @method cc.action.ActionChainContext#endSequence
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.endSequence = function () {
                if (this._sequenceStack.length) {
                    this._sequenceStack.pop();
                    if (this._sequenceStack.length) {
                        this._currentSequence = this._sequenceStack[this._sequenceStack.length - 1];
                    }
                    else {
                        this._currentSequence = null;
                    }
                    this._currentAction = this._currentSequence;
                }
                return this;
            };
            /**
             * Set action 'from' value for the current action.
             * @method cc.action.ActionChainContext#from
             * @param obj {object} the value to set for 'from' action property.
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.from = function (obj) {
                if (this._currentAction) {
                    this._currentAction.from(obj);
                }
                return this;
            };
            /**
             * Set action 'to' value for the current action.
             * @method cc.action.ActionChainContext#from
             * @param obj {object} the value to set for 'from' action property.
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.to = function (obj) {
                if (this._currentAction) {
                    this._currentAction.to(obj);
                }
                return this;
            };
            /**
             * Set action interpolator value for the current action.
             * @method cc.action.ActionChainContext#setInterpolator
             * @param i {cc.action.TimeInterpolator} a interpolator (easing function).
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.setInterpolator = function (i) {
                if (this._currentAction) {
                    this._currentAction.setInterpolator(i);
                }
                return this;
            };
            /**
             * Set action as relative.
             * @method cc.action.ActionChainContext#setRelative
             * @param b {boolean}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.setRelative = function (b) {
                if (this._currentAction) {
                    this._currentAction.setRelative(b);
                }
                return this;
            };
            /**
             * Set action duration.
             * @method cc.action.ActionChainContext#setDuration
             * @param d {number}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.setDuration = function (d) {
                if (this._currentAction) {
                    this._currentAction.setDuration(d);
                }
                return this;
            };
            /**
             * Set action repetition forever.
             * @method cc.action.ActionChainContext#setRepeatForever
             * @param obj {cc.action.RepeatTimesOptions=} some repetition attributes.
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.setRepeatForever = function (obj) {
                if (this._currentAction) {
                    this._currentAction.setRepeatForever(obj);
                }
                return this;
            };
            /**
             * Set action repetition times.
             * @method cc.action.ActionChainContext#setRepeatTimes
             * @param n {number} repetition count
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.setRepeatTimes = function (n) {
                if (this._currentAction) {
                    this._currentAction.setRepeatTimes(n);
                }
                return this;
            };
            /**
             * Chain two actions. After a call to then, any of the actionXXX methods should be called. The newly
             * created action will be chained with the current one. Chain means that will start when the preivous ends.
             * @method cc.action.ActionChainContext#then
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.then = function () {
                this._chainAction = this._currentAction;
                return this;
            };
            /**
             * Set duration and interpolator into in one call.
             * @method cc.action.ActionChainContext#timeInfo
             * @param delay {number} delay before application
             * @param duration {number} action duration in time units.
             * @param interpolator {cc.action.TimeInterpolator=} optional interpolator
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.timeInfo = function (delay, duration, interpolator) {
                this._currentAction.timeInfo(delay, duration, interpolator);
                return this;
            };
            /**
             * Set action onEnd callback.
             * @method cc.action.ActionChainContext#onEnd
             * @param f {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.onEnd = function (f) {
                if (this._currentAction) {
                    this._currentAction.onEnd(f);
                }
                return this;
            };
            /**
             * Set action onStart callback.
             * @method cc.action.ActionChainContext#onStart
             * @param f {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.onStart = function (f) {
                if (this._currentAction) {
                    this._currentAction.onStart(f);
                }
                return this;
            };
            /**
             * Set action onRepeat callback.
             * @method cc.action.ActionChainContext#onRepeat
             * @param f {cc.action.ActionCallbackRepeatCallback}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.onRepeat = function (f) {
                if (this._currentAction) {
                    this._currentAction.onRepeat(f);
                }
                return this;
            };
            /**
             * Set action onPause callback.
             * @method cc.action.ActionChainContext#onPause
             * @param f {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.onPause = function (f) {
                if (this._currentAction) {
                    this._currentAction.onPause(f);
                }
                return this;
            };
            /**
             * Set action onResume callback.
             * @method cc.action.ActionChainContext#onResume
             * @param f {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.onResume = function (f) {
                if (this._currentAction) {
                    this._currentAction.onResume(f);
                }
                return this;
            };
            /**
             * Set action onApply callback.
             * @method cc.action.ActionChainContext#onApply
             * @param f {cc.action.ActionCallbackApplicationCallback}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.onApply = function (f) {
                if (this._currentAction) {
                    this._currentAction.onApply(f);
                }
                return this;
            };
            /**
             * If the current action is a sequence, set the Sequence as sequential or spawn.
             * @method cc.action.ActionChainContext#setSequential
             * @param b {boolean}
             * @returns {cc.action.ActionChainContext}
             */
            ActionChainContext.prototype.setSequential = function (b) {
                if (this._currentAction.setSequential) {
                    this._currentAction.setSequential(b);
                }
                return this;
            };
            return ActionChainContext;
        })();
        _action.ActionChainContext = ActionChainContext;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
var cc;
(function (cc) {
    var Performance;
    (function (_Performance) {
        function __startPerformance() {
            return performance.now();
        }
        function __startTime() {
            return new Date().getTime();
        }
        var _units = typeof performance !== "undefined" ? 1000 : 1;
        var __start = typeof performance !== "undefined" ? __startPerformance : __startTime;
        var MEASURE_CACHE_SIZE = 500;
        var Measure = (function () {
            function Measure(name) {
                this._prevValues = [];
                this._accumulatedValue = 0;
                this._name = null;
                this._value = 0;
                this._start = 0;
                this._name = name;
            }
            Measure.prototype.increment = function () {
                this._value++;
            };
            Measure.prototype.clear = function () {
                this._start = 0;
                this._value = 0;
                this._accumulatedValue = 0;
            };
            Measure.prototype.clearCache = function () {
                this._prevValues = [];
            };
            Measure.prototype.setValue = function (v) {
                this._value = v;
                this._accumulatedValue += v;
            };
            Measure.prototype.getValue = function () {
                return this._value;
            };
            Measure.prototype.start = function () {
                this._start = __start();
            };
            Measure.prototype.end = function () {
                this._value += __start() - this._start;
            };
            Measure.prototype.save = function () {
                if (this._prevValues.length > MEASURE_CACHE_SIZE) {
                    this._prevValues.shift();
                }
                this._prevValues.push(this.getValue());
            };
            return Measure;
        })();
        _Performance.Measure = Measure;
        var TimeMeasure = (function (_super) {
            __extends(TimeMeasure, _super);
            function TimeMeasure(name) {
                _super.call(this, name);
            }
            TimeMeasure.prototype.getValue = function () {
                return this._value / _units;
            };
            return TimeMeasure;
        })(Measure);
        _Performance.TimeMeasure = TimeMeasure;
        var Performance = (function () {
            function Performance() {
                this._measures = {
                    draws: new Measure("draws"),
                    loop: new TimeMeasure("loop")
                };
            }
            Performance.prototype.start = function (id) {
                this._measures[id].start();
            };
            Performance.prototype.end = function (id) {
                this._measures[id].end();
            };
            Performance.prototype.increment = function (id) {
                this._measures[id].increment();
            };
            Performance.prototype.setValue = function (id, v) {
                this._measures[id].setValue(v);
            };
            Performance.prototype.clear = function () {
                for (var id in this._measures) {
                    if (this._measures.hasOwnProperty(id)) {
                        this._measures[id].clear();
                    }
                }
            };
            Performance.prototype.clearCache = function () {
                for (var id in this._measures) {
                    if (this._measures.hasOwnProperty(id)) {
                        this._measures[id].clearCache();
                    }
                }
            };
            Performance.prototype.save = function () {
                for (var id in this._measures) {
                    if (this._measures.hasOwnProperty(id)) {
                        this._measures[id].save();
                    }
                }
            };
            return Performance;
        })();
        _Performance.Performance = Performance;
    })(Performance = cc.Performance || (cc.Performance = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../action/Action.ts"/>
/// <reference path="../action/SchedulerQueue.ts"/>
/// <reference path="./Node.ts"/>
/// <reference path="../action/ActionManager.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../input/InputManager.ts"/>
var cc;
(function (cc) {
    var node;
    (function (_node) {
        "use strict";
        var Node = cc.node.Node;
        var ActionManager = cc.action.ActionManager;
        /**
         * @class cc.node.Scene
         * @extends cc.node.Node
         * @classdesc
         *
         * Scenes are specialized Nodes useful for separating in-game functional pieces.
         * For example, a Scene can be the game menu, another scene can be the game and another scene the results window.
         *
         * <li>At any given moment, only one scene can be running.
         *
         * <li>A Scene can not contain other Scenes, or any Director instance.
         * <li>The size of the scene will by default be the same as the Director, and hence, equal to the Canvas size.
         *
         * <li>A Scene manages all the Actions of all the Node's it contains.
         * <li>A scene manages chronometers/events independently to any other scene.
         *
         * <li>Every Node that hierarchically belongs to this Scene will have a reference to the Scene. This reference will be
         * set when the <code>Director</code> the Scene is running in calls <code>onEnter</code> on the scene.
         *
         * <li>There no limitation on how many Scenes can be in a game.
         *
         * <li>Scenes have no parent Node. This means that a call to <code>enumerateChildren</code> will take a Scene as the
         * root search point.
         * <li>An Scene logical parent is a Director object. Scenes have a Director instance in _parent variable.
         *
         * <p>
         *     Scenes are the source point for input routing to the nodes it contains. It contains two members:
         *     <ul>
         *      <li>_sceneGraphPriorityTree: for nodes sorted in scene graph priority. This priority is the natural
         *       way nodes are organized.
         *      <li>_priorityTree: artificial priority were nodes are sorted by value. lower value means higher priority.
         *     </ul>
         *     Each time a scene is set as running by a director, the InputSystem sets that scene as input target.
         *
         * <p>
         *     One important thing about scenes is that they contain an ActionManager which at the same time, manages a
         *     Scheduler.
         *     Scheduling actions or tasks for a Node is as straighforward as calling <code>runAction</code> or
         *     <code>schedule|scheduleUpdate</code>.
         *     These methods expect a time parameter for scheduling, which by default is in seconds. The engine will internally
         *     treat all time measures in milliseconds (makes sense since the animation loop is scheduled every 16ms approx),
         *     but the developer can instrument to set time measurements in seconds (default) by calling
         *     <code>cc.action.setTimeReferenceInSeconds</code> or milliseconds <code>setTimeReferenceInMillis</code>.
         *     Callback notifications with a time parameter will be in the developer desired time units.
         *
         */
        var Scene = (function (_super) {
            __extends(Scene, _super);
            /**
             * Create a new Scene instance.
             * @method cc.node.Scene#constructor
             */
            function Scene() {
                _super.call(this);
                /**
                 * Node's ActionManager.
                 * @member cc.node.Scene#_actionManager
                 * @type {cc.action.ActionManager}
                 * @private
                 */
                this._actionManager = new ActionManager();
                /**
                 * Callback reference for onEnter event.
                 * @member cc.node.Scene#_onEnter
                 * @type {cc.node.CallbackSceneTransition}
                 * @private
                 */
                this._onEnter = null;
                /**
                 * Callback reference for onExit event.
                 * @member cc.node.Scene#_onExit
                 * @type {cc.node.CallbackSceneTransition}
                 * @private
                 */
                this._onExit = null;
                /**
                 * Callback reference for enter transition end event.
                 * @member cc.node.Scene#_onEnterTransitionDidFinish
                 * @type {cc.node.CallbackSceneTransition}
                 * @private
                 */
                this._onEnterTransitionDidFinish = null;
                /**
                 * Callback reference for exit transition start event.
                 * @member cc.node.Scene#_onExitTransitionDidStart
                 * @type {cc.node.CallbackSceneTransition}
                 * @private
                 */
                this._onExitTransitionDidStart = null;
                this._scheduler = null;
                this._sceneGraphPriorityTree = null;
                this._priorityTree = null;
                this._scheduler = this._actionManager.getScheduler();
                this._sceneGraphPriorityTree = new cc.input.SceneGraphInputTreeNode(this);
                this._priorityTree = [];
                this.setGlobalAlpha(true);
                this.setPositionAnchor(0, 0);
            }
            Scene.prototype.enableEvents = function (enable) {
                _super.prototype.enableEvents.call(this, enable);
                this.enableEventsForNode(this);
                return this;
            };
            Scene.prototype.enablePriorityEvents = function (enable, priority) {
                _super.prototype.enablePriorityEvents.call(this, enable, priority);
                this.enableEventsForNode(this);
                return this;
            };
            /**
             * Enable events in scene-graph order for a node.
             * If the node is not attached to this scene, nothing will happen.
             * @method cc.node.Scene#enableEvents
             * @param node {cc.node.Node}
             */
            Scene.prototype.enableEventsForNode = function (node) {
                this._sceneGraphPriorityTree.insert(node.getPathToScene());
                return this;
            };
            Scene.prototype.getPathToScene = function () {
                return [this];
            };
            /**
             * Enable events in priority order for a node.
             * The priority is something external to the Node,
             * @method cc.node.Scene#enablePriorityEvents
             * @param node {cc.node.Node}
             */
            Scene.prototype.enablePriorityEventsForNode = function (node) {
                var pin;
                var pinIndex = -1;
                for (var i = 0; i < this._priorityTree.length; i++) {
                    if (this._priorityTree[i].node === node) {
                        pinIndex = i;
                        break;
                    }
                }
                if (pinIndex !== -1) {
                    pin = this._priorityTree[pinIndex];
                    if (pin.priority === node.getInputPriority()) {
                        // node added with the same priority
                        return;
                    }
                }
                else {
                    // node does not exist. create descriptor, and insert.
                    this._priorityTree.push(new cc.input.PriorityInputNode(node, node.getInputPriority()));
                }
                this._priorityTree.sort(function (n0, n1) {
                    if (n0.priority < n1.priority) {
                        return -1;
                    }
                    else if (n0.priority > n1.priority) {
                        return 1;
                    }
                    return 0;
                });
                return this;
            };
            Scene.prototype.findNodeAtScreenPoint = function (p, callback) {
                var pp = new cc.math.Vector();
                pp.set(p.x, p.y);
                for (var i = 0; i < this._priorityTree.length; i++) {
                    var node = this._priorityTree[i].node;
                    p.set(pp.x, pp.y);
                    if (node.isScreenPointInNode(p)) {
                        if (callback) {
                            if (!callback(node)) {
                                return node;
                            }
                        }
                        else {
                            return node;
                        }
                    }
                }
                // now, for scene-graph priority.
                p.set(pp.x, pp.y);
                return this._sceneGraphPriorityTree.findNodeAtScreenPoint(p, callback);
            };
            /**
             * Increment scene's timeline.
             * This time is local to this scene, and independent to other Scene's time.
             * This local time is handled by the Scene's ActionManager, which translate the delta milliseconds into
             * the desired game time measurement unit, which are seconds by default.
             * @method cc.node.Scene#step
             * @param delta {number} elapsed time in milliseconds.
             * @param ctx {cc.render.RenderingContext} where node's will render.
             */
            Scene.prototype.step = function (delta, ctx) {
                // allow for this scene's nodes actions to run.
                this._actionManager.step(delta);
                // draw scene and its children.
                this.visit(ctx);
            };
            /**
             * Register Scene onEnter callback.
             * @method cc.node.Scene#onEnter
             * @param c {cc.node.CallbackSceneTransition}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.onEnter = function (c) {
                this._onEnter = c;
                return this;
            };
            /**
             * Register Scene onExit callback.
             * @method cc.node.Scene#onExit
             * @param c {cc.node.CallbackSceneTransition}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.onExit = function (c) {
                this._onExit = c;
                return this;
            };
            /**
             * Register onExitTransitionStart callback. Called when scenes are switched by Transition objects.
             * @method cc.node.Scene#onExitTransitionDidStart
             * @param c {cc.node.CallbackSceneTransition}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.onExitTransitionDidStart = function (c) {
                this._onExitTransitionDidStart = c;
                return this;
            };
            /**
             * Register onEnterTransitionFinish callback. Called when scenes are switched by Transition objects.
             * @method cc.node.Scene#onEnterTransitionDidFinish
             * @param c {cc.node.CallbackSceneTransition}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.onEnterTransitionDidFinish = function (c) {
                this._onEnterTransitionDidFinish = c;
                return this;
            };
            /**
             * Notifiy event registered callback.
             * @method cc.node.Scene#callOnEnterTransitionDidFinish
             */
            Scene.prototype.callOnEnterTransitionDidFinish = function () {
                if (this._onEnterTransitionDidFinish) {
                    this._onEnterTransitionDidFinish(this);
                }
            };
            /**
             * Notifiy event registered callback.
             * @method cc.node.Scene#callOnExitTransitionDidStart
             */
            Scene.prototype.callOnExitTransitionDidStart = function () {
                if (this._onExitTransitionDidStart) {
                    this._onExitTransitionDidStart(this);
                }
            };
            /**
             * Notifiy event registered callback.
             *
             *
             * @method cc.node.Scene#callOnEnter
             */
            Scene.prototype.callOnEnter = function () {
                var scene = this;
                // recursively set scene for nodes.
                this.enumerateChildren("//*", function (node) {
                    node.setScene(scene);
                });
                if (this._onEnter) {
                    this._onEnter(this);
                }
                this.resetScene();
            };
            /**
             * Notify event registered callback.
             * @method cc.node.Scene#callOnExit
             */
            Scene.prototype.callOnExit = function () {
                if (this._onExit) {
                    this._onExit(this);
                }
            };
            /**
             * Overriden Node's method for set scene reference.
             * A scene does not need a scene reference.
             * @method cc.node.Scene#setScene
             * @param scene {cc.node.Scene}
             */
            Scene.prototype.setScene = function (scene) {
                // assert scene===this
            };
            /**
             * Overriden Node's method for setting a parent.
             * Scenes have no parent reference so this method does nothing.
             * @method cc.node.Scene#setParent
             * @param node {cc.node.Node}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.setParent = function (node) {
                return this;
            };
            /**
             * Reset this scene's properties.
             * Needed if the scene is managed by a Transition since position/scale/rotate can be changed.
             * @method cc.node.Scene#resetScene
             * @returns {cc.node.Scene}
             */
            Scene.prototype.resetScene = function () {
                this.alpha = 1;
                this.setScale(1, 1);
                this.setPositionAnchor(0, 0);
                this.setTransformationAnchor(0.5, 0.5);
                this.__setFlag(8 /* VISIBLE */);
                return this;
            };
            /**
             * Run an Action for a Node.
             * @method cc.node.Scene#scheduleActionForNode
             * @param node {cc.node.Node}
             * @param action {cc.action.Action}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.scheduleActionForNode = function (node, action) {
                this._actionManager.scheduleActionForNode(node, action);
                return this;
            };
            /**
             * Clear all this scene contents.
             * + all children are removed.
             */
            Scene.prototype.clear = function () {
                this.removeAllChildren();
            };
            /**
             * Schedule an action to run.
             * By the time an action is meant to be scheduled for running in a Node, there may not yet be a
             * <code>Director</code> or <code>Scene</code>. This method saves locally the actions which will be
             * scheduled in a scene's <code>ActionManager</code> later.
             * @method cc.node.Node#runAction
             * @param action {cc.action.Action}
             * @returns {cc.node.Node}
             */
            Scene.prototype.runAction = function (action) {
                this.scheduleActionForNode(this, action);
                return this;
            };
            Scene.prototype.stopNodeActionByTag = function (node, tag) {
                this._actionManager.stopNodeActionByTag(node, tag);
                return this;
            };
            Scene.prototype.stopActionsForNode = function (node) {
                this._actionManager.stopActionsForNode(node);
            };
            Scene.prototype.getScheduler = function () {
                return this._scheduler;
            };
            Scene.prototype.getScene = function () {
                return this;
            };
            /////////////// SCHEDULER METHODS BEGIN ////////////////
            Scene.prototype.scheduleTask = function (task) {
                this._scheduler.scheduleTask(task);
            };
            Scene.prototype.scheduleUpdateWithPriority = function (priority) {
                var task = cc.action.SchedulerQueue.createSchedulerUpdateTask(this, 0, Number.MAX_VALUE, 0);
                task._priority = priority;
                this._scheduler.scheduleTask(task);
            };
            /**
             * Schedule a task to per frame call update for this node.
             *
             * @method cc.node.Node#scheduleUpdate
             * @deprecated
             */
            Scene.prototype.scheduleUpdate = function () {
                var task = cc.action.SchedulerQueue.createSchedulerUpdateTask(this, 0, Number.MAX_VALUE, 0);
                this._scheduler.scheduleTask(task);
            };
            Scene.prototype.unscheduleUpate = function () {
                this._scheduler.unscheduleCallbackForTarget(this, this.update);
            };
            /**
             * Schedule a task for the node.
             * This node will be passed as target to the specified callback function.
             * If already exist a task in the scheduler for the same pair of node and callback, the task will be updated
             * with the new data.
             * @method cc.node.Node#schedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to invoke
             * @param interval {number} repeat interval time. the task will be fired every this amount of milliseconds.
             * @param repeat {number=} number of repetitions. if not set, infinite will be used.
             * @param delay {number=} wait this millis before firing the task.
             */
            Scene.prototype.schedule = function (callback_fn, interval, repeat, delay) {
                var task = cc.action.SchedulerQueue.createSchedulerTask(this, callback_fn, interval, repeat, delay);
                this._scheduler.scheduleTask(task);
            };
            /**
             * Schedule a single shot task. Will fired only once.
             * @method cc.node.Node#scheduleOnce
             * @param callback_fn {cc.action.SchedulerTaskCallback} scheduler callback.
             * @param delay {number} milliseconds to wait before firing the task.
             * @returns {cc.node.Node}
             */
            Scene.prototype.scheduleOnce = function (callback_fn, delay) {
                this.schedule(callback_fn, 0.0, 0, delay);
            };
            /**
             * Unschedule a task for the node.
             * @method cc.node.Node#unschedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to unschedule.
             */
            Scene.prototype.unschedule = function (callback_fn) {
                if (!callback_fn)
                    return;
                this._scheduler.unscheduleCallbackForTarget(this, callback_fn);
            };
            Scene.prototype.unscheduleCallbackForTarget = function (target, task) {
                this._scheduler.unscheduleCallbackForTarget(target, task);
            };
            /**
             * Unschedule all tasks for the node.
             * @method cc.node.Node#unscheduleAllCallbacks
             */
            Scene.prototype.unscheduleAllCallbacks = function (target) {
                this._scheduler.unscheduleAllCallbacks(target ? target : this);
            };
            /**
             * Resumes all scheduled tasks and actions.
             * This method is called internally by onEnter
             * @method cc.node.Node#resume
             */
            Scene.prototype.resume = function () {
                this._scheduler.resumeTarget(this);
                // PENDING: implement
                //this.actionManager && this.actionManager.resumeTarget(this);
                //cc.eventManager.resumeTarget(this);
            };
            /**
             * Pauses all scheduled selectors and actions.
             * This method is called internally by onExit.
             * @method cc.node.Node#pause
             *
             */
            Scene.prototype.pause = function () {
                this._scheduler.pauseTarget(this);
                // PENDING: implement
                //this.actionManager && this.actionManager.pauseTarget(this);
                //cc.eventManager.pauseTarget(this);
            };
            Scene.prototype.pauseTarget = function (target) {
                this._scheduler.pauseTarget(target);
            };
            Scene.prototype.resumeTarget = function (target) {
                this._scheduler.resumeTarget(target);
            };
            return Scene;
        })(Node);
        _node.Scene = Scene;
    })(node = cc.node || (cc.node = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./Node.ts"/>
/// <reference path="./Scene.ts"/>
/// <reference path="../math/Dimension.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../transition/Transition.ts"/>
/// <reference path="../action/ActionManager.ts"/>
/// <reference path="../action/SchedulerQueue.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../util/Debug.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../render/Renderer.ts"/>
/// <reference path="../render/ScaleManager.ts"/>
/// <reference path="../input/InputManager.ts"/>
/// <reference path="../input/MouseInputManager.ts"/>
/// <reference path="../render/ScaleManager.ts"/>
var cc;
(function (cc) {
    var node;
    (function (node) {
        "use strict";
        var Node = cc.node.Node;
        var Scene = cc.node.Scene;
        var Debug = cc.Debug;
        var Locale = cc.locale;
        var ActionManager = cc.action.ActionManager;
        /**
         * Enumeration of Director status.
         *
         * @tsenum cc.node.DirectorStatus
         */
        (function (DirectorStatus) {
            DirectorStatus[DirectorStatus["CREATED"] = 0] = "CREATED";
            DirectorStatus[DirectorStatus["RUNNING"] = 1] = "RUNNING";
            DirectorStatus[DirectorStatus["PAUSED"] = 2] = "PAUSED";
            DirectorStatus[DirectorStatus["STOPPED"] = 3] = "STOPPED";
        })(node.DirectorStatus || (node.DirectorStatus = {}));
        var DirectorStatus = node.DirectorStatus;
        var __window = window;
        /**
         * @class cc.node.Director
         * @extends cc.node.Node
         * @classdesc
         *
         * A Director object is the root node of a game.
         * <li>As the primary component, it is a glue which puts together platform features such as Input routing or Texture
         * and image caching, and Scenes and game logic.
         * <li>Each Director has a renderer, which acts on its own Canvas Object. Since V4, Cocos2D HTML5 allows for multiple
         * <li>Director instances and each one can have a different renderer type.
         *
         * <li>Every Director present in a Document, will share a common Texture and Image cache for better resource management.
         *
         * <li>A Director object runs Scenes. The process of switching scenes is handled using a <code>Transition</code> object.
         * <li>The preferred way of building scenes is by calling <code>director.createScene() -> Scene</code>
         *
         * @see{cc.node.Scene}
         * @see{cc.node.Transition}
         *
         */
        var Director = (function (_super) {
            __extends(Director, _super);
            /**
             * Create a new Director instance.
             * @method cc.node.Director#constructor
             */
            function Director() {
                _super.call(this);
                /**
                 * Director status
                 * @member cc.node.Director#_status
                 * @type {number}
                 * @private
                 */
                this._status = 0 /* CREATED */;
                /**
                 * Director's renderer.
                 * @member cc.node.Director#_renderer
                 * @type {cc.render.RenderingContext}
                 * @private
                 */
                this._renderer = null;
                /**
                 * Scenes available in this Director.
                 * @member cc.node.Director#_scenes
                 * @type {Array}
                 * @private
                 */
                this._scenes = [];
                /**
                 * requestAnimationFrame shim id.
                 * @member cc.node.Director#_animFrame
                 * @type {number}
                 * @private
                 */
                this._animFrame = null;
                /**
                 * Ideal milliseconds between two frames.
                 * @member cc.node.Director#_animationInterval
                 * @type {number}
                 * @private
                 */
                this._animationInterval = 1000 / 60;
                /**
                 * Currently running Scene.
                 * @member cc.node.Director#_currentScene
                 * @type {cc.node.Scene}
                 * @private
                 */
                this._currentScene = null;
                /**
                 * If <code>runAction</code> is called with a Transition, _exitingScene will be the currently moving out scene.
                 * For internal usage only.
                 * @member cc.node.Director#_exitingScene
                 * @type {cc.node.Scene}
                 * @private
                 */
                this._exitingScene = null;
                /**
                 * Scenes action manager that manages Transition objects.
                 * @member cc.node.Director#_scenesActionManager
                 * @type {cc.action.ActionManager}
                 * @private
                 * @see {cc.transition.Transition}
                 */
                this._scenesActionManager = null;
                /**
                 * Timer management. This value is the previous time the director run at.
                 * @member cc.node.Director#_prevPerf
                 * @type {number}
                 * @private
                 */
                this._prevPerf = 0;
                /**
                 * General input management system
                 * @member cc.node.Director#_inputManager
                 * @type {cc.input.InputManager}
                 * @private
                 */
                this._inputManager = null;
                this._scheduler = null;
                this._scenesActionManager = new ActionManager();
                this._scheduler = this._scenesActionManager.getScheduler();
                this._inputManager = new cc.input.InputManager();
                // BUGBUG deprecated
                cc.director = this;
            }
            /**
             * Get the current renderer.
             * @method cc.node.Director#getRenderer
             * @returns {Renderer}
             */
            Director.prototype.getRenderer = function () {
                return this._renderer;
            };
            /**
             * Set the Director's renderer.
             * It will also enable input on the renderer surface.
             * @method cc.node.Director#setRenderingContext
             * @param renderer {cc.render.Renderer}
             * @returns {cc.node.Director}
             */
            Director.prototype.setRenderer = function (renderer) {
                this._renderer = renderer;
                this._contentSize.set(renderer.getContentSize());
                this._modelViewMatrix = this._renderer.getScaleContentMatrix();
                this._worldModelViewMatrix = this._renderer.getScaleContentMatrix();
                this._inputManager.enable(renderer._surface);
                var me = this;
                renderer.onContentScaled(function (unitsWidth, unitsHeight, preferredUnitsWidth, preferredUnitsHeight, canvasWidth, canvasHeight, sceneHint) {
                    me.setContentSize(canvasWidth, canvasHeight);
                    if (sceneHint & 16 /* CENTER */) {
                        me._currentScene.setContentSize(unitsWidth, unitsHeight);
                        me._currentScene.setPosition((preferredUnitsWidth - unitsWidth) / 2, (preferredUnitsHeight - unitsHeight) / 2);
                    }
                    else if (sceneHint & 32 /* STRETCH */) {
                        me._currentScene.setContentSize(preferredUnitsWidth, preferredUnitsHeight);
                        me._currentScene.setPosition(0, 0);
                    }
                    else {
                        var x = 0;
                        var y = 0;
                        if (sceneHint & 8 /* RIGHT */) {
                            x = preferredUnitsWidth - unitsWidth;
                        }
                        if ((cc.render.RENDER_ORIGIN === cc.render.ORIGIN_TOP && sceneHint & 4 /* BOTTOM */) || (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM && sceneHint & 1 /* TOP */)) {
                            y = preferredUnitsHeight - unitsHeight;
                        }
                        me._currentScene.setContentSize(unitsWidth, unitsHeight);
                        me._currentScene.setPosition(x, y);
                    }
                });
                return this;
            };
            Director.prototype.__setTransform = function () {
                return this;
            };
            Director.prototype.__setLocalTransform = function () {
            };
            Director.prototype.__setWorldTransform = function () {
            };
            /**
             * Get the system input manager object.
             * @method cc.node.Director#getInputManager
             * @returns {cc.input.InputManager}
             */
            Director.prototype.getInputManager = function () {
                return this._inputManager;
            };
            /**
             * Pause the Director.
             * The animation loop is stopped.
             * @method cc.node.Director#pause
             */
            Director.prototype.pause = function () {
                if (this._status === 2 /* PAUSED */) {
                    return;
                }
                this.stopAnimation();
                this._status = 2 /* PAUSED */;
            };
            /**
             * Resume a paused director.
             * The animation loop restarts.
             * @method cc.node.Director#resume
             */
            Director.prototype.resume = function () {
                if (this._status !== 2 /* PAUSED */) {
                    return;
                }
                this.startAnimation();
            };
            /**
             * Make the renderer visible in the document.
             * @method cc.node.Director#addToDOM
             */
            Director.prototype.addToDOM = function () {
                this._renderer.addToDOM();
            };
            Director.prototype.__sceneExitedDirector = function (scene) {
                if (scene) {
                    scene.callOnExit();
                    scene.cleanup();
                    scene._parent = null;
                }
            };
            /**
             * Run a Scene.
             * Optionally use a transition for switching between scenes.
             * @method cc.node.Director#runScene
             * @param scene {cc.node.Scene}
             * @param transition {cc.transition.Transition}
             */
            Director.prototype.runScene = function (scene_or_transition, transition) {
                var _this = this;
                var scene;
                if (scene_or_transition instanceof Scene) {
                    scene = scene_or_transition;
                }
                else if (scene_or_transition instanceof cc.transition.Transition) {
                    // v3 style call
                    transition = scene_or_transition;
                    scene = transition._sceneIn;
                    if (!scene) {
                        throw "director.runAction(transition) has no scene set.";
                    }
                }
                else {
                    throw "Director.runScene with wrong object type.";
                }
                // wtf. zero sized containers should have no content.
                // the scene-graph will discard them immediately. This code here for backwards compatibility only.
                if (scene.width === 0 || scene.height === 0) {
                    var pw = this.getRenderer()._preferredUnits;
                    scene.setContentSize(pw.width, pw.height);
                }
                scene._parent = this;
                // the renderer will check whether it is already added.
                this.addToDOM();
                // if there's a transition, let the transition handle onExit.
                if (typeof transition !== "undefined") {
                    this._exitingScene = this._currentScene;
                    transition.initialize(scene, this._currentScene).onDirectorTransitionEnd(function (tr) {
                        //if ( this._exitingScene ) {
                        //    this.__sceneExitedDirector(this._exitingScene);
                        //}
                        _this._exitingScene = null;
                    });
                }
                else {
                    // if not, and there's a current scene
                    if (this._currentScene) {
                        // call onExit.
                        this.__sceneExitedDirector(this._currentScene);
                    }
                    // scene entered w/o transition.
                    scene.callOnEnter();
                }
                this._currentScene = scene;
                cc.input.MouseInputManager.enableInputForScene(scene);
                // check for valid orientation.
                this._renderer.checkOrientation();
                if (this._status !== 1 /* RUNNING */) {
                    this.startAnimation();
                }
            };
            /**
             * Push a new running scene on top of the stack.
             * @method cc.node.Director#pushScene
             * @param scene {cc.node.Scene}
             */
            Director.prototype.pushScene = function (scene) {
                if (this._scenes.indexOf(scene) !== -1) {
                    Debug.error(Locale.ERR_RUNNING_ALREADY_EXISTING_SCENE);
                    return;
                }
                this._scenes.push(scene);
                this.runScene(scene);
            };
            /**
             * Pop a scene from the running stack.
             * @method cc.node.Director#popScene
             * @throws cc.locale.Locale.ERR_DIRECTOR_POPSCENE_UDERFLOW if DEBUG_LEVEL is RuntimeDebugLevel.DEBUG.
             */
            Director.prototype.popScene = function () {
                if (this._scenes.length === 0) {
                    Debug.error(Locale.ERR_DIRECTOR_POPSCENE_UNDERFLOW);
                    return;
                }
                var exitScene = this._scenes.pop();
                this.__sceneExitedDirector(exitScene);
                if (this._scenes.length > 0) {
                    this._currentScene = this._scenes[this._scenes.length - 1];
                    this._currentScene.callOnEnter();
                }
                else {
                }
            };
            /**
             * Pop all scenes but one.
             * @method cc.node.Director#popToRootScene
             */
            Director.prototype.popToRootScene = function () {
                this.popToSceneStackLevel(1);
            };
            /**
             * Remove scenes from the stack until reaching 'level' scenes stack length.
             * @method cc.node.Director#popToSceneStackLevel
             * @param level {number}
             */
            Director.prototype.popToSceneStackLevel = function (level) {
                level = this._scenes.length - level;
                if (level <= 0) {
                    Debug.error(Locale.ERR_DIRECTOR_POPSCENE_UNDERFLOW);
                    return;
                }
                while (level) {
                    this.popScene();
                    level--;
                }
            };
            /**
             * Start Director's animation loop.
             * Don't call directly, or only call after manually calling <code>stopAnimation</code>
             * @method cc.node.Director#startAnimation
             */
            Director.prototype.startAnimation = function () {
                if (this._status === 1 /* RUNNING */) {
                    Debug.warn(Locale.WARN_START_ANIMATION_ON_RUNNING_DIRECTOR);
                    return;
                }
                this._status = 1 /* RUNNING */;
                var fn = this.mainLoop.bind(this);
                var me = this;
                function raf(perf) {
                    fn(perf);
                    me._animFrame = __window.requestAnimFrame(raf);
                }
                this._animFrame = __window.requestAnimFrame(raf);
                if (this._currentScene) {
                    cc.input.MouseInputManager.enableInputForScene(this._currentScene);
                }
            };
            /**
             * Stop Director's animation loop.
             * The Director status will be STOPPED.
             * @method cc.node.Director#stopAnimation
             */
            Director.prototype.stopAnimation = function () {
                if (this._status !== 1 /* RUNNING */) {
                    return;
                }
                this._status = 3 /* STOPPED */;
                if (this._animFrame !== null) {
                    __window.cancelAnimationFrame(this._animFrame);
                    this._animFrame = null;
                }
                if (this._currentScene) {
                    cc.input.MouseInputManager.disableInputForScene();
                }
            };
            /**
             * Throttle animation loop.
             * This value will be the minimum millis to wait between two frames.
             * Currently does nothing.
             * @method cc.node.Director#setAnimationInterval
             * @param interval {number}
             */
            Director.prototype.setAnimationInterval = function (interval) {
                this._animationInterval = interval;
            };
            /**
             * Main director animation Loop.
             * Don't call directly this method. It is called by startAnimation when the first scene is scheduled in the
             * Director object.
             *
             * PENDING: throttle FPS with _animationInterval value.
             *
             * @method cc.node.Director#mainLoop
             * @param perf {number=} performance time elapsed between two RAF calls.
             */
            Director.prototype.mainLoop = function (perf) {
                if (this._status !== 1 /* RUNNING */) {
                    return;
                }
                var deltaTime;
                if (typeof perf === "undefined") {
                    perf = new Date().getTime();
                }
                deltaTime = perf - this._prevPerf;
                // prevent feeding huge time increments. Useful for debugging.
                if (deltaTime > 250) {
                    deltaTime = 250;
                }
                this._prevPerf = perf;
                var ctx = this._renderer.getRenderingContext();
                ctx.clear();
                // do director's paint as a node.
                // A director does not have any action associated, so just paint.
                this.visit(ctx);
                // Step time for active scenes.
                // At any given moment, as much as two scenes can be active.
                // If a transition is in place, two scenes will be active.
                // If not, only one scene is active.
                this._scenesActionManager.step(deltaTime / cc.action.TIMEUNITS);
                // do current scene's visit when
                // transitions end.
                if (this._exitingScene) {
                    this._exitingScene.step(deltaTime / cc.action.TIMEUNITS, ctx);
                }
                this._currentScene.step(deltaTime / cc.action.TIMEUNITS, ctx);
                if (this._renderer.flush) {
                    this._renderer.flush();
                }
            };
            /**
             * Create an scene object.
             * The created Scene will have the size of this director object and have a reference to the director.
             * @method cc.node.Director#createScene
             * @returns {cc.node.Scene}
             */
            Director.prototype.createScene = function () {
                var scene = new Scene();
                scene.setContentSize(this._contentSize.width, this._contentSize.height);
                return scene;
            };
            /**
             * Get director size as a dimension object.
             * The object is a copy of the internal contentSize variable.
             * This method is for backwards compatibility
             * @method cc.node.Director#getWinSize
             * @returns {cc.math.Dimension}
             */
            Director.prototype.getWinSize = function () {
                return this._contentSize.clone();
            };
            Director.prototype.scheduleTask = function (task) {
                this._scheduler.scheduleTask(task);
            };
            /**
             * Schedule a task for the node.
             * This node will be passed as target to the specified callback function.
             * If already exist a task in the scheduler for the same pair of node and callback, the task will be updated
             * with the new data.
             * @method cc.node.Node#schedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to invoke
             * @param interval {number} repeat interval time. the task will be fired every this amount of milliseconds.
             * @param repeat {number=} number of repetitions. if not set, infinite will be used.
             * @param delay {number=} wait this millis before firing the task.
             */
            Director.prototype.schedule = function (callback_fn, interval, repeat, delay) {
                var task = cc.action.SchedulerQueue.createSchedulerTask(this, callback_fn, interval, repeat, delay);
                this._scheduler.scheduleTask(task);
            };
            /**
             * Schedule a single shot task. Will fired only once.
             * @method cc.node.Node#scheduleOnce
             * @param callback_fn {cc.action.SchedulerTaskCallback} scheduler callback.
             * @param delay {number} milliseconds to wait before firing the task.
             * @returns {cc.node.Node}
             */
            Director.prototype.scheduleOnce = function (callback_fn, delay) {
                this.schedule(callback_fn, 0.0, 0, delay);
            };
            /**
             * Unschedule a task for the node.
             * @method cc.node.Node#unschedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to unschedule.
             */
            Director.prototype.unschedule = function (callback_fn) {
                if (!callback_fn)
                    return;
                this._scheduler.unscheduleCallbackForTarget(this, callback_fn);
            };
            /**
             * Unschedule all tasks for the node.
             * @method cc.node.Node#unscheduleAllCallbacks
             */
            Director.prototype.unscheduleAllCallbacks = function (target) {
                this._scheduler.unscheduleAllCallbacks(target ? target : this);
            };
            return Director;
        })(Node);
        node.Director = Director;
    })(node = cc.node || (cc.node = {}));
})(cc || (cc = {}));
/**
 * Created by ibon on 11/17/14.
 */
/// <reference path="./WebGLState.ts"/>
/// <reference path="./Renderer.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        /**
         * @class cc.render.Texture2D
         * @classdesc
         *
         * This Object encapsulated a rendering texture, either for Canvas or WebGL.
         * The texture will handle all the burden of creating a webgl texture when needed.
         * Since renderers have different needs for different types of images a call to Renderer.prepareTexture must be
         * performed. This will automatically happen for every pre-loaded texture in the AssetManager by the time a renderer
         * is being built.
         *
         */
        var Texture2D = (function () {
            function Texture2D(el, name) {
                this._name = null;
                this._webglState = null;
                this._glId = null;
                this._textureWidth = 0;
                this._textureHeight = 0;
                /**
                 * A texture2D, is bound to a given renderer.
                 * @member cc.render.Texture2D#_image
                 * @type {Image|WebGLTexture}
                 * @private
                 */
                this._image = null;
                this._hasMipmaps = false;
                this._u0 = 0;
                this._v0 = 0;
                this._u1 = 0;
                this._v1 = 0;
                // offset in image.
                this._offsetX = 0;
                this._offsetY = 0;
                // when image is set to texture, the original image is dismissed in favor of a new dummy image.
                // from then, calling image.width or image.height will give wrong values.
                this._imageWidth = 0;
                this._imageHeight = 0;
                this._isLoaded = false;
                this._invertedY = false;
                if (el) {
                    this.initWithElement(el);
                    this._name = name;
                }
            }
            Texture2D.prototype.initWithElement = function (el) {
                if (typeof el === "string") {
                    var image = new Image();
                    image.onload = (function (me) {
                        return function (e) {
                            me.initWithElement(e.target);
                        };
                    })(this);
                    image.src = el;
                }
                else {
                    this._image = el;
                    this._imageWidth = el.width;
                    this._imageHeight = el.height;
                    this._image._textureInfo = this;
                    this._isLoaded = true;
                }
                function POT(v) {
                    var current = 1;
                    while (current < v) {
                        current <<= 1;
                    }
                    return current;
                }
                this._textureWidth = POT(this._image.width);
                this._textureHeight = POT(this._image.height);
                this._u1 = this._imageWidth / this._textureWidth;
                this._v1 = this._imageHeight / this._textureHeight;
            };
            Object.defineProperty(Texture2D.prototype, "width", {
                get: function () {
                    return this.getPixelsWide();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Texture2D.prototype, "height", {
                get: function () {
                    return this.getPixelsHigh();
                },
                enumerable: true,
                configurable: true
            });
            Texture2D.prototype.getPixelsWide = function () {
                return this._imageWidth;
            };
            Texture2D.prototype.getPixelsHigh = function () {
                return this._imageHeight;
            };
            Texture2D.prototype.getImage = function () {
                return this._glId ? this._glId : this._image;
            };
            Texture2D.prototype.isWebGLEnabled = function () {
                return this._glId !== null;
            };
            Texture2D.prototype.release = function () {
                if (this._glId && this._webglState) {
                    this._webglState._gl.deleteTexture(this._glId);
                    this._glId = null;
                }
            };
            /**
             * Turn an Image texture into a WebGL Texture.
             * The Image object reference will be set to null (gc friendly).
             * If the Texture is already a gl texture, nothing will happen.
             * @param webglstate {cc.render.WebGLState}
             * @returns {cc.render.Texture2D}
             * @private
             */
            Texture2D.prototype.__setAsGLTexture = function (webglstate) {
                // already set as texture, do nothing.
                if (!webglstate || this.isWebGLEnabled()) {
                    return this;
                }
                var gl = webglstate._gl;
                this._webglState = webglstate;
                this._glId = gl.createTexture();
                webglstate.bindTexture(gl.TEXTURE_2D, this._glId);
                webglstate.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                    this._invertedY = true;
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
                }
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._textureWidth, this._textureHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this._image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                this._image = null;
                return this;
            };
            Texture2D.prototype.setTexParameters = function (texParams, magFilter, wrapS, wrapT) {
                if (!this._webglState) {
                    return;
                }
                var gl = this._webglState._gl;
                var minFilter;
                if (typeof magFilter === "undefined") {
                    magFilter = texParams.magFilter;
                    wrapS = texParams.wrapS;
                    wrapT = texParams.wrapT;
                    minFilter = texParams.minFilter;
                }
                else {
                    minFilter = texParams;
                }
                this._webglState.bindTexture(gl.TEXTURE_2D, this._glId);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
            };
            Texture2D.prototype.setAntiAliasTexParameters = function () {
                if (!this._webglState) {
                    return;
                }
                var gl = this._webglState._gl;
                this._webglState.bindTexture(gl.TEXTURE_2D, this._glId);
                if (!this._hasMipmaps) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
                else {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                }
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            };
            Texture2D.prototype.setAliasTexParameters = function () {
                if (!this._webglState) {
                    return;
                }
                var gl = this._webglState._gl;
                this._webglState.bindTexture(gl.TEXTURE_2D, this._glId);
                if (!this._hasMipmaps) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                }
                else {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
                }
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            };
            Texture2D.prototype.generateMipmap = function () {
                if (!this._webglState || this._hasMipmaps) {
                    return;
                }
                var gl = this._webglState._gl;
                this._webglState.bindTexture(gl.TEXTURE_2D, this._glId);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.generateMipmap(gl.TEXTURE_2D);
                this._hasMipmaps = true;
            };
            return Texture2D;
        })();
        render.Texture2D = Texture2D;
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * Created by ibon on 11/26/14.
 */
/// <reference path="../../math/Point.ts"/>
/// <reference path="../../math/Rectangle.ts"/>
/// <reference path="../Sprite.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
/// <reference path="../../render/DecoratedWebGLRenderingContext.ts"/>
/// <reference path="../../render/Texture2D.ts"/>
/// <reference path="../../locale/Locale.ts"/>
/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../plugin/asset/AssetManager.ts"/>
var cc;
(function (cc) {
    var node;
    (function (node) {
        var sprite;
        (function (sprite) {
            var Vector = cc.math.Vector;
            var Rectangle = cc.math.Rectangle;
            function __createSpriteFrame(from, x, y, w, h, name, rotated, offsetx, offsety) {
                var frame = from.createSubSpriteFrame(parseFloat(x), parseFloat(y), parseFloat(w), parseFloat(h), name, offsetx, offsety);
                frame.rotated = rotated;
                return frame;
            }
            /**
             * @class cc.node.sprite.SpriteFrame
             * @classdesc
             *
             * This Object defines a pixels source (image, canvas, texture, etc.) and an associated Rect for image blitting
             * operations.
             * It has parent-child capabilities. A SpriteFrame can create subFrames. SubFrames will have a parent reference,
             * share the same Texture instance and will apply the appropriate offset.
             *
             */
            var SpriteFrame = (function () {
                /**
                 * Create a new SpriteFrame instance.
                 * @method cc.node.sprite.SpriteFrame#constructor
                 * @param _texture {Texture2D} an string or Texture2D
                 * @param rect {cc.math.Rectangle=} an optional rect on the texture. If not set, the whole image will be used.
                 */
                function SpriteFrame(_texture, rect) {
                    this._texture = _texture;
                    /**
                     * Parent's SpriteFrame. When creating Frames from an image, a call to <code>spriteFrame.createFrame</code>
                     * will create a child of a frame, set its parent, and inherit the offseting based on parent's chain.
                     * Both frames will share the same Texture2D instance.
                     * @type {cc.node.SpriteFrame}
                     * @member cc.node.sprite.SpriteFrame#_parent
                     * @private
                     */
                    this._parent = null;
                    /**
                     * Offset position in texture.
                     * When setting parents, the offset will be the parent's position.
                     * @member cc.node.sprite.SpriteFrame#_offset
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._offset = new Vector();
                    /**
                     * Displacement to add to position the spriteframe on screen.
                     * Nothing to do with uv coords.
                     * @member cc.node.sprite.SpriteFrame#_offsetFromCenter
                     * @type {cc.math.Vector}
                     * @private
                     */
                    this._offsetFromCenter = null;
                    /**
                     * Is the frame rotated ?. Not by default.
                     * @member cc.node.sprite.SpriteFrame#_rotated
                     * @type {boolean}
                     * @private
                     */
                    this._rotated = false;
                    /**
                     * Recatangle in pixels the SpriteFrame represents.
                     * @member cc.node.sprite.SpriteFrame#_rect
                     * @type {cc.math.Rectangle}
                     * @private
                     */
                    this._rect = null;
                    /**
                     * Recatangle in uv the SpriteFrame represents.
                     * @member cc.node.sprite.SpriteFrame#_normalizedRect
                     * @type {cc.math.Rectangle}
                     * @private
                     */
                    this._normalizedRect = new Rectangle();
                    /**
                     * Texture data. Texture is a source of pixels, either Image, Canvas or a GLTexture
                     * @member cc.node.sprite.SpriteFrame#_texture
                     * @type {cc.render.Texture2D}
                     * @private
                     */
                    /**
                     *
                     * @type {null}
                     * @private
                     */
                    this._name = null;
                    this._rect = rect ? rect : (_texture !== null ? new Rectangle(0, 0, _texture._imageWidth, _texture._imageHeight) : new Rectangle());
                    this.__calculateNormalizedRect();
                    this._name = _texture && _texture._name ? _texture._name : "root";
                }
                SpriteFrame.prototype.getWidth = function () {
                    return this._rect.w;
                };
                SpriteFrame.prototype.getHeight = function () {
                    return this._rect.h;
                };
                SpriteFrame.prototype.getX = function () {
                    return this._rect.x;
                };
                SpriteFrame.prototype.getY = function () {
                    return this._rect.y;
                };
                Object.defineProperty(SpriteFrame.prototype, "x", {
                    get: function () {
                        return this._rect.x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SpriteFrame.prototype, "y", {
                    get: function () {
                        return this._rect.y;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SpriteFrame.prototype, "width", {
                    get: function () {
                        return this._rect.w;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SpriteFrame.prototype, "height", {
                    get: function () {
                        return this._rect.h;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Create a new SpriteFrame from this one. The rect will be relative to this SpriteFrame's rect and offset.
                 * The rect supplied is clipped against this SpriteFrame's rect. If the resulting rect is Empty (has no dimension)
                 * null will be returned.
                 * The caller is responsible from storing the resulting SpriteFrame object.
                 * @method cc.node.sprite.SpriteFrame#createSubSpriteFrame
                 * @param x {number}
                 * @param y {number}
                 * @param w {number}
                 * @param h {number}
                 * @param name {string} a frame's name. If not set, "frameXXX" where XXX is a sequence value will be set.
                 * @returns {SpriteFrame} a new SubSpriteFrame created from this one or null if the supplied rect does not
                 *  intersect this SpriteFrame's rect.
                 */
                SpriteFrame.prototype.createSubSpriteFrame = function (x, y, w, h, name, centerOffsetX, centerOffsetY) {
                    var newRect = new Rectangle(x, y, w, h);
                    newRect.translate(this._rect.x, this._rect.y);
                    if (this._rect.intersectsWith(newRect)) {
                        var sf = new SpriteFrame(this._texture, newRect);
                        sf._name = name;
                        sf._parent = this;
                        sf.setOffset(this._offset.x + this._rect.x, this._offset.y + this._rect.y);
                        sf.setOffsetFromCenter(centerOffsetX || 0, centerOffsetY || 0);
                        return sf;
                    }
                    return null;
                };
                SpriteFrame.prototype.needsSpecialMatrix = function () {
                    return this._offsetFromCenter !== null || this._rotated;
                };
                SpriteFrame.prototype.setOffsetFromCenter = function (x, y) {
                    if (this._offsetFromCenter === null) {
                        this._offsetFromCenter = new Vector(0, 0);
                    }
                    this._offsetFromCenter.set(x, y);
                };
                SpriteFrame.prototype.createSubSpriteFrames = function (rows, columns) {
                    var sfwidth = this._rect.w / columns;
                    var sfheight = this._rect.h / rows;
                    var frames = [];
                    for (var i = 0; i < rows; i++) {
                        for (var j = 0; j < columns; j++) {
                            frames.push(this.createSubSpriteFrame(j * sfwidth, i * sfheight, sfwidth, sfheight, this._name + (j + i * columns)));
                        }
                    }
                    return frames;
                };
                /**
                 * Set the SpriteFrame offset. This is useful to properly position a Frame inside a frame. For example, a texture
                 * atlas with a font, which effectively another atlas.
                 * If the offset position is not contained the SpriteFrame's rect, the offset operation does nothing.
                 * @method cc.node.sprite.SpriteFrame#setOffset
                 * @param x {number}
                 * @param y {number}
                 */
                SpriteFrame.prototype.setOffset = function (x, y) {
                    if (!this._texture) {
                        cc.Debug.error(cc.locale.ERR_SPRITE_FRAME_NO_TEXTURE, "setOffset");
                    }
                    //if ( this._rect.contains( x,y ) ) {
                    this._offset.set(x, y);
                    this.__calculateNormalizedRect();
                    //}
                };
                Object.defineProperty(SpriteFrame.prototype, "rotated", {
                    /**
                     * Is this SpriteFrame rotated ?
                     * @method cc.node.sprite.SpriteFrame#get:rotated
                     * @returns {boolean}
                     */
                    get: function () {
                        return this._rotated;
                    },
                    /**
                     * Set this SpriteFrame to have the image rotated.
                     * @method cc.node.sprite.SpriteFrame#set:rotated
                     * @param v {boolean}
                     */
                    set: function (v) {
                        this._rotated = v;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Calculate WebGL rect based on the current frame info.
                 * @member cc.node.sprite.SpriteFrame#__calculateNormalizedRect
                 * @private
                 */
                SpriteFrame.prototype.__calculateNormalizedRect = function () {
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        this._normalizedRect.set(this._rect.x, this._texture._imageHeight - this._rect.y - this._rect.h, this._rect.w, this._rect.h).normalizeBy(this._texture._textureWidth, this._texture._textureHeight);
                    }
                    else {
                        this._normalizedRect.set(this._rect.x, this._rect.y, this._rect.w, this._rect.h).normalizeBy(this._texture._textureWidth, this._texture._textureHeight);
                    }
                };
                /**
                 * Get this SpriteFrame associated texture 2d object.
                 * @method cc.node.sprite.SpriteFrame#getTexture
                 * @returns {cc.render.Texture2D}
                 */
                SpriteFrame.prototype.getTexture = function () {
                    return this._texture;
                };
                /**
                 * Draw the SpriteFrame.
                 * This method takes care of drawing the Frame with the correct rotation and Sprite's status of flip axis values.
                 * @method cc.node.sprite.SpriteFrame#draw
                 * @param ctx {cc.render.RenderingContext}
                 * @param w {number}
                 * @param h {number}
                 */
                SpriteFrame.prototype.draw = function (ctx, w, h) {
                    if (ctx.type === cc.render.RENDERER_TYPE_WEBGL) {
                        if (!this._texture.isWebGLEnabled()) {
                            cc.Debug.warn(cc.locale.SPRITEFRAME_WARN_TEXTURE_NOT_WEBGL_INITIALIZED, "SpriteFrame.draw");
                            this._texture.__setAsGLTexture(ctx._webglState);
                            this.__calculateNormalizedRect();
                        }
                        ctx.drawTexture(this._texture, this._rect.x, this._rect.y, this._rect.w, this._rect.h, 0, 0, w, h);
                    }
                    else {
                        ctx.drawTextureUnsafe(this._texture, this._rect.x, this._rect.y, this._rect.w, this._rect.h, 0, 0, w, h);
                    }
                };
                /**
                 * Create a set of new SpriteFrames from this SpriteFrame area, and defined by a JSON object.
                 * The JSON object is typically the result of a ResourceLoaderJSON with parse flag enabled.
                 * The JSON structure is the result from the tool TexturePacker, exporting content as JSON.
                 * The function will create an array of newly created SpriteFrames. It is not this function's responsibility
                 * to add the new frames to a cache or anything but creating them.
                 *
                 * @param map {object} a TexturePacker JSON exported file.
                 * @param frames {Array<cc.node.sprite.SpriteFrame>=} array of newly created SpriteFrames. if this parameter is
                 *      not set, a new array will be created and returned.
                 * @returns {SpriteFrame[]}
                 */
                SpriteFrame.prototype.createSpriteFramesFromJSON = function (map, frames) {
                    frames = frames || [];
                    map = map.frames || map;
                    for (var element in map) {
                        if (map.hasOwnProperty(element)) {
                            var frameRect = map[element].frame;
                            frames.push(__createSpriteFrame(this, frameRect.x, frameRect.y, frameRect.w, frameRect.h, element, map[element].rotated, 0, 0));
                        }
                    }
                    return frames;
                };
                /**
                 * Create a set of new SpriteFrames from this SpriteFrame area, and defined by a 'plist' object.
                 * The plist object is typically the result of a ResourceLoaderXML.
                 * The plist structure is the result from the tool TexturePacker, exporting content as Cocos2d.
                 * The function will create an array of newly created SpriteFrames. It is not this function's responsibility
                 * to add the new frames to a cache or anything but creating them.
                 *
                 * @param obj {object} plist loaded file content in the form of a javascript array.
                 * @returns {SpriteFrame[]}
                 */
                SpriteFrame.prototype.createSpriteFramesFromPLIST = function (obj) {
                    var ret = [];
                    var frames = obj[0].frames;
                    for (var id in frames) {
                        if (frames.hasOwnProperty(id)) {
                            var frameInfo = frames[id];
                            if (frameInfo.frame) {
                                // frame info is of the form {{x,y},{w,h}}
                                var fi = frameInfo.frame.substring(1, frameInfo.frame.length - 1);
                                var fis = fi.substring(1, fi.length - 1).split('},{');
                                var xy = fis[0].split(',');
                                var wh = fis[1].split(',');
                                // frame info offset {0,0}
                                var foffset = frameInfo.offset.substring(1, fi.length - 1).split('},{');
                                var offsetxy = foffset[0].split(',');
                                // WFT!!!
                                // the file format specifies if rotated, the frame size in inverted.
                                var w, h;
                                w = parseFloat(frameInfo.rotated ? wh[1] : wh[0]);
                                h = parseFloat(frameInfo.rotated ? wh[0] : wh[1]);
                                var ox, oy;
                                //ox= parseFloat(frameInfo.rotated ? offsetxy[1] : offsetxy[0]);
                                //oy= parseFloat(frameInfo.rotated ? offsetxy[0] : offsetxy[1]);
                                ox = parseFloat(offsetxy[0]);
                                oy = parseFloat(offsetxy[1]);
                                ret.push(__createSpriteFrame(this, parseFloat(xy[0]), parseFloat(xy[1]), w, h, id, frameInfo.rotated, ox, oy));
                            }
                            else {
                                ret.push(__createSpriteFrame(this, frameInfo.x, frameInfo.y, frameInfo.width, frameInfo.height, id, frameInfo.rotated, 0, 0));
                            }
                        }
                    }
                    return ret;
                };
                return SpriteFrame;
            })();
            sprite.SpriteFrame = SpriteFrame;
        })(sprite = node.sprite || (node.sprite = {}));
    })(node = cc.node || (cc.node = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./SpriteFrame.ts"/>
/// <reference path="../../render/Texture2D.ts"/>
var cc;
(function (cc) {
    var node;
    (function (node) {
        var sprite;
        (function (sprite) {
            var Texture2D = cc.render.Texture2D;
            /**
             * @class cc.node.sprite.AnimationCache
             */
            var AnimationCache = (function () {
                function AnimationCache() {
                    this._animations = {};
                }
                AnimationCache.prototype.addAnimation = function () {
                };
                return AnimationCache;
            })();
            sprite.AnimationCache = AnimationCache;
            var __index = 0;
            /**
             * @class cc.node.sprite.Animation
             * @classdesc
             *
             * An animation is a set of SpriteFrames, playback duration and a loop value. A <code>cc.action.AnimateAction</code>
             * will play the sequence that the animation defines.
             * SpriteFrames roughly define rectangles in images. So if each of these frames is set for a node at a given speed,
             * we get the notion of a sprite animation.
             */
            var Animation = (function () {
                /**
                 * Create a new Animation instance.
                 * @method cc.node.sprite.Animation#constructor
                 */
                function Animation() {
                    /**
                     * A collection of SpriteFrames to define an animation.
                     * @type {Array<cc.node.sprite.SpriteFrame>}
                     * @member cc.node.sprite.Animation#_frames
                     * @private
                     */
                    this._frames = [];
                    /**
                     * How many times the sequence will be played.
                     * @type {number}
                     * @member cc.node.sprite.Animation#_loops
                     * @private
                     */
                    this._loops = 1;
                    /**
                     * Set the sprite back to the original frame after the animation ends playing.
                     * @type {number}
                     * @member cc.node.sprite.Animation#_restoreOriginalFrame
                     * @private
                     */
                    this._restoreOriginalFrame = false;
                    /**
                     * Time to change to the next frame. Defaults to 0.150 seconds. Value in milliseconds.
                     * @member cc.node.sprite.Animation#_delayPerUnit
                     * @type {number}
                     * @private
                     */
                    this._delayPerUnit = 150 / cc.action.TIMEUNITS;
                    /**
                     * Animation name. By default will be "animationXXX" where XXX is an index sequence value.
                     * @member cc.node.sprite.Animation#_name
                     * @type {string}
                     * @private
                     */
                    this._name = null;
                }
                /**
                 * Add an animation frame.
                 * @method cc.node.sprite.Animation#addFrame
                 * @param f {cc.node.sprite.SpriteFrame}
                 */
                Animation.prototype.addFrame = function (f) {
                    this._frames.push(f);
                    return this;
                };
                /**
                 * Add a collection of animation frames.
                 * @method cc.node.sprite.Animation#addFrames
                 * @param f {Array<cc.node.sprite.SpriteFrame>}
                 */
                Animation.prototype.addFrames = function (f) {
                    for (var i = 0; i < f.length; i++) {
                        this.addFrame(f[i]);
                    }
                    return this;
                };
                /**
                 * Set the amount of time each frame of the animation will be shown.
                 * @method cc.node.sprite.Animation#setDelayPerUnit
                 * @param d {number} delay in seconds.
                 */
                Animation.prototype.setDelayPerUnit = function (d) {
                    this._delayPerUnit = d;
                    return this;
                };
                /**
                 * Set the number of animation repetitions. If <1, it will be set to 1.
                 * @method cc.node.sprite.Animation#setLoops
                 * @param l {number} number of loops
                 */
                Animation.prototype.setLoops = function (l) {
                    if (l < 1) {
                        l = 1;
                    }
                    else {
                        l = l | 0;
                    }
                    this._loops = l;
                    return this;
                };
                /**
                 * Restore the original frame when the animation ends.
                 * @method cc.node.sprite.Animation#setRestoreOriginalFrame
                 * @param r {boolean}
                 */
                Animation.prototype.setRestoreOriginalFrame = function (r) {
                    this._restoreOriginalFrame = r;
                    return this;
                };
                /**
                 * Load an image, create a texture, a frame and then add the resulting SpriteFrame to the animation.
                 * @method cc.node.sprite.Animation#addSpriteFrameWithFile
                 * @deprecated
                 * @param f {string} valid url string for an image resource.
                 */
                Animation.prototype.addSpriteFrameWithFile = function (f) {
                    var me = this;
                    var img = new Image();
                    img.onload = function (e) {
                        var t2d = new Texture2D(img, f);
                        var sf = new sprite.SpriteFrame(t2d);
                        me.addFrame(sf);
                    };
                    img.src = f;
                };
                /**
                 * Get the animation duration. It is the number of frames * delayPerUnit
                 * @method cc.node.sprite.Animation#getDuration
                 * @returns {number} animation duration in seconds.
                 */
                Animation.prototype.getDuration = function () {
                    return this._delayPerUnit * this._frames.length;
                };
                /**
                 * Get the number of frames in the Animation.
                 * @method cc.node.sprite.Animation#getSize
                 * @returns {number}
                 */
                Animation.prototype.getSize = function () {
                    return this._frames.length;
                };
                /**
                 * Get an SpriteFrame from the array at an index.
                 * @method cc.node.sprite.Animation#getSpriteFrameAtIndex
                 * @param i {number}
                 * @returns {cc.node.sprite.SpriteFrame}
                 */
                Animation.prototype.getSpriteFrameAtIndex = function (i) {
                    return this._frames[i];
                };
                /**
                 * Set this animation to loop forever.
                 * @method cc.node.sprite.Animation#setLoopForever
                 * @returns {cc.node.sprite.Animation}
                 */
                Animation.prototype.setLoopForever = function () {
                    this._loops = Number.MAX_VALUE;
                    return this;
                };
                /**
                 * Create a copy of this Animation.
                 * The new Animation name will be the original+<an index sequence value>
                 * @method cc.node.sprite.Animation#clone
                 * @returns {cc.node.sprite.Animation}
                 */
                Animation.prototype.clone = function () {
                    var animation = new Animation();
                    animation._frames = Array.prototype.slice.call(this._frames);
                    animation._delayPerUnit = this._delayPerUnit;
                    animation._loops = this._loops;
                    animation._restoreOriginalFrame = this._restoreOriginalFrame;
                    animation._name = this._name + __index++;
                    return animation;
                };
                /**
                 * Reverse this animation. The SpriteFrame collection is reversed.
                 * @method cc.node.sprite.Animation#reverse
                 * @returns {cc.node.sprite.Animation}
                 */
                Animation.prototype.reverse = function () {
                    this._frames = this._frames.reverse();
                    return this;
                };
                return Animation;
            })();
            sprite.Animation = Animation;
        })(sprite = node.sprite || (node.sprite = {}));
    })(node = cc.node || (cc.node = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="Node.ts"/>
/// <reference path="./sprite/SpriteFrame.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="../math/Rectangle.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../render/DecoratedWebGLRenderingContext.ts"/>
/// <reference path="../render/Texture2D.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../util/Debug.ts"/>
/// <reference path="../plugin/loader/Loader.ts"/>
/// <reference path="../plugin/loader/Resource.ts"/>
/// <reference path="../plugin/asset/AssetManager.ts"/>
var cc;
(function (cc) {
    var node;
    (function (node) {
        "use strict";
        var Node = cc.node.Node;
        var Texture2D = cc.render.Texture2D;
        var SpriteFrame = cc.node.sprite.SpriteFrame;
        var __m0 = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        /**
         * @class cc.node.Sprite
         * @extend cc.node.Node
         * @classdesc
         * Sprite creates an sprite, a Node that shows images with animations.
         */
        var Sprite = (function (_super) {
            __extends(Sprite, _super);
            /**
             * @method cc.node.Sprite#constructor
             * @param ddata {cc.node.SpriteInitializer}
             * @param rect {cc.math.Rectangle}
             */
            function Sprite(ddata, rect) {
                _super.call(this);
                /**
                 * Set this frame horizontally flipped.
                 * @member cc.node.Sprite#_flippedX
                 * @type {boolean}
                 * @private
                 */
                this._flippedX = false;
                /**
                 * Set this frame horizontally flipped.
                 * @member cc.node.Sprite#_flippedY
                 * @type {boolean}
                 * @private
                 */
                this._flippedY = false;
                /**
                 * @union
                 * @type {cc.render.Texture2D|cc.node.sprite.SpriteFrame}
                 * @private
                 */
                this._spriteFrame = null;
                this._resizeOnSpriteFrameSet = true;
                this._spriteMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                this._spriteMatrixDirty = false;
                this._spriteMatrixSet = false;
                this.__init(ddata, rect);
            }
            Sprite.create = function (d) {
                return new cc.node.Sprite(d);
            };
            Sprite.prototype.__init = function (ddata, rect) {
                if (ddata instanceof cc.node.sprite.SpriteFrame) {
                    // V3 call.
                    this.setSpriteFrame(ddata);
                    cc.Debug.warn(cc.locale.WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL);
                }
                else if (ddata instanceof cc.render.Texture2D) {
                    // V3 call
                    this.setSpriteFrame(new SpriteFrame(ddata, arguments[1]));
                    cc.Debug.warn(cc.locale.WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL);
                }
                else if (typeof ddata === "string") {
                    // V3 call
                    if (ddata.charAt(0) === "#") {
                        this.setSpriteFrame(cc.plugin.asset.AssetManager.getSpriteFrame(ddata.substr(1)));
                    }
                    else {
                        this.__createFromURL(ddata, rect);
                    }
                    cc.Debug.warn(cc.locale.WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL);
                }
                else {
                    var data = ddata;
                    // V4 call
                    if (data) {
                        if (data.texture) {
                            this.setSpriteFrame(new SpriteFrame(data.texture, data.rect));
                        }
                        else if (data.frame) {
                            this.setSpriteFrame(data.frame);
                        }
                        else if (data.frameName) {
                            this.setSpriteFrame(cc.plugin.asset.AssetManager.getSpriteFrame(data.frameName));
                        }
                        else {
                            cc.Debug.warn(cc.locale.ERR_SPRITE_CONSTRUCTOR_PARAM_ERROR);
                        }
                    }
                }
            };
            /**
             * Backwards compatibility method.
             * Never use directly.
             * ugh!.
             *
             * @param url
             * @param rect
             * @private
             */
            Sprite.prototype.__createFromURL = function (url, rect) {
                // me sangran los ojos poniendo esto aqui !!!
                var resource = cc.plugin.asset.AssetManager._resources[url] || null;
                // resource exists in the backwards compatibility resources list ?.
                if (resource) {
                    // if not texture associated, create texture and main sprite frame
                    if (!cc.plugin.asset.AssetManager.getTexture(url)) {
                        cc.plugin.asset.AssetManager.addImage(resource, url);
                    }
                    var mainSpriteFrame = cc.plugin.asset.AssetManager.getSpriteFrame(url);
                    this.setSpriteFrame(!rect ? mainSpriteFrame : mainSpriteFrame.createSubSpriteFrame(rect.x, rect.y, rect.w, rect.h, url));
                }
                else {
                    // image is not even loaded.
                    var me = this;
                    // load asynchronously and create sprite frame + texture.
                    new cc.plugin.loader.Loader({
                        resources: [url]
                    }).startLoading(function finished(resources) {
                        cc.plugin.asset.AssetManager.mergeResources(resources);
                        var sf = new SpriteFrame(new Texture2D(resources[url], url));
                        if (rect) {
                            sf = sf.createSubSpriteFrame(rect.x, rect.y, rect.w, rect.h, url);
                        }
                        me.setSpriteFrame(sf);
                    });
                }
            };
            /**
             * Specialized Sprite draw function.
             * The Sprite must have a SpriteFrame, which references a region of an Image.
             * @method cc.node.Sprite#draw
             * @param ctx {cc.render.RenderingContext}
             */
            Sprite.prototype.draw = function (ctx) {
                if (this._spriteFrame) {
                    ctx.setGlobalAlpha(this._frameAlpha);
                    ctx.setTintColor(this._color);
                    this._spriteFrame.draw(ctx, this.width, this.height);
                }
            };
            /**
             * Set this Sprite's frame. Until a frame is set the Sprite won't be drawn on screen.
             * When the frame is set, the Node will have its dimension changed to fit that of the frame.
             * @param s {cc.node.sprite.SpriteFrame}
             */
            Sprite.prototype.setSpriteFrame = function (s) {
                if (s !== this._spriteFrame) {
                    this._spriteFrame = s;
                    if (this._resizeOnSpriteFrameSet) {
                        this.setContentSize(s._rect.w, s._rect.h);
                    }
                    this._spriteMatrixDirty = true;
                }
            };
            /**
             *
             *           cc.math.Matrix3.identity( this._spriteMatrix );
    
                         if (this._flippedX && this._flippedY) {
                             cc.math.Matrix3.translateBy(this._spriteMatrix, w, h);
                             cc.math.Matrix3.scaleBy(this._spriteMatrix, -1, -1);
                             this._spriteMatrixSet= true;
                         } else if (this._flippedX) {
                             cc.math.Matrix3.translateBy(this._spriteMatrix, w, 0);
                             cc.math.Matrix3.scaleBy(this._spriteMatrix, -1, 1);
                             this._spriteMatrixSet= true;
                         } else if (this._flippedY) {
                             cc.math.Matrix3.translateBy(this._spriteMatrix, 0, h);
                             cc.math.Matrix3.scaleBy(this._spriteMatrix, 1, -1);
                             this._spriteMatrixSet= true;
                         }
    
                         if ( this._spriteFrame.needsSpecialMatrix() ) {
                             cc.math.Matrix3.translateBy(this._spriteMatrix,
                                 this._spriteFrame._offsetFromCenter.x,
                                 this._spriteFrame._offsetFromCenter.y);
    
                             if (this._spriteFrame._rotated) {
                                 cc.math.Matrix3.translateBy(this._spriteMatrix, w / 2, h / 2);
                                 cc.math.Matrix3.rotateBy(this._spriteMatrix, Math.PI / 2);
                                 cc.math.Matrix3.translateBy(this._spriteMatrix, -w / 2, -h / 2);
                             }
    
                             this._spriteMatrixSet = true;
                         }
    
             *
             * @private
             */
            Sprite.prototype.__createMatrix = function () {
                var w = this.width;
                var h = this.height;
                this._spriteMatrixSet = false;
                var mat = this._spriteMatrix;
                if (this._flippedX && this._flippedY) {
                    cc.math.Matrix3.set(mat, -1.0, 0.0, 0.0, -1.0, w, h);
                    this._spriteMatrixSet = true;
                }
                else if (this._flippedX) {
                    cc.math.Matrix3.set(mat, -1.0, 0.0, 0.0, 1.0, w, 0.0);
                    this._spriteMatrixSet = true;
                }
                else if (this._flippedY) {
                    cc.math.Matrix3.set(mat, 1.0, 0.0, 0.0, -1.0, 0.0, h);
                    this._spriteMatrixSet = true;
                }
                else {
                    cc.math.Matrix3.identity(mat);
                }
                var sf = this._spriteFrame;
                if (sf.needsSpecialMatrix()) {
                    mat[2] += mat[0] * sf._offsetFromCenter.x;
                    mat[5] += mat[4] * sf._offsetFromCenter.y;
                    if (sf._rotated) {
                        mat[2] += mat[0] * w / 2.0;
                        mat[5] += mat[4] * h / 2.0;
                        var t = mat[0];
                        mat[0] = mat[1];
                        mat[1] = -t;
                        t = mat[3];
                        mat[3] = mat[4];
                        mat[4] = -t;
                        cc.math.Matrix3.translateBy(mat, -w / 2.0, -h / 2.0);
                    }
                    this._spriteMatrixSet = true;
                }
                this._spriteMatrixDirty = false;
            };
            Sprite.prototype.__setLocalTransform = function () {
                //super.__setLocalTransform();
                if (this._rotation.x !== this.rotationAngle || (this.rotationAngle % 360) !== 0 || this.__isFlagSet(4 /* REQUEST_TRANSFORM */)) {
                    this.__setLocalTransformRotate();
                }
                else if (this.scaleX !== this._scale.x || this._scale.y !== this.scaleY || this._scale.x !== 1 || this._scale.y !== 1) {
                    this.__setLocalTransformScale();
                }
                else if (this.x !== this._position.x || this.y !== this._position.y) {
                    var mm = this._modelViewMatrix;
                    var pa = this._positionAnchor;
                    var cs = this._contentSize;
                    var x = this.x - pa.x * cs.width;
                    var y = this.y - pa.y * cs.height;
                    mm[2] = x;
                    mm[5] = y;
                    mm[0] = 1.0;
                    mm[1] = 0.0;
                    mm[3] = 0.0;
                    mm[4] = 1.0;
                    mm[6] = 0.0;
                    mm[7] = 0.0;
                    mm[8] = 1.0;
                    this._position.x = this.x;
                    this._position.y = this.y;
                    this.__setFlag(2 /* TRANSFORMATION_DIRTY */);
                }
                if (this.__isFlagSet(2 /* TRANSFORMATION_DIRTY */)) {
                    if (this._spriteMatrixDirty) {
                        this.__createMatrix();
                    }
                    if (this._spriteMatrixSet) {
                        cc.math.Matrix3.multiply(this._modelViewMatrix, this._spriteMatrix);
                    }
                }
            };
            /**
             * Make the sprite to be horizontally mirrored.
             * @method cc.node.Sprite#setFlippedX
             * @param f {boolean} true to mirror, false by default.
             * @returns {cc.node.Sprite}
             */
            Sprite.prototype.setFlippedX = function (f) {
                this._flippedX = f;
                this._spriteMatrixDirty = true;
                this.__setFlag(2 /* TRANSFORMATION_DIRTY */);
                return this;
            };
            /**
             * Make the sprite to be vertically mirrored.
             * @method cc.node.Sprite#setFlippedY
             * @param f {boolean} true to mirror, false by default.
             * @returns {cc.node.Sprite}
             */
            Sprite.prototype.setFlippedY = function (f) {
                this._flippedY = f;
                this._spriteMatrixDirty = true;
                this.__setFlag(2 /* TRANSFORMATION_DIRTY */);
                return this;
            };
            Sprite.prototype.resizeOnSpriteFrameSet = function (b) {
                this._resizeOnSpriteFrameSet = b;
                return this;
            };
            Sprite.prototype.setTextureRect = function (r) {
                if (this._spriteFrame) {
                    this.setSpriteFrame(this._spriteFrame.createSubSpriteFrame(r.x, r.y, r.w, r.h, this._name));
                }
            };
            Object.defineProperty(Sprite.prototype, "flippedX", {
                set: function (b) {
                    this.setFlippedX(b);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "flippedY", {
                set: function (b) {
                    this.setFlippedY(b);
                },
                enumerable: true,
                configurable: true
            });
            return Sprite;
        })(Node);
        node.Sprite = Sprite;
        var SpriteBatchNode = (function (_super) {
            __extends(SpriteBatchNode, _super);
            function SpriteBatchNode(ddata, rect) {
                _super.call(this, null);
                this._resizeOnSpriteFrameSet = false;
                this.__init(ddata, rect);
            }
            return SpriteBatchNode;
        })(Sprite);
        node.SpriteBatchNode = SpriteBatchNode;
    })(node = cc.node || (cc.node = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./Node.ts"/>
/// <reference path="./Sprite.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../render/DecoratedWebGLRenderingContext.ts"/>
var cc;
(function (cc) {
    var node;
    (function (node) {
        /**
         * @class cc.node.FastSprite
         * @extends cc.node.Sprite
         * @classdesc
         *
         * While Nodes in general are heavy weight visual components, a Fast sprite is a very lightweight Node. In opposition
         * to a Node, a FastSprite:
         *   + scene graph does not discard it
         *   + expects to have no children. hierarchies are not handled.
         *   + get no input routed to it, such as mouse, touch, etc.
         *   + does not calculate a local bounding box, unless explicitly stated.
         *   + like old nodes, they expect than transformation and positional anchor point to be the same.
         *
         * <p>
         *     FastSprites aim at super fast management and rendering, specially in WebGL where a modern mobile phone could
         *     deliver several thousand of them at steady 60 fps.
         * <p>
         *     FastSprites are ideal for particle rendering, or for visually massive amount of nodes.
         * <p>
         *     If rendering in canvas, a FastSprite will be as fast a Sprite node. (way slower than FastSprite)
         *
         */
        var FastSprite = (function (_super) {
            __extends(FastSprite, _super);
            function FastSprite(ddata) {
                _super.call(this, ddata);
            }
            FastSprite.prototype.visit = function (ctx) {
                if (!this.__isFlagSet(8 /* VISIBLE */)) {
                    return;
                }
                if (this._spriteFrame) {
                    //ctx.globalAlpha = this._frameAlpha;
                    //ctx.setTintColor(this._color);
                    if (ctx.type === cc.render.RENDERER_TYPE_WEBGL) {
                        ctx.batchGeometryWithSpriteFast(this);
                    }
                    else {
                        _super.prototype.visit.call(this, ctx);
                    }
                }
            };
            return FastSprite;
        })(cc.node.Sprite);
        node.FastSprite = FastSprite;
    })(node = cc.node || (cc.node = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="../input/InputManager.ts"/>
/// <reference path="../input/MouseInputManager.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
var cc;
(function (cc) {
    var widget;
    (function (widget) {
        (function (ButtonStatus) {
            ButtonStatus[ButtonStatus["NORMAL"] = 0] = "NORMAL";
            ButtonStatus[ButtonStatus["PRESSED"] = 1] = "PRESSED";
            ButtonStatus[ButtonStatus["OVER"] = 2] = "OVER";
            ButtonStatus[ButtonStatus["DISABLED"] = 3] = "DISABLED";
        })(widget.ButtonStatus || (widget.ButtonStatus = {}));
        var ButtonStatus = widget.ButtonStatus;
        /**
         * @class cc.widget.Button
         * @classdesc
         *
         * @extends cc.node.Node
         *
         * A button is a special Node type that reacts to touch/mouse events.
         * It is described by 4 SpriteFrame objects of which only one is mandatory to set.
         * This are associated with the button states: normal, over, down and disabled. If any of the images is not defined,
         * they will fallback to use the normal-state image.
         */
        var Button = (function (_super) {
            __extends(Button, _super);
            function Button() {
                _super.call(this);
                /**
                 * Button images in this order: normal, pressed, over, disabled
                 * @type {Array<cc.node.sprite.SpriteFrame>}
                 * @private
                 */
                this._frames = [null, null, null, null];
                this._status = 0 /* NORMAL */;
                this._callback = null;
                this.enableEvents(true);
                var down = function (e) {
                    if (e.target._status === 3 /* DISABLED */) {
                        return;
                    }
                    e.target.setStatus(1 /* PRESSED */);
                };
                var click = function (e) {
                    if (e.target._status === 3 /* DISABLED */) {
                        return;
                    }
                    e.target.setStatus(0 /* NORMAL */);
                    if (e.target._callback) {
                        e.target._callback();
                    }
                };
                var over = function (e) {
                    if (e.target._status === 3 /* DISABLED */) {
                        return;
                    }
                    e.target.setStatus(2 /* OVER */);
                };
                var out = function (e) {
                    if (e.target._status === 3 /* DISABLED */) {
                        return;
                    }
                    e.target.setStatus(0 /* NORMAL */);
                };
                this.addEventListener("mousedown", down);
                this.addEventListener("touchstart", down);
                this.addEventListener("touchend", click);
                this.addEventListener("mouseclick", click);
                this.addEventListener("mouseover", over);
                this.addEventListener("touchover", over);
                this.addEventListener("mouseout", out);
                this.addEventListener("touchout", out);
            }
            Button.prototype.disable = function () {
                this._status = 3 /* DISABLED */;
                this.enableEvents(false);
            };
            Button.prototype.enable = function () {
                this._status = 0 /* NORMAL */;
                this.enableEvents(true);
            };
            Button.prototype.setEnabled = function (b) {
                if (b) {
                    this.enable();
                }
                else {
                    this.disable();
                }
            };
            Button.prototype.draw = function (ctx) {
                var sf = this.__getCurrentFrame();
                if (sf) {
                    ctx.setGlobalAlpha(this._frameAlpha);
                    ctx.setTintColor(this._color);
                    sf.draw(ctx, this.width, this.height);
                }
            };
            Button.prototype.init = function (obj) {
                if (obj.normal) {
                    this._frames[0 /* NORMAL */] = obj.normal;
                }
                if (obj.pressed) {
                    this._frames[1 /* PRESSED */] = obj.pressed;
                }
                if (obj.over) {
                    this._frames[2 /* OVER */] = obj.over;
                }
                if (obj.disabled) {
                    this._frames[3 /* DISABLED */] = obj.disabled;
                }
                this._status = 0 /* NORMAL */;
                if (obj.callback) {
                    this._callback = obj.callback;
                }
                this.width = obj.normal.getWidth();
                this.height = obj.normal.getHeight();
            };
            Button.prototype.__getCurrentFrame = function () {
                return this._frames[this._status] || this._frames[0 /* NORMAL */];
            };
            Button.prototype.setStatus = function (st) {
                this._status = st;
                var frame = this.__getCurrentFrame();
                this.setContentSize(frame.getWidth(), frame.getHeight());
            };
            return Button;
        })(cc.node.Node);
        widget.Button = Button;
    })(widget = cc.widget || (cc.widget = {}));
    function MenuItemSprite(normal, selected, disabled, callback, context) {
        var button = new cc.widget.Button();
        button.setAnchorPoint(.5, .5);
        var obj = {
            normal: normal._spriteFrame
        };
        if (selected) {
            obj.pressed = selected._spriteFrame;
        }
        if (disabled) {
            obj.disabled = disabled._spriteFrame;
        }
        if (callback) {
            obj.callback = context ? callback.bind(context) : callback;
        }
        button.init(obj);
        return button;
    }
    cc.MenuItemSprite = MenuItemSprite;
    function MenuItemLabel(label, callback) {
        if (callback) {
            label.enableEvents(true);
            label.addEventListener("mouseclick", function (e) {
                if (e.target._enabled) {
                    callback();
                }
            });
            label.addEventListener("touchend", function (e) {
                if (e.target._enabled) {
                    callback();
                }
            });
        }
        return label;
    }
    cc.MenuItemLabel = MenuItemLabel;
    var MenuItemFont = (function (_super) {
        __extends(MenuItemFont, _super);
        function MenuItemFont(_initializer, callback, target) {
            var _this = this;
            _super.call(this);
            this._label = null;
            this._callback = null;
            this._enabled = true;
            var label;
            if (typeof _initializer === "string") {
                label = new cc.widget.LabelTTF(_initializer, cc.MenuItemFont.DEFAULT_FONT, cc.MenuItemFont.DEFAULT_SIZE);
            }
            else {
                label = new cc.widget.LabelTTF();
                label.initialize(_initializer);
            }
            this._label = label;
            if (callback) {
                this._callback = target ? callback.bind(target) : callback;
                this._label.enableEvents(true);
                this._label.addEventListener("mouseup", function (e) {
                    if (_this._enabled) {
                        _this._callback();
                    }
                });
                this._label.addEventListener("touchend", function (e) {
                    if (_this._enabled) {
                        _this._callback();
                    }
                });
            }
            this.addChild(this._label);
            this._label.setPositionAnchor(0, 0);
            this.setContentSize(this._label.width, this._label.height);
        }
        MenuItemFont.prototype.setFontSize = function (s) {
            this._label.setFontSize(s);
        };
        MenuItemFont.prototype.getFontSize = function () {
            return this._label.getFontSize();
        };
        MenuItemFont.prototype.setFontName = function (name) {
            this._label.setFont(name);
        };
        MenuItemFont.prototype.getFontName = function () {
            return this._label.getFont();
        };
        MenuItemFont.prototype.setEnabled = function (b) {
            this._label.setEnabled(b);
        };
        Object.defineProperty(MenuItemFont.prototype, "fontSize", {
            get: function () {
                return this._label._size;
            },
            set: function (v) {
                this._label._size = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItemFont.prototype, "fontName", {
            get: function () {
                return this._label._font;
            },
            set: function (v) {
                this._label._font = v;
            },
            enumerable: true,
            configurable: true
        });
        MenuItemFont.setFontSize = function (fontSize) {
            cc.MenuItemFont.DEFAULT_SIZE = fontSize;
        };
        MenuItemFont.fontSize = function () {
            return cc.MenuItemFont.DEFAULT_SIZE;
        };
        MenuItemFont.setFontName = function (name) {
            cc.MenuItemFont.DEFAULT_FONT = name;
        };
        MenuItemFont.DEFAULT_SIZE = 16;
        MenuItemFont.DEFAULT_FONT = "Arial";
        return MenuItemFont;
    })(cc.node.Node);
    cc.MenuItemFont = MenuItemFont;
    var Menu = (function (_super) {
        __extends(Menu, _super);
        function Menu() {
            var buttons = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                buttons[_i - 0] = arguments[_i];
            }
            _super.call(this);
            for (var i = 0; i < buttons.length; i++) {
                this.addChild(buttons[i]);
            }
            this.setPositionAnchor(0, 0);
            var winSize = cc.director.getWinSize();
            this.setPosition(winSize.width / 2, winSize.height / 2);
            this.setContentSize(winSize.width, winSize.height);
        }
        Menu.prototype.alignItemsVerticallyWithPadding = function (padding) {
            this._padding = padding + this.y;
            var height = -padding, locChildren = this._children, len, i, locScaleY, locHeight, locChild;
            if (locChildren && locChildren.length > 0) {
                for (i = 0, len = locChildren.length; i < len; i++)
                    height += locChildren[i].height * locChildren[i].scaleY + padding;
                var y = height / 2.0;
                for (i = 0, len = locChildren.length; i < len; i++) {
                    locChild = locChildren[i];
                    locHeight = locChild.height;
                    locScaleY = locChild.scaleY;
                    locChild.setPosition(0, y - locHeight * locScaleY / 2);
                    y -= locHeight * locScaleY + padding;
                }
            }
        };
        Menu.prototype.alignItemsInColumns = function () {
            var rows = [];
            for (var i = 0; i < arguments.length; i++) {
                rows.push(arguments[i]);
            }
            var height = -5;
            var row = 0;
            var rowHeight = 0;
            var columnsOccupied = 0;
            var rowColumns, tmp, len;
            var locChildren = this._children;
            if (locChildren && locChildren.length > 0) {
                for (i = 0, len = locChildren.length; i < len; i++) {
                    if (row >= rows.length)
                        continue;
                    rowColumns = rows[row];
                    // can not have zero columns on a row
                    if (!rowColumns)
                        continue;
                    tmp = locChildren[i].height;
                    rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);
                    ++columnsOccupied;
                    if (columnsOccupied >= rowColumns) {
                        height += rowHeight + 5;
                        columnsOccupied = 0;
                        rowHeight = 0;
                        ++row;
                    }
                }
            }
            // check if too many rows/columns for available menu items
            //cc.assert(!columnsOccupied, "");    //?
            var winSize = cc.director.getWinSize();
            row = 0;
            rowHeight = 0;
            rowColumns = 0;
            var w = 0.0;
            var x = 0.0;
            var y = (height / 2);
            if (locChildren && locChildren.length > 0) {
                for (i = 0, len = locChildren.length; i < len; i++) {
                    var child = locChildren[i];
                    if (rowColumns == 0) {
                        rowColumns = rows[row];
                        w = winSize.width / (1 + rowColumns);
                        x = w;
                    }
                    tmp = child.height;
                    rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);
                    child.setPosition(x - winSize.width / 2, y - tmp / 2);
                    x += w;
                    ++columnsOccupied;
                    if (columnsOccupied >= rowColumns) {
                        y -= rowHeight + 5;
                        columnsOccupied = 0;
                        rowColumns = 0;
                        rowHeight = 0;
                        ++row;
                    }
                }
            }
        };
        return Menu;
    })(cc.node.Node);
    cc.Menu = Menu;
    var MenuItemToggle = (function (_super) {
        __extends(MenuItemToggle, _super);
        function MenuItemToggle() {
            var _this = this;
            _super.call(this);
            this._currentOptionIndex = -1;
            this._options = [];
            this._callback = null;
            this._enabled = true;
            this.setAnchorPoint(.5, .5);
            this.enableEvents(true);
            this.addEventListener("mouseup", function (e) {
                if (_this._enabled) {
                    _this.__nextOption();
                }
            });
            this.addEventListener("touchup", function (e) {
                if (_this._enabled) {
                    _this.__nextOption();
                }
            });
            this.__init.call(this, Array.prototype.slice.call(arguments));
        }
        MenuItemToggle.prototype.setEnabled = function (b) {
            this._enabled = b;
            for (var i = 0; i < this._options.length; i++) {
                var node = this._options[i];
                if (typeof node.setEnabled !== "undefined") {
                    node.setEnabled(b);
                }
            }
        };
        MenuItemToggle.prototype.initWithItems = function () {
            this.__init.call(this, Array.prototype.slice.call(arguments));
        };
        MenuItemToggle.prototype.__init = function (args) {
            var len = args.length;
            if (typeof args[args.length - 2] === 'function') {
                len -= 2;
                this._callback = args[args.length - 2].bind(args[args.length - 1]);
            }
            else if (typeof args[args.length - 1] === 'function') {
                len -= 1;
                this._callback = args[args.length - 1];
            }
            for (var i = 0; i < len; i++) {
                this.addItem(args[i]);
            }
            this.setSelectedIndex(0);
        };
        MenuItemToggle.prototype.addItem = function (node) {
            node.setAnchorPoint(0.5, 0.5);
            node.visible = false;
            this._options.push(node);
            this.addChild(node);
            if (this._children.length === 1) {
                this.setSelectedIndex(0);
            }
        };
        MenuItemToggle.prototype.setCallback = function (callback) {
            this.onClick(callback);
        };
        MenuItemToggle.prototype.onClick = function (callback) {
            this._callback = callback;
        };
        MenuItemToggle.prototype.setSelectedIndex = function (index) {
            if (this._options.length === 0) {
                return;
            }
            index %= this._children.length;
            if (index !== this._currentOptionIndex) {
                if (this._currentOptionIndex !== -1) {
                    this._options[this._currentOptionIndex].visible = false;
                }
                this._currentOptionIndex = index;
                var co = this._options[this._currentOptionIndex];
                co.setPosition(co.width / 2, co.height / 2);
                co.visible = true;
                this.setContentSize(co.width, co.height);
            }
        };
        MenuItemToggle.prototype.__emit = function () {
            if (this._callback) {
                this._callback(this._currentOptionIndex !== -1 ? this._options[this._currentOptionIndex] : null);
            }
        };
        MenuItemToggle.prototype.__nextOption = function () {
            if (this._children.length === 0) {
                return;
            }
            this.setSelectedIndex(this._currentOptionIndex === -1 ? 0 : this._currentOptionIndex + 1);
            this.__emit();
        };
        return MenuItemToggle;
    })(cc.node.Node);
    cc.MenuItemToggle = MenuItemToggle;
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../math/Dimension.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../render/Texture2D.ts"/>
/// <reference path="../plugin/font/SpriteFont.ts"/>
var cc;
(function (cc) {
    var widget;
    (function (widget) {
        (function (VALIGN) {
            VALIGN[VALIGN["TOP"] = 0] = "TOP";
            VALIGN[VALIGN["MIDDLE"] = 1] = "MIDDLE";
            VALIGN[VALIGN["BOTTOM"] = 2] = "BOTTOM";
        })(widget.VALIGN || (widget.VALIGN = {}));
        var VALIGN = widget.VALIGN;
        (function (HALIGN) {
            HALIGN[HALIGN["LEFT"] = 0] = "LEFT";
            HALIGN[HALIGN["CENTER"] = 1] = "CENTER";
            HALIGN[HALIGN["RIGHT"] = 2] = "RIGHT";
        })(widget.HALIGN || (widget.HALIGN = {}));
        var HALIGN = widget.HALIGN;
        /**
         * @class cc.widget.Label
         * @extends cc.node.Node
         * @classdesc
         *
         * This object represents a label widget which simply writes text.
         * The text is written using a SpriteFont object which must be in the AssetManager cache.
         *
         * The label text can be drawn freely, that is each text line will span as much width as needed (method
         * or flow constrained by calling <code>setFlowWidth</code where the text will be drawn to a fixed width.
         *
         * For both methods, the label will calculate its bounds upon text or font change. You can override this behavior
         * by calling <code>setResizeContentSize(bool)</code>
         *
         * The text can be multiline text separated by \n characters.
         *
         *
         *
         */
        var Label = (function (_super) {
            __extends(Label, _super);
            /**
             * Build a new LabelBM object instance.
             * @param text {string} label text.
             * @param fontName {string} a cc.plugin.font.SpriteFont in the AssetManager cache object name.
             */
            function Label(text, fontName) {
                _super.call(this);
                this._text = '';
                this._textSize = null;
                this._font = null;
                this._resizeContentSize = true;
                this._valign = 1 /* MIDDLE */;
                this._halign = 1 /* CENTER */;
                this._enabled = true;
                this._flowWidth = 0;
                this._text = text;
                this._font = cc.plugin.asset.AssetManager.getSpriteFont(fontName);
                this.__measureText();
            }
            Label.prototype.setResizeContentSize = function (b) {
                this._resizeContentSize = b;
                return this;
            };
            Label.prototype.__measureText = function () {
                if (this._font) {
                    var d = this._font.getTextSize(this._text, this._flowWidth);
                    this._contentSize.width = this._flowWidth ? this._flowWidth : d.width;
                    this._contentSize.height = d.height;
                    this._textSize = d;
                }
            };
            Label.prototype.setFont = function (fontName) {
                var fn = cc.plugin.asset.AssetManager.getSpriteFont(fontName);
                if (null !== fn) {
                    this._font = fn;
                    if (this._resizeContentSize) {
                        this.__measureText();
                    }
                }
            };
            Label.prototype.setText = function (text) {
                this._text = text;
                if (this._resizeContentSize) {
                    this.__measureText();
                }
            };
            Label.prototype.setHAlign = function (a) {
                this._halign = a;
                return this;
            };
            Label.prototype.setVAlign = function (a) {
                this._valign = a;
                return this;
            };
            Label.prototype.draw = function (ctx) {
                _super.prototype.draw.call(this, ctx);
                if (this._font) {
                    this._font.drawTextInRect(ctx, this._text, 0, 0, this._contentSize.width, this._contentSize.height, this._halign, this._valign);
                }
            };
            Object.defineProperty(Label.prototype, "textAlign", {
                get: function () {
                    return this._halign;
                },
                set: function (v) {
                    this._halign = v;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Label.prototype, "textVerticalAlign", {
                get: function () {
                    return this._valign;
                },
                set: function (v) {
                    this._valign = v;
                },
                enumerable: true,
                configurable: true
            });
            /**
             *
             * @param text
             * @deprecated
             */
            Label.prototype.setString = function (text) {
                this.setText(text);
            };
            Label.prototype.setEnabled = function (e) {
                this._enabled = e;
            };
            Label.prototype.flowWidth = function (f) {
                this._flowWidth = f;
                this.__measureText();
                return this;
            };
            return Label;
        })(cc.node.Node);
        widget.Label = Label;
        var __index = 0;
        var LabelTTF = (function (_super) {
            __extends(LabelTTF, _super);
            function LabelTTF(_initializer, font, fontSize, dimensions, halign, valign) {
                _super.call(this, null);
                this._text = null;
                this._font = "Arial";
                this._size = 16;
                this._flow = false;
                this._flowWidth = 1024;
                this._fillColor = "#fff";
                this._strokeColor = "#ccc";
                this._strokeSize = 1;
                this._fill = true;
                this._stroke = false;
                this._shadowBlur = 0;
                this._shadowColor = "#ff0";
                this._shadowOffsetX = 0;
                this._shadowOffsetY = 0;
                this._texture = null;
                this._horizontalAlignment = 0 /* LEFT */;
                this._verticalAlignment = 1 /* MIDDLE */;
                this._enabled = true;
                var initializer;
                if (typeof _initializer === "string") {
                    // old calls
                    initializer = {
                        text: _initializer,
                        font: typeof font !== "undefined" ? font : this._font,
                        size: typeof fontSize !== "undefined" ? fontSize : this._size
                    };
                    if (typeof dimensions !== "undefined") {
                        initializer.flowWidth = dimensions.width;
                    }
                    initializer.horizontalAlignment = typeof halign !== "undefined" ? halign : this._horizontalAlignment;
                    initializer.verticalAlignment = typeof valign !== "undefined" ? valign : this._verticalAlignment;
                }
                else {
                    initializer = _initializer;
                }
                if (initializer) {
                    this.initialize(initializer);
                    if (initializer.text) {
                        this.__initLabel();
                    }
                }
            }
            LabelTTF.prototype.initialize = function (init) {
                this._text = init.text;
                if (typeof init.font !== "undefined") {
                    this._font = init.font;
                }
                ;
                if (typeof init.size !== "undefined") {
                    this._size = init.size;
                }
                ;
                this._flow = typeof init.flowWidth !== 'undefined';
                if (typeof init.flowWidth !== 'undefined') {
                    this._flowWidth = init.flowWidth;
                }
                if (typeof init.fillColor !== 'undefined') {
                    this._fillColor = init.fillColor;
                }
                if (typeof init.strokeColor !== 'undefined') {
                    this._strokeColor = init.strokeColor;
                }
                if (typeof init.strokeSize !== 'undefined') {
                    this._strokeSize = init.strokeSize;
                }
                if (typeof init.fill !== 'undefined') {
                    this._fill = init.fill;
                }
                if (typeof init.stroke !== 'undefined') {
                    this._stroke = init.stroke;
                }
                if (typeof init.shadowBlur !== 'undefined') {
                    this._shadowBlur = init.shadowBlur;
                }
                if (typeof init.shadowColor !== 'undefined') {
                    this._shadowColor = init.shadowColor;
                }
                if (typeof init.shadowOffsetX === 'undefined') {
                    this._shadowOffsetX = init.shadowOffsetX;
                }
                if (typeof init.shadowOffsetY === 'undefined') {
                    this._shadowOffsetY = init.shadowOffsetY;
                }
                if (typeof init.horizontalAlignment !== "undefined") {
                    this._horizontalAlignment = init.horizontalAlignment;
                }
                if (typeof init.verticalAlignment !== "undefined") {
                    this._verticalAlignment = init.verticalAlignment;
                }
                this.__initLabel();
                return this;
            };
            LabelTTF.prototype.setEnabled = function (b) {
                this._enabled = b;
            };
            LabelTTF.prototype.setText = function (text) {
                if (this._text === text) {
                    return;
                }
                this._text = text;
                this.__initLabel();
            };
            LabelTTF.prototype.setString = function (text) {
                this.setText(text);
            };
            LabelTTF.prototype.__initLabel = function () {
                if (this._texture) {
                    this._texture.release();
                }
                var canvas = document.createElement("canvas");
                var ctx = canvas.getContext("2d");
                this.__prepareContext(ctx);
                var textSize = this.__getTextSize(ctx, this._text, this._flowWidth);
                var canvas = this.__drawText(this._text, textSize);
                var textureId = "labelTTF" + __index++;
                this._texture = new cc.render.Texture2D(canvas, textureId);
                this.setSpriteFrame(new cc.node.sprite.SpriteFrame(this._texture));
            };
            LabelTTF.prototype.__prepareContext = function (ctx) {
                ctx.font = "" + this._size + "px " + this._font;
                ctx.textBaseline = "top";
                ctx.fillStyle = this._fillColor;
                if (this._stroke) {
                    ctx.strokeStyle = this._strokeColor;
                    ctx.lineWidth = this._strokeSize;
                }
                if (this._shadowBlur) {
                    ctx.shadowBlur = this._shadowBlur;
                    ctx.shadowColor = this._shadowColor;
                    ctx.shadowOffsetX = this._shadowOffsetX;
                    ctx.shadowOffsetY = this._shadowOffsetY;
                }
            };
            LabelTTF.prototype.__drawText = function (text, size) {
                var y = 0;
                var flowWidth = size.width;
                var offsetX = 0;
                var offsetY = 0;
                if (this._stroke) {
                    offsetX += this._strokeSize / 2;
                    offsetY += this._strokeSize / 2;
                    size.width += this._strokeSize;
                }
                if (this._shadowBlur) {
                    size.width += this._shadowBlur + this._shadowOffsetX;
                    size.height += this._shadowBlur + this._shadowOffsetY;
                    offsetX += this._shadowBlur / 2 + this._shadowOffsetX;
                    offsetY += this._shadowBlur / 2 + this._shadowOffsetY * (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM ? -1 : 1);
                }
                var canvas = document.createElement("canvas");
                canvas.width = size.width;
                canvas.height = size.height;
                var ctx = canvas.getContext("2d");
                this.__prepareContext(ctx);
                y = offsetY;
                var lines = text.split("\n");
                for (var l = 0; l < lines.length; l++) {
                    var x = offsetX;
                    var words = lines[l].split(" ");
                    for (var w = 0; w < words.length; w++) {
                        var word = words[w] + (w < words.length - 1 ? " " : "");
                        var wordLength = ctx.measureText(word).width;
                        if (x + wordLength > flowWidth) {
                            y += this._size;
                            x = 0;
                        }
                        if (this._stroke) {
                            ctx.strokeText(word, x, y);
                        }
                        if (this._fill) {
                            ctx.fillText(word, x, y);
                        }
                        x += wordLength;
                    }
                    y += this._size;
                }
                return canvas;
            };
            LabelTTF.prototype.__getTextSize = function (ctx, text, flowWidth) {
                var dim = new cc.math.Dimension();
                flowWidth = this._flowWidth;
                var lines = text.split("\n");
                for (var l = 0; l < lines.length; l++) {
                    var x = 0;
                    var words = lines[l].split(" ");
                    for (var w = 0; w < words.length; w++) {
                        var word = words[w] + (w < words.length - 1 ? " " : "");
                        var wordLength = ctx.measureText(word).width;
                        if (x + wordLength > flowWidth) {
                            dim.width = Math.max(dim.width, x);
                            dim.height += this._size;
                            x = wordLength;
                        }
                        else {
                            x += wordLength;
                        }
                    }
                    dim.height += this._size;
                    dim.width = Math.max(dim.width, x);
                }
                if (this._flow) {
                    dim.width = flowWidth;
                }
                return dim;
            };
            LabelTTF.prototype.getFont = function () {
                return this._font;
            };
            LabelTTF.prototype.setFont = function (font) {
                this._font = font;
                this.__initLabel();
            };
            LabelTTF.prototype.setFontSize = function (s) {
                this._size = s;
                this.__initLabel();
            };
            LabelTTF.prototype.getFontSize = function () {
                return this._size;
            };
            return LabelTTF;
        })(cc.node.Sprite);
        widget.LabelTTF = LabelTTF;
    })(widget = cc.widget || (cc.widget = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
var cc;
(function (cc) {
    var render;
    (function (render) {
        /**
         * @namespace WebGLState
         * @memberOf cc.render
         *
         * @classdesc
         * This object keeps global webGL state. It has two main purposes.
         *  + Avoid duplicate webgl calls.
         *  + Share internal renderer state with external shaders or renderers so that WebGL state can be consistent when
         *    getting back to the renderer.
         *
         */
        var WebGLState = (function () {
            function WebGLState(_gl) {
                this._gl = _gl;
                /**
                 * Current program
                 * @member cc.render.WebGLState#_currentProgram
                 * @type {WebGLProgram}
                 */
                this._currentProgram = null;
                /**
                 * Current texture
                 * @member cc.render.WebGLState#_currentTexture
                 * @type {WebGLTexture}
                 */
                this._currentTexture = null;
                /**
                 * blendFunc source blending value.
                 * @member cc.render.WebGLState#_blendSource
                 * @type {number}
                 * @private
                 */
                this._blendSource = -1;
                /**
                 * blendFunc destination blending value.
                 * @member cc.render.WebGLState#_blendDestination
                 * @type {number}
                 * @private
                 */
                this._blendDestination = -1;
                /**
                 * Object to hold gl flags values, particularly, all calls to gl.enable
                 * @member cc.render.WebGLState#_flags
                 * @type {{flag:number, enabled:boolean}}
                 * @private
                 */
                this._flags = {};
                /**
                 * current gl.clearColor value.
                 * @member cc.render.WebGLState#_clearColor
                 * @type {Array<number>}
                 * @private
                 */
                this._clearColor = [-1, -1, -1, -1];
                /**
                 * current gl.viewport value.
                 * @member cc.render.WebGLState#_viewport
                 * @type {Array<number>}
                 * @private
                 */
                this._viewport = [-1, -1, -1, -1];
                /**
                 * gl.TEXTURE<XX> values.
                 * @member cc.render.WebGLState#_texture
                 * @type {{ texture:number, enabled:boolean }}
                 * @private
                 */
                this._texture = {};
                /**
                 * WebGLUniformLocation dictionary.
                 * @member cc.render.WebGLState#_uniformLocation
                 * @type {{uniform:WebGLUniformLocation, value:any}}
                 * @private
                 */
                this._uniformLocation = {};
                /**
                 * vertex attrib array enabled values.
                 * @member cc.render.WebGLState#_attribArray
                 * @type {Map<number,boolean>}
                 * @private
                 */
                this._attribArray = {
                    0: false,
                    1: false,
                    2: false,
                    3: false,
                    4: false,
                    5: false,
                    6: false,
                    7: false,
                    8: false,
                    9: false,
                    10: false
                };
                this._attribPointers = {};
                for (var i = 0; i < 16; i++) {
                    this._texture[_gl["TEXTURE" + i]] = false;
                }
            }
            WebGLState.prototype.useProgram = function (program) {
                if (program !== this._currentProgram) {
                    this._currentProgram = program;
                    this._gl.useProgram(program);
                }
            };
            /**
             *
             * @param i {number} gl.TEXTURE<X> value.
             */
            WebGLState.prototype.activeTexture = function (i) {
                if (!this._texture[i]) {
                    this._texture[i] = true;
                    this._gl.activeTexture(i);
                }
            };
            WebGLState.prototype.bindTexture = function (type, t) {
                if (t !== this._currentTexture) {
                    this._gl.bindTexture(type, t);
                    this._currentTexture = t;
                }
            };
            WebGLState.prototype.enable = function (flag) {
                if (!this._flags.hasOwnProperty(flag)) {
                    this._flags[flag] = false;
                    this._gl.enable(flag);
                    return;
                }
                if (this._flags[flag]) {
                    return;
                }
                this._flags[flag] = true;
                this._gl.enable(flag);
            };
            WebGLState.prototype.flagEnabled = function (flag) {
                return this._flags[flag];
            };
            WebGLState.prototype.disable = function (flag) {
                if (!this._flags.hasOwnProperty(flag)) {
                    this._flags[flag] = false;
                    this._gl.disable(flag);
                    return;
                }
                if (!this._flags[flag]) {
                    return;
                }
                this._flags[flag] = false;
                this._gl.disable(flag);
            };
            WebGLState.prototype.clear = function (flags) {
                this._gl.clear(flags);
            };
            WebGLState.prototype.clearColor = function (r, g, b, a) {
                if (r !== this._clearColor[0] || g !== this._clearColor[1] || b !== this._clearColor[2] || a !== this._clearColor[3]) {
                    this._clearColor[0] = r;
                    this._clearColor[1] = g;
                    this._clearColor[2] = b;
                    this._clearColor[3] = a;
                    this._gl.clearColor(r, g, b, a);
                }
            };
            WebGLState.prototype.viewport = function (x, y, w, h) {
                if (x !== this._viewport[0] || y !== this._viewport[1] || w !== this._viewport[2] || h !== this._viewport[3]) {
                    this._viewport[0] = x;
                    this._viewport[1] = y;
                    this._viewport[2] = w;
                    this._viewport[3] = h;
                    this._gl.viewport(x, y, w, h);
                }
            };
            WebGLState.prototype.blendFunc = function (blendSource, blendDestination) {
                if (this._blendSource !== blendSource || this._blendDestination !== blendDestination) {
                    this._blendSource = blendSource;
                    this._blendDestination = blendDestination;
                    this._gl.blendFunc(blendSource, blendDestination);
                }
            };
            WebGLState.prototype.__uniform1Scalar = function (location, value) {
                // pending remove hasOwnProperty with prior initialization
                if (!this._uniformLocation.hasOwnProperty(location._id)) {
                    this._uniformLocation[location._id] = null;
                }
                if (this._uniformLocation[location._id] !== value) {
                    this._gl.uniform1i(location, value);
                    this._uniformLocation[location._id] = value;
                }
            };
            WebGLState.prototype.uniform1i = function (location, value) {
                this.__uniform1Scalar(location, value);
            };
            WebGLState.prototype.uniform1f = function (location, value) {
                this.__uniform1Scalar(location, value);
            };
            WebGLState.prototype.uniformMatrix4fv = function (location, transpose, value) {
                // pending remove hasOwnProperty with prior initialization
                if (!this._uniformLocation.hasOwnProperty(location._id)) {
                    this._uniformLocation[location._id] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                }
                var v0 = this._uniformLocation[location._id];
                if (v0[0] !== value[0] || v0[1] !== value[1] || v0[2] !== value[2] || v0[3] !== value[3] || v0[4] !== value[4] || v0[5] !== value[5] || v0[6] !== value[6] || v0[7] !== value[7] || v0[8] !== value[8] || v0[9] !== value[9] || v0[10] !== value[10] || v0[11] !== value[11] || v0[12] !== value[12] || v0[13] !== value[13] || v0[14] !== value[14] || v0[15] !== value[15]) {
                    this._gl.uniformMatrix4fv(location, transpose, value);
                    this._uniformLocation[location._id] = value;
                }
            };
            WebGLState.prototype.vertexAttribPointer = function (locationIndex, size, type, normalized, stride, offset) {
                /*
                            if (!this._attribPointers.hasOwnProperty(locationIndex)) {
                                this._attribPointers[locationIndex]= {
                                    size : -1,
                                    type : -1,
                                    normalized : false,
                                    stride : -1,
                                    offset : -1
                                };
                            }
                
                            var v= this._attribPointers[locationIndex];
                            if ( v.size!==size || v.type!==type || v.normalized!==normalized || v.stride!==stride || v.offset!==offset) {
                
                                v.size= size;
                                v.type= type;
                                v.normalized= normalized;
                                v.stride= stride;
                                v.offset= offset;
                
                            }
                */
                this._gl.vertexAttribPointer(locationIndex, size, type, normalized, stride, offset);
            };
            WebGLState.prototype.enableVertexAttribArray = function (locationIndex) {
                if (!this._attribArray.hasOwnProperty(locationIndex)) {
                    this._attribArray[locationIndex] = false;
                }
                if (this._attribArray[locationIndex]) {
                    return;
                }
                this._attribArray[locationIndex] = true;
                this._gl.enableVertexAttribArray(locationIndex);
            };
            WebGLState.prototype.disableVertexAttribArray = function (locationIndex) {
                if (!this._attribArray.hasOwnProperty(locationIndex)) {
                    this._attribArray[locationIndex] = false;
                }
                if (!this._attribArray[locationIndex]) {
                    return;
                }
                this._attribArray[locationIndex] = false;
                this._gl.disableVertexAttribArray(locationIndex);
            };
            WebGLState.prototype.setTexture = function (textureIndex, textureId) {
                if (textureId !== this._currentTexture) {
                    this.activeTexture(this._gl.TEXTURE0);
                    this.bindTexture(this._gl.TEXTURE_2D, textureId);
                    this._currentTexture = textureId;
                }
            };
            return WebGLState;
        })();
        render.WebGLState = WebGLState;
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="../node/Director.ts"/>
/// <reference path="../action/Action.ts"/>
/// <reference path="../action/MoveAction.ts"/>
/// <reference path="../action/TimeInterpolator.ts"/>
var cc;
(function (cc) {
    var transition;
    (function (_transition) {
        var NodeDirtyFlags = cc.node.NodeDirtyFlags;
        var MoveAction = cc.action.MoveAction;
        var Interpolator = cc.action.Interpolator;
        /**
         * @class cc.transition.Transition
         * @classdesc
         *
         * Transitions are special action groups that move in and out Scenes.
         * <br>
         * As such, only Scenes have Transtions applied, while regulars Nodes have Actions.
         * This is the preferred way for a Director to switch between scenes by calling
         * <code>director.runScene( scene, transition )</code>.
         */
        var Transition = (function () {
            /**
             * Create a new Transition
             * @method cc.transition.Transition#constructor
             * @param duration {number} transition duration in milliseconds.
             */
            function Transition(duration, scene) {
                /**
                 * Director callback for transition end events.
                 * @member cc.transition.Transition#_transitionCallback
                 * @type {cc.transition.CallbackTransitionEnd}
                 * @private
                 */
                this._transitionCallback = null;
                /**
                 * User defined callback for transition end events.
                 * @member cc.transition.Transition#_userTransitionCallback
                 * @type {cc.transition.CallbackTransitionEnd}
                 * @private
                 */
                this._userTransitionCallback = null;
                /**
                 * Transition duration in milliseconds.
                 * @member cc.transition.Transition#_duration
                 * @type {number}
                 * @private
                 */
                this._duration = 0;
                /**
                 * Transition interpolator.
                 * <br>
                 * {@link cc.action.TimeInterpolator}
                 * @member cc.transition.Transition#_interpolator
                 * @type {cc.action.TimeInterpolator}
                 * @private
                 */
                this._interpolator = Interpolator.Linear(false, false);
                /**
                 * Scene to get in. This is a V3 backwards compatibility need.
                 * In v3, Transition extends Scene.
                 * In v4, Transition does NOT extend Scene.
                 * To keep the director.runAction( Scene|Transition ) method signature, the transition must
                 * be built with a target Scene in.
                 * @member cc.transition.Transition#_sceneIn
                 * @type {cc.node.Scene}
                 * @private
                 */
                this._sceneIn = null;
                this._duration = duration;
                this._sceneIn = scene;
            }
            /**
             * Initialize the transition.
             * @method cc.transition.Transition#initialize
             * @param sceneIn {cc.node.Scene} entering scene.
             * @param sceneOut {cc.node.Scene} exiting scene
             * @returns {cc.transition.Transition} the initialized transition
             */
            Transition.prototype.initialize = function (sceneIn, sceneOut) {
                return this;
            };
            /**
             * Register director callback for transition end events.
             * @method cc.transition.Transition#onDirectorTransitionEnd
             * @param callback {cc.transition.CallbackTransitionEnd}
             * @returns {cc.transition.Transition}
             */
            Transition.prototype.onDirectorTransitionEnd = function (callback) {
                this._transitionCallback = callback;
                return this;
            };
            /**
             * Register user callback for transition end events.
             * @method cc.transition.Transition#onTransitionEnd
             * @param callback {cc.transition.CallbackTransitionEnd}
             * @returns {cc.transition.Transition}
             */
            Transition.prototype.onTransitionEnd = function (callback) {
                this._userTransitionCallback = callback;
                return this;
            };
            /**
             * Set the transition interpolator.
             * @method cc.transition.Transition#setInterpolator
             * @param i {cc.action.TimeInterpolator}
             * @returns {cc.transition.Transition}
             */
            Transition.prototype.setInterpolator = function (i) {
                this._interpolator = i;
                return this;
            };
            /**
             * Prepare the Transition Actions callbacks.
             * In a transition, only the entering scene is mandatory. For example, when the director starts and only one
             * scene slides in.
             * @method cc.transition.Transition#__setupActionCallbacks
             * @param actionIn {cc.node.Scene} enter scene.
             * @param actionOut {cc.node.Scene=} exit scene.
             * @private
             */
            Transition.prototype.__setupActionCallbacks = function (actionIn, actionOut) {
                var _this = this;
                actionIn.onStart(function (action, target) {
                    target.callOnEnter();
                });
                actionIn.onEnd(function (action, target) {
                    if (_this._transitionCallback) {
                        _this._transitionCallback(_this);
                    }
                    if (_this._userTransitionCallback) {
                        _this._userTransitionCallback(_this);
                    }
                    target.callOnEnterTransitionDidFinish();
                });
                if (actionOut) {
                    actionOut.onStart(function (action, target) {
                        target.callOnExitTransitionDidStart();
                    });
                    actionOut.onEnd(function (action, target) {
                        target.callOnExit();
                        target.__clearFlag(8 /* VISIBLE */);
                    });
                }
            };
            return Transition;
        })();
        _transition.Transition = Transition;
        /**
         * Enumeration for TransitionMove directions.
         *
         * @tsenum cc.transition.TransitionMoveDirection
         */
        (function (TransitionMoveDirection) {
            TransitionMoveDirection[TransitionMoveDirection["LEFT"] = 0] = "LEFT";
            TransitionMoveDirection[TransitionMoveDirection["RIGHT"] = 1] = "RIGHT";
            TransitionMoveDirection[TransitionMoveDirection["TOP"] = 2] = "TOP";
            TransitionMoveDirection[TransitionMoveDirection["BOTTOM"] = 3] = "BOTTOM";
        })(_transition.TransitionMoveDirection || (_transition.TransitionMoveDirection = {}));
        var TransitionMoveDirection = _transition.TransitionMoveDirection;
        /**
         * @class cc.transition.TransitionFade
         * @classdesc
         */
        var TransitionFade = (function (_super) {
            __extends(TransitionFade, _super);
            /**
             *
             * @param duration
             */
            function TransitionFade(duration, scene) {
                _super.call(this, duration, scene);
            }
            TransitionFade.prototype.initialize = function (sceneIn, sceneOut) {
                var actionIn = null;
                var actionOut = null;
                var director = null;
                sceneIn.resetScene();
                sceneIn.setAlpha(0);
                actionIn = cc.FadeIn.create(this._duration / 1000);
                if (this._interpolator) {
                    actionIn.setInterpolator(this._interpolator);
                }
                director = sceneIn.getParent();
                director._scenesActionManager.scheduleActionForNode(sceneIn, actionIn);
                if (sceneOut) {
                    sceneOut.resetScene();
                    actionOut = cc.FadeOut.create(this._duration / 1000);
                    director._scenesActionManager.scheduleActionForNode(sceneOut, actionOut);
                }
                this.__setupActionCallbacks(actionIn, actionOut);
                return this;
            };
            return TransitionFade;
        })(Transition);
        _transition.TransitionFade = TransitionFade;
        /**
         * @class cc.transition.TransitionMove
         * @classdesc
         *
         * Base Transition for Slide Transitions.
         */
        var TransitionMove = (function (_super) {
            __extends(TransitionMove, _super);
            /**
             * Transition Slide direction.
             * @member cc.transition.TransitionMove#direction
             * @type {cc.transition.TransitionMoveDirection}
             */
            /**
             * @method cc.transition.TransitionMove#constructor
             * @param duration {number} transition duration in milliseconds.
             * @param direction {cc.transition.TransitionMoveDirection}
             * @param scene {cc.node.Scene}
             */
            function TransitionMove(duration, direction, scene) {
                if (direction === void 0) { direction = 0 /* LEFT */; }
                _super.call(this, duration, scene);
                this.direction = direction;
            }
            /**
             * Initialize the transition.
             * @method cc.transition.TransitionMove#initialize
             * @override
             * @param sceneIn {cc.node.Scene} scene in.
             * @param sceneOut {cc.node.Scene} scene out.
             * @returns {cc.transition.TransitionMove}
             */
            TransitionMove.prototype.initialize = function (sceneIn, sceneOut) {
                var actionIn = null;
                var actionOut = null;
                var director = null;
                var _inX = 0;
                var _inY = 0;
                switch (this.direction) {
                    case 0 /* LEFT */:
                        _inX = -sceneIn._contentSize.width;
                        break;
                    case 1 /* RIGHT */:
                        _inX = sceneIn._contentSize.width;
                        break;
                    case 2 /* TOP */:
                        _inY = -sceneIn._contentSize.height;
                        break;
                    case 3 /* BOTTOM */:
                        _inY = sceneIn._contentSize.height;
                        break;
                }
                sceneIn.resetScene().setPosition(_inX, _inY);
                actionIn = new MoveAction({ from: { x: 0, y: 0 }, to: { x: -_inX, y: -_inY }, relative: true }).setDuration(this._duration);
                if (this._interpolator) {
                    actionIn.setInterpolator(this._interpolator);
                }
                director = sceneIn._parent;
                director._scenesActionManager.scheduleActionForNode(sceneIn, actionIn);
                if (sceneOut) {
                    sceneOut.resetScene();
                    actionOut = actionIn.clone();
                    director._scenesActionManager.scheduleActionForNode(sceneOut, actionOut);
                }
                this.__setupActionCallbacks(actionIn, actionOut);
                return this;
            };
            return TransitionMove;
        })(Transition);
        _transition.TransitionMove = TransitionMove;
        /**
         * @class cc.transition.TransitionSlideInL
         * @classdesc
         * A Transition that enters from the left. This is just some sugar to build a TransitionMove.
         */
        var TransitionSlideInL = (function (_super) {
            __extends(TransitionSlideInL, _super);
            function TransitionSlideInL(duration, scene) {
                _super.call(this, duration, 0 /* LEFT */, scene);
            }
            return TransitionSlideInL;
        })(TransitionMove);
        _transition.TransitionSlideInL = TransitionSlideInL;
        /**
         * @class cc.transition.TransitionSlideInR
         * @classdesc
         * A Transition that enters from the right. This is just some sugar to build a TransitionMove.
         */
        var TransitionSlideInR = (function (_super) {
            __extends(TransitionSlideInR, _super);
            function TransitionSlideInR(duration, scene) {
                _super.call(this, duration, 1 /* RIGHT */, scene);
            }
            return TransitionSlideInR;
        })(TransitionMove);
        _transition.TransitionSlideInR = TransitionSlideInR;
        /**
         * @class cc.transition.TransitionSlideInT
         * @classdesc
         * A Transition that enters from the top. This is just some sugar to build a TransitionMove.
         */
        var TransitionSlideInT = (function (_super) {
            __extends(TransitionSlideInT, _super);
            function TransitionSlideInT(duration, scene) {
                _super.call(this, duration, 2 /* TOP */, scene);
            }
            return TransitionSlideInT;
        })(TransitionMove);
        _transition.TransitionSlideInT = TransitionSlideInT;
        /**
         * @class cc.transition.TransitionSlideInB
         * @classdesc
         * A Transition that enters from the bottom. This is just some sugar to build a TransitionMove.
         */
        var TransitionSlideInB = (function (_super) {
            __extends(TransitionSlideInB, _super);
            function TransitionSlideInB(duration, scene) {
                _super.call(this, duration, 3 /* BOTTOM */, scene);
            }
            return TransitionSlideInB;
        })(TransitionMove);
        _transition.TransitionSlideInB = TransitionSlideInB;
    })(transition = cc.transition || (cc.transition = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../WebGLState.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        var shader;
        (function (shader) {
            "use strict";
            var idGenerator = (function () {
                var index = 0;
                return function () {
                    return index++;
                };
            })();
            /**
             * @class cc.render.shader.Uniform
             * @classdesc
             *
             * Base class for Shader uniforms.
             *
             */
            var Uniform = (function () {
                /**
                 * Uniform name
                 * @member cc.render.shader.Uniform#_name
                 * @type {string}
                 */
                /**
                 * Uniform type
                 * @member cc.render.shader.Uniform#_type
                 * @type {string}
                 */
                /**
                 * Uniform initial value.
                 * The value is not set in the shader until <code>setValue</code> is called.
                 * @member cc.render.shader.Uniform#_value
                 * @type {any}
                 */
                /**
                 * Create a new Uniform instance.
                 * @method cc.render.shader.Uniform#constructor
                 * @param _name {string}
                 * @param _type {string}
                 * @param _value {any}
                 */
                function Uniform(_name, _type, _value) {
                    this._name = _name;
                    this._type = _type;
                    this._value = _value;
                    /**
                     * Previously value set in shader's location.
                     * @member cc.render.shader.Uniform#_prevValue
                     * @type {any}
                     * @private
                     */
                    this._prevValue = null; // previous value set.
                    /**
                     * Shader program location.
                     * @member cc.render.shader.Uniform#_location
                     * @type {any}
                     * @private
                     */
                    this._location = null; // shader program location
                }
                /**
                 * Set Uniform shader location.
                 * @method cc.render.shader.Uniform#setLocation
                 * @param l {any} shader location.
                 */
                Uniform.prototype.setLocation = function (l) {
                    this._location = l;
                    // bugbug dynamic property
                    this._location._id = idGenerator();
                };
                /**
                 * Set shader location value.
                 * @method cc.render.shader.Uniform#setValue
                 * @param gl {WebGLState}
                 */
                Uniform.prototype.updateValue = function (gl) {
                    if (this._value !== this._prevValue) {
                        gl._gl["uniform" + this._type](this._location, this._value);
                        this._prevValue = this._value;
                    }
                };
                Uniform.prototype.setValue = function (v) {
                    this._value = v;
                };
                /**
                 * Create a uniform instance based on its type.
                 * @method cc.render.shader.Uniform.createUniform
                 * @param name {string} uniform name
                 * @param type {string} uniform type
                 * @param value {any} uniform value.
                 * @returns {cc.render.Uniform} A Uniform instance.
                 */
                Uniform.createUniform = function (name, type, value) {
                    if (type === "t") {
                        return new TextureUniform(name, type, value);
                    }
                    else if (type === "m4v") {
                        return new MatrixUniform(name, type, value);
                    }
                    else {
                        return new Uniform(name, type, value);
                    }
                };
                return Uniform;
            })();
            shader.Uniform = Uniform;
            /**
             * @class cc.render.shader.TextureUniform
             * @classdesc
             *
             * Create a Texture uniform.
             * Texture value is global for every shader that uses a sampler.
             *
             */
            var TextureUniform = (function (_super) {
                __extends(TextureUniform, _super);
                /**
                 * Create a TextureUniform instance.
                 * @method cc.render.shader.TextureUniform#constructor
                 * @param name {string}
                 * @param type {string}
                 * @param value {any}
                 */
                function TextureUniform(name, type, value) {
                    _super.call(this, name, type, value);
                }
                /**
                 * Set shader location value.
                 * The current texture Id is compared with an statically stored texture Id.
                 * @member cc.render.shader.TextureUniform#setValue
                 * @param gl {WebGLRenderingContext}
                 */
                TextureUniform.prototype.updateValue = function (gl) {
                    if (this._value !== this._prevValue) {
                        gl.uniform1i(this._location, this._value);
                        this._prevValue = this._value;
                    }
                };
                return TextureUniform;
            })(Uniform);
            shader.TextureUniform = TextureUniform;
            /**
             * @class cc.render.shader.MatrixUniform
             * @classdesc
             *
             * Create a Matrix uniform.
             *
             */
            var MatrixUniform = (function (_super) {
                __extends(MatrixUniform, _super);
                /**
                 * @method cc.render.shader.MatrixUniform#constructor
                 * @param name {string}
                 * @param type {string}
                 * @param value {any}
                 */
                function MatrixUniform(name, type, value) {
                    _super.call(this, name, type, value);
                    this._dirty = true;
                }
                MatrixUniform.prototype.setValue = function (v) {
                    _super.prototype.setValue.call(this, v);
                    this._dirty = true;
                };
                /**
                 * Set Shader location value.
                 * @method cc.render.shader.MatrixUniform#setValue
                 * @param gl {WebGLRenderingContext}
                 */
                MatrixUniform.prototype.updateValue = function (gl) {
                    if (this._dirty) {
                        // PENDING: componentwise matrix comparison
                        gl.uniformMatrix4fv(this._location, false, this._value);
                        this._prevValue = this._value;
                        this._dirty = false;
                    }
                };
                return MatrixUniform;
            })(Uniform);
            shader.MatrixUniform = MatrixUniform;
        })(shader = render.shader || (render.shader = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../WebGLState.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        var shader;
        (function (shader) {
            /**
             * @class cc.render.shader.Attribute
             * @classdesc
             *
             * Shader attribute.
             *
             */
            var Attribute = (function () {
                /**
                 * Attribute name.
                 * @member cc.render.shader.Attribute#_name
                 * @type {string}
                 */
                /**
                 * Attribute location.
                 * @member cc.render.shader.Attribute#_location
                 * @type {any}
                 */
                /**
                 * Create a new Attribute instance.
                 * @method cc.render.shader.Attribute#constructor
                 * @param _name {string}
                 * @param _location {any}
                 */
                function Attribute(_name, _location) {
                    this._name = _name;
                    this._location = _location;
                }
                /**
                 * Enable the shader attribute.
                 * @method cc.render.shader.Attribute#enable
                 * @param gl {WebGLRenderingContext}
                 */
                Attribute.prototype.enable = function (gl) {
                    gl.enableVertexAttribArray(this._location);
                };
                /**
                 * Disable the shader attribute.
                 * @method cc.render.shader.Attribute#disable
                 * @param gl {WebGLRenderingContext}
                 */
                Attribute.prototype.disable = function (gl) {
                    gl.disableVertexAttribArray(this._location);
                };
                return Attribute;
            })();
            shader.Attribute = Attribute;
        })(shader = render.shader || (render.shader = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./Uniform.ts"/>
/// <reference path="./Attribute.ts"/>
/// <reference path="../../math/matrix3.ts"/>
/// <reference path="../WebGLState.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        var shader;
        (function (_shader) {
            var Uniform = cc.render.shader.Uniform;
            var Attribute = cc.render.shader.Attribute;
            "use strict";
            /**
             * @class cc.render.shader.AbstractShader
             * @classdesc
             *
             * Base class for all 2D rendering shaders.
             *
             */
            var AbstractShader = (function () {
                /**
                 * WebGLState
                 * @member cc.render.shader.AbstractShader#_webglState
                 * @type {cc.render.WebGLState}
                 */
                /**
                 * Build a new AbstractShader instance.
                 * @method cc.render.shader.AbstractShader#constructor
                 * @param _webglState {WebGLState}
                 * @param shaderDefinition {cc.render.shader.AbstractShaderInitializer}
                 */
                function AbstractShader(_webglState, shaderDefinition) {
                    this._webglState = _webglState;
                    /**
                     * Collection of the shader uniform objects.
                     * @member cc.render.shader.AbstractShader#_uniforms
                     * @type {Array<cc.render.shader.Uniform>}
                     * @private
                     */
                    this._uniforms = [];
                    /**
                     * Collection of the shader attribute objects.
                     * @member cc.render.shader.AbstractShader#_attributes
                     * @type {Array<cc.render.shader.Uniform>}
                     * @private
                     */
                    this._attributes = [];
                    /**
                     * Compiled shader program.
                     * @member cc.render.shader.AbstractShader#_shaderProgram
                     * @type {any}
                     * @private
                     */
                    this._shaderProgram = null;
                    /**
                     * Shader Uniform projection matrix.
                     * @member cc.render.shader.AbstractShader#_uniformProjection
                     * @type {any}
                     * @private
                     */
                    this._uniformProjection = null;
                    this.__initializeFromShaderDefinition(shaderDefinition);
                }
                AbstractShader.prototype.enableAttributes = function () {
                    for (var i = 0; i < this._attributes.length; i++) {
                        this._attributes[i].enable(this._webglState);
                    }
                    return this;
                };
                AbstractShader.prototype.disableAttributes = function () {
                    for (var i = 0; i < this._attributes.length; i++) {
                        this._attributes[i].disable(this._webglState);
                    }
                    return this;
                };
                AbstractShader.prototype.__getShaderDef = function (def) {
                    if (Object.prototype.toString.call(def) === "[object Array]") {
                        return def.join('\n');
                    }
                    return def;
                };
                /**
                 * Initialize a shader from a shader initializer.
                 * Do not call directly. Ever.
                 * @method cc.render.shader.AbstractShader#__initializeFromShaderDefinition
                 * @param shaderDef {cc.render.shader.AbstractShaderInitializer}
                 * @private
                 */
                AbstractShader.prototype.__initializeFromShaderDefinition = function (shaderDef) {
                    var gl = this._webglState._gl;
                    this._shaderProgram = gl.createProgram();
                    gl.attachShader(this._shaderProgram, this.__getShader(gl, "x-shader/x-vertex", this.__getShaderDef(shaderDef.vertexShader)));
                    gl.attachShader(this._shaderProgram, this.__getShader(gl, "x-shader/x-fragment", this.__getShaderDef(shaderDef.fragmentShader)));
                    gl.linkProgram(this._shaderProgram);
                    if (gl.getError()) {
                        console.log(gl.getProgramInfoLog(this._shaderProgram));
                    }
                    this._webglState.useProgram(this._shaderProgram);
                    if (shaderDef.uniforms) {
                        for (var uniformName in shaderDef.uniforms) {
                            var uniformDef = shaderDef.uniforms[uniformName];
                            var type = uniformDef.type;
                            var value = uniformDef.value;
                            var uniform = Uniform.createUniform(uniformName, type, value);
                            uniform.setLocation(gl.getUniformLocation(this._shaderProgram, uniformName));
                            if (typeof value !== "undefined" && value !== null) {
                                uniform.setValue(value);
                                uniform.updateValue(this._webglState);
                            }
                            this._uniforms.push(uniform);
                        }
                    }
                    if (shaderDef.attributes) {
                        for (var i = 0; i < shaderDef.attributes.length; i++) {
                            var attribute = new Attribute(shaderDef.attributes[i], gl.getAttribLocation(this._shaderProgram, shaderDef.attributes[i]));
                            this._attributes.push(attribute);
                        }
                    }
                };
                /**
                 * Get a shader of given type.
                 * Do not call directly.
                 * @member cc.render.shader.AbstractShader#__getShader
                 * @param gl {WebGLRenderingContext}
                 * @param type {string}
                 * @param str {string}
                 * @returns {any}
                 * @private
                 */
                AbstractShader.prototype.__getShader = function (gl, type, str) {
                    var shader;
                    if (type === "x-shader/x-fragment") {
                        shader = gl.createShader(gl.FRAGMENT_SHADER);
                    }
                    else if (type === "x-shader/x-vertex") {
                        shader = gl.createShader(gl.VERTEX_SHADER);
                    }
                    else {
                        return null;
                    }
                    gl.shaderSource(shader, str);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        alert(gl.getShaderInfoLog(shader));
                        return null;
                    }
                    return shader;
                };
                /**
                 * Use this program for gpu rendering.
                 * @method cc.render.shader.AbstractShader#useProgram
                 * @returns {cc.render.shader.AbstractShader}
                 */
                AbstractShader.prototype.useProgram = function () {
                    if (this._shaderProgram !== this._webglState._currentProgram) {
                        this._webglState.useProgram(this._shaderProgram);
                        this.enableAttributes();
                    }
                };
                AbstractShader.prototype.notUseProgram = function () {
                    if (this._shaderProgram === this._webglState._currentProgram) {
                        this.disableAttributes();
                    }
                };
                /**
                 * Flush geometry.
                 * Must br overridden.
                 * @method cc.render.shader.AbstractShader#flushBuffersWithContent
                 * @param rcs {rcs:cc.render.RenderingContextSnapshot}
                 */
                AbstractShader.prototype.flushBuffersWithContent = function (rcs) {
                };
                AbstractShader.prototype.__updateUniformValues = function () {
                    for (var i = 0; i < this._uniforms.length; i++) {
                        this._uniforms[i].updateValue(this._webglState);
                    }
                };
                /**
                 * Find a uniform by name.
                 * @method cc.render.shader.AbstractShader#findUniform
                 * @param name {string}
                 * @returns {cc.render.shader.Uniform}
                 */
                AbstractShader.prototype.findUniform = function (name) {
                    for (var i = 0; i < this._uniforms.length; i++) {
                        if (this._uniforms[i]._name === name) {
                            return this._uniforms[i];
                        }
                    }
                    return null;
                };
                /**
                 * Find an attribute by name.
                 * @method cc.render.shader.AbstractShader#findAttribute
                 * @param name {string}
                 * @returns {cc.render.shader.Attribute}
                 */
                AbstractShader.prototype.findAttribute = function (name) {
                    for (var i = 0; i < this._attributes.length; i++) {
                        if (this._attributes[i]._name === name) {
                            return this._attributes[i];
                        }
                    }
                    return null;
                };
                /**
                 * Build a shader mat4 from a Matrix3 instance.
                 * @method cc.render.shader.AbstractShader#mat4_from_mat3
                 * @param mat3 {Float32Array}
                 * @param __mat4 {Float32Array}
                 * @returns {Float32Array}
                 */
                AbstractShader.prototype.mat4_from_mat3 = function (mat3, __mat4) {
                    __mat4[0] = mat3[0];
                    __mat4[4] = mat3[1];
                    __mat4[1] = mat3[3];
                    __mat4[5] = mat3[4];
                    __mat4[12] = mat3[2];
                    __mat4[13] = mat3[5];
                    return __mat4;
                };
                return AbstractShader;
            })();
            _shader.AbstractShader = AbstractShader;
        })(shader = render.shader || (render.shader = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./AbstractShader.ts"/>
/// <reference path="../webGLState.ts"/>
/// <reference path="../../util/util.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        var shader;
        (function (shader) {
            "use strict";
            var AbstractShader = cc.render.shader.AbstractShader;
            /**
             * @class cc.render.shader.SolidColorShader
             * @classdesc
             *
             * This shader fills geometry with a solid color.
             *
             */
            var SolidColorShader = (function (_super) {
                __extends(SolidColorShader, _super);
                /**
                 * Build a new SolidColorShader instance.
                 * @method cc.render.shader.SolidColorShader#constructor
                 * @param gl {WebGLRenderingContext} gl context
                 * @param ortho {Float32Array} projection matrix.
                 */
                function SolidColorShader(gl) {
                    _super.call(this, gl, {
                        vertexShader: "" + "attribute vec2 aPosition; \n" + "attribute vec4 aColor; \n" + "uniform mat4 uProjection; \n" + "uniform mat4 uTransform; \n" + "varying vec4 vAttrColor; \n" + "void main(void) { \n" + "gl_Position = uProjection * uTransform * vec4( aPosition.x, aPosition.y, 0.0, 1.0 );\n" + "vAttrColor = aColor;\n" + "}\n",
                        fragmentShader: "precision mediump float; \n" + "varying vec4 vAttrColor;\n" + "void main(void) { \n" + "  gl_FragColor = vAttrColor; \n" + "}\n",
                        uniforms: {
                            "uProjection": {
                                type: "m4v",
                                value: [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]
                            },
                            "uTransform": {
                                type: "m4v",
                                value: [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]
                            }
                        },
                        attributes: ["aPosition", "aColor"]
                    });
                    /**
                     * Shader Uniform transformation matrix.
                     * @member cc.render.shader.SolidColorShader#_uniformTransform
                     * @type {any}
                     * @private
                     */
                    this._uniformTransform = null;
                    /**
                     * Shader geometry attribute.
                     * @member cc.render.shader.SolidColorShader#_attributePosition
                     * @type {any}
                     * @private
                     */
                    this._attributePosition = null;
                    /**
                     * Shader texture coords attribute. Not used in this shader.
                     * @member cc.render.shader.SolidColorShader#_attributeTexture
                     * @type {any}
                     * @private
                     */
                    //_attributeTexture:any = null;
                    /**
                     * Shader geometry color attribute.
                     * @member cc.render.shader.SolidColorShader#_attributeColor
                     * @type {any}
                     * @private
                     */
                    this._attributeColor = null;
                    this._uniformProjection = this.findUniform("uProjection");
                    this._uniformTransform = this.findUniform("uTransform");
                    this._attributePosition = this.findAttribute("aPosition");
                    this._attributeColor = this.findAttribute("aColor");
                    SolidColorShader.mat.set([1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]);
                }
                SolidColorShader.prototype.flushBuffersWithContent = function (rcs) {
                    this.__updateUniformValues();
                    var gl = this._webglState;
                    gl.vertexAttribPointer(this._attributePosition._location, 2, gl._gl.FLOAT, false, 12, 0);
                    gl.vertexAttribPointer(this._attributeColor._location, 4, gl._gl.UNSIGNED_BYTE, true, 12, 2 * 4);
                };
                /**
                 * Spare matrix
                 * @member cc.render.shader.SolidColorShader.mat
                 * @type {Float32Array}
                 */
                SolidColorShader.mat = new Float32Array(16);
                return SolidColorShader;
            })(AbstractShader);
            shader.SolidColorShader = SolidColorShader;
        })(shader = render.shader || (render.shader = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * Created by ibon on 11/17/14.
 */
/// <reference path="./AbstractShader.ts"/>
/// <reference path="../WebGLState.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        var shader;
        (function (shader) {
            var AbstractShader = cc.render.shader.AbstractShader;
            /**
             * @class cc.render.shader.TextureShader
             * @extends AbstractShader
             * @classdesc
             *
             * This shader fills rects with an image. It is expected to be invoked by calls to drawImage.
             *
             */
            var TextureShader = (function (_super) {
                __extends(TextureShader, _super);
                function TextureShader(gl) {
                    _super.call(this, gl, {
                        vertexShader: "" + "attribute vec2 aPosition; \n" + "attribute vec4 aColor; \n" + "attribute vec2 aTexture; \n" + "uniform mat4 uProjection; \n" + "varying vec2 vTextureCoord; \n" + "varying vec4 vAttrColor; \n" + "void main(void) { \n" + "gl_Position = uProjection * vec4( aPosition.x, aPosition.y, 0.0, 1.0 );\n" + "vTextureCoord = aTexture;\n" + "vAttrColor = aColor;\n" + "}\n",
                        fragmentShader: "" + "precision mediump float; \n" + "varying vec2 vTextureCoord; \n" + "uniform sampler2D uTextureSampler; \n" + "varying vec4 vAttrColor;\n" + "void main(void) { \n" + "  vec4 textureColor= texture2D(uTextureSampler, vec2(vTextureCoord)); \n" + "  gl_FragColor = textureColor * vAttrColor; \n" + "}\n",
                        attributes: ["aPosition", "aColor", "aTexture"],
                        uniforms: {
                            "uProjection": {
                                type: "m4v",
                                value: [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]
                            },
                            "uTextureSampler": {
                                type: "t",
                                value: null
                            }
                        }
                    });
                    /**
                     * Shader Uniform transformation matrix.
                     * @member cc.render.shader.SolidColorShader#_uniformTransform
                     * @type {any}
                     * @private
                     */
                    this._uniformTransform = null;
                    /**
                     * Shader Uniform for texture.
                     * @member cc.render.shader.SolidColorShader#_uniformTextureSampler
                     * @type {any}
                     * @private
                     */
                    this._uniformTextureSampler = null;
                    /**
                     * Shader geometry attribute.
                     * @member cc.render.shader.SolidColorShader#_attributePosition
                     * @type {any}
                     * @private
                     */
                    this._attributePosition = null;
                    /**
                     * Shader geometry attribute.
                     * @member cc.render.shader.SolidColorShader#_attributeTexture
                     * @type {any}
                     * @private
                     */
                    this._attributeTexture = null;
                    /**
                     * Shader geometry color attribute.
                     * @member cc.render.shader.SolidColorShader#_attributeColor
                     * @type {any}
                     * @private
                     */
                    this._attributeColor = null;
                    this._uniformTextureSampler = this.findUniform("uTextureSampler");
                    this._uniformProjection = this.findUniform("uProjection");
                    this._attributePosition = this.findAttribute("aPosition");
                    this._attributeColor = this.findAttribute("aColor");
                    this._attributeTexture = this.findAttribute("aTexture");
                    TextureShader.mat[0] = 1.0;
                    TextureShader.mat[5] = 1.0;
                    TextureShader.mat[10] = 1.0;
                    TextureShader.mat[15] = 1.0;
                    return this;
                }
                TextureShader.prototype.flushBuffersWithContent = function (rcs) {
                    this.__updateUniformValues();
                    var gl = this._webglState;
                    gl.vertexAttribPointer(this._attributePosition._location, 2, gl._gl.FLOAT, false, 5 * 4, 0);
                    gl.vertexAttribPointer(this._attributeColor._location, 4, gl._gl.UNSIGNED_BYTE, true, 5 * 4, 2 * 4);
                    gl.vertexAttribPointer(this._attributeTexture._location, 2, gl._gl.FLOAT, false, 5 * 4, 3 * 4);
                };
                /**
                 * Spare matrix
                 * @member cc.render.shader.TextureShader.mat
                 * @type {Float32Array}
                 */
                TextureShader.mat = new Float32Array(16);
                return TextureShader;
            })(AbstractShader);
            shader.TextureShader = TextureShader;
            /**
             * @class cc.render.shader.MeshShader
             * @extends AbstractShader
             * @classdesc
             *
             * This shader fills rects with an image. It is expected to be invoked by calls to drawImage.
             *
             */
            var MeshShader = (function (_super) {
                __extends(MeshShader, _super);
                function MeshShader(gl) {
                    _super.call(this, gl, {
                        vertexShader: "" + "attribute vec2 aPosition; \n" + "attribute vec2 aTexture; \n" + "uniform mat4 uProjection; \n" + "uniform mat4 uTransform; \n" + "varying vec2 vTextureCoord; \n" + "void main(void) { \n" + "gl_Position = uProjection * uTransform * vec4( aPosition.x, aPosition.y, 0.0, 1.0 );\n" + "vTextureCoord = aTexture;\n" + "}\n",
                        fragmentShader: "" + "precision mediump float; \n" + "varying vec2 vTextureCoord; \n" + "uniform sampler2D uTextureSampler; \n" + "uniform vec4 uColor; \n" + "void main(void) { \n" + "  vec4 textureColor= texture2D(uTextureSampler, vec2(vTextureCoord)); \n" + "  gl_FragColor = textureColor * (uColor/255.0); \n" + "}\n",
                        attributes: ["aPosition", "aTexture"],
                        uniforms: {
                            "uProjection": {
                                type: "m4v",
                                value: [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]
                            },
                            "uTransform": {
                                type: "m4v",
                                value: [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]
                            },
                            "uTextureSampler": {
                                type: "t",
                                value: null
                            },
                            "uColor": {
                                type: "4fv",
                                value: [1.0, 1.0, 1.0, 1.0]
                            }
                        }
                    });
                    /**
                     * Shader Uniform transformation matrix.
                     * @member cc.render.shader.MeshShader#_uniformTransform
                     * @type {any}
                     * @private
                     */
                    this._uniformTransform = null;
                    /**
                     * Shader Uniform for texture.
                     * @member cc.render.shader.MeshShader#_uniformTextureSampler
                     * @type {any}
                     * @private
                     */
                    this._uniformTextureSampler = null;
                    /**
                     * Shader geometry attribute.
                     * @member cc.render.shader.MeshShader#_attributePosition
                     * @type {any}
                     * @private
                     */
                    this._attributePosition = null;
                    /**
                     * Shader geometry attribute.
                     * @member cc.render.shader.MeshShader#_attributeTexture
                     * @type {any}
                     * @private
                     */
                    this._attributeTexture = null;
                    /**
                     * Shader geometry color attribute.
                     * @member cc.render.shader.MeshShader#_uniformColor
                     * @type {any}
                     * @private
                     */
                    this._uniformColor = null;
                    this._uniformTextureSampler = this.findUniform("uTextureSampler");
                    this._uniformProjection = this.findUniform("uProjection");
                    this._uniformTransform = this.findUniform("uTransform");
                    this._uniformColor = this.findUniform("uColor");
                    this._attributePosition = this.findAttribute("aPosition");
                    this._attributeTexture = this.findAttribute("aTexture");
                    TextureShader.mat[0] = 1.0;
                    TextureShader.mat[5] = 1.0;
                    TextureShader.mat[10] = 1.0;
                    TextureShader.mat[15] = 1.0;
                    return this;
                }
                MeshShader.prototype.flushBuffersWithContent = function (rcs) {
                    this.__updateUniformValues();
                    var gl = this._webglState;
                    gl.vertexAttribPointer(this._attributePosition._location, 2, gl._gl.FLOAT, false, 4 * 4, 0);
                    gl.vertexAttribPointer(this._attributeTexture._location, 2, gl._gl.FLOAT, false, 4 * 4, 2 * 4);
                };
                /**
                 * Spare matrix
                 * @member cc.render.shader.TextureShader.mat
                 * @type {Float32Array}
                 */
                MeshShader.mat = new Float32Array(16);
                return MeshShader;
            })(AbstractShader);
            shader.MeshShader = MeshShader;
        })(shader = render.shader || (render.shader = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./AbstractShader.ts"/>
/// <reference path="../webGLState.ts"/>
/// <reference path="../../util/util.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        var shader;
        (function (shader) {
            function __getPatternFragmentShader() {
                return [
                    "precision mediump float;",
                    "uniform vec4 uPatternImageBounds;",
                    "uniform sampler2D uSampler;",
                    "varying vec2 v_texCoord;",
                    "varying vec4 vColor;",
                    "void main() {",
                    "    gl_FragColor = texture2D(uSampler, mod(v_texCoord,(uPatternImageBounds.zw-uPatternImageBounds.xy))+ uPatternImageBounds.xy ) * vColor;",
                    "}"
                ];
            }
            var TexturePatternShader = (function (_super) {
                __extends(TexturePatternShader, _super);
                function TexturePatternShader(gl) {
                    _super.call(this, gl, {
                        vertexShader: [
                            "precision mediump float;",
                            "attribute vec2 aPosition;",
                            "attribute vec4 aColor;",
                            "uniform vec4 uPatternImageBounds;",
                            "uniform vec2 uPatternBounds;",
                            "uniform mat4 uProjection;",
                            "uniform mat4 uTransform;",
                            "uniform mat4 uPatternTransform;",
                            "varying vec2 v_texCoord;",
                            "varying vec4 vColor;",
                            "void main(void) {",
                            "vec4 avp= vec4( aPosition, 0, 1);",
                            "gl_Position = uProjection * uTransform * avp;",
                            "v_texCoord = (uPatternTransform * avp).xy / uPatternBounds * (uPatternImageBounds.zw-uPatternImageBounds.xy);",
                            "vColor= aColor;",
                            "}"
                        ],
                        fragmentShader: __getPatternFragmentShader(),
                        uniforms: {
                            "uPatternImageBounds": {
                                type: "4fv",
                                value: [0, 0, 0, 0]
                            },
                            "uPatternBounds": {
                                type: "2fv",
                                value: [0, 0]
                            },
                            "uProjection": {
                                type: "m4v",
                                value: [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]
                            },
                            "uTransform": {
                                type: "m4v",
                                value: [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]
                            },
                            "uPatternTransform": {
                                type: "m4v",
                                value: [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]
                            },
                            "uSampler": {
                                type: "t",
                                value: null
                            }
                        },
                        attributes: ["aPosition", "aColor"]
                    });
                    /**
                     * Shader Uniform transformation matrix.
                     * @member cc.render.shader.TexturePatternShader#_uniformTransform
                     * @type {any}
                     * @private
                     */
                    this._uniformTransform = null;
                    this._uniformPatternTransform = null;
                    this._uniformPatternImageBounds = null;
                    this._uniformPatternBounds = null;
                    /**
                     * Shader geometry attribute.
                     * @member cc.render.shader.TexturePatternShader#_attributePosition
                     * @type {any}
                     * @private
                     */
                    this._attributePosition = null;
                    /**
                     * Shader geometry color attribute.
                     * @member cc.render.shader.TexturePatternShader#_attributeColor
                     * @type {any}
                     * @private
                     */
                    this._attributeColor = null;
                    this._uniformProjection = this.findUniform("uProjection");
                    this._uniformTransform = this.findUniform("uTransform");
                    this._uniformPatternTransform = this.findUniform("uTransform");
                    this._uniformPatternImageBounds = this.findUniform("uPatternImageBounds");
                    this._uniformPatternBounds = this.findUniform("uPatternBounds");
                    this._attributePosition = this.findAttribute("aPosition");
                    this._attributeColor = this.findAttribute("aColor");
                    TexturePatternShader.mat.set([1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]);
                }
                TexturePatternShader.prototype.flushBuffersWithContent = function (rcs) {
                    this.__updateUniformValues();
                    var gl = this._webglState;
                    gl.vertexAttribPointer(this._attributePosition._location, 2, gl._gl.FLOAT, false, 3 * 4, 0);
                    gl.vertexAttribPointer(this._attributeColor._location, 4, gl._gl.FLOAT, false, 3 * 4, 2 * 4);
                };
                TexturePatternShader.mat = new Float32Array(16);
                return TexturePatternShader;
            })(shader.AbstractShader);
            shader.TexturePatternShader = TexturePatternShader;
        })(shader = render.shader || (render.shader = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./AbstractShader.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        var shader;
        (function (shader) {
            var FastTextureShader = (function (_super) {
                __extends(FastTextureShader, _super);
                function FastTextureShader(gl) {
                    _super.call(this, gl, {
                        vertexShader: "" + "precision lowp float; \n" + "attribute vec2 aPosition; \n" + "attribute vec4 aColor; \n" + "attribute vec2 aTexture; \n" + "attribute vec2 aAnchorPosition; \n" + "attribute float aRotation; \n" + "attribute vec2 aScale; \n" + "uniform mat4 uProjection; \n" + "varying vec2 vTextureCoord; \n" + "varying vec4 vAttrColor; \n" + "void main(void) { \n" + "vec2 v;\n" + "vec2 sv = aAnchorPosition * aScale; \n" + "float _rotation= aRotation * 0.017453292519943295;\n" + " v.x = sv.x * cos(_rotation) - sv.y * sin(_rotation); \n" + " v.y = sv.x * sin(_rotation) + sv.y * cos(_rotation); \n" + "gl_Position = uProjection * vec4( v + aPosition, 0.0, 1.0 );\n" + "vTextureCoord = aTexture;\n" + "vAttrColor = aColor;\n" + "}\n",
                        fragmentShader: "" + "precision lowp float; \n" + "varying vec2 vTextureCoord; \n" + "uniform sampler2D uTextureSampler; \n" + "varying vec4 vAttrColor;\n" + "void main(void) { \n" + "  gl_FragColor = texture2D(uTextureSampler,vTextureCoord) * vAttrColor; \n" + "}\n",
                        attributes: ["aPosition", "aColor", "aTexture", "aAnchorPosition", "aRotation", "aScale"],
                        uniforms: {
                            "uProjection": {
                                type: "m4v",
                                value: [1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0]
                            },
                            "uTextureSampler": {
                                type: "t",
                                value: null
                            }
                        }
                    });
                    /**
                     * Shader Uniform transformation matrix.
                     * @member cc.render.shader.SolidColorShader#_uniformTransform
                     * @type {any}
                     * @private
                     */
                    this._uniformTransform = null;
                    /**
                     * Shader Uniform for texture.
                     * @member cc.render.shader.SolidColorShader#_uniformTextureSampler
                     * @type {any}
                     * @private
                     */
                    this._uniformTextureSampler = null;
                    /**
                     * Shader geometry attribute.
                     * @member cc.render.shader.SolidColorShader#_attributePosition
                     * @type {any}
                     * @private
                     */
                    this._attributePosition = null;
                    /**
                     * Shader geometry attribute.
                     * @member cc.render.shader.SolidColorShader#_attributeTexture
                     * @type {any}
                     * @private
                     */
                    this._attributeTexture = null;
                    /**
                     * Shader geometry color attribute.
                     * @member cc.render.shader.SolidColorShader#_attributeColor
                     * @type {any}
                     * @private
                     */
                    this._attributeColor = null;
                    this._attributeAnchorPosition = null;
                    this._attributeRotation = null;
                    this._attributeScale = null;
                    this._uniformTextureSampler = this.findUniform("uTextureSampler");
                    this._uniformProjection = this.findUniform("uProjection");
                    this._attributePosition = this.findAttribute("aPosition");
                    this._attributeColor = this.findAttribute("aColor");
                    this._attributeTexture = this.findAttribute("aTexture");
                    this._attributeAnchorPosition = this.findAttribute("aAnchorPosition");
                    this._attributeRotation = this.findAttribute("aRotation");
                    this._attributeScale = this.findAttribute("aScale");
                    FastTextureShader.mat[0] = 1.0;
                    FastTextureShader.mat[5] = 1.0;
                    FastTextureShader.mat[10] = 1.0;
                    FastTextureShader.mat[15] = 1.0;
                    return this;
                }
                FastTextureShader.prototype.flushBuffersWithContent = function () {
                    this.__updateUniformValues();
                    var gl = this._webglState;
                    gl.vertexAttribPointer(this._attributePosition._location, 2, gl._gl.FLOAT, false, 10 * 4, 0);
                    gl.vertexAttribPointer(this._attributeColor._location, 4, gl._gl.UNSIGNED_BYTE, true, 10 * 4, 2 * 4);
                    gl.vertexAttribPointer(this._attributeTexture._location, 2, gl._gl.FLOAT, false, 10 * 4, 3 * 4);
                    gl.vertexAttribPointer(this._attributeAnchorPosition._location, 2, gl._gl.FLOAT, false, 10 * 4, 5 * 4);
                    gl.vertexAttribPointer(this._attributeRotation._location, 1, gl._gl.FLOAT, false, 10 * 4, 7 * 4);
                    gl.vertexAttribPointer(this._attributeScale._location, 2, gl._gl.FLOAT, false, 10 * 4, 8 * 4);
                };
                /**
                 * Spare matrix
                 * @member cc.render.shader.TextureShader.mat
                 * @type {Float32Array}
                 */
                FastTextureShader.mat = new Float32Array(16);
                return FastTextureShader;
            })(shader.AbstractShader);
            shader.FastTextureShader = FastTextureShader;
        })(shader = render.shader || (render.shader = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * Created by ibon on 11/19/14.
 */
var cc;
(function (cc) {
    var render;
    (function (render) {
        var shader;
        (function (shader) {
            (function () {
                console.log("Buffers: in bufferData mode with whole buffer.");
            })();
            var Buffer = (function () {
                function Buffer(_gl, _type, initialValue, usage) {
                    this._gl = _gl;
                    this._type = _type;
                    this._buffer = null;
                    this._prevValue = null;
                    this._usage = usage;
                    //this._usage= _gl.STATIC_DRAW;
                    this._buffer = _gl.createBuffer();
                    if (initialValue) {
                        this._gl.bindBuffer(_type, this._buffer);
                        this._gl.bufferData(_type, initialValue, usage);
                    }
                }
                /**
                 *
                 * @param gl {WebGLRenderingContext}
                 * @param v {Float32Array|UInt16Array}
                 */
                Buffer.prototype.enableWithValue = function (v) {
                    this._gl.bindBuffer(this._type, this._buffer);
                    //if ( this._prevValue!==v ) {
                    //    this._gl.bufferData( this._type, v, this._usage );
                    this._gl.bufferSubData(this._type, 0, v);
                    //this._prevValue= v;
                    //}
                };
                Buffer.prototype.forceEnableWithValue = function (v) {
                    this._gl.bindBuffer(this._type, this._buffer);
                    //this._gl.bufferData( this._type, v, this._usage );
                    this._gl.bufferSubData(this._type, 0, v);
                };
                Buffer.prototype.bind = function (type) {
                    this._gl.bindBuffer(type, this._buffer);
                };
                return Buffer;
            })();
            shader.Buffer = Buffer;
        })(shader = render.shader || (render.shader = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../math/Dimension.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="./RenderingContext.ts"/>
/// <reference path="./ScaleManager.ts"/>
/// <reference path="./Texture2D.ts"/>
/// <reference path="./DecoratedWebGLRenderingContext.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="../plugin/asset/AssetManager.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        "use strict";
        render.ORIGIN_BOTTOM = 1;
        render.ORIGIN_TOP = 0;
        /**
         * This flag sets renderer's y axis origin to be on top or bottom (y axis increases up or downwards.
         * <p>
         * Bottom is default's open/webgl while top is canvas' default.
         * <li>The default for CocosJS engine is bottom
         * <li>Setting this flag will affect both renderer types.
         * <li>This flag must be set BEFORE creating a renderer object.
         * <p>
         *     Performance considerations.
         * <p>
         *     While changing this flag for a WebGL renderer has no impact in performance, this is not the case for Canvas.
         *     If (as it is by default) bottom is specified for the renderer origin, there's an important performance penalty.
         *     This is mainly due to the fact that for each node, its coordinate system must be inverted, and thus an extra
         *     call to concatenate the current transformation matrix with the inversion matrix must be performed.
         *     In my MBA (core i7 dual core 2Ghz), with 3000 sprites in canvas the difference can be up to 8 fps. <br>
         *     There could be some solutions to avoid this extra transformation call though:
         *     <li>Invert all your images at compile time. Images are already flipped vertically before loading.
         *     <li>Invert all your images at load time. Extra memory, and extra bootstrapping time.
         *     <li>Change the y axis orientation to cc.render.ORIGIN_BOTTOM, and avoid the extra call. This will work for both canvas and
         *         webgl rendering.
         * <p>
         *     In either case, right now, the system DOES apply the extra transformation, and the performance penalty is
         *     there.
         * <p>
         *     It is also important to note that the local coordinate system y-axis will for each node be positioned as well
         *     either at the top or the bottom of the node itself.
         *
         * @member cc.render.RENDER_ORIGIN
         * @type {number}
         */
        render.RENDER_ORIGIN = cc.render.ORIGIN_BOTTOM;
        function autodetectRenderer(w, h, elem) {
            w = w || 800;
            h = h || 600;
            // BORROWED from Mr Doob (mrdoob.com)
            var webgl = (function () {
                var canvas = document.createElement("canvas");
                try {
                    return !!(typeof window.WebGLRenderingContext !== "undefined") && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                }
                catch (e) {
                    return false;
                }
            })();
            if (webgl) {
                return new cc.render.WebGLRenderer(w, h, document.getElementById(elem));
            }
            return new cc.render.CanvasRenderer(w, h, document.getElementById(elem));
        }
        render.autodetectRenderer = autodetectRenderer;
        var Dimension = cc.math.Dimension;
        /**
         * @class cc.render.Renderer
         * @classdesc
         *
         * Interface for any renderer.
         * Must be subclassed to build a canvas or gl renderer.
         *
         */
        var Renderer = (function () {
            /**
             * Create a new Renderer instance.
             * @param w {width} surface pixels width
             * @param h {height} surface pixels height
             * @param surface {HTMLCanvasElement=} canvas object. @see {cc.render.Renderer#initialize}
             * @member cc.render.Renderer#constructor
             */
            function Renderer(w, h, surface) {
                /**
                 * Surface to render to.
                 * @member cc.render.Renderer#_surface
                 * @type {HTMLCanvasElement}
                 * @private
                 */
                this._surface = null;
                /**
                 * Rendering context to render on the surface.
                 * @member cc.render.Renderer#_renderingContext
                 * @type {cc.render.RenderingContext}
                 * @private
                 */
                this._renderingContext = null;
                this._dimension = new Dimension();
                this._addedToDOM = false;
                this._scaleManager = null;
                this._onContentScaled = null;
                /**
                 * When scale content is enabled, this flag makes the canvas object to take over the whole screen and not
                 * only the area that honors aspect ratio.
                 * @member cc.render.Renderer#_adjustContentToFullScreen
                 * @type {boolean}
                 * @private
                 */
                this._adjustContentToFullScreen = false;
                this._preferredUnits = null;
                this._sceneHint = 16 /* CENTER */;
                this._surface = typeof surface !== "undefined" ? surface : document.createElement("canvas");
                this._surface.width = typeof w !== "undefined" ? w : 800;
                this._surface.height = typeof h !== "undefined" ? h : 600;
                this._preferredUnits = new Dimension();
                this._preferredUnits.set(w, h);
                this._dimension.set(w, h);
                var me = this;
                this._scaleManager = new cc.render.ScaleManager(this).onWindowResized(function (w, h) {
                    var uw = me._scaleManager._units.width;
                    var uh = me._scaleManager._units.height;
                    if (me._adjustContentToFullScreen) {
                        w = window.innerWidth;
                        h = window.innerHeight;
                    }
                    // preferred dimensions
                    me.setScaleContent(uw, uh, w, h);
                });
                this._addedToDOM = surface ? true : false;
            }
            Renderer.prototype.__calcPreferredUnits = function () {
                var d = new cc.math.Dimension();
                var units = this.getScaleManager()._units;
                if (this.getScaleManager()._contentScaled) {
                    var ratio = Math.min(window.innerWidth / units.width, window.innerHeight / units.height);
                    d.width = window.innerWidth / ratio;
                    d.height = window.innerHeight / ratio;
                }
                else {
                    d.width = units.width;
                    d.height = units.height;
                }
                this._preferredUnits.set(d.width, d.height);
                return d;
            };
            Renderer.prototype.adjustContentToFullScreen = function (hint) {
                this._adjustContentToFullScreen = true;
                this._sceneHint = hint;
                return this;
            };
            Renderer.prototype.onContentScaled = function (callback) {
                this._onContentScaled = callback;
                return this;
            };
            Renderer.prototype.isAddedToDOM = function () {
                return this._addedToDOM;
            };
            Renderer.prototype.addToDOM = function () {
                if (!this.isAddedToDOM()) {
                    document.body.appendChild(this._surface);
                    this._addedToDOM = true;
                }
            };
            /**
             * Get the rendering context. @see {cc.render.Renderer#getRenderingContext}
             * @method cc.render.Renderer#getRenderingContext
             * @returns {cc.render.RenderingContext}
             */
            Renderer.prototype.getRenderingContext = function () {
                return this._renderingContext;
            };
            /**
             * Render a node. @see {cc.render.Renderer#render}
             * @method cc.render.Renderer#render
             */
            Renderer.prototype.render = function (node) {
                node.visit(this._renderingContext);
            };
            /**
             * Flush this renderer (push remaining content to the scene).
             * @method cc.render.Renderer#flush
             */
            Renderer.prototype.flush = function () {
                this._renderingContext.flush();
            };
            Renderer.prototype.getContentSize = function () {
                return this._dimension.clone();
            };
            Renderer.prototype.prepareTexture = function (texture) {
            };
            Renderer.prototype.getScaleContentMatrix = function () {
                return this._scaleManager.getScaleContentMatrix();
            };
            /**
             * Return the internal scale management object.
             * This object handles all things relative to Renderer surface scale and on-screen positioning, as well as
             * orientation changes and content scale ratio calculations.
             * @method cc.node.Director#getScaleManager
             * @see cc.game.ScaleManager
             * @returns {cc.render.ScaleManager}
             */
            Renderer.prototype.getScaleManager = function () {
                return this._scaleManager;
            };
            /**
             * Set renderer surface scale strategy.
             * @method cc.node.Director#setScaleStrategy
             * @param ss {cc.render.ScaleManagerStrategy} how renderer surface should me up/down scaled when the window
             *          changes size.
             * @param sp {cc.render.ScalePosition} how to position the renderer surface on the window object.
             */
            Renderer.prototype.setScaleStrategy = function (ss, sp) {
                this._scaleManager.setScale(ss, sp);
            };
            /**
             * Set internal ratio to adjust screen pixels to game units.
             * A game, usually makes the assumption that one game unit maps directly to one screen pixel.
             * When we want to build better looking games which honor devicePixelRation, retina, etc. we need to undo
             * this direct assumption in favor of other better mechanisms.
             * This method undoes this mapping.
             * For example, my game is 8 by 5 meters and want to see it in a 960x640 pixels screen.
             * The difference between this method and <code>setScaleStrategy</code> is that this one acts in game content,
             * and setScaleStrategy on the renderer generated image.
             * @method cc.node.Director#setScaleContent
             * @see cc.game.ScaleManager
             * @param w {number} game units width
             * @param h {number} game units height
             * @param cw {number=} canvas width
             * @param ch {number=} canvas height
             * @return {number} the scale factor resulting from the map units-pixels.
             */
            Renderer.prototype.setScaleContent = function (w, h, cw, ch) {
                if (typeof cw !== "undefined" && typeof ch !== "undefined") {
                    // resize canvas size keeping aspect ratio relative to units size.
                    if (cw / ch > w / h) {
                        cw = w * ch / h + 1;
                    }
                    else {
                        ch = cw * h / w + 1;
                    }
                    cw = Math.ceil(cw);
                    ch = Math.ceil(ch);
                    if (this._adjustContentToFullScreen) {
                        cw = window.innerWidth;
                        ch = window.innerHeight;
                    }
                    // resize canvas object
                    this.__resize(cw >> 0, ch >> 0);
                }
                // make calcs for new unit-pixel ratio (w,h)
                this._scaleManager.setScaleContent(w, h);
                // calculate preferred units for the current canvas size
                this.__calcPreferredUnits();
                var ret = this._scaleManager.getUnitsFactor();
                if (this._onContentScaled) {
                    this._onContentScaled(w, h, this._preferredUnits.width, this._preferredUnits.height, cw, ch, this._sceneHint);
                }
                return ret;
            };
            /**
             * When <code>setScaleContent</code> has been called this method gives the scale factor for the units-pixel
             * mapping ratio.
             * @method cc.node.Director#getUnitsFactor
             * @returns {number}
             */
            Renderer.prototype.getUnitsFactor = function () {
                return this._scaleManager.getUnitsFactor();
            };
            /**
             * Set renderer surface orientation strategy. If set to landscape or portrait, when the window changes size
             * will notify about valid or wrong orientation.
             * Default orientation is set to BOTH.
             * @method cc.node.Director#setOrientationStrategy
             * @param os {cc.render.OrientationStrategy} desired orientation.
             * @param onOk {cc.render.OrientationCallback}
             * @param onError {cc.render.OrientationCallback}
             */
            Renderer.prototype.setOrientationStrategy = function (os, onOk, onError) {
                this._scaleManager.forceOrientation(os, onOk, onError);
            };
            /**
             * Get whether the device has fullScreen capabilities
             * @method cc.node.Director#isFullScreenCapable
             * @returns {boolean}
             */
            Renderer.prototype.isFullScreenCapable = function () {
                return this._scaleManager.isFullScreenCapable();
            };
            /**
             * Is currently the system in full screen ?
             * @method cc.node.Director#isFullScreen
             * @returns {boolean}
             */
            Renderer.prototype.isFullScreen = function () {
                return this._scaleManager.isFullScreen();
            };
            /**
             * Start full screen process. If the system is not full screen capable will silently fail.
             * @method cc.node.Director#startFullScreen
             * @param f {callback=} optional function called when the system enters full screen.
             */
            Renderer.prototype.startFullScreen = function (f) {
                this._scaleManager.startFullScreen(f);
            };
            /**
             * End full screen process. If the system is not full screen capable will silently fail.
             * @method cc.node.Director#endFullScreen
             * @param f {callback=} optional function called when the system enters full screen.
             */
            Renderer.prototype.endFullScreen = function (f) {
                this._scaleManager.endFullScreen(f);
            };
            Renderer.prototype.forceOrientation = function (os, onOk, onError) {
                return this._scaleManager.forceOrientation(os, onOk, onError);
            };
            Renderer.prototype.checkOrientation = function () {
                return this._scaleManager.checkOrientation();
            };
            Renderer.prototype.__resize = function (w, h) {
                this._surface.width = w;
                this._surface.height = h;
                this._dimension.width = w;
                this._dimension.height = h;
            };
            Renderer.prototype.getType = function () {
                return cc.render.RENDERER_TYPE_CANVAS;
            };
            return Renderer;
        })();
        render.Renderer = Renderer;
        function dc2d(renderer) {
            var canvas = renderer._surface;
            var c2d = canvas.getContext("2d");
            var globalAlpha = 1;
            var globalCompositeOperation = 0 /* source_over */;
            c2d.flush = function () {
                this.setTransform(1, 0, 0, 1, 0, 0);
            };
            c2d.type = cc.render.RENDERER_TYPE_CANVAS;
            //Object.defineProperty(c2d, "type", {
            //    get: function () {
            //        return cc.render.RENDERER_TYPE_CANVAS;
            //    },
            //    enumerable: true,
            //    configurable: true
            //});
            c2d.setFillStyleColor = function (color) {
                this.fillStyle = color.getFillStyle();
            };
            c2d.setFillStyleColorArray = function (colorArray) {
                this.fillStyle = new cc.math.Color(colorArray[0], colorArray[1], colorArray[2], colorArray[3]).getFillStyle();
            };
            // BUGBUG canvas can only do fill pattern with whole images.
            c2d.setFillStylePattern = function (pattern) {
                var _pattern = this.createPattern(pattern.texture._image, pattern.type);
                this.fillStyle = _pattern;
            };
            c2d.setTintColor = function (color) {
                // useless for canvas.
            };
            c2d.clear = function () {
                this.setTransform(1, 0, 0, 1, 0, 0);
                this.clearRect(0, 0, this.getWidth(), this.getHeight());
            };
            c2d.getUnitsFactor = function () {
                return renderer.getUnitsFactor();
            };
            c2d.getWidth = function () {
                return this.canvas.width;
            };
            c2d.getHeight = function () {
                return this.canvas.height;
            };
            c2d.setCompositeOperation = function (o) {
                if (o === globalCompositeOperation) {
                    return;
                }
                globalCompositeOperation = o;
                this.globalCompositeOperation = cc.render.CompositeOperationToCanvas[o];
            };
            c2d.getCompositeOperation = function () {
                return globalCompositeOperation;
            };
            c2d.setGlobalAlpha = function (alpha) {
                if (alpha === globalAlpha) {
                    return;
                }
                globalAlpha = alpha;
                this.globalAlpha = alpha;
            };
            c2d.getGlobalAlpha = function () {
                return globalAlpha;
            };
            /**
             * this.transform(1,0,0,-1,0,h);
               //this.translate(0, h);
               //this.scale(1, -1);
               this.drawImage(texture._image, sx, sy, sw, sh, dx, 0, dw, dh);
               //this.scale(1, -1);
               //this.translate(0, -h);
               this.transform(1,0,0,-1,0,-h);
    
             * @param texture
             * @param sx
             * @param sy
             * @param sw
             * @param sh
             * @param dx
             * @param dy
             * @param dw
             * @param dh
             */
            c2d.drawTexture = function (texture, sx, sy, sw, sh, dx, dy, dw, dh) {
                "use strict";
                var h;
                if (arguments.length === 3) {
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        h = texture._image.height + sy;
                        this.transform(1, 0, 0, -1, 0, h);
                        this.drawImage(texture._image, sx, 0);
                        this.transform(1, 0, 0, -1, 0, h);
                    }
                    else {
                        this.drawImage(texture._image, sx, sy);
                    }
                }
                else if (arguments.length === 5) {
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        this.transform(1, 0, 0, -1, 0, sh + sy);
                        this.drawImage(texture._image, sx, 0, sw, sh);
                        this.transform(1, 0, 0, -1, 0, sh + sy);
                    }
                    else {
                        this.drawImage(texture._image, sx, sy, sw, sh);
                    }
                }
                else {
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        this.transform(1, 0, 0, -1, 0, dy + dh);
                        this.drawImage(texture._image, sx, sy, sw, sh, dx, 0, dw, dh);
                        this.transform(1, 0, 0, -1, 0, dy + dh);
                    }
                    else {
                        this.drawImage(texture._image, sx, sy, sw, sh, dx, dy, dw, dh);
                    }
                }
            };
            /**
             * draw a texture, but not preserving transformation homogeneity.
             * For most cases will work, but not for custom drawing nodes.
             * This method is used in Sprite, where you only want to draw the associated SpriteFrame.
             *
             * @param texture
             * @param sx
             * @param sy
             * @param sw
             * @param sh
             * @param dx
             * @param dy
             * @param dw
             * @param dh
             */
            c2d.drawTextureUnsafe = function (texture, sx, sy, sw, sh, dx, dy, dw, dh) {
                "use strict";
                if (arguments.length === 3) {
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        this.transform(1, 0, 0, -1, 0, texture._image.height);
                    }
                    this.drawImage(texture._image, sx, sy);
                }
                else if (arguments.length === 5) {
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        this.transform(1, 0, 0, -1, 0, sh);
                    }
                    this.drawImage(texture._image, sx, sy, sw, sh);
                }
                else {
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        this.transform(1, 0, 0, -1, 0, dh);
                    }
                    this.drawImage(texture._image, sx, sy, sw, sh, dx, dy, dw, dh);
                }
            };
            c2d.drawMesh = function (geometry, uv, indices, colorRGBA, texture) {
                var r = (colorRGBA >> 24) & 0xff;
                var g = (colorRGBA >> 16) & 0xff;
                var b = (colorRGBA >> 8) & 0xff;
                var a = colorRGBA & 0xff;
                this.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + (a / 255) + ")";
                this.lineWidth = .05;
                for (var i = 0; i < indices.length; i += 3) {
                    var indexVertex0 = indices[i + 0] * 3;
                    var indexVertex1 = indices[i + 1] * 3;
                    var indexVertex2 = indices[i + 2] * 3;
                    this.beginPath();
                    this.moveTo(geometry[indexVertex0], geometry[indexVertex0 + 1]);
                    this.lineTo(geometry[indexVertex1], geometry[indexVertex1 + 1]);
                    this.lineTo(geometry[indexVertex2], geometry[indexVertex2 + 1]);
                    this.closePath();
                    this.stroke();
                }
            };
            return c2d;
        }
        /**
         * @class cc.render.CanvasRenderer
         * @classdesc
         *
         * Create a Canvas renderer.
         */
        var CanvasRenderer = (function (_super) {
            __extends(CanvasRenderer, _super);
            /**
             * Create a new CanvasRenderer instance
             * @method cc.render.CanvasRenderer#constructor
             * @param w {width} surface pixels width
             * @param h {height} surface pixels height
             * @param surface {HTMLCanvasElement=} canvas object. @see {cc.render.Renderer#initialize}
             */
            function CanvasRenderer(w, h, surface) {
                _super.call(this, w, h, surface);
                this._renderingContext = dc2d(this);
                cc.plugin.asset.AssetManager.prepareTextures(this);
            }
            Object.defineProperty(CanvasRenderer.prototype, "renderingContext", {
                /**
                 * Get a renderingContext. Has drawing capabilities.
                 * @method cc.render.CanvasRenderer#get:renderingContext
                 * @returns {RenderingContext}
                 */
                get: function () {
                    return this._renderingContext;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CanvasRenderer.prototype, "canvasContext", {
                /**
                 * Get Canvas context (result from calling <code>canvas.getContext</code>).
                 * @method cc.render.CanvasRenderer#get:canvasContext
                 * @returns {any}
                 */
                get: function () {
                    return this._renderingContext;
                },
                enumerable: true,
                configurable: true
            });
            CanvasRenderer.prototype.getCanvasContext = function () {
                return this._renderingContext;
            };
            CanvasRenderer.prototype.__resize = function (w, h) {
                _super.prototype.__resize.call(this, w, h);
                this._renderingContext = dc2d(this);
            };
            CanvasRenderer.prototype.getType = function () {
                return cc.render.RENDERER_TYPE_CANVAS;
            };
            return CanvasRenderer;
        })(Renderer);
        render.CanvasRenderer = CanvasRenderer;
        /**
         * @class cc.render.WebGLRenderer
         * @classdesc
         *
         * Create a WebGL Renderer with drawing capabilities like a canvas object.
         */
        var WebGLRenderer = (function (_super) {
            __extends(WebGLRenderer, _super);
            /**
             * Create a new WebGLRenderer instance.
             * @method cc.render.WebGLRenderer#constructor
             * @param w {width} surface pixels width
             * @param h {height} surface pixels height
             * @param surface {HTMLCanvasElement=} canvas object. @see {cc.render.Renderer#initialize}
             */
            function WebGLRenderer(w, h, surface) {
                _super.call(this, w, h, surface);
                /**
                 * The canvas result of calling <code>canvas.getContext("webgl")</code>
                 * @member cc.render.WebGLRenderer#_webglState
                 * @type {WebGLRenderingContext}
                 * @private
                 */
                this._webglState = null;
                var drc = new cc.render.DecoratedWebGLRenderingContext(this);
                this._webglState = drc._webglState;
                this._renderingContext = drc;
                cc.plugin.asset.AssetManager.prepareTextures(this);
            }
            WebGLRenderer.prototype.getCanvasContext = function () {
                return this._webglState;
            };
            Object.defineProperty(WebGLRenderer.prototype, "renderingContext", {
                /**
                 * Get a renderingContext. Has drawing capabilities like a <code>CanvasRenderingContext2D</code>
                 * @method cc.render.WebGLRenderer#get:renderingContext
                 * @returns {RenderingContext}
                 */
                get: function () {
                    return this._renderingContext;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLRenderer.prototype, "canvasContext", {
                /**
                 * Get Canvas context (result from calling <code>canvas.getContext</code>). Gets a gl context.
                 * @method cc.render.WebGLRenderer#get:canvasContext
                 * @returns {WebGLState}
                 */
                get: function () {
                    return this._webglState;
                },
                enumerable: true,
                configurable: true
            });
            WebGLRenderer.prototype.prepareTexture = function (texture) {
                texture.__setAsGLTexture(this._webglState);
            };
            WebGLRenderer.prototype.__resize = function (w, h) {
                _super.prototype.__resize.call(this, w, h);
                this._renderingContext.resize();
                this._webglState = this._renderingContext._webglState;
            };
            WebGLRenderer.prototype.getType = function () {
                return cc.render.RENDERER_TYPE_WEBGL;
            };
            return WebGLRenderer;
        })(Renderer);
        render.WebGLRenderer = WebGLRenderer;
        /**
         * @name RendererUtil
         * @memberOf cc.render
         *
         * Various rendering helpers like 9path, etc.
         *
         */
        render.RendererUtil = {
            /**
             * Draw a 9 patch from a SpriteFrame.
             * It assumes that the 9 patch frame size is divisible by 3 horizontal and vertically.
             * @param ctx {cc.render.RenderingContext}
             * @param frameName {string}
             * @param x {number}
             * @param y {number}
             * @param w {number}
             * @param h {number}
             * @param patchData {cc.render.PatchData?}
             */
            draw9Patch: function (ctx, frameName, x, y, w, h, patchData) {
                var sf = cc.plugin.asset.AssetManager.getSpriteFrame(frameName);
                if (null === sf) {
                    return;
                }
                // no patchdata, or destination size just scale the image.
                if (typeof patchData === "undefined") {
                    ctx.drawTexture(sf.getTexture(), 0, 0, sf.getWidth(), sf.getHeight(), x, y, w, h);
                    return;
                }
                patchData.left = patchData.left || 0;
                patchData.top = patchData.top || 0;
                patchData.right = patchData.right || 0;
                patchData.bottom = patchData.bottom || 0;
                var paddingW = patchData.left + patchData.right;
                var paddingH = patchData.bottom + patchData.top;
                var spriteBottomHeight = patchData.bottom;
                var spriteTopHeight = patchData.top;
                var spriteBottomY = sf.getHeight() - spriteBottomHeight;
                var spriteMiddleHeight = sf.getHeight() - paddingH;
                var spriteMiddleWidth = sf.getWidth() - paddingW;
                var spriteLeftWidth = patchData.left;
                var spriteRightWidth = patchData.right;
                var scaleFactor = ctx.getUnitsFactor();
                var topy = cc.render.RENDER_ORIGIN === cc.render.ORIGIN_TOP ? y : y + h - spriteTopHeight / scaleFactor;
                var bottomy = cc.render.RENDER_ORIGIN === cc.render.ORIGIN_TOP ? y + h - spriteBottomHeight / scaleFactor : y;
                var middley = cc.render.RENDER_ORIGIN === cc.render.ORIGIN_TOP ? y + spriteTopHeight / scaleFactor : y + spriteBottomHeight / scaleFactor;
                if (patchData.left) {
                    // top left
                    if (patchData.top) {
                        ctx.drawTexture(sf.getTexture(), 0, 0, spriteLeftWidth, spriteTopHeight, x, topy, spriteLeftWidth / scaleFactor, spriteTopHeight / scaleFactor);
                    }
                    // bottom left
                    if (patchData.bottom) {
                        ctx.drawTexture(sf.getTexture(), 0, spriteBottomY, spriteLeftWidth, spriteBottomHeight, x, bottomy, spriteLeftWidth / scaleFactor, spriteBottomHeight / scaleFactor);
                    }
                    ctx.drawTexture(sf.getTexture(), 0, patchData.top, spriteLeftWidth, spriteMiddleHeight, x, middley, spriteLeftWidth / scaleFactor, h - paddingH / scaleFactor);
                }
                if (patchData.right) {
                    // top left
                    if (patchData.top) {
                        ctx.drawTexture(sf.getTexture(), sf.getWidth() - patchData.right, 0, spriteRightWidth, spriteTopHeight, x + w - patchData.right / scaleFactor, topy, spriteRightWidth / scaleFactor, spriteTopHeight / scaleFactor);
                    }
                    // bottom left
                    if (patchData.bottom) {
                        ctx.drawTexture(sf.getTexture(), sf.getWidth() - patchData.right, spriteBottomY, spriteRightWidth, spriteBottomHeight, x + w - patchData.right / scaleFactor, bottomy, spriteRightWidth / scaleFactor, spriteBottomHeight / scaleFactor);
                    }
                    ctx.drawTexture(sf.getTexture(), sf.getWidth() - patchData.right, patchData.top, spriteRightWidth, spriteMiddleHeight, x + w - patchData.right / scaleFactor, middley, spriteRightWidth / scaleFactor, h - paddingH / scaleFactor);
                }
                // top left
                if (patchData.top) {
                    ctx.drawTexture(sf.getTexture(), patchData.left, 0, spriteMiddleWidth, spriteTopHeight, x + patchData.left / scaleFactor, topy, w - paddingW / scaleFactor, spriteTopHeight / scaleFactor);
                }
                // bottom left
                if (patchData.bottom) {
                    ctx.drawTexture(sf.getTexture(), patchData.left, spriteBottomY, spriteMiddleWidth, spriteBottomHeight, x + patchData.left / scaleFactor, bottomy, w - paddingW / scaleFactor, spriteBottomHeight / scaleFactor);
                }
                ctx.drawTexture(sf.getTexture(), patchData.left, patchData.top, spriteMiddleWidth, spriteMiddleHeight, x + patchData.left / scaleFactor, middley, w - paddingW / scaleFactor, h - paddingH / scaleFactor);
            }
        };
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../math/Color.ts"/>
/// <reference path="../render/Texture2D.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        "use strict";
        render.RENDERER_TYPE_CANVAS = 1;
        render.RENDERER_TYPE_WEBGL = 0;
        /**
         * @class cc.render.Pattern
         * @classdesc
         *
         * Pattern fill info.
         *
         */
        var Pattern = (function () {
            function Pattern(texture, type) {
                this._texture = null;
                this._type = "repeat";
                this._texture = texture;
                this._type = type;
            }
            Object.defineProperty(Pattern.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pattern.prototype, "type", {
                get: function () {
                    return this._type;
                },
                enumerable: true,
                configurable: true
            });
            return Pattern;
        })();
        render.Pattern = Pattern;
        (function (CompositeOperation) {
            CompositeOperation[CompositeOperation["source_over"] = 0] = "source_over";
            CompositeOperation[CompositeOperation["source_out"] = 1] = "source_out";
            CompositeOperation[CompositeOperation["source_in"] = 2] = "source_in";
            CompositeOperation[CompositeOperation["source_atop"] = 3] = "source_atop";
            CompositeOperation[CompositeOperation["destination_over"] = 4] = "destination_over";
            CompositeOperation[CompositeOperation["destination_in"] = 5] = "destination_in";
            CompositeOperation[CompositeOperation["destination_out"] = 6] = "destination_out";
            CompositeOperation[CompositeOperation["destination_atop"] = 7] = "destination_atop";
            CompositeOperation[CompositeOperation["multiply"] = 8] = "multiply";
            CompositeOperation[CompositeOperation["screen"] = 9] = "screen";
            CompositeOperation[CompositeOperation["copy"] = 10] = "copy";
            CompositeOperation[CompositeOperation["lighter"] = 11] = "lighter";
            CompositeOperation[CompositeOperation["darker"] = 12] = "darker";
            CompositeOperation[CompositeOperation["xor"] = 13] = "xor";
            CompositeOperation[CompositeOperation["add"] = 14] = "add";
        })(render.CompositeOperation || (render.CompositeOperation = {}));
        var CompositeOperation = render.CompositeOperation;
        render.CanvasToComposite = {
            "source-over": 0,
            "source-out": 1,
            "source-in": 2,
            "source-atop": 3,
            "destination-over": 4,
            "destination-in": 5,
            "destination-out": 6,
            "destination-atop": 7,
            "multiply": 8,
            "screen": 9,
            "copy": 10,
            "lighter": 11,
            "darker": 12,
            "xor": 13,
            "add": 14
        };
        render.CompositeOperationToCanvas = [
            "source-over",
            "source-out",
            "source-in",
            "source-atop",
            "destination-over",
            "destination-in",
            "destination-out",
            "destination-atop",
            "multiply",
            "screen",
            "copy",
            "lighter",
            "darker",
            "xor",
            "lighter"
        ];
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="./RenderingContext.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        var Matrix3 = cc.math.Matrix3;
        /**
         * @class cc.render.RenderingContextSnapshot
         * @classdesc
         *
         * This class has all the necessary information for a canvas rendering context.
         * Whenever a call to <code>save</code> or <code>restore</code> is made, a new Object of this type will be
         * created/destroyed.
         * A developer never interacts with this objects directly, but by calling RenderingContext methods.
         * This class is for internal use of RenderingContext implementations (webgl).
         */
        var RenderingContextSnapshot = (function () {
            /**
             * Build a new RenderingContextSnapshot instance.
             * @method cc.render.RenderingContextSnapshot#constructor
             */
            function RenderingContextSnapshot() {
                /**
                 * Composite operation.
                 * @member cc.render.RenderingContextSnapshot#_globalCompositeOperation
                 * @type {string}
                 * @private
                 */
                this._globalCompositeOperation = 0 /* source_over */;
                /**
                 * Current transformation matrix.
                 * @member cc.render.RenderingContextSnapshot#_currentMatrix
                 * @type {cc.math.Matrix3}
                 * @private
                 */
                this._currentMatrix = new Float32Array([1.0, 0, 0, 0, 1.0, 0, 0, 0, 1.0]);
                /**
                 * Current global alpha value.
                 * @member cc.render.RenderingContextSnapshot#_globalAlpha
                 * @type {number}
                 * @private
                 */
                this._globalAlpha = 1;
                /**
                 * Current miter limit.
                 * @member cc.render.RenderingContextSnapshot#_miterLimit
                 * @type {number}
                 * @private
                 */
                this._miterLimit = 10;
                this._currentFillStyleType = 0 /* COLOR */;
                /**
                 * Current fill style.
                 * @member cc.render.RenderingContextSnapshot#_fillStyle
                 * @type {any}
                 * @private
                 */
                this._fillStyleColor = new Float32Array([0.0, 0.0, 0.0, 1.0]);
                this._fillStylePattern = null;
                /**
                 * Current tint color. Only makes sense in webgl renderers.
                 * @member cc.render.RenderingContextSnapshot#_tintColor
                 * @type {Float32Array}
                 * @private
                 */
                this._tintColor = new Float32Array([0.0, 0.0, 0.0, 1.0]);
                /**
                 * Current stroke line width.
                 * @member cc.render.RenderingContextSnapshot#_lineWidth
                 * @type {number}
                 * @private
                 */
                this._lineWidth = 1.0;
                /**
                 * Current font data.
                 * @member cc.render.RenderingContextSnapshot#_fontDefinition
                 * @type {string}
                 * @private
                 */
                this._fontDefinition = "10px sans-serif";
                /**
                 * Current font baseline.
                 * @member cc.render.RenderingContextSnapshot#_textBaseline
                 * @type {string}
                 * @private
                 */
                this._textBaseline = "alphabetic";
                /**
                 * Current text align. Valid values are: left, center, right
                 * @member cc.render.RenderingContextSnapshot#_textAlign
                 * @type {string}
                 * @private
                 */
                this._textAlign = "left";
                /**
                 * Current path tracing data.
                 * @member cc.render.RenderingContextSnapshot#_currentPath
                 * @type {any}
                 * @private
                 */
                this._currentPath = null;
                /**
                 * Current clipping paths stack
                 * @member cc.render.RenderingContextSnapshot#_clippingStack
                 * @type {Array}
                 * @private
                 */
                this._clippingStack = [];
            }
            /**
             * Clone this snapshot and create a new one.
             * @method cc.render.RenderingContextSnapshot#clone
             * @returns {cc.render.RenderingContextSnapshot}
             */
            RenderingContextSnapshot.prototype.clone = function () {
                var rcs = new RenderingContextSnapshot();
                rcs._globalCompositeOperation = this._globalCompositeOperation;
                rcs._globalAlpha = this._globalAlpha;
                Matrix3.copy(rcs._currentMatrix, this._currentMatrix);
                rcs._fillStyleColor = this._fillStyleColor;
                rcs._fillStylePattern = this._fillStylePattern;
                rcs._currentFillStyleType = this._currentFillStyleType;
                rcs._tintColor = this._tintColor;
                rcs._lineWidth = this._lineWidth;
                rcs._miterLimit = this._miterLimit;
                rcs._fontDefinition = this._fontDefinition;
                rcs._textBaseline = this._textBaseline;
                rcs._textAlign = this._textAlign;
                //rcs._currentPath = this._currentPath.clone();
                rcs._clippingStack = this._clippingStack;
                return rcs;
            };
            return RenderingContextSnapshot;
        })();
        render.RenderingContextSnapshot = RenderingContextSnapshot;
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../math/Point.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="./RenderingContextSnapshot.ts"/>
/// <reference path="./WebGLState.ts"/>
/// <reference path="./shader/AbstractShader.ts"/>
/// <reference path="./shader/Buffer.ts"/>
var cc;
(function (_cc) {
    var render;
    (function (render) {
        "use strict";
        var Matrix3 = cc.math.Matrix3;
        var Buffer = cc.render.shader.Buffer;
        var __vv = { x: 0, y: 0 };
        var __color = new Uint8Array([0, 0, 0, 0]);
        /**
         * @class cc.render.GeometryBatcher
         * @classdesc
         *
         * This class handles geometry, batches it into ping-pong'ed buffers and signals when to flush.
         */
        var GeometryBatcher = (function () {
            /**
             * Build a new GeometryBatcher instance. You probably will need one of this.
             * @method cc.render.GeometryBatcher#constructor
             * @param _gl {WebGLRenderingContext}
             */
            function GeometryBatcher(glstate) {
                /**
                 * WebGL geometry, color and uv buffer ids.
                 * @member cc.render.GeometryBatcher#_glDataBuffers;
                 * @type {Array<WebGLBuffer>}
                 * @private
                 */
                this._glDataBuffers = [];
                /**
                 * WebGL indices buffer ids.
                 * @member cc.render.GeometryBatcher#_glIndexBuffers;
                 * @type {Array<WebGLBuffer>}
                 * @private
                 */
                this._glIndexBuffers = [];
                /**
                 * Batching buffers index.
                 * @member cc.render.GeometryBatcher#_currentBuffersIndex
                 * @type {number}
                 * @private
                 */
                this._currentBuffersIndex = 0;
                /**
                 * Main rendering buffer as buffer array (abstract version).
                 * @member cc.render.GeometryBatcher#_dataArrayBuffer
                 * @type {ArrayBuffer}
                 * @private
                 */
                this._dataArrayBuffer = null;
                /**
                 * Current rendering buffer as Float32 array
                 * @member cc.render.GeometryBatcher#_dataBufferFloat
                 * @type {Float32Array}
                 * @private
                 */
                this._dataBufferFloat = null;
                /**
                 * Current rendering buffer as Uint8 array.
                 * @member cc.render.GeometryBatcher#_dataBufferByte
                 * @type {Uint8Array}
                 * @private
                 */
                this._dataBufferByte = null;
                /**
                 * Current rendering buffer as Uint32 array.
                 * @member cc.render.GeometryBatcher#_dataBufferUint
                 * @type {Uint8Array}
                 * @private
                 */
                this._dataBufferUint = null;
                /**
                 * Current Buffer index.
                 * @member cc.render.GeometryBatcher#_dataBufferIndex
                 * @type {number}
                 * @private
                 */
                this._dataBufferIndex = 0;
                /**
                 * Current rendering buffer for geometry indices.
                 * @member cc.render.GeometryBatcher#_indexBuffer
                 * @type {Float32Array}
                 * @private
                 */
                this._indexBuffer = null;
                /**
                 * Current Buffer index.
                 * @member cc.render.GeometryBatcher#_indexBufferIndex
                 * @type {number}
                 * @private
                 */
                this._indexBufferIndex = 0;
                this._indexBufferMesh = null;
                this._indexBufferMeshIndex = 0;
                this._indicesChanged = false;
                this._glIndexMeshBuffers = [];
                this._glIndexMeshBuffer = null;
                /**
                 * The canvas WebGLRenderingContext
                 * @member cc.render.GeometryBatcher#_gl
                 * @type {WebGLRenderingContext}
                 */
                this._gl = null;
                this._gl = glstate._gl;
                this._dataArrayBuffer = new ArrayBuffer(GeometryBatcher.MAX_QUADS * 40 * 4);
                this._dataBufferFloat = new Float32Array(this._dataArrayBuffer); // 40 is fastshader vertex size.
                this._dataBufferByte = new Uint8Array(this._dataArrayBuffer);
                this._dataBufferUint = new Uint32Array(this._dataArrayBuffer);
                this._indexBuffer = new Uint16Array(GeometryBatcher.MAX_QUADS * 6);
                this._indexBufferMesh = new Uint16Array(GeometryBatcher.MAX_QUADS * 6);
                // preset geometry indices.
                var indexBufferIndex = 0;
                var elementIndex = 0;
                var indexBuffer = this._indexBuffer;
                for (var i = 0; i < GeometryBatcher.MAX_QUADS; i++) {
                    indexBuffer[indexBufferIndex] = elementIndex;
                    indexBuffer[indexBufferIndex + 1] = elementIndex + 1;
                    indexBuffer[indexBufferIndex + 2] = elementIndex + 2;
                    indexBuffer[indexBufferIndex + 3] = elementIndex;
                    indexBuffer[indexBufferIndex + 4] = elementIndex + 2;
                    indexBuffer[indexBufferIndex + 5] = elementIndex + 3;
                    indexBufferIndex += 6;
                    elementIndex += 4;
                    this._indexBufferMesh[i] = i;
                }
                this._glDataBuffers.push(new Buffer(this._gl, this._gl.ARRAY_BUFFER, this._dataBufferFloat, this._gl.DYNAMIC_DRAW));
                this._glDataBuffers.push(new Buffer(this._gl, this._gl.ARRAY_BUFFER, this._dataBufferFloat, this._gl.DYNAMIC_DRAW));
                this._glDataBuffers.push(new Buffer(this._gl, this._gl.ARRAY_BUFFER, this._dataBufferFloat, this._gl.DYNAMIC_DRAW));
                this._glDataBuffers.push(new Buffer(this._gl, this._gl.ARRAY_BUFFER, this._dataBufferFloat, this._gl.DYNAMIC_DRAW));
                this._glIndexBuffers.push(new Buffer(this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer, this._gl.STATIC_DRAW));
                this._glIndexBuffers.push(new Buffer(this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer, this._gl.STATIC_DRAW));
                this._glIndexBuffers.push(new Buffer(this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer, this._gl.STATIC_DRAW));
                this._glIndexBuffers.push(new Buffer(this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer, this._gl.STATIC_DRAW));
                this._glIndexMeshBuffers.push(new Buffer(this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBufferMesh, this._gl.STATIC_DRAW));
                this._glIndexMeshBuffers.push(new Buffer(this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBufferMesh, this._gl.STATIC_DRAW));
                this._glIndexMeshBuffers.push(new Buffer(this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBufferMesh, this._gl.STATIC_DRAW));
                this._glIndexMeshBuffers.push(new Buffer(this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBufferMesh, this._gl.STATIC_DRAW));
                this._glDataBuffer = this._glDataBuffers[0];
                this._glIndexBuffer = this._glIndexBuffers[0];
                this._glIndexMeshBuffer = this._glIndexMeshBuffers[0];
            }
            GeometryBatcher.prototype.batchRectGeometryWithTexture = function (vertices, u0, v0, u1, v1, rcs) {
                var cc = this.__uintColor(rcs);
                this.batchVertex(vertices[0], cc, u0, v0);
                this.batchVertex(vertices[1], cc, u1, v0);
                this.batchVertex(vertices[2], cc, u1, v1);
                this.batchVertex(vertices[3], cc, u0, v1);
                // add two triangles * 3 values each.
                this._indexBufferIndex += 6;
                return this._indexBufferIndex + 6 >= this._indexBuffer.length;
            };
            /**
             * Batch a rectangle with texture info and tint color.
             * Tint color will be modified by currently alpha value set.
             * @member cc.render.GeometryBatcher#batchRectWithTexture
             * @param x {number} rectangle position
             * @param y {number}
             * @param w {number} rectangle size
             * @param h {number}
             * @param rcs {RenderingContextSnapshot} current rendering context snapshot info
             * @param u0 {number} texture position
             * @param v0 {number}
             * @param u1 {number} texture size
             * @param v1 {number}
             */
            GeometryBatcher.prototype.batchRectWithTexture = function (x, y, w, h, rcs, u0, v0, u1, v1) {
                var cm = rcs._currentMatrix;
                var cc = this.__uintColor(rcs);
                __vv.x = x;
                __vv.y = y;
                this.batchVertex(Matrix3.transformPoint(cm, __vv), cc, u0, v0);
                __vv.x = x + w;
                __vv.y = y;
                this.batchVertex(Matrix3.transformPoint(cm, __vv), cc, u1, v0);
                __vv.x = x + w;
                __vv.y = y + h;
                this.batchVertex(Matrix3.transformPoint(cm, __vv), cc, u1, v1);
                __vv.x = x;
                __vv.y = y + h;
                this.batchVertex(Matrix3.transformPoint(cm, __vv), cc, u0, v1);
                // add two triangles * 3 values each.
                this._indexBufferIndex += 6;
                return this._indexBufferIndex + 6 >= this._indexBuffer.length;
            };
            /**
             * Batch a rect with the current rendering info. The rect color will be tinted. Resulting transparency value will
             * be modified by currently rendering context alpha value set.
             * @method cc.render.GeometryBatcher#batchRect
             * @param x {number}
             * @param y {number}
             * @param w {number}
             * @param h {number}
             * @param rcs {cc.render.RenderingContextSnapshot} current rendering context snapshot info
             */
            GeometryBatcher.prototype.batchRect = function (x, y, w, h, rcs) {
                var color = rcs._fillStyleColor;
                var tint = rcs._tintColor;
                var r = ((color[0] * tint[0]) * 255) | 0;
                var g = ((color[1] * tint[1]) * 255) | 0;
                var b = ((color[2] * tint[2]) * 255) | 0;
                var a = ((color[3] * tint[3] * rcs._globalAlpha) * 255) | 0;
                var cc = (r) | (g << 8) | (b << 16) | (a << 24);
                var cm = rcs._currentMatrix;
                __vv.x = x;
                __vv.y = y;
                Matrix3.transformPoint(cm, __vv);
                this._dataBufferFloat[this._dataBufferIndex++] = __vv.x;
                this._dataBufferFloat[this._dataBufferIndex++] = __vv.y;
                this._dataBufferUint[this._dataBufferIndex++] = cc;
                __vv.x = x + w;
                __vv.y = y;
                Matrix3.transformPoint(cm, __vv);
                this._dataBufferFloat[this._dataBufferIndex++] = __vv.x;
                this._dataBufferFloat[this._dataBufferIndex++] = __vv.y;
                this._dataBufferUint[this._dataBufferIndex++] = cc;
                __vv.x = x + w;
                __vv.y = y + h;
                Matrix3.transformPoint(cm, __vv);
                this._dataBufferFloat[this._dataBufferIndex++] = __vv.x;
                this._dataBufferFloat[this._dataBufferIndex++] = __vv.y;
                this._dataBufferUint[this._dataBufferIndex++] = cc;
                __vv.x = x;
                __vv.y = y + h;
                Matrix3.transformPoint(cm, __vv);
                this._dataBufferFloat[this._dataBufferIndex++] = __vv.x;
                this._dataBufferFloat[this._dataBufferIndex++] = __vv.y;
                this._dataBufferUint[this._dataBufferIndex++] = cc;
                // add two triangles * 3 values each.
                this._indexBufferIndex += 6;
                return this._indexBufferIndex + 6 >= this._indexBuffer.length;
            };
            /**
             * Batch a vertex with color and texture.
             * @method cc.render.GeometryBatcher#batchVertex
             * @param p {Point}
             * @param r {number}
             * @param g {number}
             * @param b {number}
             * @param a {number}
             * @param u {number}
             * @param v {number}
             */
            GeometryBatcher.prototype.batchVertex = function (p, cc, u, v) {
                this._dataBufferFloat[this._dataBufferIndex++] = p.x;
                this._dataBufferFloat[this._dataBufferIndex++] = p.y;
                this._dataBufferUint[this._dataBufferIndex++] = cc;
                this._dataBufferFloat[this._dataBufferIndex++] = u;
                this._dataBufferFloat[this._dataBufferIndex++] = v;
            };
            /**
             * Flush currently batched geometry and related info with a given shader program.
             * @method cc.render.GeometryBatcher#flush
             * @param shader {cc.render.shader.AbstractShader} program shader
             * @param rcs {cc.render.RenderingContextSnapshot}
             */
            GeometryBatcher.prototype.flush = function (shader, rcs) {
                var trianglesCount;
                if (this._indicesChanged) {
                    trianglesCount = this._indexBufferMeshIndex;
                    if (!trianglesCount) {
                        return;
                    }
                    this._glIndexMeshBuffer.bind(this._gl.ELEMENT_ARRAY_BUFFER);
                }
                else {
                    trianglesCount = this._indexBufferIndex;
                    if (!trianglesCount) {
                        return;
                    }
                    // simply rebind the buffer, not modify its contents.
                    this._glIndexBuffer.bind(this._gl.ELEMENT_ARRAY_BUFFER);
                }
                //this._glDataBuffer.forceEnableWithValue(this._dataBufferFloat);
                this._glDataBuffer.forceEnableWithValue(this._dataBufferFloat.subarray(0, this._dataBufferIndex));
                //this._glDataBuffer.enableWithValue(this._dataBufferFloat.subarray(0, this._dataBufferIndex));
                shader.flushBuffersWithContent(rcs);
                this._gl.drawElements(this._gl.TRIANGLES, trianglesCount, this._gl.UNSIGNED_SHORT, 0);
                //this._gl.drawArrays(this._gl.TRIANGLE_STRIP, 0, 4);
                // reset buffer data index.
                this._dataBufferIndex = 0;
                this._indexBufferIndex = 0;
                this._indexBufferMeshIndex = 0;
                // ping pong rendering buffer.
                this._currentBuffersIndex = (this._currentBuffersIndex + 1) & 3;
                this._glDataBuffer = this._glDataBuffers[this._currentBuffersIndex];
                this._glIndexBuffer = this._glIndexBuffers[this._currentBuffersIndex];
                this._glIndexMeshBuffer = this._glIndexMeshBuffers[this._currentBuffersIndex];
                this._indicesChanged = false;
            };
            GeometryBatcher.prototype.__uintColor = function (rcs) {
                var tint = rcs._tintColor;
                var r = (tint[0] * 255) | 0;
                var g = (tint[1] * 255) | 0;
                var b = (tint[2] * 255) | 0;
                var a = (tint[3] * rcs._globalAlpha * 255) | 0;
                return (r) | (g << 8) | (b << 16) | (a << 24);
            };
            GeometryBatcher.prototype.batchRectGeometryWithSpriteFast = function (sprite, u0, v0, u1, v1, rcs) {
                var cc = this.__uintColor(rcs);
                var db = this._dataBufferFloat;
                var dbuint = this._dataBufferUint;
                var dbi = this._dataBufferIndex;
                //var w0 = (sprite._contentSize.width ) * (1-sprite._transformationAnchor.x);
                //var w1 = (sprite._contentSize.width ) * -sprite._transformationAnchor.x;
                //
                //var h1 = sprite._contentSize.height * (1-sprite._transformationAnchor.y);
                //var h0 = sprite._contentSize.height * -sprite._transformationAnchor.y;
                dbuint[dbi + 2] = dbuint[dbi + 12] = dbuint[dbi + 22] = dbuint[dbi + 32] = cc;
                db[dbi] = db[dbi + 10] = db[dbi + 20] = db[dbi + 30] = sprite.x;
                db[dbi + 1] = db[dbi + 11] = db[dbi + 21] = db[dbi + 31] = sprite.y;
                db[dbi + 7] = db[dbi + 17] = db[dbi + 27] = db[dbi + 37] = sprite.rotationAngle;
                db[dbi + 8] = db[dbi + 18] = db[dbi + 28] = db[dbi + 38] = sprite.scaleX;
                db[dbi + 9] = db[dbi + 19] = db[dbi + 29] = db[dbi + 39] = sprite.scaleY;
                var w0 = sprite.width / 2.0;
                var w1 = -w0;
                var h1 = sprite.height / 2.0;
                var h0 = -h1;
                db[dbi + 3] = u0;
                db[dbi + 4] = v0;
                db[dbi + 5] = w0;
                db[dbi + 6] = h0;
                db[dbi + 13] = u1;
                db[dbi + 14] = v0;
                db[dbi + 15] = w1;
                db[dbi + 16] = h0;
                db[dbi + 23] = u1;
                db[dbi + 24] = v1;
                db[dbi + 25] = w1;
                db[dbi + 26] = h1;
                db[dbi + 33] = u0;
                db[dbi + 34] = v1;
                db[dbi + 35] = w0;
                db[dbi + 36] = h1;
                // add two triangles * 3 values each.
                this._indexBufferIndex += 6;
                this._dataBufferIndex += 40;
                return this._dataBufferIndex + 40 >= this._dataBufferFloat.length;
            };
            GeometryBatcher.prototype.batchMesh = function (geometry, uv, indices, color, rcs) {
                this._indicesChanged = true;
                for (var i = 0; i < indices.length; i += 3) {
                    var indexVertex0 = indices[i + 0] * 3;
                    var indexVertexUV0 = indices[i + 0] * 2;
                    this.batchMeshVertex(geometry[indexVertex0], geometry[indexVertex0 + 1], uv[indexVertexUV0], uv[indexVertexUV0 + 1]);
                    var indexVertex1 = indices[i + 1] * 3;
                    var indexVertexUV1 = indices[i + 1] * 2;
                    this.batchMeshVertex(geometry[indexVertex1], geometry[indexVertex1 + 1], uv[indexVertexUV1], uv[indexVertexUV1 + 1]);
                    var indexVertex2 = indices[i + 2] * 3;
                    var indexVertexUV2 = indices[i + 2] * 2;
                    this.batchMeshVertex(geometry[indexVertex2], geometry[indexVertex2 + 1], uv[indexVertexUV2], uv[indexVertexUV2 + 1]);
                }
            };
            GeometryBatcher.prototype.batchMeshVertex = function (x, y, u, v) {
                this._dataBufferFloat[this._dataBufferIndex++] = x;
                this._dataBufferFloat[this._dataBufferIndex++] = y;
                this._dataBufferFloat[this._dataBufferIndex++] = u;
                this._dataBufferFloat[this._dataBufferIndex++] = v;
                this._indexBufferMeshIndex++;
            };
            /**
             * Max bufferable quads.
             * @member cc.render.GeometryBatcher.MAX_QUADS
             * @type {number}
             */
            GeometryBatcher.MAX_QUADS = 16383;
            return GeometryBatcher;
        })();
        render.GeometryBatcher = GeometryBatcher;
    })(render = _cc.render || (_cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Rectangle.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="./RenderingContext.ts"/>
/// <reference path="./RenderingContextSnapshot.ts"/>
/// <reference path="./WebGLState.ts"/>
/// <reference path="./Texture2D.ts"/>
/// <reference path="./GeometryBatcher.ts"/>
/// <reference path="./shader/AbstractShader.ts"/>
/// <reference path="./shader/SolidColorShader.ts"/>
/// <reference path="./shader/TextureShader.ts"/>
/// <reference path="./shader/FastTextureShader.ts"/>
/// <reference path="./shader/TexturePatternShader.ts"/>
/// <reference path="./shader/Uniform.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        "use strict";
        var RenderingContextSnapshot = cc.render.RenderingContextSnapshot;
        var GeometryBatcher = cc.render.GeometryBatcher;
        var SolidColorShader = cc.render.shader.SolidColorShader;
        var TextureShader = cc.render.shader.TextureShader;
        var TexturePatternShader = cc.render.shader.TexturePatternShader;
        var FastTextureShader = cc.render.shader.FastTextureShader;
        var Matrix3 = cc.math.Matrix3;
        var WebGLState = cc.render.WebGLState;
        /**
         * Decorated WebGL Rendering Context fill style types.
         * @tsenum cc.render.FillStyleType
         */
        (function (FillStyleType) {
            FillStyleType[FillStyleType["COLOR"] = 0] = "COLOR";
            FillStyleType[FillStyleType["IMAGE"] = 1] = "IMAGE";
            FillStyleType[FillStyleType["IMAGEFAST"] = 2] = "IMAGEFAST";
            FillStyleType[FillStyleType["PATTERN_REPEAT"] = 3] = "PATTERN_REPEAT";
            FillStyleType[FillStyleType["MESH"] = 4] = "MESH";
        })(render.FillStyleType || (render.FillStyleType = {}));
        var FillStyleType = render.FillStyleType;
        /**
         * Shader types
         * @tsenum cc.render.ShaderType
         */
        (function (ShaderType) {
            ShaderType[ShaderType["COLOR"] = 0] = "COLOR";
            ShaderType[ShaderType["IMAGE"] = 1] = "IMAGE";
            ShaderType[ShaderType["IMAGEFAST"] = 2] = "IMAGEFAST";
            ShaderType[ShaderType["PATTERN_REPEAT"] = 3] = "PATTERN_REPEAT";
            ShaderType[ShaderType["MESH"] = 4] = "MESH";
        })(render.ShaderType || (render.ShaderType = {}));
        var ShaderType = render.ShaderType;
        /**
         * BIT Flag for WebGL enabled/disabled flags.
         * @tsenum cc.render.WEBGL_FLAGS
         */
        (function (WEBGL_FLAGS) {
            WEBGL_FLAGS[WEBGL_FLAGS["BLEND"] = 1] = "BLEND";
            WEBGL_FLAGS[WEBGL_FLAGS["DEPTH_TEST"] = 2] = "DEPTH_TEST";
            WEBGL_FLAGS[WEBGL_FLAGS["CULL_FACE"] = 4] = "CULL_FACE";
        })(render.WEBGL_FLAGS || (render.WEBGL_FLAGS = {}));
        var WEBGL_FLAGS = render.WEBGL_FLAGS;
        var __mat3 = new Float32Array([1.0, 0, 0, 0, 1.0, 0, 0, 0, 1.0]);
        var __mat4 = new Float32Array([
            1.0,
            0,
            0,
            0,
            0,
            1.0,
            0,
            0,
            0,
            0,
            1.0,
            0,
            0,
            0,
            0,
            1.0
        ]);
        /**
         * @class cc.render.DecoratedWebGLRenderingContext
         * @classdesc
         *
         * This object wraps a 3D canvas context (webgl) and exposes a canvas like 2d rendering API.
         * The implementation should be extremely efficient by:
         *   <li>lazily set every property.
         *   <li>batch all drawing operations as much as possible.
         *   <li>ping pong between buffers
         *
         * <br>
         * All this would be transparent for the developer and happen automatically. For example, is a value is set to
         * <code>globalCompositeOperation</code> (set a blend mode), a gl call is not immediately executed, which prevents
         * consecutive calls to <code>globalCompositeOperation</code> to make explicit gl calls. Instead, the gl call
         * is deferred until the moment when some geometry will happen, for example, a fillRect call.
         * <br>
         * This mechanism is set for every potential flushing operation like changing fillStyle, compisite, textures, etc.
         */
        var DecoratedWebGLRenderingContext = (function () {
            /**
             * Create a new DecoratedWebGLRenderingContext instance.
             * @method cc.render.DecoratedWebGLRenderingContext#constructor
             * @param r {cc.render.Renderer}
             */
            function DecoratedWebGLRenderingContext(r) {
                /**
                 * Current rendering context data.
                 * @member cc.render.DecoratedWebGLRenderingContext#_currentContextSnapshot
                 * @type {cc.render.RenderingContextSnapshot}
                 * @private
                 */
                this._currentContextSnapshot = null;
                /**
                 * Each call to save will create a new rendering context snapshot that will be tracked here.
                 * @member cc.render.DecoratedWebGLRenderingContext#_contextSnapshots
                 * @type {Array<cc.render.RenderingContextSnapshot>}
                 * @private
                 */
                this._contextSnapshots = [];
                /**
                 * if _currentFillStyleType===COLOR, this is the current color.
                 * @member cc.render.DecoratedWebGLRenderingContext#_currentFillStyleColor
                 * @type {Float32Array}
                 * @private
                 */
                this._currentFillStyleColor = new Float32Array([0.0, 0.0, 0.0, 1.0]);
                this._currentFillStylePattern = null;
                /**
                 * Current fill style type. The style type reflects what shader is currently set for rendering.
                 * @member cc.render.DecoratedWebGLRenderingContext#_currentFillStyleType
                 * @type {cc.render.FillStyleType}
                 * @private
                 */
                this._currentFillStyleType = 0 /* COLOR */;
                this._currentTintColor = new Float32Array([1.0, 1.0, 1.0, 1.0]);
                /**
                 * Last global composite operation set.
                 * @member cc.render.DecoratedWebGLRenderingContext#_currentGlobalCompositeOperation
                 * @type {string}
                 * @private
                 */
                this._currentGlobalCompositeOperation = 0 /* source_over */;
                /**
                 * Internal rendering shaders.
                 * @member cc.render.DecoratedWebGLRenderingContext#_shaders
                 * @type {Array<cc.render.shader.SolidColorShader>}
                 * @private
                 */
                this._shaders = [];
                /**
                 * Geometry batcher.
                 * @member cc.render.DecoratedWebGLRenderingContext#_batcher
                 * @type {cc.render.GeometryBatcher}
                 * @private
                 */
                this._batcher = null;
                this._webglState = null;
                this._width = 0;
                this._height = 0;
                this._renderer = null;
                /**
                 * Rendering surface (canvas object)
                 * @member cc.render.DecoratedWebGLRenderingContext#_canvas
                 * @type {HTMLCanvasElement}
                 * @private
                 */
                this._canvas = null;
                /**
                 * Get RenderingContext type.
                 * @member cc.render.DecoratedWebGLRenderingContext#get:type
                 * @returns {number} cc.render.RENDERER_TYPE_WEBGL or cc.render.RENDERER_TYPE_CANVAS
                 */
                this.type = cc.render.RENDERER_TYPE_WEBGL;
                this._renderer = r;
                this._canvas = r._surface;
                this.__initContext();
                this._batcher = new GeometryBatcher(this._webglState);
                this._currentContextSnapshot = new RenderingContextSnapshot();
                this._contextSnapshots.push(this._currentContextSnapshot);
                this.__createRenderingShaders(this._canvas.width, this._canvas.height);
                this.__setGlobalCompositeOperation();
            }
            DecoratedWebGLRenderingContext.prototype.__initContext = function () {
                var _canvas = this._canvas;
                function createContext() {
                    var _gl = null;
                    try {
                        var obj = {
                            premultipliedAlpha: DecoratedWebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                            antialias: DecoratedWebGLRenderingContext.ANTIALIAS,
                            alpha: DecoratedWebGLRenderingContext.CTX_ALPHA,
                            stencil: true
                        };
                        _gl = _canvas.getContext("webgl", obj) || _canvas.getContext("experimental-webgl", obj);
                        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, DecoratedWebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL ? 1 : 0);
                    }
                    catch (e) {
                        alert("WebGL context error");
                    }
                    return _gl;
                }
                function initializeContext(webglState) {
                    var _gl = webglState._gl;
                    // Set clear color to black, fully transparent
                    webglState.clearColor(0, 0, 0, 0);
                    // Disable depth testing
                    webglState.disable(_gl.DEPTH_TEST);
                    // Disable back face culling
                    webglState.disable(_gl.CULL_FACE);
                    // Clear the color as well as the depth buffer.
                    webglState.clear(_gl.COLOR_BUFFER_BIT);
                    webglState.viewport(0, 0, _canvas.width, _canvas.height);
                }
                this._width = this._canvas.width;
                this._height = this._canvas.height;
                this._webglState = new WebGLState(createContext());
                initializeContext(this._webglState);
            };
            DecoratedWebGLRenderingContext.prototype.clear = function () {
                var gl = this._webglState;
                var flags = gl._gl.COLOR_BUFFER_BIT;
                if (gl.flagEnabled(gl._gl.STENCIL_TEST)) {
                    flags |= gl._gl.STENCIL_BUFFER_BIT;
                }
                gl.clear(flags);
            };
            DecoratedWebGLRenderingContext.prototype.getWidth = function () {
                return this._width;
            };
            DecoratedWebGLRenderingContext.prototype.getHeight = function () {
                return this._height;
            };
            DecoratedWebGLRenderingContext.prototype.__createProjection = function (w, h) {
                /**
                 * Make an orthographics projection matrix.
                 * @param left {number}
                 * @param right {number}
                 * @param bottom {number}
                 * @param top {number}
                 * @param znear {number}
                 * @param zfar {number}
                 *
                 * @returns {Float32Array}
                 */
                function createOrthographicProjectionMatrix(left, right, bottom, top, znear, zfar) {
                    var tx = -(right + left) / (right - left);
                    var ty = -(top + bottom) / (top - bottom);
                    var tz = -(zfar + znear) / (zfar - znear);
                    return new Float32Array([2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, -2 / (zfar - znear), 0, tx, ty, tz, 1]);
                }
                var opm = [];
                opm.push(createOrthographicProjectionMatrix(0, w, h, 0, -1, 1));
                opm.push(createOrthographicProjectionMatrix(0, w, 0, h, -1, 1));
                return opm;
            };
            /**
             * Create internal rendering shaders.
             * Do not call directly.
             * @method cc.render.DecoratedWebGLRenderingContext#__createRenderingShaders
             * @param w {number}
             * @param h {number}
             * @private
             */
            DecoratedWebGLRenderingContext.prototype.__createRenderingShaders = function (w, h) {
                /**
                 * Never change the order the shaders are pushed.
                 * BUGBUG change the _shader array in favor of an associative collection.
                 */
                this._shaders.push(new SolidColorShader(this._webglState));
                this._shaders.push(new TextureShader(this._webglState));
                this._shaders.push(new FastTextureShader(this._webglState));
                this._shaders.push(new TexturePatternShader(this._webglState));
                this._shaders.push(new cc.render.shader.MeshShader(this._webglState));
                this.__setShadersProjection(w, h);
                this._shaders[0].useProgram();
            };
            DecoratedWebGLRenderingContext.prototype.__setShadersProjection = function (w, h) {
                var opms = this.__createProjection(w, h);
                var opm = opms[0];
                var opm_inverse = opms[1];
                for (var i = 0; i < this._shaders.length; i++) {
                    if (i !== 2) {
                        this._shaders[i]._uniformProjection.setValue(opm);
                    }
                    else {
                        /**
                         * FastShader needs different projection matrices because quad coordinates are calculated in the shader,
                         * and not in the client. Thus it is mandatory to send the correct projection matrix based on the
                         * y-axis rendering origin.
                         */
                        this._shaders[2]._uniformProjection.setValue(cc.render.RENDER_ORIGIN === cc.render.ORIGIN_TOP ? opm : opm_inverse);
                    }
                }
            };
            Object.defineProperty(DecoratedWebGLRenderingContext.prototype, "canvas", {
                /**
                 * Get the rendering surface object (canvas).
                 * @method cc.render.DecoratedWebGLRenderingContext#get:canvas
                 * @returns {HTMLCanvasElement}
                 */
                get: function () {
                    return this._canvas;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Set the current rendering tint color. Tint color is an array of 4 components for rgba. Values 0..1
             * @method cc.render.DecoratedWebGLRenderingContext#set:tintColor
             * @param color {cc.math.Color}
             */
            DecoratedWebGLRenderingContext.prototype.setTintColor = function (color) {
                this._currentTintColor = color._color;
            };
            Object.defineProperty(DecoratedWebGLRenderingContext.prototype, "tintColor", {
                set: function (color) {
                    this._currentTintColor = color._color;
                },
                enumerable: true,
                configurable: true
            });
            DecoratedWebGLRenderingContext.prototype.setGlobalAlpha = function (v) {
                this._currentContextSnapshot._globalAlpha = v;
            };
            DecoratedWebGLRenderingContext.prototype.getGlobalAlpha = function () {
                return this._currentContextSnapshot._globalAlpha;
            };
            /**
             * Set the current rendering composite operation (blend mode).
             * The value is any of:
             *
             * "source-over", "source-out", "source-in", "source-atop", "destination-over", "destination-in",
             * "destination-out", "destination-atop", "multiply", "screen", "copy", "lighter", "darker", "xor", "add"
             *
             * @method cc.render.DecoratedWebGLRenderingContext#set:globalCompositeOperation
             * @param gco {cc.render.CompositeOperation}
             */
            DecoratedWebGLRenderingContext.prototype.setCompositeOperation = function (gco) {
                this._currentGlobalCompositeOperation = gco;
            };
            DecoratedWebGLRenderingContext.prototype.getCompositeOperation = function () {
                return this._currentGlobalCompositeOperation;
            };
            /**
             * Internal blending mode set.
             * This function is called not when the blending mode is set, but when an actual geometry operation is about
             * to happen.
             * @method cc.render.DecoratedWebGLRenderingContext#__setGlobalCompositeOperation
             * @private
             */
            DecoratedWebGLRenderingContext.prototype.__setGlobalCompositeOperation = function () {
                var gl = this._webglState._gl;
                this._webglState.enable(gl.BLEND);
                switch (this._currentGlobalCompositeOperation) {
                    case 0 /* source_over */:
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 1 /* source_out */:
                        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ZERO);
                        break;
                    case 2 /* source_in */:
                        gl.blendFunc(gl.DST_ALPHA, gl.ZERO);
                        break;
                    case 3 /* source_atop */:
                        gl.blendFunc(gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 4 /* destination_over */:
                        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.DST_ALPHA);
                        break;
                    case 5 /* destination_in */:
                        gl.blendFunc(gl.ZERO, gl.SRC_ALPHA);
                        break;
                    case 6 /* destination_out */:
                        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 7 /* destination_atop */:
                        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA);
                        break;
                    case 8 /* multiply */:
                        gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 9 /* screen */:
                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
                        break;
                    case 10 /* copy */:
                        gl.blendFunc(gl.ONE, gl.ZERO);
                        break;
                    case 11 /* lighter */:
                        gl.blendFunc(gl.ONE, gl.ONE);
                        break;
                    case 12 /* darker */:
                        gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 13 /* xor */:
                        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 14 /* add */:
                        gl.blendFunc(gl.SRC_ALPHA, gl.DST_ALPHA);
                        break;
                    default:
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                }
                this._currentContextSnapshot._globalCompositeOperation = this._currentGlobalCompositeOperation;
            };
            /**
             * Set the current transformation matrix.
             * @method cc.render.DecoratedWebGLRenderingContext#setTransform
             * @param a {number}
             * @param b {number}
             * @param c {number}
             * @param d {number}
             * @param tx {number}
             * @param ty {number}
             */
            DecoratedWebGLRenderingContext.prototype.setTransform = function (a, b, c, d, tx, ty) {
                Matrix3.setTransform(this._currentContextSnapshot._currentMatrix, a, b, c, d, tx, ty);
            };
            /**
             * Concatenate current transformation matrix with the given matrix coeficients.
             * @method cc.render.DecoratedWebGLRenderingContext#transform
             * @param a {number}
             * @param b {number}
             * @param c {number}
             * @param d {number}
             * @param tx {number}
             * @param ty {number}
             */
            DecoratedWebGLRenderingContext.prototype.transform = function (a, b, c, d, tx, ty) {
                Matrix3.transform(this._currentContextSnapshot._currentMatrix, a, b, c, d, tx, ty);
            };
            /**
             * Fill an area with the current fillStyle.
             * If w or h are <= 0 the call does nothing.
             * @method cc.render.DecoratedWebGLRenderingContext#fillRect
             * @param x {number}
             * @param y {number}
             * @param w {number}
             * @param h {number}
             */
            DecoratedWebGLRenderingContext.prototype.fillRect = function (x, y, w, h) {
                if (w <= 0 || h <= 0) {
                    return;
                }
                this.__flushFillRectIfNeeded();
                if (this._batcher.batchRect(x, y, w, h, this._currentContextSnapshot)) {
                    this.flush();
                }
            };
            DecoratedWebGLRenderingContext.prototype.drawTextureUnsafe = function (texture, sx, sy, sw, sh, dx, dy, dw, dh) {
            };
            DecoratedWebGLRenderingContext.prototype.drawTexture = function (texture, sx, sy, sw, sh, dx, dy, dw, dh) {
                var ti = texture;
                var textureId = ti._glId;
                // no texture info, or invalid gl texture id. do nothing.
                if (textureId === null) {
                    // BUGBUG refactor this
                    cc.Debug.warn(" --- lazy image to texture call.  --- deprecated and dangerous.");
                    ti.__setAsGLTexture(this._webglState);
                    textureId = ti._glId;
                }
                this.__drawImageFlushIfNeeded(textureId);
                var _sx;
                var _sy;
                var _sw;
                var _sh;
                var _dx;
                var _dy;
                var _dw;
                var _dh;
                if (arguments.length >= 9) {
                    if (ti._invertedY) {
                        sy = ti._imageHeight - (ti._offsetY + sy) - sh;
                    }
                    _sy = (sy + ti._offsetY) / ti._textureHeight;
                    _sx = (sx + ti._offsetX) / ti._textureWidth;
                    _sw = (sx + sw + ti._offsetX) / ti._textureWidth;
                    _sh = (sy + sh + ti._offsetY) / ti._textureHeight;
                    _dx = dx;
                    _dy = dy;
                    _dw = dw;
                    _dh = dh;
                }
                else if (arguments.length >= 5) {
                    _dx = sx;
                    _dy = sy;
                    _dw = sw;
                    _dh = sh;
                    _sx = ti._u0;
                    _sy = ti._v0;
                    _sw = ti._u1;
                    _sh = ti._v1;
                }
                else {
                    _dx = sx;
                    _dy = sy;
                    _dw = ti._imageWidth;
                    _dh = ti._imageHeight;
                    _sx = ti._u0;
                    _sy = ti._v0;
                    _sw = ti._u1;
                    _sh = ti._v1;
                }
                if (this._batcher.batchRectWithTexture(_dx, _dy, _dw, _dh, this._currentContextSnapshot, _sx, _sy, _sw, _sh)) {
                    this.flush();
                }
            };
            DecoratedWebGLRenderingContext.prototype.batchGeometryWithSprite = function (sprite, transposed) {
                var frame = sprite._spriteFrame;
                var rect = frame._normalizedRect;
                var u0 = rect.x;
                var v0 = rect.y;
                var u1 = rect.x1;
                var v1 = rect.y1;
                if (transposed) {
                }
                if (sprite.flippedX) {
                    var itmp = u0;
                    u0 = u1;
                    u1 = itmp;
                }
                if (sprite.flippedY) {
                    var itmp = v0;
                    v0 = v1;
                    v1 = itmp;
                }
                this.__drawImageFlushIfNeeded(frame._texture._glId);
                if (this._batcher.batchRectGeometryWithTexture(sprite._BBVertices, u0, v0, u1, v1, this._currentContextSnapshot)) {
                    this.flush();
                }
            };
            DecoratedWebGLRenderingContext.prototype.batchGeometryWithSpriteFast = function (sprite) {
                var frame = sprite._spriteFrame;
                var rect = frame._normalizedRect;
                var u0 = rect.x;
                var v0 = rect.y;
                var u1 = rect.x1;
                var v1 = rect.y1;
                if (sprite.flippedX) {
                    var itmp = u0;
                    u0 = u1;
                    u1 = itmp;
                }
                if (sprite.flippedY) {
                    var itmp = v0;
                    v0 = v1;
                    v1 = itmp;
                }
                this.__drawImageFastFlushIfNeeded(frame._texture._glId);
                if (this._batcher.batchRectGeometryWithSpriteFast(sprite, u0, v0, u1, v1, this._currentContextSnapshot)) {
                    this.flush();
                }
            };
            /**
             * Translate the current rendering context transformation matrix.
             * @method cc.render.DecoratedWebGLRenderingContext#translate
             * @param x {number}
             * @param y {number}
             */
            DecoratedWebGLRenderingContext.prototype.translate = function (x, y) {
                Matrix3.setTranslate(__mat3, x, y);
                Matrix3.multiply(this._currentContextSnapshot._currentMatrix, __mat3);
            };
            /**
             * Rotate the current rendering context transformation matrix.
             * @method cc.render.DecoratedWebGLRenderingContext#rotate
             * @param angle {number} angle in radians.
             */
            DecoratedWebGLRenderingContext.prototype.rotate = function (angle) {
                Matrix3.setRotate(__mat3, angle);
                Matrix3.multiply(this._currentContextSnapshot._currentMatrix, __mat3);
            };
            /**
             * Scale the current rendering context transformation matrix.
             * @method cc.render.DecoratedWebGLRenderingContext#scale
             * @param x {number} scale x axis.
             * @param y {number} scale y axis.
             */
            DecoratedWebGLRenderingContext.prototype.scale = function (x, y) {
                Matrix3.setScale(__mat3, x, y);
                Matrix3.multiply(this._currentContextSnapshot._currentMatrix, __mat3);
            };
            /**
             * Flush the content geometry, color and texture to the screen.
             * @member cc.render.DecoratedWebGLRenderingContext#flush
             */
            DecoratedWebGLRenderingContext.prototype.flush = function () {
                this._batcher.flush(this._shaders[this._currentContextSnapshot._currentFillStyleType], this._currentContextSnapshot);
                //            this._debugInfo._draws++;
            };
            DecoratedWebGLRenderingContext.prototype.resize = function () {
                this.__initContext();
                this.__setShadersProjection(this._canvas.width, this._canvas.height);
            };
            DecoratedWebGLRenderingContext.prototype.getUnitsFactor = function () {
                return this._renderer.getUnitsFactor();
            };
            /**
             * @method cc.render.DecoratedWebGLRenderingContext#__drawImageFlushIfNeeded
             * @param textureId {WebGLTexture}
             * @private
             */
            DecoratedWebGLRenderingContext.prototype.__drawImageFastFlushIfNeeded = function (textureId) {
                this.__drawImageFlushIfNeededImpl(2 /* IMAGEFAST */, this._shaders[2 /* IMAGEFAST */], textureId);
            };
            /**
             * @method cc.render.DecoratedWebGLRenderingContext#__drawImageFlushIfNeeded
             * @param textureId {WebGLTexture}
             * @private
             */
            DecoratedWebGLRenderingContext.prototype.__drawImageFlushIfNeeded = function (textureId) {
                this.__drawImageFlushIfNeededImpl(1 /* IMAGE */, this._shaders[1 /* IMAGE */], textureId);
            };
            DecoratedWebGLRenderingContext.prototype.__drawImageFlushIfNeededImpl = function (fillStyleType, shader, textureId) {
                if (this._currentContextSnapshot._currentFillStyleType !== fillStyleType) {
                    this.flush();
                    this.__setCurrentFillStyleType(fillStyleType);
                    this._currentContextSnapshot._tintColor = this._currentTintColor;
                    shader._uniformTextureSampler.setValue(0);
                    this._webglState.setTexture(0, textureId);
                }
                else {
                    // different textures ? flush.
                    if (this._webglState._currentTexture !== textureId) {
                        this.flush();
                        shader._uniformTextureSampler.setValue(0);
                        this._webglState.setTexture(0, textureId);
                    }
                    this._currentContextSnapshot._tintColor = this._currentTintColor;
                    this.__compositeFlushIfNeeded();
                }
            };
            DecoratedWebGLRenderingContext.prototype.__flushFillRectIfNeeded = function () {
                if (this._currentContextSnapshot._currentFillStyleType !== this._currentFillStyleType) {
                    this.flush();
                    this.__setCurrentFillStyleType(this._currentFillStyleType);
                }
                this._currentContextSnapshot._fillStyleColor = this._currentFillStyleColor;
                this._currentContextSnapshot._fillStylePattern = this._currentFillStylePattern;
                this._currentContextSnapshot._tintColor = this._currentTintColor;
            };
            DecoratedWebGLRenderingContext.prototype.__compositeFlushIfNeeded = function () {
                if (this._currentGlobalCompositeOperation !== this._currentContextSnapshot._globalCompositeOperation) {
                    this.flush();
                    this.__setGlobalCompositeOperation();
                }
            };
            /**
             * @method cc.render.DecoratedWebGLRenderingContext#__setCurrentFillStyleType
             * @param f {cc.render.FillStyleType}
             * @private
             */
            DecoratedWebGLRenderingContext.prototype.__setCurrentFillStyleType = function (f) {
                this._shaders[this._currentContextSnapshot._currentFillStyleType].notUseProgram();
                this._shaders[f].useProgram();
                this._currentContextSnapshot._currentFillStyleType = f;
                this._currentFillStyleType = f;
            };
            DecoratedWebGLRenderingContext.prototype.setFillStyleColor = function (color) {
                this._currentFillStyleColor = color._color;
                this._currentFillStyleType = 0 /* COLOR */;
            };
            DecoratedWebGLRenderingContext.prototype.setFillStyleColorArray = function (colorArray) {
                this._currentFillStyleColor = colorArray;
                this._currentFillStyleType = 0 /* COLOR */;
            };
            DecoratedWebGLRenderingContext.prototype.setFillStylePattern = function (pattern) {
                // BUGBUG change for actual pattern type
                this._currentFillStyleType = 3 /* PATTERN_REPEAT */;
                this._currentFillStylePattern = pattern;
            };
            DecoratedWebGLRenderingContext.prototype.beginPath = function () {
            };
            DecoratedWebGLRenderingContext.prototype.stroke = function () {
            };
            DecoratedWebGLRenderingContext.prototype.moveTo = function (x, y) {
            };
            DecoratedWebGLRenderingContext.prototype.lineTo = function (x, y) {
            };
            DecoratedWebGLRenderingContext.prototype.save = function () {
            };
            DecoratedWebGLRenderingContext.prototype.restore = function () {
            };
            DecoratedWebGLRenderingContext.prototype.drawMesh = function (geometry, uv, indices, color, texture) {
                this.__checkMeshFlushConditions(texture._glId, color);
                this._batcher.batchMesh(geometry, uv, indices, color, this._currentContextSnapshot);
                this.flush();
            };
            DecoratedWebGLRenderingContext.prototype.__checkMeshFlushConditions = function (textureId, color) {
                if (this._currentContextSnapshot._currentFillStyleType !== 4 /* MESH */) {
                    this.flush();
                    this.__setCurrentFillStyleType(4 /* MESH */);
                }
                var shader = this._shaders[4 /* MESH */];
                shader.mat4_from_mat3(this._currentContextSnapshot._currentMatrix, __mat4);
                var r = (color >> 24) & 0xff;
                var g = (color >> 16) & 0xff;
                var b = (color >> 8) & 0xff;
                var a = (color) & 0xff;
                shader._uniformTransform.setValue(__mat4);
                shader._uniformTextureSampler.setValue(0);
                shader._uniformColor.setValue([r, g, b, a]);
                this._webglState.setTexture(0, textureId);
            };
            /**
             * Enable UNPACK_PREMULTIPLY_ALPHA_WEBGL for textures. False by default.
             * @member cc.render.DecoratedWebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL
             * @type {boolean}
             */
            DecoratedWebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL = false;
            /**
             * Enable antialias. False by default
             * @member cc.render.DecoratedWebGLRenderingContext.ANTIALIAS
             * @type {boolean}
             */
            DecoratedWebGLRenderingContext.ANTIALIAS = false;
            /**
             * Enable context-document alpha blending. False by default.
             * @member cc.render.DecoratedWebGLRenderingContext.CTX_ALPHA
             * @type {boolean}
             */
            DecoratedWebGLRenderingContext.CTX_ALPHA = false;
            return DecoratedWebGLRenderingContext;
        })();
        render.DecoratedWebGLRenderingContext = DecoratedWebGLRenderingContext;
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../math/Dimension.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../util/Debug.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        /**
         * When setScaleContent is called on a renderer, this hint will tell how to position scenes in director's area.
         * TOP and BOTTOM values are specified regardless of y-axis rendering origin. TOP will always be TOP of the screen.
         * @tsenum cc.render.ScaleContentSceneHint
         */
        (function (ScaleContentSceneHint) {
            ScaleContentSceneHint[ScaleContentSceneHint["TOP"] = 1] = "TOP";
            ScaleContentSceneHint[ScaleContentSceneHint["LEFT"] = 2] = "LEFT";
            ScaleContentSceneHint[ScaleContentSceneHint["BOTTOM"] = 4] = "BOTTOM";
            ScaleContentSceneHint[ScaleContentSceneHint["RIGHT"] = 8] = "RIGHT";
            ScaleContentSceneHint[ScaleContentSceneHint["CENTER"] = 16] = "CENTER";
            ScaleContentSceneHint[ScaleContentSceneHint["STRETCH"] = 32] = "STRETCH";
        })(render.ScaleContentSceneHint || (render.ScaleContentSceneHint = {}));
        var ScaleContentSceneHint = render.ScaleContentSceneHint;
        /**
         * Values for Scale canvas and Scale content.
         * @tsenum cc.render.ScaleManagerStrategy
         */
        (function (ScaleManagerStrategy) {
            ScaleManagerStrategy[ScaleManagerStrategy["NONE"] = 0] = "NONE";
            ScaleManagerStrategy[ScaleManagerStrategy["SCALE_FIT"] = 1] = "SCALE_FIT";
            ScaleManagerStrategy[ScaleManagerStrategy["SCALE_ASPECT"] = 2] = "SCALE_ASPECT";
            ScaleManagerStrategy[ScaleManagerStrategy["SCALE_CONTENT"] = 128] = "SCALE_CONTENT";
        })(render.ScaleManagerStrategy || (render.ScaleManagerStrategy = {}));
        var ScaleManagerStrategy = render.ScaleManagerStrategy;
        /**
         * Values for forcing orientation.
         * @tsenum cc.render.OrientationStrategy
         */
        (function (OrientationStrategy) {
            OrientationStrategy[OrientationStrategy["BOTH"] = 0] = "BOTH";
            OrientationStrategy[OrientationStrategy["PORTRAIT"] = 1] = "PORTRAIT";
            OrientationStrategy[OrientationStrategy["LANDSCAPE"] = 2] = "LANDSCAPE";
        })(render.OrientationStrategy || (render.OrientationStrategy = {}));
        var OrientationStrategy = render.OrientationStrategy;
        /**
         * Values for canvas positioning inside parent node after setting canvas Scale values.
         * @tsenum cc.render.ScalePosition
         */
        (function (ScalePosition) {
            ScalePosition[ScalePosition["NONE"] = 0] = "NONE";
            ScalePosition[ScalePosition["CENTER"] = 1] = "CENTER";
            ScalePosition[ScalePosition["LEFT"] = 2] = "LEFT";
            ScalePosition[ScalePosition["RIGHT"] = 4] = "RIGHT";
        })(render.ScalePosition || (render.ScalePosition = {}));
        var ScalePosition = render.ScalePosition;
        /**
         * @class cc.render.ScaleManager
         * @classdesc
         *
         *
         * The ScaleManager object has different responsibilities that affect the final visual of the built Canvas object.
         * <p>
         * Its main responsibilities are:
         * <ul>
         *     <li>Up/Down scale the canvas object to fit the screen.
         *     <li>Up/Down scale the game content.
         *     <li>Fix the orientation and notify when it changes.
         * </ul>
         * <p>
         * There are important differences between the first and second responsibility, as well as important performance/visual
         * implications.
         *
         * <h3>Up/Down scale the canvas object.</h3>
         * <p>
         *     This feature affects the canvas object, which is scaled using css attributes. This operation affects the final
         *     game's visual quality. For example, if your game uses a 400x300 pixels canvas object, and the window is 1200x900
         *     pixels, the canvas object could be scaled by 3 in each axe, which will lower the visual quality. There are
         *     ways of overcoming this by up/down scaling the game content though.
         * <p>
         *     These scaling operations are sensitive to the DOM node that contains the canvas object though. Internally, this
         *     API call modifies the canvas size with a CSS style.
         * <p>
         *     There are two different modifiers which will tell how to up/down scale the canvas object:
         *
         *     <h4>Scale strategy (How to scale the canvas)</h4>
         *
         *     <ul>NONE</ul>
         *     <p>
         *         This modifier does not change the canvas in any way. It will be presented on screen with the original size
         *     <ul>SCALE_FIT</ul>
         *     <p>
         *         This modifier will stretch the canvas to fit the DOM parent container object. The stretching can be uneven,
         *         breaking the aspect ratio.
         *     <ul>SCALE_ASPECT</ul>
         *     <p>
         *         This modifier will stretch the canvas preserving its aspect ratio. The final scaled Canvas may not take
         *         over the whole parent node's screen area, and some letterboxing effect may occur. This effect makes some
         *         horizontal or vertical lines appear since the canvas can't cover the whole area. You control how these
         *         lines appear with the ScalePosition modifier.
         *
         *     <h4>Scale position (how to position the canvas relative to the parent's client area.</h4>
         *     <ul>NONE</ul>
         *     <p>
         *         Do nothing special. Follow the natural browser rules to position the canvas in the parent. If the
         *         scale strategy is SCALE_ASPECT, the letter-boxing will be on the right/bottom or left/bottom (depending
         *         if the browser writes text left-to-right or right-to-left respectively).
         *     <ul>LEFT</ul>
         *     <p>
         *         Force the canvas position to be left in the parent Node's client area.
         *     <ul>RIGHT</ul>
         *     <p>
         *         Force the canvas position to be right in the parent Node's client area.
         *     <ul>CENTER</ul>
         *     <p>
         *         Force the canvas position to be centered in the parent Node's client area. When the ccale strategy is
         *         SCALE_ASPECT, this is the best option since the letterbox will be evenly distributed to the sides or
         *         top/down of the canvas.
         *
         * <h3>Up/down scale the canvas content, not the canvas itself.</h3>
         * <p>
         *     This feature affects the Canvas content which has a direct impact in better visual quality (if higher resolution
         *     graphics are used) but has an impact in performance as well (bigger graphics, could mean lower performance).
         * <p>
         *     When you want to build a retina enabled game, this is the feature you need to focus on.
         * <p>
         *     Basically, what we want to achieve is to break the bound between pixels and in-game units. This is what happens
         *     with retina displays, which for example, report a 480x320 viewport size, while the actual screen resolution
         *     is 960x640. The system is breaking the bound between points and pixels.
         * <p>
         *     For our games, we may to achieve the same effect, and it is achieved by setting the ratio between pixels and
         *     game units.
         * <p>
         *     A call in the ScaleManager of the form: <code>setScaleContent( unitsWidth:number, unitsHeight:number )</code>
         *     must be done. This will instrument the CocosJS core to break the bound, and start upscaling content.
         *     CocosJS already makes all internal considerations to draw bigger resources in the same screen area resulting
         *     in an upgraded visual experience at no cost.
         * <p>
         *     Internally this API will build a bigger canvas to conform to all the available space, so don't rely on
         *     canvas.width or canvas.height values at all in your game.
         *
         *
         * <h3>Orientation</h3>
         * <p>
         *     This feature affects mobile device or screen orientation. Events for this events can be fired as well if the
         *     browser window aspect ratio changes.
         * <p>
         *     Even though the screen orientation can't yet be locked in HTML5, this API will allow you to manually switch
         *     to a wrong-orientation mode. The default orientation mode is BOTH, so any orientation will be considered valid.
         * <p>
         *     A call to <code>ScaleManager.forceOrientation( orientation:OrientationStrategy, onOk, onError )</code>
         *     must be done to enable orientation control.
         *
         *
         */
        var ScaleManager = (function () {
            /**
             * Create a new ScaleManager object instance.
             * @method cc.render.ScaleManager#constructor
             */
            function ScaleManager(renderer) {
                /**
                 * A DOM Node, and is the reference node to calculate values for ScaleStrategy's canvas
                 * positioning. Null means to use the window as reference.
                 * @member cc.render.ScaleManager#_referenceParentNode
                 * @type {HTMLElement}
                 * @private
                 */
                this._referenceParentNode = null;
                /**
                 * The Scale strategy for up/down scaling the canvas object. Values are from the enum
                 * object ScaleManagerStrategy. By default, no scale on the canvas will be applied.
                 * @member cc.render.ScaleManager#_scaleStrategy
                 * @type {number}
                 * @private
                 */
                this._scaleStrategy = 0 /* NONE */;
                /**
                 * The Canvas position after setting a ScaleStrategy value. By default, no Position will be forced since by default,
                 * there's no scale to apply. Values are from the enum object ScalePosition.
                 * @member cc.render.ScaleManager#_scalePosition
                 * @type {number}
                 * @private
                 */
                this._scalePosition = 0 /* NONE */;
                /**
                 * The preferred Game orientation. By default, both orientations are suitable. The values are from the enum
                 * object OrientationStrategy.
                 * @member cc.render.ScaleManager#_forceOrientationStrategy
                 * @type {number}
                 * @private
                 */
                this._forceOrientationStrategy = 0 /* BOTH */;
                /**
                 * Internal boolean that sets current orientation as valid or not depending on the forced orientation strategy.
                 * @member cc.render.ScaleManager#_wrongOrientation
                 * @type {boolean}
                 * @private
                 */
                this._wrongOrientation = false;
                /**
                 * Callback invoked when the device is or enters in a wrong orientation.
                 * @member cc.render.ScaleManager#_onOrientationError
                 * @type {cc.render.OrientationCallback}
                 * @private
                 */
                this._onOrientationError = null;
                /**
                 * Callback invoked when the device is or enters in a valid orientation.
                 * @member cc.render.ScaleManager#_onOrientationOk
                 * @type {cc.render.OrientationCallback}
                 * @private
                 */
                this._onOrientationOk = null;
                /**
                 * Is the game in fullscreen ?
                 * @member cc.render.ScaleManager#_fullScreen
                 * @type {boolean}
                 * @private
                 */
                this._fullScreen = false;
                /**
                 * Is current browser/device/wrapper full screen capable ?
                 * @member cc.render.ScaleManager#_fullScreenCapable
                 * @type {boolean}
                 * @private
                 */
                this._fullScreenCapable = false;
                /**
                 * Canvas object to apply the Scale strategies to.
                 * @member cc.render.ScaleManager#_surface
                 * @type {HTMLCanvasElement}
                 * @private
                 */
                this._surface = null;
                /**
                 * Current browser vendor prefix for orientation and full screen operations.
                 * @member cc.render.ScaleManager#_prefix
                 * @type {string}
                 * @private
                 */
                this._prefix = null;
                /**
                 * When resizing the window object, the ScaleManager must wait a few milliseconds to fire its internal
                 * orientation, and scale tests. This member is the setTimeout generated id.
                 * @member cc.render.ScaleManager#_windowResizeTimer
                 * @type {number}
                 * @private
                 */
                this._windowResizeTimer = null;
                /**
                 * Callback invoked when the system exits full screen.
                 * @member cc.render.ScaleManager#_onExitFullScreen
                 * @type {cc.render.FullScreenCallback}
                 * @private
                 */
                this._onExitFullScreen = null;
                /**
                 * Callback invoked when the system enters full screen.
                 * @member cc.render.ScaleManager#_onEnterFullScreen
                 * @type {cc.render.FullScreenCallback}
                 * @private
                 */
                this._onEnterFullScreen = null;
                /**
                 * Cached vendor-dependent enter fullscreen function name.
                 * @member cc.render.ScaleManager#_requestFullScreen
                 * @type {string}
                 * @private
                 */
                this._requestFullScreen = null;
                /**
                 * Cached vendor-dependent exit fullscreen function name.
                 * @member cc.render.ScaleManager#_exitFullScreen
                 * @type {string}
                 * @private
                 */
                this._exitFullScreen = null;
                /**
                 * When scale content is enabled, this is the internal matrix to achieve the expected result.
                 * @member cc.render.ScaleManager#_unitsMatrix
                 * @type {Float32Array}
                 * @private
                 */
                this._unitsMatrix = new Float32Array(9);
                /**
                 * If scale content is enabled, this is the scale ratio to convert units to pixels.
                 * @member cc.render.ScaleManager#_unitsFactor
                 * @type {number}
                 * @private
                 */
                this._unitsFactor = 1;
                /**
                 * Has setContentScale been called ?
                 * @member cc.render.ScaleManager#_contentScaled
                 * @type {boolean}
                 * @private
                 */
                this._contentScaled = false;
                // bugbug refactor this.
                this._renderer = null;
                this._onWindowResized = null;
                this._renderer = renderer;
                this._units = new cc.math.Dimension();
                cc.math.Matrix3.identity(this._unitsMatrix);
                this._unitsFactor = 1;
                this.__initialize();
                this.setScaleSurface(renderer._surface);
                //this.setScaleContent( renderer._surface.width, renderer._surface.height );
                this.__setScaleContentMatrix();
            }
            /**
             * Initialize the ScaleManager, get method cache names, etc.
             * @method cc.render.ScaleManager#__initialize
             * @private
             */
            ScaleManager.prototype.__initialize = function () {
                var prefix = ['', 'moz', 'ms', 'webkit'];
                for (var i = 0; i < prefix.length; i++) {
                    if (prefix[i] === "moz") {
                        if (typeof document.body['mozRequestFullScreen'] !== "undefined") {
                            this._prefix = 'moz';
                            this._requestFullScreen = 'mozRequestFullScreen';
                            this._exitFullScreen = 'mozCancelFullScreen';
                            document.addEventListener(this._prefix + 'fullscreenchange', this.__fullScreenChange.bind(this), false);
                            document.addEventListener(this._prefix + 'fullscreenerror', this.__fullScreenError.bind(this), false);
                        }
                    }
                    else {
                        if (document.body[prefix[i] + (prefix[i] === '' ? 'requestFullscreen' : 'RequestFullscreen')]) {
                            this._prefix = prefix[i];
                            this._requestFullScreen = prefix[i] === '' ? 'requestFullscreen' : prefix[i] + 'RequestFullscreen';
                            this._exitFullScreen = prefix[i] === '' ? 'exitFullscreen' : prefix[i] + 'ExitFullscreen';
                            if (prefix[i] === 'ms') {
                                document.addEventListener('MSFullscreenChange', this.__fullScreenChange.bind(this), false);
                                document.addEventListener('MSFullscreenError', this.__fullScreenError.bind(this), false);
                            }
                            else {
                                document.addEventListener(this._prefix + 'fullscreenchange', this.__fullScreenChange.bind(this), false);
                                document.addEventListener(this._prefix + 'fullscreenerror', this.__fullScreenError.bind(this), false);
                            }
                            break;
                        }
                    }
                }
                this._fullScreenCapable = null !== this._prefix;
                window.addEventListener('resize', this.__windowResized.bind(this), false);
            };
            /**
             * Set the canvas to apply the ScaleStrategy to.
             * @method cc.render.ScaleManager#setScaleSurface
             * @param surface {HTMLCanvasElement}
             */
            ScaleManager.prototype.setScaleSurface = function (surface) {
                this._surface = surface;
                this._units.width = surface.width;
                this._units.height = surface.height;
                this.checkOrientation();
                var me = this;
                setTimeout(function () {
                    me.__setScaleImpl();
                }, 200);
            };
            /**
             * After setting scale content, this value is the ratio to transform in-game units to pixels.
             * @method cc.render.ScaleManager#getUnitsFactor
             * @returns {number}
             */
            ScaleManager.prototype.getUnitsFactor = function () {
                return this._unitsFactor;
            };
            /**
             * Enable orientation change detection. If not set, landscape and portrait will be valid orientations.
             * @method cc.render.ScaleManager#forceOrientation
             * @param os {cc.render.OrientationStrategy} enum orientation value
             * @param onOk {cc.render.OrientationOkCallback=} callback invoked when the orientation changes and is valid.
             * @param onError {cc.render.OrientationErrorCallback=} callback invoked when the orientation changes and is NOT valid.
             * @returns {cc.render.ScaleManager}
             */
            ScaleManager.prototype.forceOrientation = function (os, onOk, onError) {
                this._forceOrientationStrategy = os;
                // don't use setters to prevent fire reflow events.
                if (onOk) {
                    this._onOrientationOk = onOk;
                }
                if (onError) {
                    this._onOrientationError = onError;
                }
                this.checkOrientation();
                return this;
            };
            /**
             * Check whether the orientation is valid, and invoke callbacks accordingly.
             * @method cc.render.ScaleManager#checkOrientation
             * @private
             */
            ScaleManager.prototype.checkOrientation = function () {
                var currentOrientation = window.innerWidth > window.innerHeight ? 2 /* LANDSCAPE */ : 1 /* PORTRAIT */;
                if (this._forceOrientationStrategy === 0 /* BOTH */) {
                    if (this._onOrientationOk) {
                        this._onOrientationOk(currentOrientation);
                    }
                }
                if (currentOrientation !== this._forceOrientationStrategy) {
                    this._wrongOrientation = true;
                    if (this._onOrientationError) {
                        this._onOrientationError();
                    }
                }
                else {
                    if (this._wrongOrientation && this._onOrientationOk) {
                        if (this._onOrientationOk) {
                            this._onOrientationOk(currentOrientation);
                        }
                    }
                    this._wrongOrientation = false;
                }
            };
            /**
             * Get whether the current orientation is valid compared to the expected orientation.
             * @method cc.render.ScaleManager#isWrongOrientation
             * @returns {boolean}
             */
            ScaleManager.prototype.isWrongOrientation = function () {
                return this._wrongOrientation;
            };
            /**
             * Get whether the system is able to switch to full screen mode.
             * @method cc.render.ScaleManager#isFullScreenCapable
             * @returns {boolean}
             */
            ScaleManager.prototype.isFullScreenCapable = function () {
                return this._fullScreenCapable;
            };
            /**
             * Start full screen process. If success the optional f callback function will be called.
             * @method cc.render.ScaleManager#startFullScreen
             * @param f {cc.render.FullScreenCallback=} callback invoked when successfully switching to full screen.
             */
            ScaleManager.prototype.startFullScreen = function (f) {
                if (this._fullScreenCapable) {
                    if (typeof f !== "undefined") {
                        this.onEnterFullScreen(f);
                    }
                    this._surface[this._requestFullScreen]();
                }
            };
            /**
             * End full screen process. If success the optional f callback function will be called.
             * @method cc.render.ScaleManager#startFullScreen
             * @param f {cc.render.FullScreenCallback=} callback invoked when successfully exiting from full screen.
             */
            ScaleManager.prototype.endFullScreen = function (f) {
                if (this._fullScreenCapable) {
                    if (typeof f !== "undefined") {
                        this.onExitFullScreen(f);
                    }
                    document[this._exitFullScreen]();
                }
            };
            /**
             * Get whether the scale manager is currently in full screen mode.
             * @method cc.render.ScaleManager#isFullScreen
             * @returns {boolean}
             */
            ScaleManager.prototype.isFullScreen = function () {
                return this._fullScreen;
            };
            ScaleManager.prototype.onWindowResized = function (callback) {
                this._onWindowResized = callback;
                return this;
            };
            /**
             * Internal operation when the window resizes and scale content/scale strategies are set.
             * @method cc.render.ScaleManager#__windowResized
             * @param e {UIEvent}
             * @private
             */
            ScaleManager.prototype.__windowResized = function (e) {
                if (this._windowResizeTimer !== null) {
                    clearTimeout(this._windowResizeTimer);
                }
                var me = this;
                this._windowResizeTimer = setTimeout(function () {
                    clearTimeout(me._windowResizeTimer);
                    me._windowResizeTimer = null;
                    me.checkOrientation();
                    if (me._contentScaled) {
                        var w, h;
                        if (this._referenceParentNode) {
                            w = this._referenceParentNode.width;
                            h = this._referenceParentNode.height;
                        }
                        else {
                            w = window.innerWidth;
                            h = window.innerHeight;
                        }
                        //me._renderer.setScaleContent( me._units.width,  me._units.height, w, h );
                        me._onWindowResized(w, h);
                    }
                    if (!this.__wrongOrientation) {
                        me.__setScaleImpl();
                    }
                }, 1000);
            };
            /**
             * Internal operation when the system switches to full screen.
             * @method cc.render.ScaleManager#__fullScreenChange
             * @param e {UIEvent}
             * @private
             */
            ScaleManager.prototype.__fullScreenChange = function (e) {
                if (this._fullScreen) {
                    if (this._onExitFullScreen) {
                        this._onExitFullScreen();
                    }
                    this._fullScreen = false;
                }
                else {
                    if (this._onEnterFullScreen) {
                        this._onEnterFullScreen();
                    }
                    this._fullScreen = true;
                }
                var me = this;
                setTimeout(function () {
                    me.__setScaleImpl();
                }, 500);
            };
            /**
             * Register callback to be notified when the system successfully enters full screen mode.
             * @method cc.render.ScaleManager#onEnterFullScreen
             * @param f {cc.render.FullScreenCallback}
             * @returns {cc.render.ScaleManager}
             */
            ScaleManager.prototype.onEnterFullScreen = function (f) {
                this._onEnterFullScreen = f;
                return this;
            };
            /**
             * Register callback to be notified when the system successfully exits full screen mode.
             * @method cc.render.ScaleManager#onExitFullScreen
             * @param f {cc.render.FullScreenCallback}
             * @returns {cc.render.ScaleManager}
             */
            ScaleManager.prototype.onExitFullScreen = function (f) {
                this._onExitFullScreen = f;
                return this;
            };
            /**
             * Register callback to be notified when the system successfully changes orientation.
             * @method cc.render.ScaleManager#onOrientationOk
             * @param f {cc.render.OrientationOkCallback}
             * @returns {cc.render.ScaleManager}
             */
            ScaleManager.prototype.onOrientationOk = function (f) {
                this._onOrientationOk = f;
                this.checkOrientation();
                return this;
            };
            /**
             * Register callback to be notified when the system unsuccessfully changes orientation.
             * @method cc.render.ScaleManager#onOrientationError
             * @param f {cc.render.OrientationCallback}
             * @returns {cc.render.ScaleManager}
             */
            ScaleManager.prototype.onOrientationError = function (f) {
                this._onOrientationError = f;
                this.checkOrientation();
                return this;
            };
            /**
             * Internal method called at system level when there's no full screen availability.
             * @method cc.render.ScaleManager#__fullScreenError
             * @param e {UIEvent}
             * @private
             */
            ScaleManager.prototype.__fullScreenError = function (e) {
                cc.Debug.warn(cc.locale.WARN_FULLSCREEN_ERROR);
            };
            /**
             * When ScaleStrategy is set, this DOM node will be the reference for position calculations.
             * @method cc.render.ScaleManager#setReferenceParentNode
             * @param node {HTMLElement}
             */
            ScaleManager.prototype.setReferenceParentNode = function (node) {
                this._referenceParentNode = node;
            };
            /**
             * Enable canvas scale capabilities. This will scale the canvas object, not its internal drawing operations.
             * @method cc.render.ScaleManager#setScale
             * @param scale {cc.render.ScaleManagerStrategy} the scale type.
             * @param positionOp {cc.render.ScalePosition=} the positioning when the scale is set.
             * @returns {cc.render.ScaleManager}
             * @see cc.render.ScaleManager#setScaleContent
             */
            ScaleManager.prototype.setScale = function (scale, positionOp) {
                if (this._scaleStrategy === scale) {
                    return;
                }
                this._scaleStrategy = scale;
                this._scalePosition = positionOp || 0 /* NONE */;
                if (this._surface) {
                    var me = this;
                    setTimeout(function () {
                        me.__setScaleImpl();
                    }, 200);
                }
                return this;
            };
            /**
             * Enable content scale. Content scale is necessary for retina display honor mechanisms. This method instruments
             * CocosJS core that there's no direct mapping between a pixel and a game unit.
             * @method cc.render.ScaleManager#setScaleContent
             * @param unitsWidth {number}
             * @param unitsHeight {number}
             */
            ScaleManager.prototype.setScaleContent = function (unitsWidth, unitsHeight) {
                this._units.width = unitsWidth;
                this._units.height = unitsHeight;
                this.__setScaleContentMatrix();
                this._contentScaled = true;
                return this._unitsMatrix;
            };
            /**
             * Internal method to calculate the pixel-point mapping operations.
             * @method cc.render.ScaleManager#__setScaleContentMatrix
             * @private
             */
            ScaleManager.prototype.__setScaleContentMatrix = function () {
                if (this._surface && this._units.width > 0 && this._units.height > 0) {
                    var scale = Math.min(this._surface.width / this._units.width, this._surface.height / this._units.height);
                    this._unitsFactor = scale;
                    cc.math.Matrix3.setScale(this._unitsMatrix, scale, scale);
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        // invert viewport
                        var um = this.getScaleContentMatrix();
                        um[1] *= -1;
                        um[4] *= -1;
                        um[5] += this._renderer._dimension.height;
                    }
                }
            };
            ScaleManager.prototype.getScaleContentMatrix = function () {
                return this._unitsMatrix;
            };
            /**
             * Internal method to scale the canvas object using css styles.
             * @method cc.render.ScaleManager#__setScaleImpl
             * @private
             */
            ScaleManager.prototype.__setScaleImpl = function () {
                this._surface.style.width = '';
                this._surface.style.height = '';
                var scale = this._scaleStrategy;
                if (scale === 0 /* NONE */) {
                    this.__setScaleNone(this._surface);
                }
                else if (scale === 1 /* SCALE_FIT */) {
                    this.__setScaleFit(this._surface);
                }
                else if (scale === 2 /* SCALE_ASPECT */) {
                    this.__setScaleAspect(this._surface);
                }
            };
            /**
             * When setting the scale strategy, this method calculates the necessary styles to position the canvas relative to
             * its parent client area. The calculations will be based on the ScalePosition parameter of setScale method call.
             * @method cc.render.ScaleManager#__setScalePosition
             * @param scaleW {number} canvas scale factor. when setScale is called, the canvas can be scaled with different
             *          values. this is the width scale parameter.
             * @private
             */
            ScaleManager.prototype.__setScalePosition = function (scaleW) {
                if (this.isFullScreen()) {
                    this._surface.style.margin = "0";
                    return;
                }
                var pw = 0;
                if (this._referenceParentNode === null) {
                    pw = window.innerWidth;
                }
                else {
                    pw = this._referenceParentNode.getBoundingClientRect().width;
                }
                switch (this._scalePosition) {
                    case 2 /* LEFT */:
                        this._surface.style.margin = "0";
                        break;
                    case 4 /* RIGHT */:
                        this._surface.style.marginLeft = ((pw - scaleW * this._surface.width) | 0) + 'px';
                        break;
                    case 1 /* CENTER */:
                        this._surface.style.marginLeft = (((pw - scaleW * this._surface.width) / 2) | 0) + 'px';
                        break;
                }
                this._surface.style.padding = "0";
            };
            /**
             * Set the canvas with no scale.
             * @method cc.render.ScaleManager#__setScaleNone
             * @param surface {HTMLCanvasElement}
             * @private
             */
            ScaleManager.prototype.__setScaleNone = function (surface) {
                surface.style.width = surface.width + 'px';
                surface.style.height = surface.height + 'px';
                this.__setScalePosition(1);
            };
            /**
             * Stretch the canvas with css scale attributes to fit exactly in its parent.
             * This can lead to uneven scaling, because of canvas object stretch operations.
             * @method cc.render.ScaleManager#__setScaleFit
             * @param surface {HTMLCanvasElement}
             * @private
             */
            ScaleManager.prototype.__setScaleFit = function (surface) {
                // remove element so that document reflows and can get actual parent size.
                surface.style.display = 'none';
                // scale in parent, but keeping aspect ratio. letterbox  warning!!
                var pw, ph;
                var parentBounds;
                if (this._referenceParentNode === null) {
                    pw = window.innerWidth;
                    ph = window.innerHeight;
                }
                else {
                    parentBounds = this._referenceParentNode.getBoundingClientRect();
                    pw = parentBounds.width;
                    ph = parentBounds.height;
                }
                var sw = surface.width;
                var sh = surface.height;
                var factorx = pw / sw;
                var factory = ph / sh;
                surface.style.width = (factorx * sw) + 'px';
                surface.style.height = (factory * sh) + 'px';
                surface.style.display = 'block';
                this.__setScalePosition(factorx);
            };
            /**
             * Scale the canvas keeping aspect ratio to fit in its parent node client area.
             * @param surface {HTMLCanvasElement}
             * @method cc.render.ScaleManager#__setScaleAspect
             * @private
             */
            ScaleManager.prototype.__setScaleAspect = function (surface) {
                // remove element so that document reflows and can get actual parent size.
                surface.style.display = 'none';
                // scale in parent, but keeping aspect ratio. letterbox  warning!!
                var pw, ph;
                var parentBounds;
                if (this._referenceParentNode === null) {
                    pw = window.innerWidth;
                    ph = window.innerHeight;
                }
                else {
                    parentBounds = this._referenceParentNode.getBoundingClientRect();
                    pw = parentBounds.width;
                    ph = parentBounds.height;
                }
                var sw = surface.width;
                var sh = surface.height;
                var factor = Math.min(pw / sw, ph / sh);
                surface.style.width = (factor * sw) + 'px';
                surface.style.height = (factor * sh) + 'px';
                surface.style.display = 'block';
                this.__setScalePosition(factor);
            };
            /**
             * Get the currently applied canvas scale strategy.
             * @method cc.render.ScaleManager#getScaleStrategy
             * @returns {cc.render.ScaleManagerStrategy}
             */
            ScaleManager.prototype.getScaleStrategy = function () {
                return this._scaleStrategy;
            };
            return ScaleManager;
        })();
        render.ScaleManager = ScaleManager;
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
var cc;
(function (cc) {
    var render;
    (function (render) {
        var util;
        (function (util) {
            function getAlphaChannel(image) {
                return getChannel(image, 3);
            }
            util.getAlphaChannel = getAlphaChannel;
            function getRedChannel(image) {
                return getChannel(image, 0);
            }
            util.getRedChannel = getRedChannel;
            function getGreenChannel(image) {
                return getChannel(image, 1);
            }
            util.getGreenChannel = getGreenChannel;
            function getBlueChannel(image) {
                return getChannel(image, 2);
            }
            util.getBlueChannel = getBlueChannel;
            function getChannel(image, channel) {
                var canvas = null;
                var ctx = null;
                if (image instanceof HTMLCanvasElement) {
                    canvas = image;
                    ctx = canvas.getContext("2d");
                }
                else {
                    var canvas = createCanvas(image.width, image.height);
                    ctx = canvas.getContext("2d");
                    ctx.drawImage(image, 0, 0);
                }
                var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                return extractChannel(imageData.data, canvas.width, canvas.height, 3);
            }
            util.getChannel = getChannel;
            function createCanvas(w, h) {
                var canvas = document.createElement("canvas");
                canvas.width = w;
                canvas.height = h;
                return canvas;
            }
            util.createCanvas = createCanvas;
            function extractChannel(data, width, height, channel) {
                var ret = typeof Uint8Array !== "undefined" ? new Uint8Array(width * height) : new Array(width * height);
                var pos = 0;
                for (var i = 0; i < data.length; i += 4) {
                    ret[pos++] = data[i + channel];
                }
                return ret;
            }
            util.extractChannel = extractChannel;
        })(util = render.util || (render.util = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../../node/sprite/SpriteFrame.ts"/>
/// <reference path="../RenderingContext.ts"/>
/// <reference path="../../math/Rectangle.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        var mesh;
        (function (mesh) {
            /**
             * A mesh is a grid composed of geometry and u,v information.
             */
            var Mesh = (function () {
                function Mesh() {
                    this._originalGeometry = null;
                    this._geometry = null;
                    this._uv = null;
                    this._workuv = null;
                    this._indices = null;
                    this._initialized = false;
                    this._rectgl = null;
                }
                Mesh.prototype.Mesh = function () {
                };
                Mesh.prototype.initialize = function (pointsWidth, pointsHeight, width, height) {
                    var numPointsInMesh = pointsWidth * pointsHeight;
                    this._geometry = new Float32Array(numPointsInMesh * 3);
                    this._originalGeometry = new Float32Array(numPointsInMesh * 3);
                    this._uv = new Float32Array(numPointsInMesh * 2);
                    this._workuv = new Float32Array(numPointsInMesh * 2);
                    this._indices = new Uint16Array((pointsWidth - 1) * (pointsHeight - 1) * 6);
                    for (var i = 0; i < pointsHeight; i++) {
                        for (var j = 0; j < pointsWidth; j++) {
                            var pointIndex = j + i * pointsWidth;
                            this._geometry[pointIndex * 3] = j / (pointsWidth - 1) * width; // x
                            this._geometry[pointIndex * 3 + 1] = i / (pointsHeight - 1) * height; // y
                            this._geometry[pointIndex * 3 + 2] = 0; // z
                            this._originalGeometry[pointIndex * 3] = this._geometry[pointIndex * 3];
                            this._originalGeometry[pointIndex * 3 + 1] = this._geometry[pointIndex * 3 + 1];
                            this._originalGeometry[pointIndex * 3 + 2] = this._geometry[pointIndex * 3 + 2];
                            this._uv[pointIndex * 2] = j / (pointsWidth - 1); // normalized u
                            this._uv[pointIndex * 2 + 1] = i / (pointsHeight - 1); // normalized v
                            this._workuv[pointIndex * 2] = j / (pointsWidth - 1); // normalized u
                            this._workuv[pointIndex * 2 + 1] = i / (pointsHeight - 1); // normalized v
                        }
                    }
                    var index = 0;
                    for (var i = 0; i < pointsHeight - 1; i++) {
                        for (var j = 0; j < pointsWidth - 1; j++) {
                            var indexindex = j + i * pointsWidth;
                            this._indices[index] = indexindex;
                            this._indices[index + 1] = indexindex + 1;
                            this._indices[index + 2] = indexindex + pointsWidth;
                            this._indices[index + 3] = indexindex + pointsWidth;
                            this._indices[index + 4] = indexindex + 1;
                            this._indices[index + 5] = indexindex + pointsWidth + 1;
                            index += 6;
                        }
                    }
                    this._initialized = true;
                };
                Mesh.prototype.draw = function (ctx, sf, color) {
                    if (!this._initialized) {
                        return;
                    }
                    color = typeof color === "undefined" ? 0xffffffff : color;
                    if (this._rectgl !== sf._normalizedRect) {
                        this._rectgl = sf._normalizedRect;
                        var offx = this._rectgl.x;
                        var offy = this._rectgl.y;
                        var diffx = this._rectgl.x1 - this._rectgl.x;
                        var diffy = this._rectgl.y1 - this._rectgl.y;
                        for (var i = 0; i < this._uv.length; i += 2) {
                            this._workuv[i] = this._uv[i] * diffx + offx;
                            this._workuv[i] = this._uv[i] * diffy + offy;
                        }
                    }
                    ctx.drawMesh(this._geometry, this._workuv, this._indices, color, sf._texture);
                };
                Mesh.prototype.deform = function (segment) {
                };
                return Mesh;
            })();
            mesh.Mesh = Mesh;
        })(mesh = render.mesh || (render.mesh = {}));
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
var cc;
(function (cc) {
    //export function extend(derived, base) {
    //    for (var p in base) {
    //        if (base.hasOwnProperty(p)) {
    //            derived[p] = base[p];
    //        }
    //    }
    //
    //    function __() {
    //        this.constructor = derived;
    //    }
    //
    //    __.prototype = base.prototype;
    //    derived.prototype = new __();
    //}
    var util;
    (function (util) {
        "use strict";
        /**
         * Create a Float32Array. If it is not possible a plain Array will be created.
         * @method cc.util.FloatArray
         * @param size {number} array size.
         * @param defaultValue {number} default array values.
         * @returns {Float32Array|Array}
         */
        function FloatArray(size, defaultValue) {
            var a, i;
            defaultValue = defaultValue || 0;
            if (typeof Float32Array !== "undefined") {
                a = new Float32Array(size);
                if (defaultValue) {
                    for (i = 0; i < size; i++) {
                        a[i] = defaultValue;
                    }
                }
            }
            else {
                a = new Array(size);
                for (i = 0; i < size; i++) {
                    a[i] = defaultValue;
                }
            }
            return a;
        }
        util.FloatArray = FloatArray;
        /**
         * Create a UInt16Array. If it is not possible a plain Array will be created.
         * @method cc.util.UInt16Array
         * @param size {number} array size.
         * @param defaultValue {number} default array value.
         * @returns {Uint16Array|Array}
         */
        function UInt16Array(size, defaultValue) {
            var a, i;
            defaultValue = defaultValue || 0;
            if (typeof Uint16Array !== "undefined") {
                a = new Uint16Array(size);
                if (defaultValue) {
                    for (i = 0; i < size; i++) {
                        a[i] = defaultValue;
                    }
                }
            }
            else {
                a = new Array(size);
                for (i = 0; i < size; i++) {
                    a[i] = defaultValue;
                }
            }
            return a;
        }
        util.UInt16Array = UInt16Array;
        /**
         * Transform an string with POSIX like regular expressions into javascript regular expressions.
         * @method cc.util.fromPosixRegularExpression
         * @param expr {string}
         * @returns {string} a javascript like valid regular expression string.
         */
        function fromPosixRegularExpression(expr) {
            expr = expr.replace(/\[\:digit\:\]/g, "\\d");
            expr = expr.replace(/\[\:alpha\:\]/g, "[A-Za-z]");
            expr = expr.replace(/\[\:alnum\:\]/g, "[A-Za-z0-9]");
            expr = expr.replace(/\[\:word\:\]/g, "\\w");
            expr = expr.replace(/\[\:cntrl\:\]/g, "[\\x00-\\x1F\\x7F]");
            expr = expr.replace(/\[\:graph\:\]/g, "[\\x21-\\x7E]");
            expr = expr.replace(/\[\:lower\:\]/g, "[a-z]");
            expr = expr.replace(/\[\:print\:\]/g, "[\\x20-\\x7E]");
            expr = expr.replace(/\[\:punct\:\]/g, "[][!\"#$%&\'()*+,./:;<=>?@\\^_`{|}~-]");
            expr = expr.replace(/\[\:space\:\]/g, "\\s");
            expr = expr.replace(/\[\:upper\:\]/g, "[A-Z]");
            expr = expr.replace(/\[\:xdigit\:\]/g, "[A-Fa-f0-9]");
            return expr;
        }
        util.fromPosixRegularExpression = fromPosixRegularExpression;
    })(util = cc.util || (cc.util = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="./Loader.ts"/>
/// <reference path="./ResourceLoader.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var loader;
        (function (_loader) {
            /**
             * @class cc.util.Resource
             * @classdesc
             *
             * <p>
             *     Class for identifying resources at Cocos level.
             *     Resources are shares across all Director instances by storing them in the static AssetManager object.
             *     This class keeps Resource status and its value after loading.
             *     This class is the same for each resource type, but there are specialized Resource loaders depending on the
             *     type, for example loaders for XML, JSON and text are the same one, but convert the content before emitting
             *     it to any observer.
             * <p>
             *     Resources are identified by a string of the form: <valid_url>[@<id>]
             *     If &lt;id&rt; exists, it will be set as Resource's id, otherwise, the &lt;url&gt; will be.
             *     The Resource will dismiss all information (and including) after the ? sign in its loading url.
             *     Resources url are not normalized. That means that urls of the type ../../end/x/../y.png will be untouched.
             * <p>
             *     It is encouraged to define ids for every resouce by using the resource form <url>@<id>.
             *     It could seem handy to have all resources automatically identify themselves by the name part of the url,
             *     but since resources can be downloaded from different sources and id's could clash, the full url will be
             *     used if not id is defined.
             */
            var Resource = (function () {
                /**
                 * Create a new Resource instance.
                 * Resources are automatically built from a list of resource url/uri passed to a
                 * <code>cc.plugin.loader.Loader</code> or <code>cc.plugin.loader.ResourceManager</code>.
                 * @method cc.plugin.loader.Resource#constructor
                 * @param url
                 */
                function Resource(_url) {
                    /**
                     * Resource id.
                     * The id is extracted from the url path, and is just the equivalent to the file name.
                     * To obtain the id, everything behing an optional question mark is removed.
                     * For example, for a resource called /a/b/c/anim.png?stamp=495849809384 the id will be 'anim.png'.
                     * @member cc.plugin.loader.Resource#id
                     * @type {string}
                     */
                    this.id = null;
                    /**
                     * Resource id extension.
                     * It is extracted from the id, and is whatever lies behind the last dot character.
                     * The extension is used to identify what loader is needed for this king of resource.
                     * @member cc.plugin.loader.Resource#extension
                     * @type {string}
                     */
                    this.extension = null;
                    /**
                     * After the loader ends its work, the resulting object of loading the result is stored in this variable.
                     * The value is only valid if the status of the resource is 'loaded'.
                     * @memver cc.plugin.loader.Resource#value
                     * @type {string}
                     */
                    this.value = null;
                    /**
                     * Resource status.
                     * Valid status are:
                     *   + created: the resource is created and still no load operation has ended for it.
                     *   + error: the resource could not be loaded due to an error.
                     *   + loaded: the resource has been loaded and is valid to be used.
                     * @member cc.plugin.loader.Resource#_status
                     * @type {string}
                     * @private
                     */
                    this._status = "created";
                    /**
                     * Resource type. Either image, font, atlas, etc.
                     * @member cc.plugin.loader.Resource#type
                     * @type {string}
                     */
                    this.type = null;
                    /**
                     * resource name. the url part after the last slash sigh.
                     * @member cc.plugin.loader.Resource#name
                     * @type {string}
                     */
                    this.name = null;
                    /**
                     * Source url the Resource was loaded from.
                     * @member cc.plugin.loader.Resource#url
                     * @type {string}
                     */
                    this.url = null;
                    this._progress = null;
                    var url_and_id = _url.split("@");
                    var url = url_and_id[0];
                    var id = url_and_id.length > 1 ? url_and_id[1] : null;
                    var path = url.split("/");
                    var name = path[path.length - 1];
                    name = name.split("?")[0];
                    var extensionPos;
                    var extension;
                    extensionPos = url.lastIndexOf(".");
                    extension = null;
                    // exists extension
                    if (-1 !== extensionPos) {
                        extension = url.substr(extensionPos + 1);
                    }
                    else {
                        extension = "default";
                    }
                    this.url = url;
                    this.extension = extension;
                    this.id = id || url;
                    this.name = name;
                }
                /**
                 * Load a Resource by creating a suitable instance of a ResourceLoader based on the resource extension.
                 * The resource exposes its loading results throughout the callback parameters.
                 * If there's no loader associated with the resource extension, the error callback is called immediately.
                 * @param loaded {cc.plugin.loader.ResourceLoaderResultCallback} callback notification if the resource loaded ok.
                 * @param error {cc.plugin.loader.ResourceLoaderResultCallback} callback notification if the resource loaded with error.
                 */
                Resource.prototype.load = function (loaded, error) {
                    var _this = this;
                    var loaderDescriptor = cc.plugin.loader.getLoaderByType(this.extension);
                    if (loaderDescriptor) {
                        this.type = loaderDescriptor.type;
                        var loader = loaderDescriptor.loader(this.url);
                        loader.load(function (content) {
                            _this.__setValue(content);
                            loaded(_this);
                        }, function () {
                            _this.__setError();
                            error(_this);
                        }, this._progress);
                    }
                    else {
                        cc.Debug.warn(cc.locale.WARN_RESOURCE_OF_UNKNOWN_TYPE, this.id);
                        error(this);
                    }
                };
                /**
                 * Helper function.
                 * @method cc.plugin.loader.Resource#__setValue
                 * @param value {object} result from the loading operation.
                 * @private
                 */
                Resource.prototype.__setValue = function (value) {
                    this.value = value;
                    this._status = "loaded";
                };
                /**
                 * Helper function.
                 * @method cc.plugin.loader.Resource#__setError
                 * @private
                 */
                Resource.prototype.__setError = function () {
                    this._status = "error";
                };
                /**
                 * Has this Resource a valid value ?
                 * @method cc.plugin.loader.Resource#isValid
                 * @returns {boolean}
                 */
                Resource.prototype.isValid = function () {
                    return this._status === 'loaded';
                };
                /**
                 * Get the resource id.
                 * @method cc.plugin.loader.Resource#getId
                 * @returns {string}
                 */
                Resource.prototype.getId = function () {
                    return this.id;
                };
                Resource.prototype.setProgress = function (progress) {
                    this._progress = progress;
                };
                return Resource;
            })();
            _loader.Resource = Resource;
        })(loader = plugin.loader || (plugin.loader = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var loader;
        (function (loader) {
            /**
             * Register a loader type for a given url extension.
             * @member cc.plugin.loader.RegisterLoaderForType
             * @param builder {cc.plugin.loader.ResourceLoader} a loader of this type will be reated for each resource needing it.
             * @param extension {string}
             */
            function registerLoaderForType(extension, builder) {
                __resourceLoaderByType[extension] = builder;
            }
            loader.registerLoaderForType = registerLoaderForType;
            /**
             * Get a loader type for a given url extension.
             * @member cc.plugin.loader.GetLoaderByType
             * @param extension {string}
             * @return {cc.plugin.loader.ResourceLoaderBuilder}
             */
            function getLoaderByType(extension) {
                return __resourceLoaderByType[extension];
            }
            loader.getLoaderByType = getLoaderByType;
            var __resourceLoaderByType = {};
        })(loader = plugin.loader || (plugin.loader = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="./ResourceLoader.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var loader;
        (function (loader) {
            /**
             * @class cc.plugin.loader.ResourceLoaderImage
             * @implements cc.plugin.loader.ResourceLoader
             * @classdesc
             *
             * <p>
             *     This object loads images from a url.
             */
            var ResourceLoaderImage = (function () {
                /**
                 * Create a new ResourceLoaderImage instance.
                 * @method cc.plugin.loader.ResourceLoaderImage#constructor
                 * @param url {string}
                 */
                function ResourceLoaderImage(url) {
                    /**
                     * Url string where the resource is located.
                     * @member cc.plugin.loader.ResourceLoaderImage#_url
                     * @type {string}
                     * @private
                     */
                    this._url = null;
                    this._url = url;
                }
                /**
                 * Load the resource.
                 * @param loaded {cc.plugin.loader.ResourceLoaderResourceOkCallback} callback invoked when the resource is successfully loaded.
                 * @param error {cc.plugin.loader.ResourceLoaderResourceErrorCallback} callback invoked when the resource is not successfully loaded.
                 */
                ResourceLoaderImage.prototype.load = function (loaded, error) {
                    var img = new Image();
                    img.addEventListener("load", function (e) {
                        loaded(e.target);
                    }, false);
                    img.addEventListener("error", function () {
                        error();
                    }, false);
                    img.src = this._url;
                };
                return ResourceLoaderImage;
            })();
            loader.ResourceLoaderImage = ResourceLoaderImage;
            cc.plugin.loader.registerLoaderForType("png", { type: "image", loader: function (url) {
                return new ResourceLoaderImage(url);
            } });
            cc.plugin.loader.registerLoaderForType("jpg", { type: "image", loader: function (url) {
                return new ResourceLoaderImage(url);
            } });
            cc.plugin.loader.registerLoaderForType("jpeg", { type: "image", loader: function (url) {
                return new ResourceLoaderImage(url);
            } });
        })(loader = plugin.loader || (plugin.loader = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="./ResourceLoader.ts"/>
/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../locale/Locale.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var loader;
        (function (loader) {
            /**
             * @class cc.plugin.loader.ResourceLoaderJSON
             * @implements cc.plugin.loader.ResourceLoader
             * @classdesc
             *
             * <p>
             *     This object loads images a JSON object
             */
            var ResourceLoaderJSON = (function () {
                /**
                 * Create a new ResourceLoaderJSON instance.
                 * @method cc.plugin.loader.ResourceLoaderJSON#constructor
                 * @param url {string}
                 */
                function ResourceLoaderJSON(url, initializer) {
                    /**
                     * Url string where the resource is located.
                     * @member cc.plugin.loader.ResourceLoaderJSON#_url
                     * @type {string}
                     * @private
                     */
                    this._url = null;
                    /**
                     * Use JSON.parse from the loaded value ?
                     * @member cc.plugin.loader.ResourceLoaderJSON#_parse
                     * @type {boolean}
                     * @private
                     */
                    this._parse = true;
                    this._url = url;
                    if (typeof initializer !== "undefined") {
                        this._parse = typeof initializer.parse !== "undefined" ? initializer.parse : true;
                    }
                }
                /**
                 * Load the resource.
                 * @param loaded {cc.plugin.loader.ResourceLoaderResourceOkCallback} callback invoked when the resource is successfully loaded.
                 * @param error {cc.plugin.loader.ResourceLoaderResourceErrorCallback} callback invoked when the resource is not successfully loaded.
                 */
                ResourceLoaderJSON.prototype.load = function (loaded, error, progress) {
                    var me = this;
                    var req = null;
                    if (typeof XMLHttpRequest !== "undefined" && typeof ActiveXObject === "undefined") {
                        try {
                            req = new XMLHttpRequest();
                        }
                        catch (e) {
                            req = null;
                        }
                    }
                    else if (typeof ActiveXObject !== "undefined") {
                        try {
                            req = new ActiveXObject("Msxml2.XMLHTTP");
                        }
                        catch (e) {
                            try {
                                req = new ActiveXObject("Microsoft.XMLHTTP");
                            }
                            catch (e1) {
                                req = null;
                            }
                        }
                    }
                    if (req) {
                        req.open("GET", me._url, true);
                        if (progress) {
                            req.onprogress = function (evt) {
                                if (evt.lengthComputable) {
                                    var percentComplete = (evt.loaded / evt.total) * 100;
                                    progress(percentComplete);
                                }
                                else {
                                    progress(-1);
                                }
                            };
                        }
                        req.onload = function (e) {
                            if (req.status != 200) {
                                error();
                                return;
                            }
                            var text = e.currentTarget ? e.currentTarget.responseText : e.target.responseText;
                            if (text !== "") {
                                loaded(me.getValue(text));
                            }
                        };
                        req.send();
                    }
                };
                ResourceLoaderJSON.prototype.getValue = function (text) {
                    return this._parse ? JSON.parse(text) : text;
                };
                return ResourceLoaderJSON;
            })();
            loader.ResourceLoaderJSON = ResourceLoaderJSON;
            /**
             * @class cc.plugin.loader.ResourceLoaderXML
             * @extends ResourceLoaderJSON
             * @classdesc
             *
             * Loads a xml file. Will return a javascript array object parsed form the plist contents.
             * object[0] will be the first plist node, and so on.
             */
            var ResourceLoaderXML = (function (_super) {
                __extends(ResourceLoaderXML, _super);
                /**
                 * @method cc.plugin.loader.ResourceLoaderXML#constructor
                 * @param url
                 */
                function ResourceLoaderXML(url) {
                    _super.call(this, url);
                }
                /**
                 * Get the value from the loaded content.
                 * It will parse the xml and build a javascript array object.
                 * @method cc.plugin.loader.ResourceLoaderXML#getValue
                 * @override
                 * @param text {string} file contents.
                 * @returns {object}
                 */
                ResourceLoaderXML.prototype.getValue = function (text) {
                    if (typeof DOMParser !== "undefined") {
                        var parser = new DOMParser();
                        var doc = parser.parseFromString(text, "text/xml");
                        // type Node
                        return this.__parseNode(doc.documentElement);
                    }
                    else {
                        return {};
                    }
                };
                /**
                 * Parse a XML Document.documentElement.
                 * @method cc.plugin.loader.ResourceLoaderXML#__parseNode
                 * @param node
                 * @returns
                 * @private
                 */
                ResourceLoaderXML.prototype.__parseNode = function (node) {
                    var data = null, tagName = node.tagName;
                    if (tagName === "plist") {
                        return this.__parseArray(node);
                    }
                    else if (tagName === "dict") {
                        return this.__parseDict(node);
                    }
                    else if (tagName === "array") {
                        return this.__parseArray(node);
                    }
                    else if (tagName === "string") {
                        if (node.childNodes.length == 1)
                            data = node.firstChild.nodeValue;
                        else {
                            //handle Firefox's 4KB nodeValue limit
                            data = "";
                            for (var i = 0; i < node.childNodes.length; i++)
                                data += node.childNodes[i].nodeValue;
                        }
                    }
                    else if (tagName === "false") {
                        return false;
                    }
                    else if (tagName === "true") {
                        return true;
                    }
                    else if (tagName === "real") {
                        return parseFloat(node.firstChild.nodeValue);
                    }
                    else if (tagName === "integer") {
                        return parseInt(node.firstChild.nodeValue, 10);
                    }
                    return data;
                };
                /**
                 * Parse an array Node from a plist.
                 * @method cc.plugin.loader.ResourceLoaderXML#__parseArray
                 * @param node
                 * @returns {Array<object>}
                 * @private
                 */
                ResourceLoaderXML.prototype.__parseArray = function (node) {
                    var data = [];
                    for (var i = 0; i < node.childNodes.length; i++) {
                        var child = node.childNodes[i];
                        if (child.nodeType !== 1)
                            continue;
                        data.push(this.__parseNode(child));
                    }
                    return data;
                };
                /**
                 * Parse a dictionary node form a plist.
                 * @method cc.plugin.loader.ResourceLoaderXML#__parseDict
                 * @param node
                 * @returns {Map<string,object>}
                 * @private
                 */
                ResourceLoaderXML.prototype.__parseDict = function (node) {
                    var data = {};
                    var key = null;
                    for (var i = 0; i < node.childNodes.length; i++) {
                        var child = node.childNodes[i];
                        if (child.nodeType !== 1)
                            continue;
                        // Grab the key, next noe should be the value
                        if (child.tagName === 'key')
                            key = child.firstChild.nodeValue;
                        else
                            data[key] = this.__parseNode(child); // Parse the value node
                    }
                    return data;
                };
                return ResourceLoaderXML;
            })(ResourceLoaderJSON);
            loader.ResourceLoaderXML = ResourceLoaderXML;
            cc.plugin.loader.registerLoaderForType("json", { type: "javascript json", loader: function (url) {
                return new ResourceLoaderJSON(url, { parse: true });
            } });
            cc.plugin.loader.registerLoaderForType("txt", { type: "plain text files", loader: function (url) {
                return new ResourceLoaderJSON(url, { parse: false });
            } });
            cc.plugin.loader.registerLoaderForType("fnt", { type: "Glypth designer fnt", loader: function (url) {
                return new ResourceLoaderJSON(url, { parse: false });
            } });
            cc.plugin.loader.registerLoaderForType("xml", { type: "XML file", loader: function (url) {
                return new ResourceLoaderXML(url);
            } });
            cc.plugin.loader.registerLoaderForType("plist", { type: "MAC Plist file", loader: function (url) {
                return new ResourceLoaderXML(url);
            } });
        })(loader = plugin.loader || (plugin.loader = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="./ResourceLoader.ts"/>
/// <reference path="../../../lib/webaudio/webaudio.d.ts" />
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var loader;
        (function (loader) {
            var audioContext = (function () {
                //var ww= <any>window;
                var ctx = typeof AudioContext !== "undefined" ? AudioContext : (typeof webkitAudioContext !== "undefined" ? webkitAudioContext : null);
                return ctx && new ctx();
            })();
            /**
             * @class cc.plugin.loader.ResourceLoaderAudioBuffer
             * @implements cc.plugin.loader.ResourceLoader
             * @classdesc
             *
             * This object loads an audio as an arraybuffer. It must then be turned into an AudioBuffer by dynamically
             * decoding it.
             */
            var ResourceLoaderAudioBuffer = (function () {
                /**
                 * Create a new ResourceLoaderAudioBuffer instance.
                 * @method cc.plugin.loader.ResourceLoaderAudioBuffer#constructor
                 */
                function ResourceLoaderAudioBuffer(url) {
                    /**
                     * Url string where the resource is located.
                     * @member cc.plugin.loader.ResourceLoaderAudioBuffer#_url
                     * @type {string}
                     * @private
                     */
                    this._url = null;
                    this._url = url;
                }
                /**
                 * Load the resource.
                 * @param loaded {cc.plugin.loader.ResourceLoaderResourceOkCallback} callback invoked when the resource is successfully loaded.
                 * @param error {cc.plugin.loader.ResourceLoaderResourceErrorCallback} callback invoked when the resource is not successfully loaded.
                 */
                ResourceLoaderAudioBuffer.prototype.load = function (loaded, error) {
                    var me = this;
                    var req = null;
                    if (typeof XMLHttpRequest !== "undefined" && typeof ActiveXObject === "undefined") {
                        try {
                            req = new XMLHttpRequest();
                        }
                        catch (e) {
                            req = null;
                        }
                    }
                    else if (typeof ActiveXObject !== "undefined") {
                        try {
                            req = new ActiveXObject("Msxml2.XMLHTTP");
                        }
                        catch (e) {
                            try {
                                req = new ActiveXObject("Microsoft.XMLHTTP");
                            }
                            catch (e1) {
                                req = null;
                            }
                        }
                    }
                    if (req) {
                        req.open("GET", me._url, true);
                        req.responseType = "arraybuffer";
                        req.onload = function () {
                            audioContext.decodeAudioData(req.response, function (buffer) {
                                loaded(buffer);
                            }, function (e) {
                                console.log("decode error ", e);
                                error();
                            });
                        };
                        req.send();
                    }
                };
                return ResourceLoaderAudioBuffer;
            })();
            loader.ResourceLoaderAudioBuffer = ResourceLoaderAudioBuffer;
            cc.plugin.loader.registerLoaderForType("mp3", { type: "mp3 audio", loader: function (url) {
                return new ResourceLoaderAudioBuffer(url);
            } });
            cc.plugin.loader.registerLoaderForType("ogg", { type: "ogg audio", loader: function (url) {
                return new ResourceLoaderAudioBuffer(url);
            } });
            cc.plugin.loader.registerLoaderForType("wav", { type: "wav audio", loader: function (url) {
                return new ResourceLoaderAudioBuffer(url);
            } });
        })(loader = plugin.loader || (plugin.loader = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../locale/Locale.ts"/>
/// <reference path="./Resource.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var loader;
        (function (loader) {
            var Resource = cc.plugin.loader.Resource;
            /**
             * @class cc.plugin.loader.Loader
             * @classdesc
             *
             * <p>
             *     A loader object has the responsibility of loading different types of files and notify success or error
             *     of loading operations.
             * <p>
             *     It has the ability to register new types of loader for different extension files.
             *     The Loader loads data synchronous or asynchronously.
             *     Notifies for each resource in the list about success or error on loading.
             * <p>
             *     The Loader keeps track of loaded content, and notifies callback functions for each resource
             *     loaded, and another callback when it is done with all resources.
             *     When all resources all loaded, local references to these resources are cleared to avoid memory leaks.
             *     Also all resources are instrumented to remove unnecessary information such as loading/error callbacks, etc.
             * <p>
             *     To avoid repetition in resources urls, a common 'prefix' can be specified which will be prepended to every
             *     resource before loading.
             */
            var Loader = (function () {
                function Loader(loaderData) {
                    /**
                     * Common uri prefix to add to all resources before loading.
                     * The prefix is added to resources that
                     *   * don't start with a protocol prefix (http, https, etc.)
                     *   * don't start with a slash '/'
                     * This way, you could mix prefixed and non-prefixed resources.
                     * <p>
                     * The prefix is added as is, is not normalized, or modified in any way.
                     * <p>
                     * The prefix saves time and typing, so that instead of setting something like:
                     *
                     * <code>
                     * {
                     *    resources : [
                     *      "/folder/folder2/img1.png",
                     *      "/folder/folder2/img2.png",
                     *      ...
                     *    ]
                     * }
                     * </code>
                     *
                     * you could instead do:
                     *
                     * <code>
                     * {
                     *   prefix : "/folder/folder2/",
                     *   resources : [ "img1.png", "img2.png" ]
                     * }
                     * </code>
                     *
                     * @member cc.plugin.loader.Loader#_prefix
                     * @type {string}
                     * @private
                     */
                    this._prefix = null;
                    /**
                     * Resources list.
                     * @member cc.plugin.loader.Loader#_resources
                     * @type {Array<string>}
                     * @private
                     */
                    this._resources = [];
                    /**
                     * Current
                     * @type {number}
                     * @private
                     */
                    this._currentLoadedResourcesCount = 0;
                    if (loaderData) {
                        // if there's a prefix, set it.
                        if (typeof loaderData.prefix !== "undefined") {
                            this._prefix = loaderData.prefix;
                        }
                        // if there are resources to load, register them.
                        if (typeof loaderData.resources !== "undefined") {
                            this.addResources(loaderData.resources);
                        }
                    }
                }
                /**
                 * Prepend the _prefix to the string s if needed.
                 * <p>
                 * Won't be added for:
                 *   * strings starting with /
                 *   * strings starting with protocol http,https or ftp
                 *
                 * @method cc.plugin.loader.Loader#__addPrefixIfNeeded
                 * @param s {string} string to add prefix to.
                 * @returns {string}
                 * @private
                 */
                Loader.prototype.__addPrefixIfNeeded = function (s) {
                    // there's no prefix, nothing to prepend.
                    if (!this._prefix) {
                        return s;
                    }
                    // remove trailing spaces.
                    s = s.trim();
                    // resouce starts with /, an absolute uri, don't add prefix.
                    if (s.charAt(0) === '/') {
                        return s;
                    }
                    // is a protocol url, don't add prefix.
                    if (s.indexOf("http") === 0 || s.indexOf("https") === 0 || s.indexOf("ftp") === 0) {
                        return s;
                    }
                    return this._prefix + s;
                };
                /**
                 * Add one resource to the load queue.
                 * @method cc.plugin.loader.Loader#addResource
                 * @param url {string}
                 */
                Loader.prototype.addResource = function (url) {
                    url = this.__addPrefixIfNeeded(url);
                    var resource = new Resource(url);
                    this._resources.push(resource);
                    return this;
                };
                /**
                 * Add a collection of resources to the load queue.
                 * @method cc.plugin.loader.Loader#addResources
                 * @param resources {Array<string>}
                 */
                Loader.prototype.addResources = function (resources) {
                    for (var i = 0; i < resources.length; i++) {
                        this.addResource(resources[i]);
                    }
                    return this;
                };
                Loader.prototype.setProgressLoadForResource = function (id, progress) {
                    for (var i = 0; i < this._resources.length; i++) {
                        if (this._resources[i].id === id) {
                            this._resources[i].setProgress(progress);
                        }
                    }
                };
                /**
                 * Start loading all resources in this loader.
                 * @param onEnd {cc.plugin.loader.LoaderFinishedCallback} callback invoked when all asset are loaded. If no resources
                 *  are registered, this callback will be immediately invoked.
                 * @param onProgress {cc.plugin.loader.LoaderProgressCallback} invoked for each successfully loaded resource.
                 * @param onError {cc.plugin.loader.LoaderErrorCallback} invoked for each not sucessfully loaded resource.
                 */
                Loader.prototype.startLoading = function (onEnd, onProgress, onError) {
                    var _this = this;
                    if (this._resources.length === 0) {
                        onEnd({});
                        return;
                    }
                    for (var i = 0; i < this._resources.length; i++) {
                        this._resources[i].load(function (resource) {
                            _this._currentLoadedResourcesCount++;
                            if (onProgress) {
                                onProgress(resource, _this._currentLoadedResourcesCount, _this._resources.length, true);
                            }
                            if (_this._currentLoadedResourcesCount === _this._resources.length) {
                                // create resources object. Has index with resources, and associate values by id.
                                var notify = {};
                                for (var i = 0; i < _this._resources.length; i++) {
                                    //notify[i]= this._resources[i];
                                    notify[_this._resources[i].getId()] = _this._resources[i].value;
                                }
                                //notify.length= this._resources.length;
                                onEnd(notify);
                                // remove all local references for resources. Avoid leaks.
                                _this._resources = null;
                                _this._currentLoadedResourcesCount = 0;
                            }
                        }, function (resource) {
                            _this._currentLoadedResourcesCount++;
                            if (onProgress) {
                                onProgress(resource, _this._currentLoadedResourcesCount, _this._resources.length, false);
                            }
                            if (onError) {
                                onError(resource);
                            }
                        });
                    }
                    return this;
                };
                return Loader;
            })();
            loader.Loader = Loader;
        })(loader = plugin.loader || (plugin.loader = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../../math/Dimension.ts"/>
/// <reference path="../../node/sprite/SpriteFrame.ts"/>
/// <reference path="../../render/Texture2D"/>
/// <reference path="../../render/RenderingContext"/>
/// <reference path="../asset/AssetManager.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var texture;
        (function (texture) {
            "use strict";
            var getTexturePageIndex = function () {
                var index = 0;
                return function () {
                    return index++;
                };
            }();
            var SortStrategies = {
                __compare: function (v0, v1) {
                    if (v0 < v1) {
                        return 1;
                    }
                    else if (v0 > v1) {
                        return -1;
                    }
                    return 0;
                },
                perimeter: function (i0, i1) {
                    var w0 = i0.getWidth();
                    var h0 = i0.getHeight();
                    var w1 = i1.getWidth();
                    var h1 = i1.getHeight();
                    return SortStrategies.__compare(w0 + w0 + h0 + h0, w1 + w1 + h1 + h1);
                },
                area: function (i0, i1) {
                    var w0 = i0.getWidth();
                    var h0 = i0.getHeight();
                    var w1 = i1.getWidth();
                    var h1 = i1.getHeight();
                    return SortStrategies.__compare(w0 * h0, w1 * h1);
                },
                width: function (i0, i1) {
                    return SortStrategies.__compare(i0.getWidth(), i1.getHeight());
                },
                height: function (i0, i1) {
                    return SortStrategies.__compare(i0.getWidth(), i1.getHeight());
                }
            };
            /**
             * @class cc.plugin.texture.TexturePackerNode
             * @classdesc
             *
             * This Object is a helper for a TexturePackerPage object. It represents a region on a packed image.
             * This object is a actually a binary tree.
             * It will either hold an Image, or two descendant nodes.
             *
             */
            var TexturePackerNode = (function () {
                /**
                 * Create anew TexturePackerNode object instance.
                 * @method cc.plugin.texture.TexturePackerNode#constructor
                 */
                function TexturePackerNode() {
                    /**
                     * x position in page.
                     * @member cc.plugin.texture.TexturePackerNode#_x
                     * @type {number}
                     * @private
                     */
                    this._x = 0;
                    /**
                     * y position in page.
                     * @member cc.plugin.texture.TexturePackerNode#_y
                     * @type {number}
                     * @private
                     */
                    this._y = 0;
                    /**
                     * node width in page.
                     * @member cc.plugin.texture.TexturePackerNode#_width
                     * @type {number}
                     * @private
                     */
                    this._width = 0;
                    /**
                     * node height in page.
                     * @member cc.plugin.texture.TexturePackerNode#_height
                     * @type {number}
                     * @private
                     */
                    this._height = 0;
                    /**
                     * Left child node.
                     * @member cc.plugin.texture.TexturePackerNode#_left
                     * @type {cc.plugin.texture.TexturePackerNode}
                     * @private
                     */
                    this._left = null;
                    /**
                     * right child node.
                     * @member cc.plugin.texture.TexturePackerNode#_right
                     * @type {cc.plugin.texture.TexturePackerNode}
                     * @private
                     */
                    this._right = null;
                    /**
                     * Item this node contains. The item is a pair of Image/Canvas and an id.
                     * @member cc.plugin.texture.TexturePackerNode#_item
                     * @type {{any,string}
                     * @private
                     */
                    this._item = null;
                }
                /**
                 * Insert a Node in this node with the given size.
                 * The function will recursively traverse in-order the node to find the most suitable place to insert.
                 * It will eventually create child nodes as needed.
                 *
                 * @param w {number}
                 * @param h {height}
                 * @param margin {Array<number>=} an array describing a margin around the node. array index are: left, top, right, bottom
                 * @returns {cc.plugin.texture.TexturePackerNode}
                 */
                TexturePackerNode.prototype.insert = function (w, h, margin) {
                    var marginw = margin[0] + margin[2];
                    var marginh = margin[1] + margin[3];
                    if (this._left) {
                        var node = this._left.insert(w, h, margin);
                        return null === node ? this._right.insert(w, h, margin) : node;
                    }
                    else {
                        // node has been assigned ? no further search
                        if (this._item !== null) {
                            return null;
                        }
                        // does not fit here
                        if (this._width < w || this._height < h) {
                            // return signal to try in another node
                            return null;
                        }
                        else if (this._width === w && this._height === h) {
                            // perfect match. return this, w/o further dividing
                            return this;
                        }
                        else {
                            // create descendants
                            this._left = new TexturePackerNode();
                            this._right = new TexturePackerNode();
                            // when substracting the desired area, it is wider than taller ?
                            // create children maximizing available area.
                            if (this._width - w >= this._height - h) {
                                // divide vertically
                                this._left._x = this._x;
                                this._left._y = this._y;
                                this._left._width = w;
                                this._left._height = this._height;
                                //this._right._x= this._x + w;
                                this._right._x = this._x + w + marginw;
                                this._right._y = this._y;
                                //this._right._width= this._width - w;
                                this._right._width = this._width - w - marginw;
                                this._right._height = this._height;
                            }
                            else {
                                // divide horizontally
                                this._left._x = this._x;
                                this._left._y = this._y;
                                this._left._width = this._width;
                                this._left._height = h;
                                this._right._x = this._x;
                                //this._right._y= this._y + h;
                                this._right._y = this._y + h + marginh;
                                this._right._width = this._width;
                                //this._right._height= this._height - h;
                                this._right._height = this._height - h - marginh;
                            }
                            return this._left.insert(w, h, margin);
                        }
                    }
                };
                /**
                 * Paint this node and all its descendants.
                 * @method cc.plugin.texture.TexturePackerNode#paint
                 * @param ctx {CanvasRenderingContext2D}
                 * @param margin {Array<number>=} an array describing a margin around the node. array index are: left, top, right, bottom
                 * @param debug {boolean} draw debug info: a red crossed-rect for empty nodes, and a white rect around packed
                 * images.
                 */
                TexturePackerNode.prototype.paint = function (ctx, margin, debug) {
                    if (debug) {
                        // DEBUG rects.
                        if (this._item) {
                            ctx.strokeStyle = "#fff";
                            ctx.strokeRect(this._x + .5, this._y + .5, this._width - 1, this._height - 1);
                        }
                        else if (!this._left) {
                            ctx.strokeStyle = "#f00";
                            ctx.lineWidth = 1;
                            ctx.strokeRect(this._x + .5, this._y + .5, this._width - 1, this._height - 1);
                            ctx.beginPath();
                            ctx.moveTo(this._x + .5, this._y + .5);
                            ctx.lineTo(this._x + this._width - .5, this._y + this._height - .5);
                            ctx.moveTo(this._x + this._width - .5, this._y + .5);
                            ctx.lineTo(this._x + .5, this._y + this._height - .5);
                            ctx.stroke();
                        }
                    }
                    if (this._item) {
                        this._item.draw(ctx, this._x, this._y);
                    }
                    if (this._left) {
                        this._left.paint(ctx, margin, debug);
                    }
                    if (this._right) {
                        this._right.paint(ctx, margin, debug);
                    }
                };
                /**
                 * Create and add to the AssetManager a SpriteFrame for each node in the tree that has an associated image.
                 * The SpriteFrames will be created using the SpriteFrame that corresponds to the textureId parameter.
                 * @method cc.plugin.texture.TexturePackerNode#createFrames
                 * @param textureId {string}
                 */
                TexturePackerNode.prototype.createFrames = function (textureId) {
                    if (this._item) {
                        cc.plugin.asset.AssetManager.addSpriteFrame(cc.plugin.asset.AssetManager.getSpriteFrame(textureId).createSubSpriteFrame(this._x, this._y, this._width, this._height, this._item.getId()));
                    }
                    if (this._left) {
                        this._left.createFrames(textureId);
                    }
                    if (this._right) {
                        this._right.createFrames(textureId);
                    }
                };
                return TexturePackerNode;
            })();
            texture.TexturePackerNode = TexturePackerNode;
            /**
             * @class cc.plugin.texture.TexturePackerPage
             * @classdesc
             *
             * This object creates an on-the-fly Image atlas with the Images that best fit in it.
             * Internally keeps a Tree of Nodes to maintain the Atlas image representation.
             * When requested, it will create a canvas object with all the images drawn in it in a non-overlapping manner.
             * Images can (and should) have a margin around them of at least 1 pixel.
             *
             */
            var TexturePackerPage = (function () {
                /**
                 * Create a new TexturePackerPage object instance.
                 * @method {cc.plugin.texture.TexturePackerPage#constructor}
                 * @param id {string}
                 * @param w {number}
                 * @param h {number}
                 */
                function TexturePackerPage(id, w, h) {
                    /**
                     * Canvas with packer images.
                     * @member cc.plugin.texture.TexturePackerPage#_canvas
                     * @type {null}
                     * @private
                     */
                    this._canvas = null;
                    /**
                     * Canvas rendering context.
                     * @member cc.plugin.texture.TexturePackerPage#_ctx
                     * @type {CanvasRenderingContext2D}
                     * @private
                     */
                    this._ctx = null;
                    /**
                     * This tree keeps the regions for each image.
                     * @member {cc.plugin.texture.TexturePackerPage#_root}
                     * @type {cc.plugin.texture.TexturePackerNode}
                     * @private
                     */
                    this._root = null;
                    this._id = id;
                    this._width = w;
                    this._height = h;
                    this._root = new TexturePackerNode();
                    this._root._width = w;
                    this._root._height = h;
                }
                /**
                 * Insert an image in the best place for it in the node's tree.
                 * @method {cc.plugin.texture.TexturePackerPage#insertImage}
                 * @param item {{any,string}} a pair of image/canvas and an id
                 * @param margin {Array<number>=} an array describing a margin around the node. array index are: left, top, right, bottom
                 * @returns {cc.plugin.texture.TexturePackerNode}
                 */
                TexturePackerPage.prototype.insertImage = function (item, margin) {
                    var node = this._root.insert(item.getWidth(), item.getHeight(), margin);
                    if (null !== node) {
                        node._item = item;
                    }
                    return node;
                };
                /**
                 * Create page's assets and adds them to the AssetManager.
                 * @method cc.plugin.texture.TexturePackerPage#createAssets
                 */
                TexturePackerPage.prototype.createAssets = function (margin, debug) {
                    // create a canvas.
                    this._canvas = document.createElement("canvas");
                    this._canvas.width = this._width;
                    this._canvas.height = this._height;
                    this._ctx = this._canvas.getContext("2d");
                    // draw nodes.
                    this._root.paint(this._ctx, margin, debug);
                    // create texture
                    cc.plugin.asset.AssetManager.addImage(this._canvas, this._id);
                    // add all SpriteFrames
                    this._root.createFrames(this._id);
                };
                return TexturePackerPage;
            })();
            texture.TexturePackerPage = TexturePackerPage;
            var TexturePackerItemImage = (function () {
                function TexturePackerItemImage(image, id) {
                    this.image = image;
                    this.id = id;
                }
                TexturePackerItemImage.prototype.getId = function () {
                    return this.id;
                };
                TexturePackerItemImage.prototype.getWidth = function () {
                    return this.image.width;
                };
                TexturePackerItemImage.prototype.getHeight = function () {
                    return this.image.height;
                };
                TexturePackerItemImage.prototype.fits = function (w, h) {
                    return this.image.width <= w && this.image.height <= h;
                };
                TexturePackerItemImage.prototype.draw = function (ctx, x, y) {
                    ctx.drawImage(this.image, x, y);
                };
                return TexturePackerItemImage;
            })();
            var TexturePackerItemSpriteFrame = (function () {
                function TexturePackerItemSpriteFrame(frame, id) {
                    this.frame = frame;
                    this.id = id;
                }
                TexturePackerItemSpriteFrame.prototype.getId = function () {
                    return this.id;
                };
                TexturePackerItemSpriteFrame.prototype.getWidth = function () {
                    return this.frame.getWidth();
                };
                TexturePackerItemSpriteFrame.prototype.getHeight = function () {
                    return this.frame.getHeight();
                };
                TexturePackerItemSpriteFrame.prototype.fits = function (w, h) {
                    return this.frame.getWidth() <= w && this.frame.getHeight() <= h;
                };
                TexturePackerItemSpriteFrame.prototype.draw = function (ctx, x, y) {
                    ctx.save();
                    var w = this.frame.getWidth();
                    var h = this.frame.getHeight();
                    var rect = this.frame._rect;
                    if (this.frame._rotated) {
                        ctx.translate(w / 2, h / 2);
                        ctx.rotate(-Math.PI / 2);
                        ctx.translate(-w / 2, -h / 2);
                    }
                    //if ( cc.render.RENDER_ORIGIN==="" )
                    ctx.drawImage(this.frame._texture._image, rect.x, rect.y, rect.w, rect.h, x, y, w, h);
                    ctx.restore();
                };
                return TexturePackerItemSpriteFrame;
            })();
            /**
             * @class cc.plugin.texture.TexturePacker
             * @classdesc
             *
             * This class is a very simple yet effective TexturePacker. It will create images of a user-defined size
             * and pack images in them.
             *
             * The process is:
             * <li>Add images to the packer. Each image must have an id associated.
             * <li>call pack. This will create page object and the tree of nodes with image references.
             * <li>call createAssets, that creates the Page Images and packs the supplied images on them. It also creates
             *   necessary SpriteFrames and Texture objects.
             *
             * This packer is not expected to be used with dynamic textures, adding and removing textures on-the-fly.
             *
             * Images that don't fit in the specified texture page size will be silently discarded.
             *
             */
            var TexturePacker = (function () {
                /**
                 * Create a new TexturePacker object instance.
                 * @method cc.plugin.texture.TexturePacker#constructor
                 */
                function TexturePacker() {
                    /**
                     * An array of pair Image,id with images to pack.
                     * @member cc.plugin.texture.TexturePacker#_images
                     * @type {Array<{any,string}>}
                     * @private
                     */
                    this._images = [];
                    /**
                     * An array of generated texture page object.
                     * @member cc.plugin.texture.TexturePacker#_pages
                     * @type {Array<cc.plugin.texture.TexturePackerPage>}
                     * @private
                     */
                    this._pages = [];
                    this._margin = [0, 0, 0, 0];
                    this._debug = false;
                }
                /**
                 * Add an image with associated id to pack.
                 * @method cc.plugin.texture.TexturePacker#addImage
                 * @param image {HTMLImageElement|HTMLCanvasElement}
                 * @param id {string}
                 */
                TexturePacker.prototype.addImage = function (image, id) {
                    this._images.push(new TexturePackerItemImage(image, id ? id : image.src));
                };
                TexturePacker.prototype.addSpriteFrame = function (spriteFrame) {
                    this._images.push(new TexturePackerItemSpriteFrame(spriteFrame, spriteFrame._name));
                };
                TexturePacker.prototype.addSpriteFrames = function (spriteFrames) {
                    for (var i = 0; i < spriteFrames.length; i++) {
                        this.addSpriteFrame(spriteFrames[i]);
                    }
                };
                TexturePacker.prototype.addPListAtlas = function (image, atlasInfo) {
                    var main = new cc.node.sprite.SpriteFrame(new cc.render.Texture2D(image, ""));
                    var sf = main.createSpriteFramesFromPLIST(atlasInfo);
                    this.addSpriteFrames(sf);
                };
                TexturePacker.prototype.addJSONAtlas = function (image, atlasInfo) {
                    var main = new cc.node.sprite.SpriteFrame(new cc.render.Texture2D(image, ""));
                    var sf = main.createSpriteFramesFromJSON(atlasInfo);
                    this.addSpriteFrames(sf);
                };
                /**
                 * Pack images.
                 * This method ONLY creates the internal TexturePackerPage nodes, not the images.
                 * Images will be packed in pages of the specified size.
                 * @method cc.plugin.texture.TexturePacker#pack
                 * @param pack {cc.plugin.texture.PackInfo} texture packer packing info.
                 */
                TexturePacker.prototype.pack = function (pack) {
                    var w = pack.width || 2048;
                    var h = pack.height || 2048;
                    var sortStrategy = pack.sortBy;
                    var margin_v = pack.margin || 0;
                    // left top right bottom
                    var margin = [margin_v, margin_v, margin_v, margin_v];
                    if (pack['margin-left']) {
                        margin[0] = pack['margin-left'];
                    }
                    if (pack['margin-top']) {
                        margin[1] = pack['margin-top'];
                    }
                    if (pack['margin-right']) {
                        margin[2] = pack['margin-right'];
                    }
                    if (pack['margin-bottom']) {
                        margin[3] = pack['margin-bottom'];
                    }
                    this._debug = typeof pack.debug !== "undefined" ? pack.debug : false;
                    this._margin = margin;
                    this._pages = [];
                    if (sortStrategy) {
                        var ss = SortStrategies[sortStrategy] || SortStrategies['perimeter'];
                        this._images.sort(ss);
                    }
                    this._pages.push(new TexturePackerPage("texturepage" + getTexturePageIndex(), w, h));
                    for (var i = 0; i < this._images.length; i++) {
                        if (this._images[i].fits(w, h)) {
                            var node = null;
                            for (var j = 0; j < this._pages.length; j++) {
                                node = this._pages[j].insertImage(this._images[i], margin);
                                if (node !== null) {
                                    break;
                                }
                            }
                            // not a valid insertion node in the currently created pages.
                            // create a new one (the image fits in page dimensions after all)
                            if (null === node) {
                                var newPage = new TexturePackerPage("texturepage" + getTexturePageIndex(), w, h);
                                this._pages.push(newPage);
                                newPage.insertImage(this._images[i], margin);
                            }
                        }
                    }
                };
                /**
                 * Builds page images and the associated SpriteFrame and Texture2D objects.
                 * Will also add the assets to the AssetManager.
                 * Added images will register a SpriteFrame identified by the supplied id or the image.src if it was not set.
                 * Added sprite frames will register a SpriteFrame identified by its id.
                 * Created Texture pages will register a SpriteFrame identified as texturepage<i>, where i is the sequence
                 * of the created page.
                 * This TexturePage index grows with every created frame, so don't always expect to habe texturepage0 as the
                 * first created page.
                 * @method cc.plugin.texture.TexturePacker#createAssets
                 */
                TexturePacker.prototype.createAssets = function () {
                    for (var i = 0; i < this._pages.length; i++) {
                        this._pages[i].createAssets(this._margin, this._debug);
                    }
                };
                return TexturePacker;
            })();
            texture.TexturePacker = TexturePacker;
        })(texture = plugin.texture || (plugin.texture = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../asset/AssetManager.ts"/>
/// <reference path="../../node/sprite/SpriteFrame.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
/// <reference path="../../render/Texture2D.ts"/>
/// <reference path="../../widget/Label.ts"/>
/// <reference path="./SpriteFontHelper.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var font;
        (function (_font) {
            /**
             * @class cc.plugin.font.SpriteFontChar
             * @classdesc
             *
             * For a SpriteFont, this class represents a TextureFont character.
             * It contains information about its size and kerning.
             *
             */
            var SpriteFontChar = (function () {
                /**
                 * Create a new SpritFontChar object instance.
                 * @method cc.plugin.font.SpriteFontChar#constructor
                 */
                function SpriteFontChar() {
                    /**
                     * This numerical id is the charCode of a font character.
                     * @member cc.plugin.font.SpriteFontChar#_id
                     * @type {number}
                     * @private
                     */
                    this._id = null;
                    /**
                     * A SpriteFrame representing character texture information.
                     * @member cc.plugin.font.SpriteFontChar#_frame
                     * @type {cc.node.sprite.SpriteFrame}
                     * @private
                     */
                    this._frame = null;
                    /**
                     * Pixels to advance the cursor after typing this character.
                     * @member cc.plugin.font.SpriteFontChar#_xadvance
                     * @type {number}
                     * @private
                     */
                    this._xadvance = 0;
                    /**
                     * Horizontal offset to draw the character.
                     * @member cc.plugin.font.SpriteFontChar#_xoffset
                     * @type {number}
                     * @private
                     */
                    this._xoffset = 0;
                    /**
                     * Vertical offset to draw the character. this offset will make the character lie on the baseline.
                     * @member cc.plugin.font.SpriteFontChar#_yoffset
                     * @type {number}
                     * @private
                     */
                    this._yoffset = 0;
                    /**
                     * Kerning info.
                     * @member cc.plugin.font.SpriteFontChar#_kerningInfo
                     * @type {Map<string,number>}
                     * @private
                     */
                    this._kerningInfo = {};
                    /**
                     * Reference to the SpriteFont object this char belongs to.
                     * @member cc.plugin.font.SpriteFontChar#_font
                     * @type {cc.node.sprite.SpriteFont}
                     * @private
                     */
                    this._font = null;
                }
                Object.defineProperty(SpriteFontChar.prototype, "width", {
                    /**
                     * Get the char width.
                     * @member cc.plugin.font.SpriteFontChar#get:width
                     * @returns {number}
                     */
                    get: function () {
                        return this._frame._rect.w;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Set the char SpriteFont reference.
                 * @member cc.plugin.font.SpriteFontChar#setFont
                 * @param f {cc.plugin.font.SpriteFont}
                 */
                SpriteFontChar.prototype.setFont = function (f) {
                    this._font = f;
                };
                /**
                 * Set the char SpriteFrame.
                 * @member cc.plugin.font.SpriteFontChar#setFrame
                 * @param spriteFrame {cc.node.sprite.SpriteFrame}
                 */
                SpriteFontChar.prototype.setFrame = function (spriteFrame) {
                    this._frame = spriteFrame;
                };
                /**
                 * Add kerning info for a given char.
                 * @member cc.plugin.font.SpriteFontChar#addKerning
                 * @param char {string} a single character string.
                 * @param v {number} kerning value for the char parameter
                 */
                SpriteFontChar.prototype.addKerning = function (char, v) {
                    this._kerningInfo[char] = v;
                };
                /**
                 * Draw a SpritFont character.
                 * @member cc.plugin.font.SpriteFontChar#draw
                 * @param ctx {cc.render.RenderingContext}
                 * @param x {number}
                 * @param y {number}
                 * @param nextChar {string} next drawing character. needed for kerning adjustment.
                 */
                SpriteFontChar.prototype.draw = function (ctx, x, y, nextChar) {
                    if (null === this._frame || this._frame._rect.isEmpty()) {
                        return;
                    }
                    if (nextChar !== null) {
                        var _kerning = this._kerningInfo[nextChar];
                        if (_kerning) {
                            x += _kerning;
                        }
                    }
                    var rect = this._frame._rect;
                    var _y;
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_TOP) {
                        _y = y + this._yoffset;
                    }
                    else {
                        _y = y + this._font._height - (rect.h + this._yoffset);
                    }
                    ctx.drawTexture(this._frame.getTexture(), rect.x, rect.y, rect.w, rect.h, x + this._xoffset, _y, rect.w, rect.h);
                };
                /**
                 * Create a SpriteFontChar from a SpriteFrame and some data definition.
                 * @member cc.plugin.font.SpriteFontChar.createFrom
                 * @param frame {cc.node.sprite.SpriteFrame} a sprite frame the character will be mapped to.
                 * @param data {object} SpriteFontChar definition.
                 * @returns {cc.plugin.font.SpriteFontChar}
                 */
                SpriteFontChar.createFrom = function (frame, data) {
                    var sfc = new SpriteFontChar();
                    sfc._frame = frame.createSubSpriteFrame(data.x - 2, data.y, data.width, data.height, data.id);
                    if (null === sfc._frame) {
                        cc.Debug.info(cc.locale.ERR_FONT_GLYPTH_NOT_IN_FRAME, data.id);
                    }
                    sfc._xadvance = data.xadvance || 0;
                    sfc._xoffset = data.xoffset || 0;
                    sfc._yoffset = data.yoffset || 0;
                    sfc._id = data.id;
                    return sfc;
                };
                return SpriteFontChar;
            })();
            _font.SpriteFontChar = SpriteFontChar;
            /**
             * @class cc.plugin.font.SpriteFont
             * @classdesc
             *
             * A sprite font is a fast drawing type of font that for webgl autobatches with very good performance results.
             * This kind of fonts are backed by a texture, where the characters are already drawn. The font basically blits
             * characters to the screen.
             *
             * Currently, a SpriteFont can be created:
             * <li>From a glyph designer output file
             * <li>A FNT output file, like the ones coming from https://www.glyphite.com
             * <li>From Texture packer JSON output
             *
             * Fonts can be cached in the AssetManager.
             *
             * BUGBUG: fonts are slow. remove all split calls in favor or faster methods.
             */
            var SpriteFont = (function () {
                /**
                 * Create a new SpriteFont object instance.
                 * @method cc.plugin.font.SpriteFont#constructor
                 * @param name
                 */
                function SpriteFont(name) {
                    /**
                     * A font name of choice. This name will be used as the key for the SpriteFont cache.
                     * @member cc.plugin.font.SpriteFont#_fontName
                     * @type {string}
                     * @private
                     */
                    this._fontName = null;
                    /**
                     * Whether the font is valid for draw.
                     * @member cc.plugin.font.SpriteFont#_valid
                     * @type {boolean}
                     * @private
                     */
                    this._valid = false;
                    /**
                     * Collection of objects representing font characters.
                     * @member cc.plugin.font.SpriteFont#_chars
                     * @type {Map<string,SpriteFontChar>}
                     * @private
                     */
                    this._chars = {};
                    /**
                     * Font height. The height is the height of every font character. Height is the result of ascent+descent.
                     * @member cc.plugin.font.SpriteFont#_height
                     * @type {number}
                     * @private
                     */
                    this._height = 0;
                    /**
                     * Font baseline, corresponding to the alphabetic baseline.
                     * @member cc.plugin.font.SpriteFont#_baseline
                     * @type {number}
                     * @private
                     */
                    this._baseline = 0;
                    /**
                     * Font ascent. Height of char area corresponding to the content above the baseline.
                     * @member cc.plugin.font.SpriteFont#_descent
                     * @type {number}
                     * @private
                     */
                    this._descent = 0;
                    /**
                     * Font descent. Height of the char area correspoingind to the content below the baseline.
                     * @member cc.plugin.font.SpriteFont#_ascent
                     * @type {number}
                     * @private
                     */
                    this._ascent = 0;
                    this._fontName = name;
                }
                /**
                 * Whether the font is valid.
                 * @method cc.plugin.font.SpriteFont#isValid
                 * @returns {boolean}
                 */
                SpriteFont.prototype.isValid = function () {
                    return this._valid;
                };
                /**
                 * Insert a SpriteFontChar in the font definition.
                 * @method cc.plugin.font.SpriteFont#__addChar
                 * @param obj {cc.plugin.font.SpriteFontChar}
                 * @private
                 */
                SpriteFont.prototype.__addChar = function (obj) {
                    obj.setFont(this);
                    this._chars[String.fromCharCode(obj._id)] = obj;
                };
                /**
                 * Create a font font a FNT file.
                 * @method cc.plugin.font.SpriteFont#setAsGlypthDesigner
                 * @param spriteFrameId {string} The name of a SpriteFrame in the AssetManager cache. The font characters
                 *  will be mapped on the SpriteFrame represented by the id.
                 * @param fontDef {string} a .fnt file contents.
                 * @returns {cc.plugin.font.SpriteFont}
                 */
                SpriteFont.prototype.setAsFnt = function (spriteFrameId, fontDef) {
                    return this.setAsGlypthDesigner(spriteFrameId, fontDef);
                };
                /**
                 * Build the font from a glyph designer output file.
                 * @method cc.plugin.font.SpriteFont#setAsGlypthDesigner
                 * @param spriteFrameId {string} The name of a SpriteFrame in the AssetManager cache. The font characters
                 *  will be mapped on the SpriteFrame represented by the id.
                 * @param fontDef {string} a glyph designed file contents.
                 * @returns {cc.plugin.font.SpriteFont}
                 */
                SpriteFont.prototype.setAsGlypthDesigner = function (spriteFrameId, fontDef) {
                    var f = cc.plugin.asset.AssetManager.getSpriteFrame(spriteFrameId);
                    // remove tabs for spaces.
                    var text = fontDef.split("\n");
                    for (var i = 0; i < text.length; i++) {
                        text[i] = text[i].replace(/\t/gi, " ");
                        // parse a char
                        if (0 === text[i].indexOf("char ")) {
                            var str = text[i].substring(5);
                            var pairs = str.split(' ');
                            var props = {};
                            for (var j = 0; j < pairs.length; j++) {
                                var pair = pairs[j];
                                // skip empty split pairs which are just ""
                                if (pair !== "") {
                                    var pairData = pair.trim().split("=");
                                    if (pairData[0] !== "page" && pairData[0] !== "chnl" && pairData[0] !== "letter") {
                                        var property = pairData[0];
                                        var value = pairData[1];
                                        props[property] = parseFloat(value);
                                    }
                                }
                            }
                            this.__addChar(SpriteFontChar.createFrom(f, props));
                        }
                        else if (0 === text[i].indexOf("kerning ")) {
                            // parse kerning info.
                            var str = text[i].substring(8);
                            var pairs = str.trim().split(' ');
                            for (var j = 0; j < pairs.length; j++) {
                                var first = pairs[0].split('=')[1];
                                var second = pairs[1].split('=')[1];
                                var amount = pairs[2].split('=')[1];
                                var char = this._chars[String.fromCharCode(parseInt(first))];
                                if (char) {
                                    char.addKerning(String.fromCharCode(parseInt(second)), parseInt(amount));
                                }
                            }
                        }
                        else if (0 === text[i].indexOf("common")) {
                            // parse font definition info
                            var str = text[i].substring(7);
                            var pairs = str.trim().split(' ');
                            for (var j = 0; j < pairs.length; j++) {
                                var vv = pairs[j].split("=");
                                var key = vv[0];
                                value = vv[1];
                                if (key === "lineHeight") {
                                    this._height = parseFloat(value);
                                }
                                else if (key === "base") {
                                    this._baseline = parseFloat(value);
                                    this._descent = this._height - this._baseline;
                                }
                            }
                        }
                        else if (0 === text[i].indexOf("info")) {
                        }
                    }
                    this._valid = true;
                    return this;
                };
                /**
                 * Build the font from a systm font object initializer.
                 * @method cc.plugin.font.SpriteFont#setAsSystemFont
                 * @param fontDef {cc.plugin.font.SystemFontInitializer} font definition
                 * @returns {cc.plugin.font.SpriteFont}
                 */
                SpriteFont.prototype.setAsSystemFont = function (fontDef) {
                    if (typeof fontDef.fontface === "undefined") {
                        fontDef.fontface = "arial";
                    }
                    if (typeof fontDef.size === "undefined") {
                        fontDef.size = 20;
                    }
                    fontDef.padding = fontDef.padding || 2;
                    fontDef.strokeSize = fontDef.strokeSize || 1;
                    fontDef.strokeStyle = fontDef.strokeStyle || "#000";
                    fontDef.fillStyle = fontDef.fillStyle || "#000";
                    // create a canvas object
                    var canvas = document.createElement("canvas");
                    var ctx = canvas.getContext("2d");
                    var font = "" + fontDef.size + "px " + fontDef.fontface + (fontDef.style ? " " + fontDef.style : "");
                    ctx.font = font;
                    ctx.strokeStyle = fontDef.strokeStyle;
                    ctx.fillStyle = fontDef.fillStyle;
                    ctx.lineWidth = fontDef.strokeSize;
                    var mt = cc.plugin.font.getFontMetrics(ctx, font);
                    this._height = mt.height + fontDef.padding;
                    this._baseline = this._height;
                    var mwidth = ctx.measureText(fontDef.characters).width; //  measured width
                    var w = (Math.min(mwidth, 1024) | 0) + 1;
                    var h = (2 + ((mwidth / 1024) | 0)) * this._height;
                    canvas.width = w;
                    canvas.height = h;
                    ctx = canvas.getContext("2d");
                    ctx.font = font;
                    ctx.textBaseline = "alphabetic";
                    ctx.textAlign = "center";
                    ctx.strokeStyle = fontDef.strokeStyle;
                    ctx.fillStyle = fontDef.fillStyle;
                    ctx.lineWidth = fontDef.strokeSize;
                    var x = 0;
                    var y = mt.ascent;
                    var chars = {};
                    for (var i = 0; i < fontDef.characters.length; i++) {
                        var str = fontDef.characters.substr(i, 1);
                        var strw = 1 + (ctx.measureText(str).width | 0);
                        if (x + strw + fontDef.padding >= w) {
                            x = 0;
                            y += this._height;
                        }
                        if (fontDef.stroke) {
                            ctx.strokeText(str, x + strw / 2, y);
                        }
                        if (fontDef.fill) {
                            ctx.fillText(str, x + strw / 2, y);
                        }
                        chars[str] = {
                            x: x + fontDef.padding / 2,
                            y: y - mt.ascent,
                            width: strw + fontDef.strokeSize / 2,
                            height: this._height,
                            id: str.charCodeAt(0),
                            xadvance: strw
                        };
                        x += strw + fontDef.padding;
                    }
                    cc.plugin.asset.AssetManager.addImage(canvas, this._fontName);
                    for (var char in chars) {
                        this.__addChar(SpriteFontChar.createFrom(cc.plugin.asset.AssetManager.getSpriteFrame(this._fontName), chars[char]));
                    }
                    this._valid = true;
                    return this;
                };
                /**
                 * Draw text with the font.
                 * Characters not present in the font will be skipped, as if they were not in the string.
                 * The string can be multiline, and text is splitted in lines with \n character.
                 * The split operation is slow and GC prone, so better call drawTextArray.
                 * @method cc.plugin.font.SpriteFont#drawText
                 * @param ctx {cc.render.RenderingContext}
                 * @param text {string}
                 * @param x {number}
                 * @param y {number}
                 */
                SpriteFont.prototype.drawText = function (ctx, text, x, y) {
                    var lines = text.split('\n');
                    this.drawTextArray(ctx, lines, x, y);
                };
                /**
                 * Draw an array of strings. Each string will be considered one line of text.
                 * This method will be called by drawText. Prefer this method to avoid creating intermediate strings
                 * per frame compared to drawText.
                 * @param ctx {cc.render.RenderingContext}
                 * @param lines {string[]}
                 * @param x {number}
                 * @param y {number}
                 */
                SpriteFont.prototype.drawTextArray = function (ctx, lines, x, y) {
                    var h = this._height;
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        y += (lines.length - 1) * this._height;
                        h = -h;
                    }
                    for (var n = 0; n < lines.length; n++) {
                        this.drawTextLine(ctx, lines[n], x, y);
                        y += h;
                    }
                };
                /**
                 * This method is like drawText but does not take into account line breaks.
                 * It will therefore draw all text in one single line.
                 * This method is called by drawTextArray. Prefer this method if the text has one single line of text.
                 * @param ctx {cc.render.RenderingContext}
                 * @param text {string}
                 * @param x {number}
                 * @param y {number}
                 */
                SpriteFont.prototype.drawTextLine = function (ctx, text, x, y) {
                    for (var i = 0; i < text.length; i++) {
                        var char = this._chars[text.charAt(i)];
                        if (char) {
                            // draw char
                            char.draw(ctx, x, y, i < text.length - 1 ? text.charAt(i + 1) : null);
                            x += char._xadvance;
                        }
                    }
                };
                /**
                 * Draw a text with the current font that will fit in a given rectangle.
                 * The text will flow with the given rectangle width.
                 * The text will be horizontal and vertically aligned in the rect based on the valign/halign hints.
                 * The text can have multiple lines separated by \n characters.
                 * @param ctx {cc.render.RenderingContext} multi renderer rendering context.
                 * @param text {string} text to fit in the rectangle.
                 * @param x {number} x position of the rect to fit the text in.
                 * @param y {number} y position of the rect to fit the text in.
                 * @param width {number} width of the rect to fit the text in.
                 * @param height {number} height of the rect to fit the text in.
                 * @param valign {cc.widget.VALIGN} vertical alignment hint
                 * @param halign {cc.widget.HALIGN} horizontal alignment hint
                 */
                SpriteFont.prototype.drawTextInRect = function (ctx, text, x, y, width, height, halign, valign) {
                    var textSize = this.getTextSize(text, width);
                    var lines = text.split('\n');
                    var textHeight = textSize.height;
                    var yoffset = 0;
                    // make top be always up regardless how y-axis grows.
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        if (valign === 2 /* BOTTOM */) {
                            valign = 0 /* TOP */;
                        }
                        else if (valign === 0 /* TOP */) {
                            valign = 2 /* BOTTOM */;
                        }
                    }
                    switch (valign) {
                        case 1 /* MIDDLE */:
                            yoffset = (height - textHeight) / 2;
                            break;
                        case 2 /* BOTTOM */:
                            yoffset = height - textHeight - 1;
                    }
                    if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                        yoffset += (lines.length - 1) * this._height;
                    }
                    var xx = x;
                    for (var n = 0; n < lines.length; n++) {
                        var xoffset = 0;
                        var lineWidth = this.getStringWidth(lines[n]);
                        switch (halign) {
                            case 1 /* CENTER */:
                                break;
                            case 2 /* RIGHT */:
                        }
                        var words = lines[n].split(" ");
                        for (var i = 0; i < words.length; i++) {
                            var word = words[i];
                            if (i < words.length - 1) {
                                word += " ";
                            }
                            var wordWidth = this.getStringWidth(word);
                            if (x + wordWidth > width) {
                                y += this._height * (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM ? -1 : 1);
                                x = 0;
                            }
                            for (var j = 0; j < word.length; j++) {
                                var char = this._chars[word[j]];
                                if (char) {
                                    // draw char
                                    char.draw(ctx, x + xoffset, y + yoffset, lines[n].charAt(i + 1));
                                    x += char._xadvance;
                                }
                            }
                        }
                        y += this._height * (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM ? -1 : 1);
                        x = xx;
                    }
                };
                /**
                 * Get a text dimension by this font.
                 * @method cc.plugin.font.SpriteFont#textSize
                 * @param text {string}
                 * @param flowWidth {number=}
                 * @returns {cc.math.Dimension}
                 */
                SpriteFont.prototype.getTextSize = function (text, flowWidth) {
                    var width = 0;
                    var height = 0;
                    if (!flowWidth) {
                        var lines = text.split('\n');
                        for (var n = 0; n < lines.length; n++) {
                            var w = this.getStringWidth(lines[n]);
                            if (w > width) {
                                width = w;
                            }
                            height += this._height;
                        }
                        return new cc.math.Dimension(width, height);
                    }
                    else {
                        return this.getTextSizeFlow(text, flowWidth);
                    }
                };
                SpriteFont.prototype.getTextSizeFlow = function (text, flowWidth) {
                    var lines = text.split("\n");
                    var ret = new cc.math.Dimension();
                    for (var i = 0; i < lines.length; i++) {
                        var d = this.getLineSizeFlow(lines[i], flowWidth);
                        if (d.width > ret.width) {
                            ret.width = d.width;
                        }
                        ret.height += d.height;
                    }
                    return ret;
                };
                SpriteFont.prototype.getLineSizeFlow = function (text, flowWidth) {
                    var maxWidth = 0;
                    var w = 0;
                    var h = this._height;
                    var words = text.split(" ");
                    for (var i = 0; i < words.length; i++) {
                        var word = words[i];
                        if (i < words.length - 1) {
                            word += " ";
                        }
                        var wordWidth = this.getStringWidth(word);
                        // wrap line
                        if (w + wordWidth > flowWidth) {
                            h += this._height;
                            if (w > maxWidth) {
                                maxWidth = w;
                            }
                            w = wordWidth;
                        }
                        else {
                            w += wordWidth;
                        }
                    }
                    if (w > maxWidth) {
                        maxWidth = w;
                    }
                    return new cc.math.Dimension(maxWidth, h);
                };
                /**
                 * Get a string width based on the font char definition.
                 * If the string contains an unknown character to the font, that character will be skipped and add 0 to the
                 * string width.
                 * @param text {string}
                 * @returns {number} string width based on the current font.
                 */
                SpriteFont.prototype.getStringWidth = function (text) {
                    var w = 0;
                    for (var i = 0; i < text.length; i++) {
                        var char = this._chars[text.charAt(i)];
                        if (char) {
                            w += char._xadvance;
                        }
                    }
                    return w;
                };
                return SpriteFont;
            })();
            _font.SpriteFont = SpriteFont;
        })(font = plugin.font || (plugin.font = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var font;
        (function (_font) {
            /**
             * @class cc.plugin.font.FontMetrics
             * @classdesc
             *
             * This class represents Font metrics information.
             * It is needed for building on-the-fly system SpriteFont objects.
             *
             */
            var FontMetrics = (function () {
                /**
                 * Build a new FontMetrics object instance.
                 * @method cc.plugin.font.FontMetrics#constructor
                 */
                function FontMetrics(h, as, des) {
                    this.height = h;
                    this.ascent = as;
                    this.descent = des;
                }
                return FontMetrics;
            })();
            _font.FontMetrics = FontMetrics;
            /**
             * Get a FontMetrics object. The system will try to guess the most accurate FontMetrics object based on system
             * capabilities:
             *
             * <li>First, try to get metrics info from the CanvasRenderingContext2D TextMetrics object.
             * <li>If not available, will try to execute a voodoo function to measure size using DOM and CSS.
             * <li>If not, will guess from the font size. most inaccurate, and buggy.
             *
             * @name getFontMetrics
             * @memberOf cc.plugin.font
             *
             * @param ctx {CanvasRenderingContext2D}
             * @param font {string} valid canvas font representation.
             */
            function getFontMetrics(ctx, font) {
                var prevFont = ctx.font;
                ctx.font = font;
                var fm = ctx.measureText("WHGg");
                var ffm = fm;
                if (typeof ffm.actualBoundingBoxDescent !== "undefined") {
                    var ret = new FontMetrics();
                    ret.height = ffm.actualBoundingBoxAscent + ffm.actualBoundingBoxDescent;
                    ret.ascent = ffm.actualBoundingBoxAscent;
                    ret.descent = ffm.actualBoundingBoxDescent;
                    ctx.font = prevFont;
                    return ret;
                }
                try {
                    ret = getFontMetricsCSS(font);
                    return ret;
                }
                catch (e) {
                }
                return getFontMetricsNoCSS(font);
            }
            _font.getFontMetrics = getFontMetrics;
            function getFontMetricsNoCSS(font) {
                var re = /(\d+(\.\d+)?)p[x|t]\s*/i;
                var res = re.exec(font);
                var height;
                if (!res) {
                    height = 32;
                }
                else {
                    // yes, no need to split the px|t, parsefloat is good enough !!
                    height = parseFloat(res[1]);
                }
                var ascent = height - 1;
                var h = (height + height * 0.25) | 0;
                return new FontMetrics(h, ascent, h - ascent);
            }
            /**
             * Totally ripped from:
             *
             * jQuery (offset function)
             * Daniel Earwicker: http://stackoverflow.com/questions/1134586/how-can-you-find-the-height-of-text-on-an-html-canvas
             *
             * @param font
             * @return {*}
             */
            function getFontMetricsCSS(font) {
                function offset(elem) {
                    var box, docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft, top, left;
                    var doc = elem && elem.ownerDocument;
                    docElem = doc.documentElement;
                    box = elem.getBoundingClientRect();
                    body = document.body;
                    win = doc.nodeType === 9 ? doc.defaultView || doc.parentWindow : false;
                    clientTop = docElem.clientTop || body.clientTop || 0;
                    clientLeft = docElem.clientLeft || body.clientLeft || 0;
                    scrollTop = win.pageYOffset || docElem.scrollTop;
                    scrollLeft = win.pageXOffset || docElem.scrollLeft;
                    top = box.top + scrollTop - clientTop;
                    left = box.left + scrollLeft - clientLeft;
                    return { top: top, left: left };
                }
                try {
                    var text = document.createElement("span");
                    text.style.font = font;
                    text.innerHTML = "g";
                    var block = document.createElement("div");
                    block.style.display = "inline-block";
                    block.style.width = "1px";
                    block.style.height = "0px";
                    var div = document.createElement("div");
                    div.appendChild(text);
                    div.appendChild(block);
                    var body = document.body;
                    body.appendChild(div);
                    try {
                        var result = new FontMetrics();
                        block.style.verticalAlign = 'baseline';
                        result.ascent = offset(block).top - offset(text).top;
                        block.style.verticalAlign = 'bottom';
                        result.height = offset(block).top - offset(text).top;
                        result.ascent = Math.ceil(result.ascent);
                        result.height = Math.ceil(result.height);
                        result.descent = result.height - result.ascent;
                        return result;
                    }
                    finally {
                        body.removeChild(div);
                    }
                }
                catch (e) {
                    return null;
                }
            }
        })(font = plugin.font || (plugin.font = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../../../lib/webaudio/webaudio.d.ts" />
/// <reference path="../../math/Rectangle.ts"/>
/// <reference path="../../node/sprite/SpriteFrame.ts"/>
/// <reference path="../../node/sprite/Animation.ts"/>
/// <reference path="../../render/Texture2D.ts"/>
/// <reference path="../../render/Renderer.ts"/>
/// <reference path="../../plugin/font/SpriteFont.ts"/>
/// <reference path="../loader/Loader.ts"/>
/// <reference path="../loader/Resource.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var asset;
        (function (asset) {
            var Loader = cc.plugin.loader.Loader;
            /**
             * Stores all image resources.
             * @type {Map<string,cc.render.Texture2D>}
             * @private
             */
            var _textures = {};
            /**
             * Stores all SpriteFrame resources. Loaded Atlases will also add SpriteFrames based on their internal definitions.
             * @type {Map<string,cc.node.sprite.SpriteFrame>}
             * @private
             */
            var _frames = {};
            /**
             * Stores Animation objects
             * @type {Map<string,cc.node.sprite.Animation>}
             * @private
             */
            var _animations = {};
            /**
             * Stores SpriteFont objects
             * @type {Map<string,cc.plugin.font.SpriteFont>}
             * @private
             */
            var _spriteFonts = {};
            var _audioBuffers = {};
            /**
             * @class cc.plugin.asset.AssetManager
             * @classdesc
             *
             * A AssetManager manager keeps references of in-game resources. The difference with a plain resource is that a
             * resource manages load-and-set operations, but an asset han have some postprocessing, like creating an atlas
             * from an image, etc.
             * This object is the only globally available object and thus, can be shared across different Director objects.
             * The idea is to have a centralized resource mechanism where sounds, sprites, atlases, fonts, etc. can be directly
             * accessed. The resource manager will just store, contents, not handle or load it in anyway.
             * <p>
             *     The AssetManager can be the listener or any Loader objects, thus receiving the independent resources,
             *     and then grouping them in different stores.
             * <p>
             *     The method load, creates a Loader object and registers itself as observer of the loading events.
             */
            var AssetManager = (function () {
                function AssetManager() {
                }
                AssetManager.mergeResources = function (res) {
                    for (var i in res) {
                        cc.plugin.asset.AssetManager._resources[i] = res[i];
                    }
                };
                /**
                 * Load a resource set.
                 * Internally, it builds a <code>cc.plugin.loader.Loader</code> object and starts the loading process.
                 * @method cc.plugin.loader.AssetManager.load
                 * @param data {cc.plugin.loader.LoaderInitializer} resources descriptor.
                 * @param onEnd {cc.plugin.loader.LoaderFinishedCallback} callback invoked when all resources end loading.
                 *          either the resources loaded ok or wrong, this method will be called.
                 * @param onProgress {cc.plugin.loader.LoaderProgressCallback=} callback invoked for each loaded resource
                 *          regardless of its loading result.
                 * @param onError {cc.plugin.loader.LoaderErrorCallback=} callback invoked for each resource loaded with error.
                 */
                AssetManager.load = function (data, onEnd, onProgress, onError) {
                    new Loader(data).startLoading(function end(resources) {
                        if (onEnd) {
                            onEnd(resources);
                        }
                    }, function progress(resource, index, total, errored) {
                        //AssetManager.addResource( resource );
                        if (onProgress) {
                            onProgress(resource, index, total, errored);
                        }
                    }, function error(resource) {
                        if (onError) {
                            onError(resource);
                        }
                    });
                };
                /**
                 * Setup textures for a given renderer. Concretelly, if the renderer is webgl, textures are turned into webgl
                 * textures.
                 * @method cc.plugin.asset.AssetManager.prepareTextures
                 * @param renderer {cc.render.Renderer}
                 */
                AssetManager.prepareTextures = function (renderer) {
                    for (var texture in _textures) {
                        if (_textures.hasOwnProperty(texture)) {
                            renderer.prepareTexture(_textures[texture]);
                        }
                    }
                };
                /**
                 * Add an Image to the Manager resources.
                 * The image will be stored as a cc.render.Texture2D object.
                 * A SpriteFrame with the given id and representing the whole image will be added too.
                 * @method cc.plugin.asset.AssetManager.addImage
                 * @param img {HTMLImageElement|HTMLCanvasElement}
                 * @param id {string} The texture and the SpriteFrame representing the texture will have this id.
                 */
                AssetManager.addImage = function (img, id) {
                    var texture = new cc.render.Texture2D(img, id);
                    _textures[id] = texture;
                    _frames[id] = new cc.node.sprite.SpriteFrame(texture);
                    return texture;
                };
                /**
                 * Add a cc.plugin.loader.Resource instance.
                 * Currently only works for images.
                 * @method cc.plugin.asset.AssetManager.addResource
                 * @param resource {cc.plugin.loader.Resource}
                 */
                AssetManager.addResource = function (resource) {
                    if (resource.isValid()) {
                        switch (resource.type) {
                            case "image":
                                AssetManager.addImage(resource.value, resource.id);
                                break;
                        }
                    }
                };
                /**
                 * Add a SpriteFrame to the cache.
                 * @method cc.plugin.asset.AssetManager.addSpriteFrame
                 * @param frame {cc.node.sprite.SpriteFrame}
                 */
                AssetManager.addSpriteFrame = function (frame) {
                    _frames[frame._name] = frame;
                };
                /**
                 * Get an SpriteFrame by id.
                 * @method cc.plugin.asset.AssetManager.getSpriteFrame
                 * @param id {string}
                 * @returns {cc.node.sprite.SpriteFrame}
                 */
                AssetManager.getSpriteFrame = function (id) {
                    var ret = _frames[id];
                    return ret ? ret : null;
                };
                /**
                 * Add an array of SpriteFrames to the cache.
                 * @method cc.plugin.asset.AssetManager.addSpriteFrames
                 * @param frames {Array<cc.node.sprite.SpriteFrame>}
                 */
                AssetManager.addSpriteFrames = function (frames) {
                    for (var i = 0; i < frames.length; i++) {
                        this.addSpriteFrame(frames[i]);
                    }
                };
                /**
                 * Get an array of sprite frames identified by an array of SpriteFrame ids.
                 * If any of the ids does not match a SpriteFrame object, a warning will be printed in the console,
                 * but nothing will happen.
                 * @method cc.plugin.asset.AssetManager.getSpriteFrames
                 * @param ids {Array<string>}
                 * @returns {Array<cc.node.sprite.SpriteFrame>}
                 */
                AssetManager.getSpriteFrames = function (ids) {
                    var ret = [];
                    for (var i = 0; i < ids.length; i++) {
                        var sf = AssetManager.getSpriteFrame(ids[i]);
                        if (sf) {
                            ret.push(sf);
                        }
                        else {
                            cc.Debug.warn(cc.locale.ASSETMANAGER_WARN_SPRITEFRAME_NOT_FOUND, "getSpriteFrames", ids[i]);
                        }
                    }
                    return ret;
                };
                /**
                 * Add a Texture2D to the cache.
                 * @method cc.plugin.asset.AssetManager.addTexture
                 * @param texture {cc.render.Texture2D}
                 */
                AssetManager.addTexture = function (texture) {
                    _textures[texture._name] = texture;
                };
                /**
                 * Get a Texture2D object by string id.
                 * @param name {string}
                 * @returns {cc.render.Texture2D}
                 */
                AssetManager.getTexture = function (name) {
                    var ret = _textures[name];
                    return ret ? ret : null;
                };
                AssetManager.addAnimation = function (animation, name) {
                    _animations[name] = animation;
                };
                /**
                 * Create and store an animation build of the frames identified by the frames array.
                 * If there's a prefix set, the frames is assumed to be an array of number, to build the SpriteFrame names:
                 *  prefix+frames[0], prefix+frames[1], ..., etc.
                 * If no prefix, the frames array is assumed to be the sting identifiers of the frames composing the animation.
                 * @param animationName {string}
                 * @param frames {Array<number|string>}
                 * @param prefix {string=}
                 */
                AssetManager.addAnimationForFrames = function (animationId, frames, prefix) {
                    var animation = new cc.node.sprite.Animation();
                    for (var i = 0; i < frames.length; i++) {
                        var frameName = prefix ? prefix + frames[i] : frames[i];
                        var spriteFrame = _frames[frameName];
                        if (spriteFrame) {
                            animation.addFrame(spriteFrame);
                        }
                    }
                    _animations[animationId] = animation;
                    return animation;
                };
                /**
                 * Get an animation by id.
                 * @param animationId {string}
                 * @returns {cc.node.sprite.Animation}
                 */
                AssetManager.getAnimationById = function (animationId) {
                    var anim = _animations[animationId];
                    if (anim) {
                        return anim.clone();
                    }
                    return null;
                };
                /**
                 * Create SpriteFrames for all the elements in the JSON object.
                 * The new SpriteFrame objects will be mapped inside the SpriteFrame identified by the spriteFrameId parameter.
                 * @method cc.plugin.asset.AssetManager.addSpriteFramesFromFrameWithJSON
                 * @param spriteFrameId {string} a SpriteFrame in the cache.
                 * @param json {any}
                 * @param prefix {string=} an optional prefix to prepend to all sprite frame names.
                 */
                AssetManager.addSpriteFramesFromFrameWithJSON = function (spriteFrameId, json, prefix) {
                    var spriteFrame = AssetManager.getSpriteFrame(spriteFrameId);
                    if (spriteFrame) {
                        var frames = spriteFrame.createSpriteFramesFromJSON(json);
                        if (prefix) {
                            for (var i = 0; i < frames.length; i++) {
                                frames[i]._name = prefix + frames[i]._name;
                            }
                        }
                        AssetManager.addSpriteFrames(frames);
                    }
                };
                /**
                 * Create a grid of sub SpriteFrames from a given SpriteFrame.
                 * @method cc.plugin.asset.AssetManager.addGridSpriteFramesFromFrame
                 * @param spriteFrameId {string} a SpriteFrame id from the cache
                 * @param rows {number} number or rows of the grid
                 * @param cols {number} number or columns of the grid
                 */
                AssetManager.addGridSpriteFramesFromFrame = function (spriteFrameId, rows, cols) {
                    var spriteFrame = AssetManager.getSpriteFrame(spriteFrameId);
                    if (spriteFrame) {
                        var frames = spriteFrame.createSubSpriteFrames(rows, cols);
                        AssetManager.addSpriteFrames(frames);
                    }
                };
                /**
                 * Create a SpriteFont from the definition of a Glypth Designer file.
                 * The font will be stored in the fonts cache.
                 * @methoc cc.plugin.asset.AssetManager.createSpriteFontFromGlypthDesigner
                 * @param fontName {string} name for storing the font.
                 * @param spriteFrameId {string} a SpriteFrame from the cache. The glypths will be mapped in this SpriteFrame.
                 * @param glypthDesignerInfo {string} the contents of a Glypth Designer file.
                 */
                AssetManager.createSpriteFontFromGlypthDesigner = function (fontName, spriteFrameId, glypthDesignerInfo) {
                    var font = new cc.plugin.font.SpriteFont(fontName).setAsGlypthDesigner(spriteFrameId, glypthDesignerInfo);
                    if (font.isValid()) {
                        _spriteFonts[fontName] = font;
                    }
                };
                /**
                 * Get a SpriteFont from the cache.
                 * @methoc cc.plugin.asset.AssetManager.getSpriteFont
                 * @param fontName {string} the id of a SpriteFont in the cache.
                 * @returns {cc.plugin.font.SpriteFont}
                 */
                AssetManager.getSpriteFont = function (fontName) {
                    var ret = _spriteFonts[fontName];
                    return ret ? ret : null;
                };
                /**
                 * Create a SpriteFont for a System Font.
                 * @param fontName {string} the name to store the font in the cache.
                 * @param systemFont {cc.plugin.font.SystemFontInitializer} font definition object.
                 */
                AssetManager.createSystemSpriteFont = function (fontName, systemFont) {
                    var font = new cc.plugin.font.SpriteFont(fontName).setAsSystemFont(systemFont);
                    if (font.isValid()) {
                        _spriteFonts[fontName] = font;
                    }
                };
                AssetManager.addSpriteFramesFromFrameWithPLIST = function (spriteFrameId, plist) {
                    var spriteFrame = AssetManager.getSpriteFrame(spriteFrameId);
                    if (spriteFrame) {
                        var frames = spriteFrame.createSpriteFramesFromPLIST(plist);
                        AssetManager.addSpriteFrames(frames);
                    }
                };
                AssetManager.getAudioBuffer = function (id) {
                    var ret = _audioBuffers[id];
                    return ret ? ret : null;
                };
                AssetManager.addAudioBuffer = function (buffer, id) {
                    _audioBuffers[id] = buffer;
                };
                /**
                 * For backwards compatibility
                 * Map of string,Resource
                 */
                AssetManager._resources = {};
                return AssetManager;
            })();
            asset.AssetManager = AssetManager;
        })(asset = plugin.asset || (plugin.asset = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 *
 */
/// <reference path="../../../lib/webaudio/webaudio.d.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var audio;
        (function (_audio) {
            var audioContext = (function () {
                var ctx = typeof AudioContext !== "undefined" ? AudioContext : (typeof webkitAudioContext !== "undefined" ? webkitAudioContext : null);
                return ctx && new ctx();
            })();
            var codecs = null;
            (function () {
                function check(str) {
                    return str !== '' && str !== "no";
                }
                var audio = new Audio();
                codecs = {
                    mp3: check(audio.canPlayType('audio/mpeg;')),
                    ogg: check(audio.canPlayType('audio/ogg; codecs="vorbis"')),
                    wav: check(audio.canPlayType('audio/wav; codecs="1"')),
                    aac: check(audio.canPlayType('audio/aac;')),
                    m4a: check(audio.canPlayType('audio/x-m4a;')) || check(audio.canPlayType('audio/m4a;')) || check(audio.canPlayType('audio/aac;')),
                    mp4: check(audio.canPlayType('audio/x-mp4;')) || check(audio.canPlayType('audio/mp4;')) || check(audio.canPlayType('audio/aac;')),
                    weba: check(audio.canPlayType('audio/webm; codecs="vorbis"'))
                };
            })();
            /**
             * @tsenum cc.plugin.audio.AudioEffectStatus
             */
            (function (AudioEffectStatus) {
                AudioEffectStatus[AudioEffectStatus["NONE"] = 0] = "NONE";
                AudioEffectStatus[AudioEffectStatus["PLAY"] = 1] = "PLAY";
                AudioEffectStatus[AudioEffectStatus["PAUSE"] = 2] = "PAUSE";
                AudioEffectStatus[AudioEffectStatus["STOP"] = 3] = "STOP";
                AudioEffectStatus[AudioEffectStatus["END"] = 4] = "END";
                AudioEffectStatus[AudioEffectStatus["LOADED"] = 5] = "LOADED";
            })(_audio.AudioEffectStatus || (_audio.AudioEffectStatus = {}));
            var AudioEffectStatus = _audio.AudioEffectStatus;
            /**
             * @class cc.plugin.audio.AudioEffect
             * @classdesc
             *
             * This object represents a WebAudio enabled Object. It can:
             *
             * <ul>
             *  <li>play, pause, resume, stop and loop.
             *  <li>define an AudioSprite (a region over a given audio).
             *  <li>Apply BiquadFilters to output.
             *  <li>Apply Convolution (needs external audio buffers).
             *  <li>Expose full lifecycle: start, stop, repeat, pause and resume.
             *  <li>Manage volume.
             *  <li>Be independently muted.
             *  <li>Play with delay time, so that you can schedule sounds on the future.
             *  <li>Seek audio.
             *  <li>On-the-fly change of properties such as volume, filter, convolver, loop, etc.
             * </ul>
             *
             * This audio object is connected to a master volume.
             */
            var AudioEffect = (function () {
                /**
                 * @method cc.plugin.audio.AudioEffect#constructor
                 * @param buffer {object} Audio buffer object.
                 * @param masterGain {object} a GainNode which will act as system volume.
                 */
                function AudioEffect(masterGain, buffer) {
                    /**
                     * An string id.
                     * @member cc.plugin.audio.AudioEffect#_id
                     * @type {string}
                     * @private
                     */
                    this._id = null;
                    /**
                     *
                     * @member cc.plugin.audio.AudioEffect#_isWebAudio
                     * @type {boolean}
                     * @private
                     */
                    this._isWebAudio = false;
                    /**
                     * Internal audio object status.
                     * @member cc.plugin.audio.AudioEffect#_status
                     * @type {cc.plugin.audio.AudioEffectStatus}
                     * @private
                     */
                    this._status = 0 /* NONE */;
                    /**
                     * Is this object muted ?
                     * @member cc.plugin.audio.AudioEffect#_muted
                     * @type {boolean}
                     * @private
                     */
                    this._muted = false;
                    /**
                     * The audio volume. Volume ranges from 0 to 1.
                     * @member cc.plugin.audio.AudioEffect#_volume
                     * @type {boolean}
                     * @private
                     */
                    this._volume = 1;
                    /**
                     * The original audio buffer duration.
                     * this value opposes to _duration which is the current Audio object duration.
                     * @member cc.plugin.audio.AudioEffect#_bufferDuration
                     * @type {number}
                     * @private
                     */
                    this._bufferDuration = 0;
                    /**
                     * Current Audio object duration. If the audio is a sprite, the value will be different from _bufferDuration
                     * @member cc.plugin.audio.AudioEffect#_bufferDuration
                     * @type {number}
                     * @private
                     */
                    this._duration = 0;
                    /**
                     * The audio source node.
                     * @member cc.plugin.audio.AudioEffect#_source
                     * @type {AudioBufferSourceNode}
                     * @private
                     */
                    this._source = null;
                    /**
                     * The audio contents.
                     * @member cc.plugin.audio.AudioEffect#_buffer
                     * @type {AudioBuffer}
                     * @private
                     */
                    this._buffer = null;
                    /**
                     * Relative to duration time when the audio was paused. Never use directly
                     * @member cc.plugin.audio.AudioEffect#_pauseTime
                     * @type {number}
                     * @private
                     */
                    this._pauseTime = 0;
                    /**
                     * The audioContext time when play was called.
                     * @member cc.plugin.audio.AudioEffect#_startPlaybackTime
                     * @type {number}
                     * @private
                     */
                    this._startPlaybackTime = 0;
                    /**
                     * If play is called with delay, this is the delay time before play the sound.
                     * @member cc.plugin.audio.AudioEffect#_delayTime
                     * @type {number}
                     * @private
                     */
                    this._delayTime = 0;
                    /**
                     * Master volume node to which the audio volume will be connected.
                     * @member cc.plugin.audio.AudioEffect#_masterGain
                     * @type {number}
                     * @private
                     */
                    this._masterGain = null;
                    /**
                     * The audio volume node.
                     * @member cc.plugin.audio.AudioEffect#_gain
                     * @type {number}
                     * @private
                     */
                    this._gain = null;
                    /**
                     * Whether the audio is a sprite audio. A sprite audio is just a region from another audio object.
                     * @member cc.plugin.audio.AudioEffect#_isSprite
                     * @type {boolean}
                     * @private
                     */
                    this._isSprite = false;
                    /**
                     * If the audio is a Sprite audio, relative time offset where the sprite starts.
                     * @member cc.plugin.audio.AudioEffect#_spriteStartTime
                     * @type {boolean}
                     * @private
                     */
                    this._spriteStartTime = 0;
                    /**
                     * Loop the audio ?.
                     * @member cc.plugin.audio.AudioEffect#_loop
                     * @type {boolean}
                     * @private
                     */
                    this._loop = false;
                    /**
                     * Internal loop timer.
                     * @member cc.plugin.audio.AudioEffect#_endTimerId
                     * @type {number}
                     * @private
                     */
                    this._endTimerId = null;
                    /**
                     * Audio end callback.
                     * @member cc.plugin.audio.AudioEffect#_onEnd
                     * @type {cc.plugin.audio.AudioCallback}
                     * @private
                     */
                    this._onEnd = null;
                    /**
                     * Audio resume callback.
                     * @member cc.plugin.audio.AudioEffect#_onResume
                     * @type {cc.plugin.audio.AudioCallback}
                     * @private
                     */
                    this._onResume = null;
                    /**
                     * Audio pause callback.
                     * @member cc.plugin.audio.AudioEffect#_onPause
                     * @type {cc.plugin.audio.AudioCallback}
                     * @private
                     */
                    this._onPause = null;
                    /**
                     * Audio stop callback.
                     * @member cc.plugin.audio.AudioEffect#_onStop
                     * @type {cc.plugin.audio.AudioCallback}
                     * @private
                     */
                    this._onStop = null;
                    /**
                     * Audio start callback.
                     * @member cc.plugin.audio.AudioEffect#_onStart
                     * @type {cc.plugin.audio.AudioCallback}
                     * @private
                     */
                    this._onStart = null;
                    /**
                     * Audio repeat callback.
                     * @member cc.plugin.audio.AudioEffect#_onRepeat
                     * @type {cc.plugin.audio.AudioCallback}
                     * @private
                     */
                    this._onRepeat = null;
                    /**
                     * Internal BiquadFilter node for sound filtering.
                     * @member cc.plugin.audio.AudioEffect#_filter
                     * @type {object}
                     * @private
                     */
                    this._filter = null;
                    /**
                     * Is filtering enabled ?
                     * @member cc.plugin.audio.AudioEffect#_filterEnabled
                     * @type {boolean}
                     * @private
                     */
                    this._filterEnabled = false;
                    /**
                     * Internal convolver node for sound convolution.
                     * @member cc.plugin.audio.AudioEffect#_convolver
                     * @type {object}
                     * @private
                     */
                    this._convolver = null;
                    /**
                     * Is convolution enabled ?
                     * @member cc.plugin.audio.AudioEffect#_convolverEnabled
                     * @type {boolean}
                     * @private
                     */
                    this._convolverEnabled = false;
                    this._playbackRate = 1;
                    this._isWebAudio = true;
                    if (buffer) {
                        this.setBuffer(buffer);
                    }
                    this._gain = (typeof audioContext.createGain === "undefined") ? audioContext.createGainNode() : audioContext.createGain();
                    this._gain.connect(masterGain);
                    this._masterGain = masterGain;
                    this._filter = cc.plugin.audio.AudioManager.getContext().createBiquadFilter();
                    this._convolver = cc.plugin.audio.AudioManager.getContext().createConvolver();
                }
                AudioEffect.prototype.setId = function (s) {
                    this._id = s;
                    return this;
                };
                AudioEffect.prototype.getId = function () {
                    return this._id;
                };
                AudioEffect.prototype.setBuffer = function (buffer) {
                    this._bufferDuration = buffer.duration;
                    this._duration = buffer.duration;
                    this._buffer = buffer;
                };
                /**
                 * Make the audio loop or not. This can be changed at any given time.
                 * @method cc.plugin.audio.AudioEffect#loop
                 * @param enable {boolean} enable loop or not.
                 * @returns {cc.plugin.audio.AudioEffect}
                 */
                AudioEffect.prototype.loop = function (enable) {
                    this._loop = enable;
                    return this;
                };
                /**
                 * Get whether the sound is looping.
                 * @method cc.plugin.audio.AudioEffect#isLoop
                 * @returns {boolean}
                 */
                AudioEffect.prototype.isLoop = function () {
                    return this._loop;
                };
                /**
                 * Get the audio volume
                 * @method cc.plugin.audio.AudioEffect#getVolume
                 * @returns {number}
                 */
                AudioEffect.prototype.getVolume = function () {
                    return this._gain.gain.value;
                };
                /**
                 * Set the audio volume.
                 * @method cc.plugin.audio.AudioEffect#setVolume
                 * @param v {number} a number ranging from 0 (no sound) to 1 (full sound)
                 */
                AudioEffect.prototype.setVolume = function (v) {
                    this._volume = v;
                    if (!this._muted) {
                        this._gain.gain.value = v;
                    }
                };
                /**
                 * Set this audio as sprite.
                 * Sprites must not be changed while playing. Should be set before.
                 * The default sprite will be from starting of sound to its length;
                 * If setSprite is called with enable=false, it will set the audio as non sprite, but the information of
                 * sprite's start and duration can still be set. If not specified, these values will be kept 'as is'.
                 * @method cc.plugin.audio.AudioEffect#setSprite
                 * @param enable {boolean} enable this audio as sprite.
                 * @param start {number} time offset to play the sound
                 * @param duration {number} the audio will play from start to start+duration
                 */
                AudioEffect.prototype.setSprite = function (enable, start, duration) {
                    this._isSprite = enable;
                    if (typeof start !== "undefined") {
                        this._spriteStartTime = start;
                        this._duration = duration;
                    }
                    if (this._source) {
                        this.__setSpriteData();
                    }
                    return this;
                };
                /**
                 * Configure internal audio sprite data.
                 * @method cc.plugin.audio.AudioEffect#__setSpriteData
                 * @private
                 */
                AudioEffect.prototype.__setSpriteData = function () {
                    if (this._isSprite) {
                        if (this._isWebAudio) {
                            this._source.loopStart = this._spriteStartTime;
                            this._source.loopEnd = Math.min(this._duration, this._spriteStartTime + this._duration);
                        }
                    }
                    else {
                        if (this._isWebAudio) {
                            this._duration = this._bufferDuration;
                            this._source.loopStart = 0;
                            this._source.loopEnd = this._duration;
                        }
                    }
                };
                AudioEffect.prototype.setPlaybackRate = function (rate) {
                    this._playbackRate = rate;
                    if (this._source) {
                        var wasPlaying = this.isPlaying();
                        if (wasPlaying) {
                            this.pause();
                        }
                        this._source.playbackRate.value = rate;
                        if (wasPlaying) {
                            this.resume();
                        }
                    }
                };
                /**
                 * Get audio duration. If the audio loops, getDuration will be Number.MAX_VALUE, and the buffer or sprite duration
                 * otherwise plus the delay otherwise.
                 * @method cc.plugin.audio.AudioEffect#getDuration
                 * @returns {number}
                 */
                AudioEffect.prototype.getDuration = function () {
                    return this._loop ? Number.MAX_VALUE : this._delayTime + this._duration;
                };
                /**
                 * Create the audio source and some internal piping.
                 * @method cc.plugin.audio.AudioEffect#__createSource
                 * @private
                 */
                AudioEffect.prototype.__createSource = function () {
                    this._source = audioContext.createBufferSource();
                    this._source.buffer = this._buffer;
                    this.__connectNodes();
                    this.loop(this._loop);
                    this.__setSpriteData();
                    this._delayTime = 0;
                    this._startPlaybackTime = 0;
                    if (!this._muted) {
                        this._gain.gain.value = this._volume;
                    }
                    this._status = 0 /* NONE */;
                };
                /**
                 * Do the internal volume, source, filter, convolver wiring.
                 * @method cc.plugin.audio.AudioEffect#__connectNodes
                 * @private
                 */
                AudioEffect.prototype.__connectNodes = function () {
                    var chain = [];
                    chain.push(this._source);
                    if (this._filterEnabled) {
                        chain.push(this._filter);
                    }
                    if (this._convolverEnabled) {
                        chain.push(this._convolver);
                    }
                    chain.push(this._gain);
                    for (var i = 0; i < chain.length - 1; i++) {
                        chain[i].connect(chain[i + 1]);
                    }
                };
                /**
                 * Set a filter for the effect.
                 * @method cc.plugin.audio.AudioEffect#setFilter
                 * @param f {cc.plugin.audio.AudioFilterInitializer} filter info.
                 */
                AudioEffect.prototype.setFilter = function (f) {
                    var wasFilterEnabled = this._filterEnabled;
                    this._filterEnabled = f !== null;
                    if (f) {
                        var type = f.type.toLowerCase();
                        this._filter.type = type;
                        for (var pr in f) {
                            if (pr !== "type" && f.hasOwnProperty(pr)) {
                                this._filter[pr].value = f[pr];
                            }
                        }
                    }
                    if (this._status === 1 /* PLAY */) {
                        // only if there's no filter now or was not before, do the audio filter wiring.
                        if (!wasFilterEnabled || !this._filterEnabled) {
                            this.__pausePlay();
                        }
                    }
                };
                /**
                 * Internal method to pause and play the audio. Between pause and play, will do some wiring of the internal nodes.
                 * @method cc.plugin.audio.AudioEffect#__pausePlay
                 * @private
                 */
                AudioEffect.prototype.__pausePlay = function () {
                    var ct = this.getCurrentTime();
                    this.stop();
                    this.setCurrentTime(ct);
                    this.__connectNodes();
                    this.play();
                };
                /**
                 * Play the audio. Alternatively, the play can be deferred by passing a delay parameter.
                 * @method cc.plugin.audio.AudioEffect#play
                 * @param delay {number} milliseconds to defer audio play.
                 * @returns {cc.plugin.audio.AudioEffect}
                 */
                AudioEffect.prototype.play = function (delay) {
                    delay = delay || 0;
                    var startTime = 0;
                    var waspaused = false;
                    if (this._status === 1 /* PLAY */) {
                        this.stop();
                    }
                    else if (this._status === 2 /* PAUSE */) {
                        startTime = this._pauseTime;
                        waspaused = true;
                    }
                    this.__createSource();
                    this._status = 1 /* PLAY */;
                    this._startPlaybackTime = audioContext.currentTime;
                    this._delayTime = delay;
                    this._source.playbackRate.value = this._playbackRate;
                    if (this._isSprite) {
                        if (this._isWebAudio) {
                            if (typeof this._source.start === 'undefined') {
                                this._source.noteGrainOn(delay, this._spriteStartTime + startTime, this.getRemainingTime());
                            }
                            else {
                                this._source.start(delay, this._spriteStartTime + startTime, this.getRemainingTime());
                            }
                        }
                    }
                    else {
                        if (this._isWebAudio) {
                            this._source.start(delay, startTime);
                        }
                    }
                    //if ( !this._loop ) {
                    this.__cancelEndTimer();
                    this.__startEndTimer();
                    //}
                    if (waspaused) {
                        if (this._onResume) {
                            this._onResume(this);
                        }
                    }
                    else {
                        if (this._onStart) {
                            this._onStart(this);
                        }
                    }
                    return this;
                };
                /**
                 * Is the audio playing ?
                 * @method cc.plugin.audio.AudioEffect#isPlaying
                 * @returns {boolean}
                 */
                AudioEffect.prototype.isPlaying = function () {
                    return this._status === 1 /* PLAY */;
                };
                /**
                 * Convolve the audio.
                 * @method cc.plugin.audio.AudioEffect#convolve
                 * @param _buffer {string|object} if string, it will look up an AudioObject in the AssetManager as convolution
                 *    parameter. If not, a convolution audio buffer is expected.
                 */
                AudioEffect.prototype.convolve = function (_buffer) {
                    var buffer = null;
                    if (typeof _buffer !== "undefined") {
                        if (typeof _buffer === 'string') {
                            buffer = cc.plugin.asset.AssetManager.getAudioBuffer(_buffer);
                        }
                    }
                    if (null === buffer) {
                        this._convolver.buffer = null;
                        this._convolverEnabled = false;
                    }
                    else {
                        this._convolverEnabled = true;
                        this._convolver.buffer = buffer;
                    }
                    if (this.isPlaying()) {
                        this.__pausePlay();
                    }
                };
                /**
                 * Get current audio time. If playing or paused, will give the actual audio time and zero otherwise.
                 * @method cc.plugin.audio.AudioEffect#getCurrentTime
                 */
                AudioEffect.prototype.getCurrentTime = function () {
                    return this._status === 1 /* PLAY */ || this._status === 2 /* PAUSE */ ? ((audioContext.currentTime - this._startPlaybackTime + this._spriteStartTime) % this._duration) - this._delayTime + this._pauseTime : 0;
                };
                /**
                 * Set current audio time. The time will be modulo the duration.
                 * @method cc.plugin.audio.AudioEffect#setCurrentTime
                 * @param time {number} expected audio seek position.
                 */
                AudioEffect.prototype.setCurrentTime = function (time) {
                    var wasPlaying = this._status === 1 /* PLAY */;
                    this.stop();
                    this._pauseTime = time % this._duration + this._spriteStartTime;
                    // hack to restart from pause position.
                    this._status = 2 /* PAUSE */;
                    if (wasPlaying) {
                        this.play();
                    }
                };
                /**
                 * If the audio is playing or paused get remaining play time, zero otherwise.
                 * @method cc.plugin.audio.AudioEffect#getRemainingTime
                 */
                AudioEffect.prototype.getRemainingTime = function () {
                    // sometimes, an few milliseconds negative time could happen when you mess around a lot with pause/resume
                    return this._status === 1 /* PLAY */ || this._status === 2 /* PAUSE */ ? Math.max(0, this._duration - this.getCurrentTime()) : 0;
                };
                /**
                 * Internal method that cancels the end play timer.
                 * @method cc.plugin.audio.AudioEffect#__cancelEndTimer
                 */
                AudioEffect.prototype.__cancelEndTimer = function () {
                    if (this._endTimerId) {
                        clearTimeout(this._endTimerId);
                        this._endTimerId = null;
                    }
                };
                /**
                 * Internal method that starts the end play timer.
                 * @method cc.plugin.audio.AudioEffect#__startEndTimer
                 */
                AudioEffect.prototype.__startEndTimer = function () {
                    if (this._endTimerId) {
                        return;
                    }
                    var timeleft = this.getRemainingTime() / this._playbackRate;
                    var me = this;
                    this._endTimerId = setTimeout(function () {
                        me._endTimerId = null;
                        me._pauseTime = 0;
                        me._status = 4 /* END */;
                        if (me._loop) {
                            if (me._onRepeat) {
                                me._onRepeat(me);
                            }
                            me.play(0);
                        }
                        else {
                            if (me._onEnd) {
                                me._onEnd(me);
                            }
                        }
                    }, timeleft * 1000);
                };
                /**
                 * Internal method that performs the common stop audio part.
                 * @method cc.plugin.audio.AudioEffect#__pause_stop_common
                 */
                AudioEffect.prototype.__pause_stop_common = function () {
                    if (typeof this._source.stop === 'undefined') {
                        this._source.noteOff(0);
                    }
                    else {
                        this._source.stop(0);
                    }
                    this.__cancelEndTimer();
                };
                /**
                 * Stop the audio
                 * @method cc.plugin.audio.AudioEffect#stop
                 */
                AudioEffect.prototype.stop = function () {
                    if (this._source) {
                        this.__pause_stop_common();
                    }
                    this._pauseTime = 0;
                    this._status = 3 /* STOP */;
                    if (this._onStop) {
                        this._onStop(this);
                    }
                    return this;
                };
                /**
                 * Pause the audio
                 * @method cc.plugin.audio.AudioEffect#pause
                 */
                AudioEffect.prototype.pause = function () {
                    if (this._status !== 1 /* PLAY */) {
                        return;
                    }
                    var pt = this.getCurrentTime();
                    this.__pause_stop_common();
                    var ct = audioContext.currentTime;
                    this._pauseTime = pt;
                    //console.log("pause at "+this._pauseTime);
                    this._startPlaybackTime = ct;
                    this._status = 2 /* PAUSE */;
                    if (this._onPause) {
                        this._onPause(this);
                    }
                    return this;
                };
                /**
                 * Resume the audio
                 * @method cc.plugin.audio.AudioEffect#resume
                 */
                AudioEffect.prototype.resume = function () {
                    if (this._status !== 2 /* PAUSE */) {
                        return;
                    }
                    return this.play();
                };
                /**
                 * Set audio on end callback
                 * @method cc.plugin.audio.AudioEffect#onEnd
                 * @param c {cc.plugin.audio.AudioCallback}
                 */
                AudioEffect.prototype.onEnd = function (c) {
                    this._onEnd = c;
                    return this;
                };
                /**
                 * Set audio on repeat callback.
                 * Effects repeat when looping.
                 * @method cc.plugin.audio.AudioEffect#onRepeat
                 * @param c {cc.plugin.audio.AudioCallback}
                 */
                AudioEffect.prototype.onRepeat = function (c) {
                    this._onRepeat = c;
                    return this;
                };
                /**
                 * Set audio on pause callback
                 * @method cc.plugin.audio.AudioEffect#onPause
                 * @param c {cc.plugin.audio.AudioCallback}
                 */
                AudioEffect.prototype.onPause = function (c) {
                    this._onPause = c;
                    return this;
                };
                /**
                 * Set audio on resume callback
                 * @method cc.plugin.audio.AudioEffect#onResume
                 * @param c {cc.plugin.audio.AudioCallback}
                 */
                AudioEffect.prototype.onResume = function (c) {
                    this._onResume = c;
                    return this;
                };
                /**
                 * Set audio on stop callback
                 * @method cc.plugin.audio.AudioEffect#onStop
                 * @param c {cc.plugin.audio.AudioCallback}
                 */
                AudioEffect.prototype.onStop = function (c) {
                    this._onStop = c;
                    return this;
                };
                /**
                 * Set audio on start callback
                 * @method cc.plugin.audio.AudioEffect#onStart
                 * @param c {cc.plugin.audio.AudioCallback}
                 */
                AudioEffect.prototype.onStart = function (c) {
                    this._onStart = c;
                    return this;
                };
                /**
                 * Mute the audio.
                 * @method cc.plugin.audio.AudioEffect#mute
                 */
                AudioEffect.prototype.mute = function () {
                    if (this._isWebAudio) {
                        this._gain.gain.value = 0;
                    }
                    this._muted = true;
                    return this;
                };
                /**
                 * Unmute the audio.
                 * @method cc.plugin.audio.AudioEffect#unmute
                 */
                AudioEffect.prototype.unmute = function () {
                    if (this._isWebAudio) {
                        this._gain.gain.value = this._volume;
                    }
                    this._muted = false;
                    return this;
                };
                return AudioEffect;
            })();
            _audio.AudioEffect = AudioEffect;
            var SimpleAudioEffect = (function () {
                function SimpleAudioEffect() {
                    this._audio = null;
                    this._loaded = false;
                    this._status = 0 /* NONE */;
                    this._url = null;
                    this._pauseTime = 0;
                    this._volume = 1;
                    this._masterVolume = 1;
                    this._audio = document.createElement('audio');
                    this._audio.preload = "auto";
                    this._audio.autoplay = false;
                }
                SimpleAudioEffect.prototype.setUrl = function (url, autoplay) {
                    if (url === this._url) {
                        return;
                    }
                    var me = this;
                    this._url = url;
                    this._loaded = false;
                    this._audio.addEventListener("canplaythrough", function (e) {
                        e.srcElement.removeEventListener("canplaythrough", this);
                        me._loaded = true;
                        me._status = 5 /* LOADED */;
                        if (autoplay) {
                            me.play();
                        }
                    }, false);
                    this._audio.src = url;
                };
                SimpleAudioEffect.prototype.setMasterVolume = function (v) {
                    this._masterVolume = v;
                };
                SimpleAudioEffect.prototype.setVolume = function (v) {
                    this._volume = v;
                    this._audio.volume = v * this._masterVolume;
                };
                SimpleAudioEffect.prototype.loop = function (v) {
                    this._loop = true;
                    this.play();
                };
                SimpleAudioEffect.prototype.play = function () {
                    if (this._status !== 0 /* NONE */) {
                        this._status = 1 /* PLAY */;
                        this._audio.currentTime = 0;
                        this._audio.loop = this._loop;
                        this._audio.play();
                    }
                };
                SimpleAudioEffect.prototype.pause = function () {
                    if (this._status !== 0 /* NONE */) {
                        this._status = 2 /* PAUSE */;
                        this._pauseTime = this._audio.currentTime;
                        this._audio.pause();
                    }
                };
                SimpleAudioEffect.prototype.resume = function () {
                    if (this._status !== 0 /* NONE */) {
                        this._status = 1 /* PLAY */;
                        this._audio.currentTime = this._pauseTime;
                        this._audio.play();
                        this._pauseTime = 0;
                    }
                };
                SimpleAudioEffect.prototype.stop = function () {
                    this._status = 3 /* STOP */;
                    this._pauseTime = 0;
                    this._audio.pause();
                };
                return SimpleAudioEffect;
            })();
            _audio.SimpleAudioEffect = SimpleAudioEffect;
            /**
             * @class cc.plugin.audio.AudioManager
             * @classdesc
             *
             * This object represents a sound manager.
             * The sound manager does several things:
             *
             * <li>keep an internal AudioEffect object pool. These elements are AudioBuffer decoded objects or Audio tags,
             *     depending on the AudioManager implementation.
             * <li>Has 3 gain nodes: music, effects, and a general one connected to the two previous ones.
             * <li>Plays background music using an Audio tag. You definitely don't want to have a 10 minutes song decoded
             *     into memory.
             *
             * There's only one music node and up to MAX_AUDIO_EFFECTS (16) for a total of 17 concurrent sounds.
             * The AudioManager objects manages lifecycle of the sounds. That means that an effect can be requested for play,
             * but not stop pause or resume. For such fine control, call <code>createAudio</code> method to get an
             * <code>AudioEffect</code> object which has much more advanced capabilities.
             */
            var AudioManager = (function () {
                function AudioManager(ami) {
                    var _this = this;
                    this._context = null;
                    /**
                     * Master volume.
                     * @type {number}
                     * @private
                     */
                    this._volume = 1;
                    this._masterGain = null;
                    this._soundPool = [];
                    this._playingPool = [];
                    this._music = null;
                    if (audioContext) {
                        this._masterGain = audioContext.createGain();
                        this._masterGain.connect(audioContext.destination);
                    }
                    this._music = new SimpleAudioEffect();
                    ami = ami || {};
                    ami.numChannels = ami.numChannels || 16;
                    for (var i = 0; i < ami.numChannels; i++) {
                        var ae = new AudioEffect(this._masterGain);
                        this._soundPool.push(ae);
                        ae.onEnd(function (ae) {
                            _this.__recycle(ae);
                        });
                        ae.onStop(function (ae) {
                            _this.__recycle(ae);
                        });
                    }
                }
                AudioManager.prototype.__recycle = function (ae) {
                    var index = this._playingPool.indexOf(ae);
                    if (-1 !== index) {
                        this._playingPool.splice(index, 1);
                        this._soundPool.push(ae);
                    }
                    else {
                        console.log("recycle sound for not found element.");
                    }
                };
                AudioManager.prototype.createAudio = function (id) {
                    return new AudioEffect(this._masterGain, cc.plugin.asset.AssetManager.getAudioBuffer(id));
                };
                AudioManager.prototype.setVolume = function (v) {
                    this._volume = v;
                    this._masterGain.gain.value = v;
                    this._music.setMasterVolume(v);
                };
                AudioManager.prototype.setMusicVolume = function (v) {
                    this._music.setVolume(v);
                };
                /**
                 * Play a loaded AudioBuffer.
                 * This method plays a fully system-controlled sound. There's no user-side control.
                 * To have a client side controlled audio effect object, call <code>createAudio</code>.
                 * @param id {string|AudioBuffer} a string id in the asset manager.
                 * @param volume {number=} the volume for this effect. if not set, full volume will be used.
                 */
                AudioManager.prototype.playEffect = function (id, volume) {
                    if (this._soundPool.length === 0) {
                        cc.Debug.warn(cc.locale.ERR_SOUND_POOL_EMPTY);
                    }
                    var ab = null;
                    if (typeof id === 'string') {
                        ab = cc.plugin.asset.AssetManager.getAudioBuffer(id);
                    }
                    else {
                        ab = id;
                    }
                    if (null !== ab) {
                        var ae = this._soundPool.pop();
                        ae.setVolume(volume || 1);
                        ae.setBuffer(ab);
                        ae.play();
                        this._playingPool.push(ae);
                    }
                };
                AudioManager.prototype.pauseEffects = function () {
                    for (var i = 0; i < this._playingPool.length; i++) {
                        this._playingPool[i].pause();
                    }
                };
                AudioManager.prototype.resumeEffects = function () {
                    for (var i = 0; i < this._playingPool.length; i++) {
                        this._playingPool[i].resume();
                    }
                };
                AudioManager.prototype.stopEffects = function () {
                    for (var i = 0; i < this._playingPool.length; i++) {
                        this._playingPool[i].stop();
                    }
                };
                AudioManager.prototype.setMusic = function (url, autoplay) {
                    this._music.loop(true);
                    this._music.setUrl(url, autoplay);
                };
                AudioManager.prototype.playMusic = function () {
                    this._music.loop(true);
                    this._music.play();
                };
                AudioManager.prototype.pauseMusic = function () {
                    this._music.pause();
                };
                AudioManager.prototype.resumeMusic = function () {
                    this._music.resume();
                };
                AudioManager.prototype.stopMusic = function () {
                    this._music.stop();
                };
                //
                //  enableiOSAudio() {
                //    var me = this;
                //
                //    if (audioContext && (me._iOSEnabled || !/iPhone|iPad|iPod/i.test(navigator.userAgent))) {
                //      return;
                //    }
                //
                //    me._iOSEnabled = false;
                //
                //    // call this method on touch start to create and play a buffer,
                //    // then check if the audio actually played to determine if
                //    // audio has now been unlocked on iOS
                //    var unlock = function() {
                //      // create an empty buffer
                //      var buffer = ctx.createBuffer(1, 1, 22050);
                //      var source = ctx.createBufferSource();
                //      source.buffer = buffer;
                //      source.connect(ctx.destination);
                //
                //      // play the empty buffer
                //      if (typeof source.start === 'undefined') {
                //        source.noteOn(0);
                //      } else {
                //        source.start(0);
                //      }
                //
                //      // setup a timeout to check that we are unlocked on the next event loop
                //      setTimeout(function() {
                //        if ((source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE)) {
                //          // update the unlocked state and prevent this check from happening again
                //          me._iOSEnabled = true;
                //          me.iOSAutoEnable = false;
                //
                //          // remove the touch start listener
                //          window.removeEventListener('touchstart', unlock, false);
                //        }
                //      }, 0);
                //    };
                //
                //    // setup a touch start listener to attempt an unlock in
                //    window.addEventListener('touchstart', unlock, false);
                //
                //    return me;
                //  }
                //}
                AudioManager.canPlay = function (codec) {
                    return codecs[codec];
                };
                AudioManager.getContext = function () {
                    return audioContext;
                };
                AudioManager.isWebAudioEnabled = function () {
                    return audioContext !== null;
                };
                return AudioManager;
            })();
            _audio.AudioManager = AudioManager;
        })(audio = plugin.audio || (plugin.audio = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../../math/Rectangle.ts"/>
/// <reference path="../../math/Dimension.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var layout;
        (function (_layout) {
            /**
             * @class cc.plugin.layout.Unit
             * @classdesc
             *
             * This class encapsulates a value in a given unit.
             * Currently, it could be a number, or a percentage value.
             * If the value is a percentage, a call to <code>getValue</code> needs a reference value.
             */
            var Unit = (function () {
                /**
                 * Create a new Unit object instance.
                 * @method cc.plugin.layout.Unit#constructor
                 * @param original {string=} Unit value. if not set, the unit it set to 0.
                 */
                function Unit(original) {
                    /**
                     * Unit value.
                     * @member cc.plugin.layout.Unit#_orgValue
                     * @type {number}
                     * @private
                     */
                    this._orgValue = 0;
                    /**
                     * Unit type. Either px, %, or nothing.
                     * @member cc.plugin.layout.Unit#_orgType
                     * @type {string}
                     * @private
                     */
                    this._orgType = "";
                    if (typeof original !== 'undefined') {
                        this.setValue(original);
                    }
                }
                /**
                 * Set the unit value. For example '2%', '100px', '100'
                 * @method cc.plugin.layout.Unit#setValue
                 * @param original {string}
                 */
                Unit.prototype.setValue = function (original) {
                    var exp = new RegExp("\\d+\\.?\\d*(.*)", "gi");
                    var m = exp.exec("" + original);
                    if (m) {
                        this._orgType = m[1];
                        this._orgValue = parseInt(m[0]);
                    }
                };
                /**
                 * Get the unit value.
                 * If the unit type is percentage, and no reference value is supplied, zero will be returned as value.
                 * @method cc.plugin.layout.Unit#getValue
                 * @param ref {number=} percentage reference value.
                 * @returns {number}
                 */
                Unit.prototype.getValue = function (ref) {
                    switch (this._orgType) {
                        case "":
                            return this._orgValue;
                        case "px":
                            return this._orgValue;
                        case "%":
                            return typeof ref !== "undefined" ? this._orgValue / 100 * ref : 0;
                    }
                };
                return Unit;
            })();
            _layout.Unit = Unit;
            /**
             * @class cc.plugin.layout.Insets
             * @classdesc
             *
             * This class describes a layout element internal padding.
             * It is descibed as independent inset values for top, bottom, left and right.
             * These values are Unit objects, so can be described as percentage values. The relative values are relative to
             * the Layout element assigned dimension, so its calculation is deferred to the proper layout stage.
             */
            var Insets = (function () {
                function Insets() {
                    /**
                     * Layout element left inset Unit.
                     * @member cc.plugin.layout.Insets#left
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.left = new Unit();
                    /**
                     * Layout element top inset Unit.
                     * @member cc.plugin.layout.Insets#top
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.top = new Unit();
                    /**
                     * Layout element right inset Unit.
                     * @member cc.plugin.layout.Insets#right
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.right = new Unit();
                    /**
                     * Layout element bottom inset Unit.
                     * @member cc.plugin.layout.Insets#bottom
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.bottom = new Unit();
                }
                return Insets;
            })();
            _layout.Insets = Insets;
            /**
             * @class cc.plugin.layout.Gap
             * @classdesc
             *
             * This object describes the separation values between two adjacent layout elements.
             * For example, for a grid, describes the Units to separate the grid elements.
             */
            var Gap = (function () {
                function Gap() {
                    /**
                     * Horizontal gap Unit.
                     * @member cc.plugin.layout.Gap#horizontal
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.horizontal = new Unit();
                    /**
                     * Vertical gap Unit.
                     * @member cc.plugin.layout.Gap#vertical
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.vertical = new Unit();
                }
                return Gap;
            })();
            _layout.Gap = Gap;
            /**
             * @class cc.plugin.layout.Layout
             * @classdesc
             *
             * This object is the base for all other layout objects.
             * The layout will assign bounds (position and size) for all the layout elements it contains.
             * Layouts will apply different space partitioning rules to conform elements to available space.
             * Layout elements can be nested. for example, a grid cell can contain another grid of elements.
             * <p>
             * Each layout element will have its bounds modified by an <code>Insets</code> object which will reduce the
             * available element bounds.
             * Some layout types, like <code>GridLayout</code> or <code>BorderLayout</code> will be able to apply a gap
             * to separate the contained elements.
             * <p>
             * A layout element can define a preferred size (either in units or percentage) to layout with. This value is
             * needed for layout types that don't impose a size constraint. For example, a GridLayout will set each element's
             * bounds with a fixed rule, that is, dividing the space evenly. But others, like a BorderLayout won't, so you
             * must hint how much space each element is expected to take.
             * <p>
             *     Layouts are defined declaratively and a Node or any other object, does not need to know anything about
             *     the layout itself.
             * <p>
             * The BaseLayout object assumes no children when laying out. Other extending objects will modify this behavior.
             */
            var BaseLayout = (function () {
                /**
                 * Create a new BaseLayout object instance.
                 * Do not create directly, only by subclasses.
                 * @method cc.plugin.layout.BaseLayout#constructor
                 */
                function BaseLayout() {
                    /**
                     * Resulting bounds after applying the layout rules.
                     * @member cc.plugin.layout.BaseLayout#_bounds
                     * @type {cc.math.Rectangle}
                     * @private
                     */
                    this._bounds = null;
                    /**
                     * The layout insets. Insets will reduce the bounds area by setting a padding for the element.
                     * @member cc.plugin.layout.BaseLayout#_insets
                     * @type {cc.plugin.layout.Insets}
                     * @private
                     */
                    this._insets = null;
                    /**
                     * Separation between each layout elements. Not all layout will use this value.
                     * @member cc.plugin.layout.BaseLayout#_gap
                     * @type {cc.plugin.layout.Gap}
                     * @private
                     */
                    this._gap = null;
                    /**
                     * Array of elements to lay out. Since layouts are nestable, children are layout instances as well.
                     * @member cc.plugin.layout.BaseLayout#_children
                     * @type {Array<cc.plugin.layout.BaseLayout>}
                     * @private
                     */
                    this._children = [];
                    /**
                     * Layout preferred width Unit hint.
                     * @member cc.plugin.layout.BaseLayout#_preferredWidth
                     * @type {cc.plugin.layout.Unit}
                     * @private
                     */
                    this._preferredWidth = null;
                    /**
                     * Layout preferred height Unit hint.
                     * @member cc.plugin.layout.BaseLayout#_preferredHeight
                     * @type {cc.plugin.layout.Unit}
                     * @private
                     */
                    this._preferredHeight = null;
                    /**
                     * Optional layout identifier.
                     * This is useful so that a node tag or name can be matched against this layout element.
                     * @member cc.plugin.layout.BaseLayout#_name
                     * @type {string}
                     * @private
                     */
                    this._name = '';
                    this._parent = null;
                    this._bounds = new cc.math.Rectangle();
                    this._insets = new Insets();
                    this._gap = new Gap();
                    this._preferredWidth = new Unit();
                    this._preferredHeight = new Unit();
                }
                /**
                 * Parse a layout initializer object to get a layout element object.
                 * @param layout {string|cc.plugin.layout.BaseLayoutInitializer} a layout initializer object, or a string.
                 *   If a string is set, a BaseLayout object will be used.
                 */
                BaseLayout.parse = function (layout) {
                    if (typeof layout === "string") {
                        return new BaseLayout().parse({
                            type: 'element',
                            name: layout
                        });
                    }
                    else if (layout.type === "element") {
                        return new BaseLayout().parse(layout);
                    }
                    else if (layout.type === "border") {
                        return new BorderLayout().parse(layout);
                    }
                    else if (layout.type === "layer") {
                        return new LayerLayout().parse(layout);
                    }
                    else if (layout.type === "grid") {
                        return new GridLayout().parse(layout);
                    }
                    else {
                        console.log("unknown layout type: " + layout.type);
                    }
                };
                /**
                 * Helper method to visually see the layout result.
                 * @method cc.plugin.layout.BaseLayout#paint
                 * @param ctx {CanvasRenderingContext2D}
                 */
                BaseLayout.prototype.paint = function (ctx) {
                    //ctx.setTransform(1,0,0,1,0,0);
                    ctx.strokeRect(this._bounds.x, this._bounds.y, this._bounds.w, this._bounds.h);
                    for (var i = 0; i < this._children.length; i++) {
                        this._children[i].paint(ctx);
                    }
                };
                /**
                 * Set the layout bounds.
                 * @method cc.plugin.layout.BaseLayout#setBounds
                 * @param x {number}
                 * @param y {number}
                 * @param w {number}
                 * @param h {number}
                 */
                BaseLayout.prototype.setBounds = function (x, y, w, h) {
                    this._bounds.set(x, y, w, h);
                };
                /**
                 * Set the layout size.
                 * @method cc.plugin.layout.BaseLayout#setSize
                 * @param w {number}
                 * @param h {number}
                 */
                BaseLayout.prototype.setSize = function (w, h) {
                    this._bounds.w = w;
                    this._bounds.h = h;
                };
                /**
                 * Set the layout preferred size Unit hints.
                 * @param w {number|string}
                 * @param h {number|string}
                 */
                BaseLayout.prototype.setPreferredSize = function (w, h) {
                    this._preferredWidth.setValue(w);
                    this._preferredHeight.setValue(h);
                };
                /**
                 * Get the element preferredSize.
                 * The size units are evaluated, so if they are percentage, the value is recalculated now again.
                 * @method cc.plugin.layout.BaseLayout#getPreferredSize
                 * @returns {cc.math.Dimension}
                 */
                BaseLayout.prototype.getPreferredSize = function () {
                    return new cc.math.Dimension(this._preferredWidth.getValue(this._parent ? this._parent._bounds.w : this._bounds.w), this._preferredHeight.getValue(this._parent ? this._parent._bounds.h : this._bounds.h));
                };
                /**
                 * Recursively evaluate the layout elements and get the resulting preferred size.
                 * This does not take into account the size constraints, will get the desired size.
                 * In this object, the implementation returns the result of the preferredSize Unit hints + Insets.
                 * @method cc.plugin.layout.BaseLayout#getPreferredLayoutSize
                 * @returns {cc.math.Dimension}
                 */
                BaseLayout.prototype.getPreferredLayoutSize = function () {
                    var ps = this.getPreferredSize();
                    this.adjustWithInsets(ps);
                    return ps;
                };
                /**
                 * Evaluate the layout with the current size constraints. The root layout element bounds will be used
                 * as size constraint.
                 * @method cc.plugin.layout.BaseLayout#doLayout
                 */
                BaseLayout.prototype.doLayout = function () {
                    var d = new cc.math.Dimension();
                    this.adjustWithInsets(d);
                    this._bounds.w -= d.width;
                    this._bounds.h -= d.height;
                    this._bounds.x += d.width / 2;
                    this._bounds.y += d.height / 2;
                };
                /**
                 * Set size constraints and evaluate the layout.
                 * The result will be all layout elements have assigned a bounds.
                 * @method cc.plugin.layout.BaseLayout#layout
                 * @param x {number}
                 * @param y {number}
                 * @param w {number}
                 * @param h {number}
                 */
                BaseLayout.prototype.layout = function (x, y, w, h) {
                    this.setBounds(x, y, w, h);
                    this.getPreferredLayoutSize();
                    this.doLayout();
                };
                /**
                 * Parse a layout definition object.
                 * This will get all the common layout properties: insets, gap, preferred size and elements.
                 * @method cc.plugin.layout.BaseLayout#parse
                 * @param layoutInfo {cc.plugin.layout.BaseLayoutInitializer}
                 * @returns {cc.plugin.layout.BaseLayout}
                 */
                BaseLayout.prototype.parse = function (layoutInfo) {
                    if (typeof layoutInfo.insets !== 'undefined') {
                        var arr = layoutInfo.insets;
                        if (arr.length !== 4) {
                            console.log("wrong defined insets: " + arr);
                        }
                        this._insets.left.setValue(layoutInfo.insets[0]);
                        this._insets.right.setValue(layoutInfo.insets[2]);
                        this._insets.top.setValue(layoutInfo.insets[1]);
                        this._insets.bottom.setValue(layoutInfo.insets[3]);
                    }
                    if (typeof layoutInfo.gap !== 'undefined') {
                        var arr = layoutInfo.gap;
                        if (arr.length !== 2) {
                            console.log("wrong defined gap: " + arr);
                        }
                        this._gap.horizontal.setValue(layoutInfo.gap[0]);
                        this._gap.vertical.setValue(layoutInfo.gap[1]);
                    }
                    if (typeof layoutInfo.preferredWidth !== 'undefined') {
                        this._preferredWidth.setValue(layoutInfo.preferredWidth);
                    }
                    if (typeof layoutInfo.preferredHeight !== 'undefined') {
                        this._preferredHeight.setValue(layoutInfo.preferredHeight);
                    }
                    if (typeof layoutInfo.name !== 'undefined') {
                        this._name = layoutInfo.name;
                    }
                    if (typeof layoutInfo.elements !== 'undefined') {
                        if (Object.prototype.toString.call(layoutInfo.elements) === '[object Array]') {
                            this.parseElements(layoutInfo.elements);
                        }
                        else {
                            console.log("Layout elememts block is not array.");
                        }
                    }
                    return this;
                };
                /**
                 * Parse the elements block from the layout initializer object.
                 * @method cc.plugin.layout.BaseLayout#parseElements
                 * @param children {Array<object>}
                 */
                BaseLayout.prototype.parseElements = function (children) {
                    var me = this;
                    function addElement(s, parent) {
                        var elem = cc.plugin.layout.BaseLayout.parse(s);
                        if (elem) {
                            elem._parent = parent;
                            me._children.push(elem);
                        }
                        else {
                        }
                    }
                    for (var i = 0; i < children.length; i++) {
                        if (typeof children[i] === 'string') {
                            var elem = children[i];
                            // is elem of the form text[...] ?
                            if (elem.indexOf('[') !== -1 && elem.indexOf(']') !== -1) {
                                var exp = new RegExp("(.*)\\[(.*)\\]", "gi");
                                var m = exp.exec(elem);
                                var prefix = m[1];
                                var pattern = m[2].split('-');
                                if (pattern.length === 2) {
                                    var from = parseInt(pattern[0]);
                                    var to = parseInt(pattern[1]);
                                    while (from <= to) {
                                        addElement(prefix + from, this);
                                        from++;
                                    }
                                }
                                else {
                                    /// wrong pattern ?!?!?!?!?
                                    console.log("wrong pattern for element by name: " + elem);
                                    addElement(elem, this);
                                }
                            }
                            else {
                                // not name pattern.
                                addElement(elem, this);
                            }
                        }
                        else {
                            addElement(children[i], this);
                        }
                    }
                };
                /**
                 * Add an element layout to this layout object.
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @param constraint {string=} a constraint to add an element. For example, BorderLayout requires a position hint
                 *      to add an element.
                 */
                BaseLayout.prototype.addElement = function (e, constraint) {
                    this._children.push(e);
                };
                /**
                 * Helper method to add the Inset object value to a Dimension.
                 * @method cc.plugin.layout.BaseLayout#adjustWithInsets
                 * @param d
                 */
                BaseLayout.prototype.adjustWithInsets = function (d) {
                    d.width += this._insets.left.getValue(this._bounds.w) + this._insets.right.getValue(this._bounds.w);
                    d.height += this._insets.top.getValue(this._bounds.h) + this._insets.bottom.getValue(this._bounds.h);
                };
                /**
                 * Recursively traverse the layout elements and, if a layout element has name, find a node with that name
                 * and then set the found node's position to the layout calculated position. If resize is set to true,
                 * the found node's content size will be set to the layout calculated size.
                 * The node is searched in the _node parameter or any of its children.
                 * @param _node {cc.node.Node} the node to traverse to find a node with a layout name
                 * @param resize {boolean} change de node size to that of the calculated layout ?
                 */
                BaseLayout.prototype.applyToNode = function (_node, resize) {
                    var _this = this;
                    if (!_node) {
                        return;
                    }
                    if (this._name !== "") {
                        _node.enumerateChildren(this._name, function (node) {
                            node.setPosition(_this._bounds.x, _this._bounds.y);
                            if (resize) {
                                node.setContentSize(_this._bounds.w, _this._bounds.h);
                            }
                        });
                    }
                    for (var i = 0; i < this._children.length; i++) {
                        this._children[i].applyToNode(_node, resize);
                    }
                };
                return BaseLayout;
            })();
            _layout.BaseLayout = BaseLayout;
            /**
             * @class cc.plugin.layout.BorderLayout
             * @extends cc.plugin.layout.BaseLayout
             * @classdesc
             *
             * A BorderLayout object divides the available space in up to 5 different regions as follows:
             * <pre>
             *
             *     +----------------------------+
             *     |            TOP             |
             *     +------+-------------+-------+
             *     | LEFT |             | RIGHT |
             *     |      |             |       |
             *     |      |             |       |
             *     |      |   CENTER    |       |
             *     |      |             |       |
             *     |      |             |       |
             *     |      |             |       |
             *     +------+-------------+-------+
             *     |           BOTTOM           |
             *     +----------------------------+
             * </pre>
             *
             * <p>
             *     Since all bounds are dynamically calculated, elements added to a BorderLayout (at any nesting level) must
             *     have preferred size hints.
             * <p>
             *     The gap values will be empty filler values between every elements. Horizontal between left-center center-right
             *     and vertical betweeen top and bottom and all the others.
             * <p>
             *     All Elements are optional to define.
             * <p>
             *     The center element will get the remaining space after laying out all the other elements.
             *     The left, right and center elements will get the remaining height after evaluating top and then
             *     bottom elements.
             * <p>
             *     top, left, right, bottom and center can be, at the same time, other layouts.
             *
             */
            var BorderLayout = (function (_super) {
                __extends(BorderLayout, _super);
                /**
                 * Build a new BorderLayout object instance
                 * @method cc.plugin.layout.BorderLayout#constructor
                 */
                function BorderLayout() {
                    _super.call(this);
                    /**
                     * Left layout element.
                     * @member cc.plugin.layout.BorderLayout#_left
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._left = null;
                    /**
                     * Right layout element.
                     * @member cc.plugin.layout.BorderLayout#_right
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._right = null;
                    /**
                     * Top layout element.
                     * @member cc.plugin.layout.BorderLayout#_top
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._top = null;
                    /**
                     * Bottom layout element.
                     * @member cc.plugin.layout.BorderLayout#_bottom
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._bottom = null;
                    /**
                     * Center layout element.
                     * @member cc.plugin.layout.BorderLayout#_center
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._center = null;
                }
                /**
                 * Get the preferred layout size after recursively applying the layout. The size will be the preferred size,
                 * not the actual size.
                 * @method cc.plugin.layout.BorderLayout#getPreferredLayoutSize
                 * @returns {cc.math.Dimension}
                 */
                BorderLayout.prototype.getPreferredLayoutSize = function () {
                    var ret = new cc.math.Dimension();
                    var d;
                    if (this._left) {
                        d = this._left.getPreferredLayoutSize();
                        ret.width += d.width + this._gap.horizontal.getValue(this._bounds.w);
                        ret.height = Math.max(d.height, ret.height);
                    }
                    if (this._right) {
                        d = this._right.getPreferredLayoutSize();
                        ret.width += d.width + this._gap.horizontal.getValue(this._bounds.w);
                        ret.height = Math.max(d.height, ret.height);
                    }
                    if (this._center) {
                        d = this._center.getPreferredLayoutSize();
                        ret.width += d.width;
                        ret.height = Math.max(d.height, ret.height);
                    }
                    if (this._top) {
                        d = this._top.getPreferredLayoutSize();
                        ret.height += d.height + this._gap.vertical.getValue(this._bounds.h);
                        ret.width = Math.max(ret.width, d.width);
                    }
                    if (this._bottom) {
                        d = this._bottom.getPreferredLayoutSize();
                        ret.height += d.height + this._gap.vertical.getValue(this._bounds.h);
                        ret.width = Math.max(ret.width, d.width);
                    }
                    this.adjustWithInsets(d);
                    var pd = this.getPreferredSize();
                    d.width = Math.max(d.width, pd.width);
                    d.height = Math.max(d.width, pd.height);
                    return d;
                };
                /**
                 * Set the left layout element.
                 * @method cc.plugin.layout.BorderLayout#left
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.left = function (e) {
                    this._children.push(e);
                    this._left = e;
                    this._left._parent = this;
                    return this;
                };
                /**
                 * Set the right layout element.
                 * @method cc.plugin.layout.BorderLayout#right
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.right = function (e) {
                    this._children.push(e);
                    this._right = e;
                    this._right._parent = this;
                    return this;
                };
                /**
                 * Set the top layout element.
                 * @method cc.plugin.layout.BorderLayout#top
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.top = function (e) {
                    this._children.push(e);
                    this._top = e;
                    this._top._parent = this;
                    return this;
                };
                /**
                 * Set the bottom layout element.
                 * @method cc.plugin.layout.BorderLayout#bottom
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.bottom = function (e) {
                    this._children.push(e);
                    this._bottom = e;
                    this._bottom._parent = this;
                    return this;
                };
                /**
                 * Set the center layout element.
                 * @method cc.plugin.layout.BorderLayout#center
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.center = function (e) {
                    this._children.push(e);
                    this._center = e;
                    this._center._parent = this;
                    return this;
                };
                /**
                 * Parse the BorderLayout.
                 * @method cc.plugin.layout.BorderLayout#parse
                 * @param layoutInfo {cc.plugin.layout.BorderLayoutInitializer}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.parse = function (layoutInfo) {
                    _super.prototype.parse.call(this, layoutInfo);
                    if (typeof layoutInfo.left !== "undefined") {
                        this.left(cc.plugin.layout.BaseLayout.parse(layoutInfo.left));
                    }
                    if (typeof layoutInfo.right !== "undefined") {
                        this.right(cc.plugin.layout.BaseLayout.parse(layoutInfo.right));
                    }
                    if (typeof layoutInfo.bottom !== "undefined") {
                        this.bottom(cc.plugin.layout.BaseLayout.parse(layoutInfo.bottom));
                    }
                    if (typeof layoutInfo.top !== "undefined") {
                        this.top(cc.plugin.layout.BaseLayout.parse(layoutInfo.top));
                    }
                    if (typeof layoutInfo.center !== "undefined") {
                        this.center(cc.plugin.layout.BaseLayout.parse(layoutInfo.center));
                    }
                    return this;
                };
                /**
                 * Add an element to the layout. Since this layout only allows for 5 specific elements, an adding constraint
                 * must be used.
                 * @method cc.plugin.layout.BorderLayout#addElement
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @param constraint {string} must exist. a value from 'top','bottom','left','right' or 'center'.
                 */
                BorderLayout.prototype.addElement = function (e, constraint) {
                    if (typeof this[constraint] !== 'undefined') {
                        this[constraint](e);
                    }
                    else {
                        console.log("wrong border layout constraint.");
                    }
                };
                /**
                 * Do the actual lay out process. Elements will fit into the previously set element bounds.
                 * @method cc.plugin.layout.BorderLayout#doLayout
                 */
                BorderLayout.prototype.doLayout = function () {
                    var left = this._bounds.x + this._insets.left.getValue(this._bounds.w);
                    var top = this._bounds.y + this._insets.top.getValue(this._bounds.h);
                    var right = this._bounds.x1 - this._insets.right.getValue(this._bounds.w);
                    var bottom = this._bounds.y1 - this._insets.bottom.getValue(this._bounds.h);
                    var d;
                    if (this._top) {
                        this._top.setSize(right - left, this._top._bounds.h);
                        d = this._top.getPreferredLayoutSize();
                        this._top._bounds.set(left, top, right - left, d.height);
                        this._top.doLayout();
                        top += d.height + this._gap.vertical.getValue(this._bounds.h);
                    }
                    if (this._bottom) {
                        this._bottom.setSize(right - left, this._bottom._bounds.h);
                        d = this._bottom.getPreferredLayoutSize();
                        d.height = Math.min(d.height, bottom - top);
                        this._bottom._bounds.set(left, bottom - d.height, right - left, d.height);
                        this._bottom.doLayout();
                        bottom -= d.height + this._gap.vertical.getValue(this._bounds.h);
                    }
                    if (this._right) {
                        this._right.setSize(this._right._bounds.w, bottom - top);
                        d = this._right.getPreferredLayoutSize();
                        this._right._bounds.set(right - d.width, top, d.width, bottom - top);
                        this._right.doLayout();
                        right -= d.width + this._gap.horizontal.getValue(this._bounds.w);
                    }
                    if (this._left) {
                        this._left.setSize(this._left._bounds.w, bottom - top);
                        d = this._left.getPreferredLayoutSize();
                        d.width = Math.min(d.width, right - left);
                        this._left._bounds.set(left, top, d.width, bottom - top);
                        this._left.doLayout();
                        left += d.width + this._gap.horizontal.getValue(this._bounds.w);
                    }
                    if (this._center) {
                        this._center._bounds.set(left, top, right - left, bottom - top);
                        this._center.doLayout();
                    }
                };
                return BorderLayout;
            })(BaseLayout);
            _layout.BorderLayout = BorderLayout;
            /**
             * @class cc.plugin.layout.GridLayout
             * @extends cc.plugin.layout.BaseLayout
             * @classdesc
             *
             * A grid layout lays elements out either in rows or columns. If rows are specified, the lay out will keep the fixed
             * number of rows and grow on the number of columns or vice versa, like as follows:
             *
             * <pre>
             *
             *     3 rows                        3 columns
             *
             *     +------------+-----...        +----------+----------+----------+
             *     |  row1      |                |   col1   |   col2   |   col3   |
             *     +------------+-----...        +----------+----------+----------+
             *     |  row2      |                |          |          |          |
             *     +------------+-----...        .          .          .          .
             *     |  row3      |                .          .          .          .
             *     +------------+-----...
             * </pre>
             *
             */
            var GridLayout = (function (_super) {
                __extends(GridLayout, _super);
                /**
                 * Create a new GridLayout object instance.
                 * @method cc.plugin.layout.GridLayout#constructor
                 */
                function GridLayout() {
                    _super.call(this);
                    /**
                     * Lay out in rows or columns.
                     * @member cc.plugin.layout.GridLayout#_layoutRows
                     * @type {boolean}
                     * @private
                     */
                    this._layoutRows = false;
                    /**
                     * Elements to layout before adding a row or column.
                     * @member cc.plugin.layout.GridLayout#_numElements
                     * @type {number}
                     * @private
                     */
                    this._numElements = 0;
                    /**
                     * Calculated number of rows for the current added elements.
                     * @member cc.plugin.layout.GridLayout#_rows
                     * @type {number}
                     * @private
                     */
                    this._rows = 0;
                    /**
                     * Calculated number of columns for the current added elements.
                     * @member cc.plugin.layout.GridLayout#_columns
                     * @type {number}
                     * @private
                     */
                    this._columns = 0;
                }
                /**
                 * Parse the grid info.
                 * @method cc.plugin.layout.GridLayout#parse
                 * @param layoutInfo {cc.plugin.layout.GridLayoutInitializer}
                 * @returns {cc.plugin.layout.GridLayout}
                 */
                GridLayout.prototype.parse = function (layoutInfo) {
                    _super.prototype.parse.call(this, layoutInfo);
                    if (typeof layoutInfo.rows !== 'undefined') {
                        this._layoutRows = true;
                        this._numElements = layoutInfo.rows;
                    }
                    if (typeof layoutInfo.columns !== 'undefined') {
                        this._layoutRows = false;
                        this._numElements = layoutInfo.columns;
                    }
                    if (!this._numElements) {
                        console.log("bug bug grid info wrong defined.");
                    }
                    return this;
                };
                /**
                 * Get the preferred layout elements size. The preferred size will be the adjusted to the biggest element's
                 * preferred size, adding the gap for each of the layout elements.
                 * Finally, the insets will be added to the size.
                 * @method cc.plugin.layout.GridLayout#getPreferredLayoutSize
                 * @returns {cc.math.Dimension}
                 */
                GridLayout.prototype.getPreferredLayoutSize = function () {
                    var rows = 0;
                    var columns = 0;
                    var ret = new cc.math.Dimension();
                    if (this._layoutRows) {
                        rows = this._numElements;
                        columns = ((rows + this._children.length - 1) / rows) >> 0;
                    }
                    else {
                        columns = this._numElements;
                        rows = ((columns + this._children.length - 1) / columns) >> 0;
                    }
                    for (var i = 0; i < this._children.length; i++) {
                        var d = this._children[i].getPreferredLayoutSize();
                        if (d.width > ret.width) {
                            ret.width = d.width;
                        }
                        if (d.height > ret.height) {
                            ret.height = d.height;
                        }
                    }
                    this.adjustWithInsets(d);
                    d.width += columns * ret.width + (columns - 1) * this._gap.horizontal.getValue(this._bounds.w);
                    d.height += rows * ret.height + (rows - 1) * this._gap.vertical.getValue(this._bounds.h);
                    var pd = this.getPreferredSize();
                    d.width = Math.max(d.width, pd.width);
                    d.height = Math.max(d.height, pd.height);
                    this._rows = rows;
                    this._columns = columns;
                    return d;
                };
                /**
                 * Do the actual elements lay out. The size of each element will be constrained to the element's bound.
                 * @method cc.plugin.layout.GridLayout#doLayout
                 */
                GridLayout.prototype.doLayout = function () {
                    if (!this._children.length) {
                        return;
                    }
                    var rows, columns;
                    if (this._layoutRows) {
                        rows = this._numElements;
                        columns = ((rows + this._children.length - 1) / rows) >> 0;
                    }
                    else {
                        columns = this._numElements;
                        rows = ((columns + this._children.length - 1) / columns) >> 0;
                    }
                    this._rows = rows;
                    this._columns = columns;
                    var nrows = this._rows;
                    var ncols = this._columns;
                    var totalGapsWidth = (ncols - 1) * this._gap.horizontal.getValue(this._bounds.w);
                    var widthWOInsets = this._bounds.w - (this._insets.left.getValue(this._bounds.w) + this._insets.right.getValue(this._bounds.w));
                    var widthOnComponent = ((widthWOInsets - totalGapsWidth) / ncols); // floor
                    var extraWidthAvailable = ((widthWOInsets - (widthOnComponent * ncols + totalGapsWidth)) / 2); // floor
                    var totalGapsHeight = (nrows - 1) * this._gap.vertical.getValue(this._bounds.h);
                    var heightWOInsets = this._bounds.h - (this._insets.top.getValue(this._bounds.h) + this._insets.bottom.getValue(this._bounds.h));
                    var heightOnComponent = ((heightWOInsets - totalGapsHeight) / nrows); // floor
                    var extraHeightAvailable = ((heightWOInsets - (heightOnComponent * nrows + totalGapsHeight)) / 2); // floor
                    for (var c = 0, x = this._insets.left.getValue(this._bounds.w) + extraWidthAvailable; c < ncols; c++, x += widthOnComponent + this._gap.horizontal.getValue(this._bounds.w)) {
                        for (var r = 0, y = this._insets.top.getValue(this._bounds.h) + extraHeightAvailable; r < nrows; r++, y += heightOnComponent + this._gap.vertical.getValue(this._bounds.h)) {
                            var i = r * ncols + c;
                            if (i < this._children.length) {
                                var child = this._children[i];
                                if (null !== child) {
                                    child.setBounds(this._bounds.x + x, this._bounds.y + y, widthOnComponent, heightOnComponent);
                                    child.doLayout();
                                }
                            }
                        }
                    }
                };
                return GridLayout;
            })(BaseLayout);
            _layout.GridLayout = GridLayout;
            /**
             * @class cc.plugin.layout.LayerLayout
             * @extends cc.plugin.layout.BaseLayout
             * @classdesc
             *
             * A LayerLayout stacks elements one on top of the other making their bounds the same.
             * The layout does not work on z-index, simply makes them to take over the same area.
             *
             */
            var LayerLayout = (function (_super) {
                __extends(LayerLayout, _super);
                /**
                 * Build a new LayerLayout
                 * @method cc.plugin.layout.LayerLayout#constructor
                 */
                function LayerLayout() {
                    _super.call(this);
                }
                /**
                 * @method cc.plugin.layout.LayerLayout#getPreferredLayoutSize
                 * @returns {cc.math.Dimension}
                 */
                LayerLayout.prototype.getPreferredLayoutSize = function () {
                    var d = new cc.math.Dimension();
                    d.set(this._preferredWidth.getValue(this._bounds.w), this._preferredHeight.getValue(this._bounds.h));
                    this.adjustWithInsets(d);
                    var pd = this.getPreferredSize();
                    d.width = Math.max(d.width, pd.width);
                    d.height = Math.max(d.width, pd.height);
                    return d;
                };
                /**
                 * @method cc.plugin.layout.LayerLayout#doLayout
                 */
                LayerLayout.prototype.doLayout = function () {
                    var x = this._bounds.x + this._insets.left.getValue(this._bounds.w);
                    var y = this._bounds.y + this._insets.top.getValue(this._bounds.h);
                    var w = this._bounds.w - this._insets.left.getValue(this._bounds.w) - this._insets.right.getValue(this._bounds.w);
                    var h = this._bounds.h - this._insets.top.getValue(this._bounds.h) - this._insets.bottom.getValue(this._bounds.h);
                    for (var i = 0; i < this._children.length; i++) {
                        this._children[i].setBounds(x, y, w, h);
                        this._children[i].doLayout();
                    }
                };
                return LayerLayout;
            })(BaseLayout);
            _layout.LayerLayout = LayerLayout;
        })(layout = plugin.layout || (plugin.layout = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../util/Debug.ts"/>
/// <reference path="./KeyboardInputManager.ts"/>
/// <reference path="./MouseInputManager.ts"/>
var cc;
(function (cc) {
    var input;
    (function (input) {
        /**
         * @class cc.input.InputManagerEvent
         * @classdesc
         *
         * This is the base type for all CocosJS input events.
         */
        var InputManagerEvent = (function () {
            /**
             * Build a new InputManagerEvent object.
             * Does nothing.
             * @method cc.input.InputManagerEvent#constructor
             */
            function InputManagerEvent() {
                /**
                 * Target is the object for which the event happened.
                 * For example, for MouseInputManagerEvents, _target is the node in which the event happened.
                 * @member cc.input.InputManagerEvent#_target
                 * @type {Object}
                 * @private
                 */
                this._target = null;
                /**
                 * Input event type.
                 * Identifies the emitted event type for each addEventListener event call.
                 * @member cc.input.InputManagerEvent#_type
                 * @type {string}
                 * @private
                 */
                this._type = null;
            }
            Object.defineProperty(InputManagerEvent.prototype, "target", {
                /**
                 * Get this event's target. The target can be any type.
                 * @method cc.input.InputManagerEvent#get:target
                 * @returns {any}
                 */
                get: function () {
                    return this._target;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Get the event target.
             * @method cc.input.InputManagerEvent#getCurrentTarget
             * @returns {cc.node.Node}
             */
            InputManagerEvent.prototype.getCurrentTarget = function () {
                return this._target;
            };
            Object.defineProperty(InputManagerEvent.prototype, "type", {
                /**
                 * Get this event's type.
                 * @method cc.input.InputManagerEvent#get:type
                 * @returns {string}
                 */
                get: function () {
                    return this._type;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Must override and honor.
             * @method cc.input.InputManagerEvent#initializeEventForTarget
             * @param target {Object} a target object.
             * @param type {string} an event type.
             *
             */
            InputManagerEvent.prototype.initializeEventForTarget = function (target, type) {
                this._target = target;
                this._type = type;
            };
            return InputManagerEvent;
        })();
        input.InputManagerEvent = InputManagerEvent;
        /**
         * @class cc.input.InputManager
         * @classdesc
         *
         * General input manager object.
         *
         */
        var InputManager = (function () {
            function InputManager() {
                this._keyboardManager = null;
                this._keyboardManager = new cc.input.KeyboardInputManager();
            }
            InputManager.prototype.enable = function (element) {
                this._keyboardManager.enable();
                cc.input.MouseInputManager.enable(element);
                return this;
            };
            InputManager.prototype.disable = function () {
                this._keyboardManager.disable();
                cc.input.MouseInputManager.disable();
                return this;
            };
            InputManager.prototype.addEventListener = function (event, callback, params) {
                if (event === "keydown") {
                    this._keyboardManager.onDown(params, callback);
                }
                else if (event === "keyup") {
                    this._keyboardManager.onUp(params, callback);
                }
            };
            InputManager.prototype.registerCursor = function (kd, callback) {
                return this._keyboardManager.registerCursor(kd, callback);
            };
            InputManager.prototype.unregisterCursor = function (id) {
                this._keyboardManager.unregisterCursor(id);
            };
            return InputManager;
        })();
        input.InputManager = InputManager;
        /**
         * @class cc.input.PriorityInputNode
         * @classdesc
         *
         * This class encapsulated a descriptor for priority input routing. Basically keeps track of a target Node and
         * a priority value.
         * These descriptors are sorted in priority value, meaning lower values will be evaluated for input first.
         */
        var PriorityInputNode = (function () {
            /**
             * Input target.
             * @member cc.input.PriorityInputNode#node
             * @type {cc.node.Node}
             */
            /**
             * Priority value.
             * @member cc.input.PriorityInputNode#priority
             * @type {number}
             */
            /**
             * @method cc.input.PriorityInputNode#constructor
             * @param node {cc.node.Node}
             * @param priority {number}
             */
            function PriorityInputNode(node, priority) {
                this.node = node;
                this.priority = priority;
            }
            return PriorityInputNode;
        })();
        input.PriorityInputNode = PriorityInputNode;
        /**
         *
         * @class cc.input.SceneGraphInputTreeNode
         * @classdesc
         *
         * Input is routed in two different ways:
         *  + prioritized: where elements are sorted in priority order.
         *  + scene graph: where elements are sorted in scene-graph order, that is, in a parent/child order.
         *
         * Some Input managers will keep a root node of this type, which has inserting/removing capabilities and keeps
         * nodes in SceneGraph order.
         *
         * Preferred way of input routing should be prioritized.
         * SceneGraph, for a large number of nodes, sounds reasonably to maintain an smaller subset of the scene graph
         * to try routing input to. For smaller amounts, sounds like not a good idea to keep a copy, and have to notify
         * each manager about scene-graph mutation operations to rebuild the nodes tree.
         *
         * The input system will traverse this tree in pre-order to test for input.
         *
         * This class will only be used for point-like input systems like mouse or touch.
         */
        var SceneGraphInputTreeNode = (function () {
            /**
             * Create a new Scene-Graph priority node/tree.
             * @method cc.input.SceneGraphInputTreeNode#constructor
             * @param node {cc.node.Node=}
             */
            function SceneGraphInputTreeNode(node) {
                /**
                 * Target Node.
                 * @member cc.input.SceneGraphInputTreeNode#node
                 * @type {cc.node.Node}
                 */
                this.node = null;
                /**
                 * This node's Scene-Graph priority children nodes.
                 * @member cc.input.SceneGraphInputTreeNode#children
                 * @type {cc.input.SceneGraphInputTreeNode}
                 */
                this.children = null;
                /**
                 * Is this node enabled ? if not, it won't be tested for input.
                 * @member cc.input.SceneGraphInputTreeNode#enabled
                 * @type {boolean}
                 */
                this.enabled = false;
                this.children = [];
                if (typeof node !== "undefined") {
                    this.node = node;
                }
            }
            /**
             * Insert a Path of nodes.
             * A path of nodes is an array of a Node, and all its ancestors.
             * These path will be added to the tree, creating nodes for missing nodes, and modifying existing ones for input
             * route enable as needed.
             * If the path does not have as top most ancestor the tree's root node, nothing will be added, and an error
             * will be sent to the console.
             * @method cc.input.SceneGraphInputTreeNode#insert
             * @param path {Array<cc.node.Node>}
             */
            SceneGraphInputTreeNode.prototype.insert = function (path) {
                var lastNode = path[path.length - 1];
                if (lastNode === this.node) {
                    return this.__insertImpl(this, path);
                }
                else {
                    cc.Debug.warn(cc.locale.INPUT_WARN_WRONG_ROOT_NODE);
                }
                return null;
            };
            /**
             * Node path insertion implementation.
             * @method cc.input.SceneGraphInputTreeNode#__insertImpl
             * @param inputNode {cc.input.SceneGraphInputTreeNode} a tree node.
             * @param path {Array<cc.node.Node>} node path.
             * @returns {cc.input.SceneGraphInputTreeNode}
             * @private
             */
            SceneGraphInputTreeNode.prototype.__insertImpl = function (inputNode, path) {
                var pathNode = path.pop();
                // adding input to the inputNode.
                if (pathNode !== inputNode.node) {
                    // the node is not of this input tree node.
                    // add it as children, and go on.
                    inputNode = inputNode.addChildInputNode(pathNode);
                }
                if (path.length === 0) {
                    inputNode.enabled = true;
                }
                else {
                    return this.__insertImpl(inputNode, path);
                }
                return inputNode;
            };
            /**
             * Add a node as a Scene-Graph priority tree node's child.
             * @method cc.input.SceneGraphInputTreeNode#addChildInputNode
             * @param node {cc.node.Node}
             * @returns {*}
             */
            SceneGraphInputTreeNode.prototype.addChildInputNode = function (node) {
                for (var i = 0; i < this.children.length; i++) {
                    if (this.children[i].node === node) {
                        return this.children[i];
                    }
                }
                // the node is not as children
                var newInputNode = new SceneGraphInputTreeNode(node);
                this.children.push(newInputNode);
                this.children.sort(function (sn0, sn1) {
                    // nodes for input are sorted inversely, input goes to the top most.
                    var n0 = sn0.node;
                    var n1 = sn1.node;
                    if (n0._localZOrder < n1._localZOrder) {
                        return 1;
                    }
                    if (n0._localZOrder > n1._localZOrder) {
                        return -1;
                    }
                    return n0._orderOfArrival < n1._orderOfArrival ? 1 : -1;
                });
                return newInputNode;
            };
            /**
             * Flatten this tree and get an array of pre-order sorted nodes.
             * @method cc.input.SceneGraphInputTreeNode#flatten
             * @returns {Array<cc.node.Node>}
             */
            SceneGraphInputTreeNode.prototype.flatten = function () {
                var ret = [];
                this.__flattenImpl(this, ret);
                return ret;
            };
            /**
             * Tree flatten operation implementation.
             * @method cc.input.SceneGraphInputTreeNode#__flattenImpl
             * @param inputNode {cc.input.SceneGraphInputTreeNode} a tree node.
             * @param nodes {Array<cc.node.Node>} an array to push the sorted nodes.
             * @private
             */
            SceneGraphInputTreeNode.prototype.__flattenImpl = function (inputNode, nodes) {
                var i;
                for (i = 0; i < inputNode.children.length; i++) {
                    this.__flattenImpl(inputNode.children[i], nodes);
                }
                // all enabled nodes, must be added to the list of enabled elements.
                if (inputNode.enabled) {
                    nodes.push(inputNode.node);
                }
            };
            /**
             * For an screen position, get the first node that is at that position and has input enabled.
             * This will be the target of the pointer input operation.
             * @method cc.input.SceneGraphInputTreeNode#findNodeAtScreenPoint
             * @param e {cc.input.MouseInputManager}
             * @returns {cc.node.Node}
             */
            SceneGraphInputTreeNode.prototype.findNodeAtScreenPoint = function (p, callback) {
                var node = this.__findNodeAtScreenPoint(this, p, callback);
                if (!node && callback) {
                    callback(null);
                }
                return node;
            };
            /**
             * findNodeAtScreenPoint's implementation
             * @method cc.input.SceneGraphInputTreeNode#__findNodeAtScreenPoint
             * @param inputNode {cc.input.SceneGraphInputTreeNode}
             * @param e {cc.input.MouseInputManager}
             * @returns {cc.node.Node}
             * @private
             */
            SceneGraphInputTreeNode.prototype.__findNodeAtScreenPoint = function (inputNode, p, callback) {
                var i;
                var pp = new cc.math.Vector();
                pp.set(p.x, p.y);
                for (i = 0; i < inputNode.children.length; i++) {
                    var node = this.__findNodeAtScreenPoint(inputNode.children[i], p, callback);
                    if (node) {
                        return node;
                    }
                }
                // all enabled nodes, must be added to the list of enabled elements.
                if (inputNode.enabled) {
                    var node = inputNode.node;
                    p.set(pp.x, pp.y);
                    if (node.isScreenPointInNode(p)) {
                        //return node;
                        if (callback) {
                            if (!callback(node)) {
                                return node;
                            }
                            p.set(pp.x, pp.y);
                        }
                        else {
                            return node;
                        }
                    }
                }
                p.set(pp.x, pp.y);
                return null;
            };
            return SceneGraphInputTreeNode;
        })();
        input.SceneGraphInputTreeNode = SceneGraphInputTreeNode;
    })(input = cc.input || (cc.input = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="InputManager.ts"/>
var cc;
(function (cc) {
    var input;
    (function (input) {
        var Vector = cc.math.Vector;
        var InputManagerEvent = cc.input.InputManagerEvent;
        var __p0 = new Vector();
        /**
         * DOM target element. Tipically a Canvas object.
         * Director will call this method when the renderer is set.
         * @type {HTMLElement}
         * @private
         */
        var _target = null;
        /**
         * Current event screen-space point.
         * @type {cc.math.Vector}
         * @private
         */
        var _screenPoint = new Vector();
        /**
         * Previous event screen-space point. When a drag event is detected, the event emitted will contain current and
         * previous screen coordinated which will allow for a proper dragging calculation w/o the client need to store
         * previous coords.
         * @type {cc.math.Vector}
         * @private
         */
        var _prevScreenPoint = new Vector();
        /**
         * Mouse event in _target space. For a node this will have the _screenPoint transformed to node's local coordinate
         * system (regardless of the compound affine transform it has).
         * @type {cc.math.Vector}
         * @private
         */
        var _targetPoint = new Vector();
        /**
         * This is director's current scene.
         * It is needed since each scene will have two lists for input: priority and scene-graph order.
         * @type {cc.node.Scene}
         * @private
         */
        var _scene = null;
        /**
         * Flag indicating whether the mouse/touch is pressed when moving. This allows to differentiate between move and drag.
         * @type {boolean}
         * @private
         */
        var _isMouseDown = false;
        /**
         * Is dragging internal flag.
         * @type {boolean}
         * @private
         */
        var _isDragging = false;
        var _isDraggingInCapture = false;
        /**
         * When the mouse/pointer is down, a target Node is identified as event target.
         * This variable holds a Node reference as capturing Node.
         * @type {cc.node.Node}
         * @private
         */
        var _currentCaptureNode = null;
        /**
         * Internal flag that identifies an IOS user agent.
          * @type {Navigator|string[]}
         */
        var isIOS = navigator && navigator.userAgent.match(/iOS/);
        /**
         * Create a MouseInputManagerEvent.
         * This event contains:
         *   + target for the event. A Node.
         *   + type of event (mouseover, mouseout, mousedown, mouseup, mousemove, mousedrag, mouseclick, doubleclick)
         *   + screen point (canvas space) where the event originated.
         *   + previous screen point (canvas space) where the event originated in the previous event.
         *   + local node point (node space) where the event originated in the previous event.
         *
         * WARNING: all properties of this event must be copied. Don't rely on the point values unless you make a copy
         * of them.
         * WARNING: don't change any of the event properties in the callback functions it is passed to.
         *
         * @param e {MouseEvent} original DOM event
         * @param event {string} the type of event that will be emitted.
         * @param node {cc.node.Node} a target node.
         *
         * @returns {MouseInputManagerEvent}
         */
        function createEvent(e, event, node) {
            var mie = new MouseInputManagerEvent(e);
            getTargetSpacePoint(__p0, e);
            // original canvas-space position
            mie.setScreenPoint(__p0.x, __p0.y);
            if (null === _prevScreenPoint) {
                _prevScreenPoint = new Vector(__p0.x, __p0.y);
            }
            mie.localPoint.x = mie.screenPoint.x;
            mie.localPoint.y = mie.screenPoint.y;
            mie.prevScreenPoint.x = _prevScreenPoint.x;
            mie.prevScreenPoint.y = _prevScreenPoint.y;
            mie.initializeEventForTarget(node, event);
            return mie;
        }
        function routeEvent(p, callback) {
            if (_scene) {
                return _scene.findNodeAtScreenPoint(p, callback);
            }
            return null;
        }
        /**
         * Mouse down handler.
         * @param e {MouseEvent}
         */
        function mouseDown(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputDown(createEvent(e, "mousedown", _currentCaptureNode), "mousedown");
        }
        function __inputDown(ee, event) {
            _isMouseDown = true;
            ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
            routeEvent(ee._localPoint, function (node) {
                var ret = false;
                if (node) {
                    ee._type = event;
                    ee._target = node;
                    ret = node.notifyEvent(ee);
                }
                if (_currentCaptureNode !== node && !ret) {
                    if (_currentCaptureNode) {
                        ee._type = event === "mousedown" ? "mouseout" : "touchend";
                        ee._target = _currentCaptureNode;
                        _currentCaptureNode.notifyEvent(ee);
                    }
                }
                if (!ret) {
                    _currentCaptureNode = node;
                }
                _prevScreenPoint.set(ee.screenPoint.x, ee.screenPoint.y);
                return ret;
            });
        }
        /**
         * Mouse up handler
         * @param e {MouseEvent}
         */
        function mouseUp(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputUp(createEvent(e, "mouseup", _currentCaptureNode), "mouseup");
        }
        function __inputUp(ee, event) {
            ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
            var node = routeEvent(ee._localPoint);
            var ret = false;
            if (_currentCaptureNode) {
                // up in a different node
                if (_currentCaptureNode !== node) {
                    // send out to the previous one.
                    ee._type = event === "mouseup" ? "mouseout" : "touchend";
                    ee._target = _currentCaptureNode;
                    ee.localPoint.x = ee.screenPoint.x;
                    ee.localPoint.y = ee.screenPoint.y;
                    _currentCaptureNode.isScreenPointInNode(ee.localPoint);
                    _currentCaptureNode.notifyEvent(ee);
                }
                else {
                    // up in the same captured node
                    // notify mouse up
                    _currentCaptureNode.notifyEvent(ee);
                    // and if not dragging, mouse click
                    if (!_isDragging && event === "mouseup") {
                        ee._type = "mouseclick";
                        ee._target = _currentCaptureNode;
                        _currentCaptureNode.notifyEvent(ee);
                    }
                }
            }
            _currentCaptureNode = null;
            _isMouseDown = false;
            _isDragging = false;
            _isDraggingInCapture = false;
            _prevScreenPoint = null;
        }
        /**
         * Mouse move handler
         * @param e {MouseEvent}
         * @param _event {string} mouseout/mouseover are treated as mouseMove. If set, this variable forces the event type.
         */
        function mouseMove(e, _event) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            var event = _event ? _event : (_isMouseDown ? "mousedrag" : "mousemove");
            __inputMove(createEvent(e, event, _currentCaptureNode), event);
        }
        function __inputMove(ee, event) {
            if (_isMouseDown) {
                _isDragging = true;
                _isDraggingInCapture = true;
            }
            // drag is sent to the captured node.
            if (!_isDragging) {
                ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
                routeEvent(ee._localPoint, function (node) {
                    var ret = false;
                    if (node) {
                        ee._type = event;
                        ee._target = node;
                        ret = node.notifyEvent(ee);
                    }
                    if (node !== _currentCaptureNode && !ret) {
                        // if there's a previous capture node notify mouse-out on it.
                        if (_currentCaptureNode) {
                            ee._type = event === "mousedrag" || event === "mousemove" ? "mouseout" : "touchout";
                            ee._target = _currentCaptureNode;
                            _currentCaptureNode.notifyEvent(ee);
                        }
                        if (node) {
                            ee._type = event === "mousedrag" || event === "mousemove" ? "mouseover" : "touchover";
                            ee._target = node;
                            ret = node.notifyEvent(ee);
                        }
                    }
                    if (!ret) {
                        _currentCaptureNode = node;
                    }
                    _prevScreenPoint.set(ee.screenPoint.x, ee.screenPoint.y);
                    return ret;
                });
            }
            else {
                // dragging
                // dragging outside the capture node ??
                //routeEvent( ee.screenPoint, function(node:Node) : boolean {
                ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
                var node = routeEvent(ee._localPoint);
                var ret = false;
                if (node !== _currentCaptureNode) {
                    if (_currentCaptureNode) {
                        ee._type = ee._type = event === "mousedrag" || event === "mousemove" ? "mouseout" : "touchout";
                        ee.localPoint.x = ee.screenPoint.x;
                        ee.localPoint.y = ee.screenPoint.y;
                        _currentCaptureNode.getScreenPointInLocalSpace(ee.localPoint);
                        _currentCaptureNode.notifyEvent(ee);
                        _isDraggingInCapture = false;
                    }
                }
                else {
                    if (!_isDraggingInCapture) {
                        _isDraggingInCapture = true;
                        ee._type = ee._type = event === "mousedrag" || event === "mousemove" ? "mouseover" : "touchover";
                        _currentCaptureNode.notifyEvent(ee);
                    }
                }
                // notify mouse-over to the new capture node
                if (_currentCaptureNode !== null) {
                    ee._type = event;
                    ee._target = _currentCaptureNode;
                    //ret= _currentCaptureNode.notifyEvent( ee );
                    ret = _currentCaptureNode.notifyEvent(ee);
                }
                _prevScreenPoint.set(ee.screenPoint.x, ee.screenPoint.y);
            }
        }
        /**
         * double click handler.
         * @param e {MouseEvent}
         */
        function doubleClick(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            var ee = createEvent(e, "doubleclick", _currentCaptureNode);
            if (_currentCaptureNode) {
                _currentCaptureNode.notifyEvent(ee);
            }
            else {
                ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
                routeEvent(ee._localPoint, function (node) {
                    var ret = false;
                    if (_currentCaptureNode) {
                        ret = _currentCaptureNode.notifyEvent(ee);
                    }
                    return ret;
                });
            }
            _prevScreenPoint = null;
        }
        /**
         * Mouse over handler.
         * @param e {MouseEvent}
         */
        function mouseOver(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            mouseMove(e, "mouseoever");
        }
        /**
         * Mouse out handler
         * @param e {MouseEvent}
         */
        function mouseOut(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            mouseMove(e, "mouseout");
        }
        function touchStart(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputDown(createEvent(e.targetTouches[0], "touchstart", _currentCaptureNode), "touchstart");
        }
        function touchEnd(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputUp(createEvent(e.changedTouches[0], "touchend", _currentCaptureNode), "touchend");
        }
        function touchMove(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputMove(createEvent(e.targetTouches[0], "touchmove", _currentCaptureNode), "touchmove");
        }
        function __accumulateOffset(node, parentProperty, property) {
            var left = property + 'Left';
            var top = property + 'Top';
            var x = 0, y = 0, style;
            while (isIOS && node && node.style) {
                if (node.currentStyle) {
                    style = node.currentStyle.position;
                }
                else {
                    style = (node.ownerDocument.defaultView || node.ownerDocument.parentWindow).getComputedStyle(node, null);
                    style = style ? style.getPropertyValue('position') : null;
                }
                if (!/^(fixed)$/.test(style)) {
                    x += node[left];
                    y += node[top];
                    node = node[parentProperty];
                }
                else {
                    break;
                }
            }
            return {
                x: x,
                y: y,
                style: style
            };
        }
        /**
         * Get a DOM node offset based on its position attribute.
         * @param node {HTMLElement}
         * @returns {cc.math.Point}
         * @private
         */
        function __getOffset(node) {
            var res = __accumulateOffset(node, 'offsetParent', 'offset');
            if (res.style === 'fixed') {
                var res2 = __accumulateOffset(node, node.parentNode ? 'parentNode' : 'parentElement', 'scroll');
                return {
                    x: res.x + res2.x,
                    y: res.y + res2.y
                };
            }
            return {
                x: res.x,
                y: res.y
            };
        }
        /**
         * This function tansforms a window-space input coordinate event into a _target-space coordinate.
         * Modern browsers have a getBoundingClientRect for this purpose, but older don't so a more complex mechanism for
         * finding out the coordinate is deployed.
         * This includes logic based on the position style of the canvas, screen scroll, etc., and some other perks.
         *
         * It surely does not cover corner or weird cases !!!.
         *
         * It also stores the _screenPoint value.
         *
         * @param point {cc.math.Point} an output point.
         * @param e {MouseEvent}
         */
        function getTargetSpacePoint(point, e) {
            _screenPoint.x = e.clientX;
            _screenPoint.y = e.clientY;
            var posx = 0;
            var posy = 0;
            if (navigator.isCocoonJS) {
                posx = e.pageX;
                posy = e.pageY;
            }
            else if (typeof e.offsetX !== "undefined" || typeof e.layerX !== "undefined" || typeof e.clientX !== "undefined") {
                var bcr = _target.getBoundingClientRect();
                posx = e.clientX; // || e.offsetX || e.layerX;
                posy = e.clientY; // || e.offsetY || e.layerY;
                posx = (posx - bcr.left) * (_target.width / bcr.width);
                posy = (posy - bcr.top) * (_target.height / bcr.height);
            }
            else {
                /**
                 * older browsers.
                 * survival model. try to find things on your own by traversing upwards the DOM tree.
                 */
                if (!e)
                    e = window.event;
                if (e.pageX || e.pageY) {
                    posx = e.pageX;
                    posy = e.pageY;
                }
                else if (e.clientX || e.clientY) {
                    posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                    posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
                }
                var offset = __getOffset(this.canvas);
                posx -= offset.x;
                posy -= offset.y;
            }
            _targetPoint.set(posx, posy);
            point.set(posx, posy);
        }
        /**
         * @class cc.input.MouseInputManagerEvent
         * @extends cc.input.InputManagerEvent
         * @classdesc
         *
         * This class represents information for a Mouse-level event and translated into CocosJS needed information.
         *
         */
        var MouseInputManagerEvent = (function (_super) {
            __extends(MouseInputManagerEvent, _super);
            /**
             * Create a new MouseInputManagerEvent instance.
             * @method cc.input.MouseInputManagerEvent#constructor
             * @param e {MouseEvent} DOM level original event.
             */
            function MouseInputManagerEvent(e) {
                _super.call(this);
                /**
                 * Original DOM level event that triggered this MouseInputManagerEvent
                 * @member cc.input.MouseInputManagerEvent#_originalDOMEvent
                 * @type {MouseEvent}
                 * @private
                 */
                this._originalDOMEvent = null;
                /**
                 * position in canvas space.
                 * @member cc.input.MouseInputManagerEvent#_screenPoint
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._screenPoint = null;
                /**
                 * Target Node local coordinate.
                 * @member cc.input.MouseInputManagerEvent#_screenPoint
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._localPoint = null;
                /**
                 * For a dragging operation, position in canvas space of the previous event.
                 * @member cc.input.MouseInputManagerEvent#_screenPoint
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._prevScreenPoint = null;
                this._originalDOMEvent = e;
                this._screenPoint = new Vector();
                this._localPoint = new Vector();
                this._prevScreenPoint = new Vector();
            }
            MouseInputManagerEvent.prototype.getDelta = function () {
                return {
                    x: this._screenPoint.x - this._prevScreenPoint.x,
                    y: this._screenPoint.y - this._prevScreenPoint.y
                };
            };
            /**
             * Set this event's screen point.
             * @method cc.input.MouseInputManagerEvent#setScreenPoint
             * @param x {number}
             * @param y {number}
             */
            MouseInputManagerEvent.prototype.setScreenPoint = function (x, y) {
                this._screenPoint.set(x, y);
            };
            /**
             * Initialize the event for type and target.
             * @method cc.input.MouseInputManagerEvent#initializeEventForTarget
             * @param target {cc.node.Node}
             * @param event {string}
             */
            MouseInputManagerEvent.prototype.initializeEventForTarget = function (target, event) {
                _super.prototype.initializeEventForTarget.call(this, target, event);
                this._localPoint.set(this._screenPoint.x, this._screenPoint.y);
            };
            Object.defineProperty(MouseInputManagerEvent.prototype, "localPoint", {
                /**
                 * Get target Node's local coordinate where the event originated.
                 * @method cc.input.MouseInputManagerEvent#get:localPoint
                 * @returns {cc.math.Vector}
                 */
                get: function () {
                    return this._localPoint;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MouseInputManagerEvent.prototype, "prevScreenPoint", {
                /**
                 * Get target screen coordinate where the previous event originated.
                 * @method cc.input.MouseInputManagerEvent#get:prevScreenPoint
                 * @returns {cc.math.Vector}
                 */
                get: function () {
                    return this._prevScreenPoint;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MouseInputManagerEvent.prototype, "screenPoint", {
                /**
                 * Get target screen coordinate where the event originated.
                 * @method cc.input.MouseInputManagerEvent#get:screenPoint
                 * @returns {cc.math.Vector}
                 */
                get: function () {
                    return this._screenPoint;
                },
                enumerable: true,
                configurable: true
            });
            return MouseInputManagerEvent;
        })(InputManagerEvent);
        input.MouseInputManagerEvent = MouseInputManagerEvent;
        function hasTouch() {
            return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
        }
        /**
         * @class cc.input.MouseInputManager
         * @classdesc
         *
         * This object is CocosJS system general mouse/touch input manager.
         * Mouse events are registered at window level. This will prevent from stop receiving input events if the mouse/touch
         * gets out of the canvas area, but on the other hand, it will impose a more complicated local canvas coordinate
         * matching for older browsers.
         *
         * It is a non-instantiable object, and a call to enable/disable, like to any other system-wide input event must
         * be performed before receiving input events.
         *
         * Touch events are mapped as follows:
         *
         *  <li>touch start -> mousedown
         *  <li>touch end   -> mouseup
         *  <li>touch move  -> mousedrag
         *
         * There's no need to register specific listeners for the touch events. If a corresponding mouse event is registered
         * it will be notified on these instead.
         *
         */
        var MouseInputManager = (function () {
            function MouseInputManager() {
            }
            /**
             * Set the scene to route input events to.
             * This happens automatically at director level whenever a call to runAction happens.
             * @method cc.input.MouseInputManager.enableInputForScene
             * @param scene {cc.node.Scene}
             */
            MouseInputManager.enableInputForScene = function (scene) {
                _scene = scene;
            };
            MouseInputManager.disableInputForScene = function () {
                _scene = null;
            };
            /**
             * Enable the input for mouse and touch.
             * @method cc.input.MouseInputManager.enable
             * @param target {HTMLCanvasElement} canvas target.
             */
            MouseInputManager.enable = function (target) {
                if (_target !== null) {
                    this.disable();
                }
                _target = target;
                if (hasTouch()) {
                    target.addEventListener("touchstart", touchStart, false);
                    target.addEventListener("touchmove", touchMove, false);
                    target.addEventListener("touchend", touchEnd, false);
                }
                else {
                    window.addEventListener('mouseup', mouseUp, false);
                    window.addEventListener('mousedown', mouseDown, false);
                    window.addEventListener('mouseover', mouseOver, false);
                    window.addEventListener('mouseout', mouseOut, false);
                    window.addEventListener('mousemove', mouseMove, false);
                    window.addEventListener('dblclick', doubleClick, false);
                }
            };
            /**
             * Disable the input for mouse and touch.
             * @method cc.input.MouseInputManager.disable
             */
            MouseInputManager.disable = function () {
                if (_target !== null) {
                    if (hasTouch()) {
                        _target.removeEventListener("touchstart", touchStart, false);
                        _target.removeEventListener("touchmove", touchMove, false);
                        _target.removeEventListener("touchend", touchEnd, false);
                    }
                    else {
                        window.removeEventListener('mouseup', mouseUp, false);
                        window.removeEventListener('mousedown', mouseDown, false);
                        window.removeEventListener('mouseover', mouseOver, false);
                        window.removeEventListener('mouseout', mouseOut, false);
                        window.removeEventListener('mousemove', mouseMove, false);
                        window.removeEventListener('dblclick', doubleClick, false);
                    }
                    _target = null;
                }
            };
            return MouseInputManager;
        })();
        input.MouseInputManager = MouseInputManager;
    })(input = cc.input || (cc.input = {}));
})(cc || (cc = {}));
/**
 * Created by ibon on 1/6/15.
 */
/// <reference path="./InputManager.ts"/>
var cc;
(function (cc) {
    var input;
    (function (input) {
        /**
         * Keys names and ascii chars.
         * From Impact Game Engine.
         * @name KEYS
         * @memberOf cc.input
         * @type {Map<string,number>}
         */
        input.KEYS = {
            enter: 13,
            backspace: 8,
            tab: 9,
            shift: 16,
            ctrl: 17,
            alt: 18,
            pause: 19,
            capslock: 20,
            escape: 27,
            pageup: 33,
            pagedown: 34,
            end: 35,
            home: 36,
            left: 37,
            up: 38,
            right: 39,
            down: 40,
            insert: 45,
            "delete": 46,
            0: 48,
            1: 49,
            2: 50,
            3: 51,
            4: 52,
            5: 53,
            6: 54,
            7: 55,
            8: 56,
            9: 57,
            a: 65,
            b: 66,
            c: 67,
            d: 68,
            e: 69,
            f: 70,
            g: 71,
            h: 72,
            i: 73,
            j: 74,
            k: 75,
            l: 76,
            m: 77,
            n: 78,
            o: 79,
            p: 80,
            q: 81,
            r: 82,
            s: 83,
            t: 84,
            u: 85,
            v: 86,
            w: 87,
            x: 88,
            y: 89,
            z: 90,
            command: 91,
            meta: 91,
            select: 93,
            rcommand: 93,
            numpad0: 96,
            numpad1: 97,
            numpad2: 98,
            numpad3: 99,
            numpad4: 100,
            numpad5: 101,
            numpad6: 102,
            numpad7: 103,
            numpad8: 104,
            numpad9: 105,
            multiply: 106,
            add: 107,
            subtract: 109,
            decimalpoint: 110,
            divide: 111,
            f1: 112,
            f2: 113,
            f3: 114,
            f4: 115,
            f5: 116,
            f6: 117,
            f7: 118,
            f8: 119,
            f9: 120,
            f10: 121,
            f11: 122,
            f12: 123,
            numlock: 144,
            scrolllock: 145,
            semicolon: 186,
            equalsign: 187,
            comma: 188,
            dash: 189,
            period: 190,
            forwardslash: 191,
            graveaccent: 192,
            openbracket: 219,
            backslash: 220,
            closebracket: 221,
            singlequote: 222,
            commandright: 224
        };
        /**
         * Build a keyboard modifiers object.
         * Modifers have some numerical members corresponding to the key codes for command, commandright, shift, alt and control.
         *
         * @returns {object}
         */
        function buildKeyModifiers() {
            var modifiers = {};
            modifiers[input.KEYS.command] = false;
            modifiers[input.KEYS.commandright] = false;
            modifiers[input.KEYS.ctrl] = false;
            modifiers[input.KEYS.shift] = false;
            modifiers[input.KEYS.alt] = false;
            return modifiers;
        }
        /**
         * @class cc.input.KeyInfo
         * @classdesc
         *
         * Describes a key and its modifiers.
         * For example: command+a, shift+alt+g
         * A Key, is parsed from a string, amd must be defined in this order: modifiers+key.
         * It won't recognize something like: a+shift whili it will recognized shift+a
         * KeyInfo objects keep internal state for parsing result validity.
         *
         * Objects of this type are internal to the keyboard manager.
         */
        var KeyInfo = (function () {
            /**
             * Build a new KeyInfo instance from a string key representation.
             * @method cc.input.KeyInfo#constructor
             * @param keyDef {string}
             */
            function KeyInfo(keyDef) {
                /**
                 * Key Code.
                 * @member cc.input.KeyInfo#key
                 * @type {number}
                 */
                this.key = null;
                /**
                 * Modifiers Object.
                 * @member cc.input.KeyInfo#modifiers
                 * @type {object}
                 */
                this.modifiers = null;
                /**
                 * Key has been parsed correctly ?
                 * @member cc.input.KeyInfo#isValid
                 * @type {boolean}
                 */
                this.isValid = true;
                this.modifiers = buildKeyModifiers();
                var keys = keyDef.split("+");
                for (var i = 0; i < keys.length - 1; i++) {
                    if (this.modifiers.hasOwnProperty(cc.input.KEYS[keys[i]])) {
                        this.modifiers[cc.input.KEYS[keys[i]]] = true;
                    }
                    else {
                        this.isValid = false;
                        console.log("wrong key modifier: '" + keys[i] + "' in key definition: " + keyDef);
                    }
                }
                var key = keys[keys.length - 1];
                if (input.KEYS.hasOwnProperty(key)) {
                    this.key = input.KEYS[key];
                }
                else {
                    this.isValid = false;
                    console.log("wrong key '" + key + "' in key definition: " + keyDef);
                }
            }
            /**
             * Test whether this KeyInfo matches a keyCode and some modifiers.
             * @method cc.input.KeyInfo#matches
             * @param key {number} key code.
             * @param modifiers {object}
             * @returns {boolean}
             */
            KeyInfo.prototype.matches = function (key, modifiers) {
                return this.key === key && modifiers.ctrl === this.modifiers.ctrl && modifiers.alt === this.modifiers.alt && modifiers.shift === this.modifiers.shift && modifiers.command === this.modifiers.command && modifiers.commandright === this.modifiers.commandright;
            };
            return KeyInfo;
        })();
        input.KeyInfo = KeyInfo;
        /**
         * @class cc.input.KeyActionInfo
         * @classdesc
         *
         * A KeyActionInfo is responsible for defining a key sequence, composed by a collection of KeyInfo objects.
         * It will also be responsible for identifying whether the sequence has been types correctly, and of notifying any
         * sequence listeners registered for it.
         *
         * A sample KeyActionInfo could be for example the konami code:
         * "up up down dow left right left right b a", "a b c", or a simple "a". The callback associated with the sequence
         * will be fired when all the keys are pressed in order.
         *
         * An action info will be fired on key down or up, depending on the construction parameter.
         * For multi-key actions, the callback will be fired on key down or up of the last sequence key.
         * The sequence will be invalidated if the wrong key for the current sequence position is typed, or it more than
         * KeyActionInfo._typeTime is exceeded.
         */
        var KeyActionInfo = (function () {
            /**
             * Create a new KeyActionInfo sequence object.
             * @method cc.input.KeyActionInfo#constructor
             * @param keys {string} a string with the sequence keys definition.
             * @param action {string} down or up. If keys is a sequence of keys, the sequence will be fired on up or down
             *                        of the last sequence key.
             * @param callback {function} a parameterless callback function.
             */
            function KeyActionInfo(keys, action, callback) {
                /**
                 * The registered keys of the sequence action.
                 * @member cc.input.KeyActionInfo#_keys
                 * @type {Array<cc.input.KeyInfo>}
                 * @private
                 */
                this._keys = [];
                /**
                 * Action for which the ket sequence action was registered. Either 'down' or 'up'.
                 * @member cc.input.KeyActionInfo#_action
                 * @type {string}
                 * @private
                 */
                this._action = null;
                /**
                 * Callback to fire when the sequence is complete.
                 * @member cc.input.KeyActionInfo#_callback
                 * @type {Function}
                 * @private
                 */
                this._callback = null;
                /**
                 * Current sequence expected key.
                 * @member cc.input.KeyActionInfo#_currentKeyInfoIndex
                 * @type {number}
                 * @private
                 */
                this._currentKeyInfoIndex = -1;
                /**
                 * Time at which the last valid action sequence key was typed.
                 * @member cc.input.KeyActionInfo#_time
                 * @type {number}
                 * @private
                 */
                this._time = -1;
                /**
                 * A index-sequence generated id. It is valid for unregistering key sequences from the keyboard manager.
                 * @member cc.input.KeyActionInfo#_id
                 * @type {number}
                 * @private
                 */
                this._id = KeyboardIdGenerator();
                /**
                 * If more than this milliseconds elapse between two valid sequence action keys, the sequence will be aborted.
                 * @member cc.input.KeyActionInfo#_typeTime
                 * @type {number}
                 * @private
                 */
                this._typeTime = 1000;
                this._action = action;
                this._callback = callback;
                this.__parseKeys(keys);
            }
            /**
             * Get the sequence id.
             * @method cc.input.KeyActionInfo#getId
             * @returns {number}
             */
            KeyActionInfo.prototype.getId = function () {
                return this._id;
            };
            /**
             * Build KeyInfo objects from a keys definition string.
             * @method cc.input.KeyActionInfo#__parseKeys
             * @param keys {string} a string with keys (combinations) names. for example: "command+b", "alt+shift+f1 a b c"
             * @private
             */
            KeyActionInfo.prototype.__parseKeys = function (keys) {
                var keyDefs = keys.split(" ");
                for (var i = 0; i < keyDefs.length; i++) {
                    var keyDef = new KeyInfo(keyDefs[i]);
                    if (keyDef.isValid) {
                        this._keys.push(keyDef);
                    }
                }
            };
            /**
             * Signal a key down event has been generated at keyboard manager level
             * @method cc.intpu.KeyInfoAction#down
             * @param modifiers {object} modifiers object
             * @param key {number} key code
             * @param time {number} time at which the event key was produced.
             */
            KeyActionInfo.prototype.down = function (modifiers, key, time) {
                if (this._action === "down") {
                    this.__checkKey(key, modifiers, time);
                }
            };
            /**
             * Signal a key up event has been generated at keyboard manager level
             * @method cc.intpu.KeyInfoAction#up
             * @param modifiers {object} modifiers object
             * @param key {number} key code
             * @param time {number} time at which the event key was produced.
             */
            KeyActionInfo.prototype.up = function (modifiers, key, time) {
                if (this._action === "up") {
                    this.__checkKey(key, modifiers, time);
                }
            };
            /**
             * Check whether the key code fulfills the key sequence in time.
             * The sequence will be reset if the wrong expected key is pressed or too much time elapse between two valid
             * sequence keys.
             * @param key {number} key code
             * @param modifiers {object} modifiers object
             * @param time {number} time at which the event key was produced.
             * @private
             */
            KeyActionInfo.prototype.__checkKey = function (key, modifiers, time) {
                // too much time for sequence
                if (time - this._time > this._typeTime) {
                    // restart
                    this._currentKeyInfoIndex = -1;
                }
                if (this._currentKeyInfoIndex === -1) {
                    this._currentKeyInfoIndex = 0;
                    this._time = time;
                }
                if (this._keys[this._currentKeyInfoIndex].matches(key, modifiers)) {
                    // right key + modifiers
                    this._currentKeyInfoIndex++;
                    this._time = time;
                    if (this._currentKeyInfoIndex === this._keys.length) {
                        // sequence ok
                        this._callback();
                        this._currentKeyInfoIndex = -1;
                    }
                }
                else {
                    // wrong key, restart
                    this._currentKeyInfoIndex = -1;
                }
            };
            /**
             * Change the valid waiting time between two valid sequence keys.
             * The function won't check whether the number is valid or too low.
             * @method cc.input.KeyInfoAction#setSequenceTypeMaxTime
             * @param m {number}
             */
            KeyActionInfo.prototype.setSequenceTypeMaxTime = function (m) {
                this._typeTime = m;
                return this;
            };
            return KeyActionInfo;
        })();
        input.KeyActionInfo = KeyActionInfo;
        var KeyboardIdGenerator = function () {
            var index = 0;
            return function () {
                return index++;
            };
        }();
        /**
         * @class cc.input.KeyboardCursor
         * @classdesc
         *
         * This class represents a cursor composed of the 4 cursor events up, down, left and right.
         * For each of the events, a valid key enumeration can be defined.
         * For example, if "w up" is specified for up, the Cursor will fire a callback for each of the keys 'w' and 'up'.
         * This class makes all the necessary wiring between the cursor keys and KeyInfoAction objects.
         */
        var KeyboardCursor = (function () {
            /**
             * Create a new KeyboardCursor object instance.
             * @method cc.input.KeyboardCursor#constructor
             * @param kim {cc.input.KeyboardInputManager}
             * @param cd {cc.input.CursorInitializer}
             * @param callback {function(string,boolean)}
             */
            function KeyboardCursor(kim, cd, callback) {
                /**
                 * Cursor up flag.
                 * @member cc.input.KeyboardCursor#_upPressed
                 * @type {boolean}
                 * @private
                 */
                this._upPressed = false;
                /**
                 * Cursor down flag.
                 * @member cc.input.KeyboardCursor#_downPressed
                 * @type {boolean}
                 * @private
                 */
                this._downPressed = false;
                /**
                 * Cursor left flag.
                 * @member cc.input.KeyboardCursor#_leftPressed
                 * @type {boolean}
                 * @private
                 */
                this._leftPressed = false;
                /**
                 * Cursor right flag.
                 * @member cc.input.KeyboardCursor#_rightPressed
                 * @type {boolean}
                 * @private
                 */
                this._rightPressed = false;
                /**
                 * Array for KeyActionInfo generated objects to keep track of the cursor.
                 * @member cc.input.KeyboardCursor#_actionInfoIds
                 * @type {Array<number>}
                 * @private
                 */
                this._actionInfoIds = [];
                /**
                 * Internal cursor id. Necessary for unregistering a cursor.
                 * @member cc.input.KeyboardCursor#_id
                 * @type {number}
                 * @private
                 */
                this._id = KeyboardIdGenerator();
                var me = this;
                this._callback = callback;
                this.__registerKeys(kim, cd.up, function () {
                    me._upPressed = true;
                    me.__onKeyChange("up", me._upPressed);
                }, function () {
                    me._upPressed = false;
                    me.__onKeyChange("up", me._upPressed);
                });
                this.__registerKeys(kim, cd.down, function () {
                    me._downPressed = true;
                    me.__onKeyChange("down", me._downPressed);
                }, function () {
                    me._downPressed = false;
                    me.__onKeyChange("down", me._downPressed);
                });
                this.__registerKeys(kim, cd.left, function () {
                    me._leftPressed = true;
                    me.__onKeyChange("left", me._leftPressed);
                }, function () {
                    me._leftPressed = false;
                    me.__onKeyChange("left", me._leftPressed);
                });
                this.__registerKeys(kim, cd.right, function () {
                    me._rightPressed = true;
                    me.__onKeyChange("right", me._rightPressed);
                }, function () {
                    me._rightPressed = false;
                    me.__onKeyChange("right", me._rightPressed);
                });
            }
            /**
             * Notify a cursor key status change.
             * @method cc.input.KeyboardCursor#__onKeyChange
             * @param key {string} the cursor event type.
             * @param pressed {boolean} true the key is pressed, false is released.
             * @private
             */
            KeyboardCursor.prototype.__onKeyChange = function (key, pressed) {
                this._callback(key, pressed, input.KEYS[key]);
            };
            /**
             * Register a KeyActionInfo for each key defined in the cursor event key description.
             * For example if "up w" is supplied, it will generate sequences for 'up' and 'w' respectively.
             * @param kim {cc.input.KeyboardInputManager}
             * @param keysdesc {string} keys descripion
             * @param callbackdown {function}
             * @param callbackup {function}
             * @private
             */
            KeyboardCursor.prototype.__registerKeys = function (kim, keysdesc, callbackdown, callbackup) {
                var keys = keysdesc.split(" ");
                for (var i = 0; i < keys.length; i++) {
                    this._actionInfoIds.push(kim.onDown(keys[i], callbackdown));
                    this._actionInfoIds.push(kim.onUp(keys[i], callbackup));
                }
            };
            /**
             * Get the cursor id.
             * @method cc.input.KeyboardCursor#getId
             * @returns {number}
             */
            KeyboardCursor.prototype.getId = function () {
                return this._id;
            };
            /**
             * Unregisted all key sequences from the cursor.
             * This method is internally used by the KeyboardInputManager
             * @method cc.input.KeyboardCursor#unregisted
             * @param kim {cc.action.KeyboardInputManager}
             */
            KeyboardCursor.prototype.unregister = function (kim) {
                for (var i = 0; i < this._actionInfoIds.length; i++) {
                    kim.removeActionInfo(this._actionInfoIds[i]);
                }
            };
            Object.defineProperty(KeyboardCursor.prototype, "up", {
                /**
                 * Get cursor's event up status flag.
                 * @method cc.input.KeyboardCursor#get:up
                 * @returns {boolean} true is pressed.
                 */
                get: function () {
                    return this._upPressed;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(KeyboardCursor.prototype, "down", {
                /**
                 * Get cursor's event down status flag.
                 * @method cc.input.KeyboardCursor#get:down
                 * @returns {boolean} true is pressed.
                 */
                get: function () {
                    return this._downPressed;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(KeyboardCursor.prototype, "left", {
                /**
                 * Get cursor's event left status flag.
                 * @method cc.input.KeyboardCursor#get:left
                 * @returns {boolean} true is pressed.
                 */
                get: function () {
                    return this._leftPressed;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(KeyboardCursor.prototype, "right", {
                /**
                 * Get cursor's event right status flag.
                 * @method cc.input.KeyboardCursor#get:right
                 * @returns {boolean} true is pressed.
                 */
                get: function () {
                    return this._rightPressed;
                },
                enumerable: true,
                configurable: true
            });
            return KeyboardCursor;
        })();
        input.KeyboardCursor = KeyboardCursor;
        /**
         * @class cc.input.KeyboardInputManager
         * @classdesc
         *
         * This object is the general keyboard input manager.
         * It must be instantiated.
         *
         */
        var KeyboardInputManager = (function () {
            /**
             * Create a new KeyboardInputManager instance.
             * @method cc.input.KeyboardInputManager#constructor
             */
            function KeyboardInputManager() {
                /**
                 * Whether the keyboard handler is enabled.
                 * @member cc.input.KeyboardInputManager#_enabled
                 * @type {boolean}
                 * @private
                 */
                this._enabled = false;
                /**
                 * Global keyboard modifiers.
                 * @member cc.input.KeyboardInputManager#_modifiers
                 * @type {object}
                 * @private
                 */
                this._modifiers = null;
                /**
                 * Registered KeyboardCursor objects.
                 * @member cc.input.KeyboardInputManager#_cursors
                 * @type {Map<string,KeyboardCursor>}
                 * @private
                 */
                this._cursors = {};
                /**
                 * Internally bound function for down events.
                 * Do not use or modify.
                 * @member cc.input.KeyboardInputManager#_onDown
                 * @type {function(KeyboardEvent)}
                 * @private
                 */
                this._onDown = null;
                /**
                 * Internally bound function for up events.
                 * Do not use or modify.
                 * @member cc.input.KeyboardInputManager#_onUp
                 * @type {function(KeyboardEvent)}
                 * @private
                 */
                this._onUp = null;
                this._keyActionInfos = [];
                this._onDown = this.__onDown.bind(this);
                this._onUp = this.__onUp.bind(this);
                this._modifiers = buildKeyModifiers();
            }
            KeyboardInputManager.prototype.__onDown = function (e) {
                var key = e.which ? e.which : e.keyCode;
                var time = new Date().getTime();
                if (!this.__setModifiers(key, true)) {
                    for (var i = 0; i < this._keyActionInfos.length; i++) {
                        this._keyActionInfos[i].down(this._modifiers, key, time);
                    }
                }
            };
            KeyboardInputManager.prototype.__onUp = function (e) {
                var key = e.which ? e.which : e.keyCode;
                var time = new Date().getTime();
                if (!this.__setModifiers(key, false)) {
                    for (var i = 0; i < this._keyActionInfos.length; i++) {
                        this._keyActionInfos[i].up(this._modifiers, key, time);
                    }
                }
            };
            KeyboardInputManager.prototype.__setModifiers = function (key, down) {
                if (this._modifiers.hasOwnProperty(key)) {
                    this._modifiers[key] = down;
                    return true;
                }
                return false;
            };
            /**
             * Register and Enable the keyboard manager.
             * @method cc.input.KeyboardInputManager#enable
             */
            KeyboardInputManager.prototype.enable = function () {
                if (!this._enabled) {
                    window.addEventListener("keydown", this._onDown, false);
                    window.addEventListener("keyup", this._onUp, false);
                    this._enabled = true;
                }
            };
            /**
             * Disable the keyboard manager and remove keyboard listeners.
             * @method cc.input.KeyboardInputManager#enable
             */
            KeyboardInputManager.prototype.disable = function () {
                if (this._enabled) {
                    window.removeEventListener("keydown", this._onDown, false);
                    window.removeEventListener("keyup", this._onUp, false);
                    this._enabled = false;
                }
            };
            /**
             * Add a callback for a key sequence. Fired on 'down' of the last sequence key.
             * @method cc.input.KeyboardInputManager#onDown
             * @param keys {string}
             * @param callback {function()}
             * @returns {number}
             */
            KeyboardInputManager.prototype.onDown = function (keys, callback) {
                var kai = new KeyActionInfo(keys, "down", callback);
                this._keyActionInfos.push(kai);
                return kai.getId();
            };
            /**
             * Add a callback for a key sequence. Fired on 'up' of the last sequence key.
             * @method cc.input.KeyboardInputManager#onUp
             * @param keys {string}
             * @param callback {function()}
             * @returns {number}
             */
            KeyboardInputManager.prototype.onUp = function (keys, callback) {
                var kai = new KeyActionInfo(keys, "up", callback);
                this._keyActionInfos.push(kai);
                return kai.getId();
            };
            /**
             * Register a cursor object with the cursor keys defined in the initializer.
             * @method cc.input.KeyboardInputManager#registerCursor
             * @param cd {cc.input.CursorInitializer}
             * @param callback {function({string},{boolean}) a callback function invoked with the cursor event name and
             *        status of the cursor key.
             * @returns {number}
             */
            KeyboardInputManager.prototype.registerCursor = function (cd, callback) {
                var kc = new KeyboardCursor(this, cd, callback);
                this._cursors[kc.getId()] = kc;
                return kc.getId();
            };
            /**
             * Unregister a KeyboardCursor object.
             * @method cc.input.KeyboardInputManager#unregisterCursor
             * @param id {number}
             */
            KeyboardInputManager.prototype.unregisterCursor = function (id) {
                if (this._cursors.hasOwnProperty(id)) {
                    this._cursors[id].unregister(this);
                    this._cursors[id] = null;
                }
            };
            /**
             * Remove a key sequence from the keyboard manager.
             * @method cc.input.KeyboardInputManager#removeActionInfo
             * @param id {number}
             */
            KeyboardInputManager.prototype.removeActionInfo = function (id) {
                for (var i = 0; i < this._keyActionInfos.length; i++) {
                    if (this._keyActionInfos[i].getId() === id) {
                        this._keyActionInfos.splice(i, 1);
                        return;
                    }
                }
            };
            return KeyboardInputManager;
        })();
        input.KeyboardInputManager = KeyboardInputManager;
    })(input = cc.input || (cc.input = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="../node/Director.ts"/>
/// <reference path="../render/ScaleManager.ts"/>
/// <reference path="../plugin/asset/AssetManager.ts"/>
/// <reference path="../plugin/loader/Loader.ts"/>
/// <reference path="../plugin/loader/Resource.ts"/>
var cc;
(function (cc) {
    var game;
    (function (_game) {
        /**
         * @class cc.game.Game
         * @classdesc
         *
         * Helper object to glue all CocosJS components together.
         * The game object builds a default Director, is able to define orientation, scale and content scale, load assets
         * and preload them into the asset manager, etc. etc.
         *
         */
        var Game = (function () {
            function Game() {
                this._director = new cc.node.Director();
            }
            Game.prototype.setDesignResolutionSize = function (ri) {
                if (typeof ri === "undefined") {
                    ri = {
                        width: 800,
                        height: 600
                    };
                }
                if (typeof ri.canvasPosition === "undefined") {
                    ri.canvasPosition = "center";
                }
                if (typeof ri.scaleStrategy === "undefined") {
                    ri.scaleStrategy = "scale_aspect";
                }
                if (typeof ri.orientation === "undefined") {
                    ri.orientation = "both";
                }
                var renderer;
                if (typeof ri.renderer === "string") {
                    if (ri.renderer === "canvas") {
                        renderer = new cc.render.CanvasRenderer(ri.width, ri.height, document.getElementById(ri.canvasElement));
                    }
                    else if (ri.renderer === "webgl") {
                        renderer = new cc.render.WebGLRenderer(ri.width, ri.height, document.getElementById(ri.canvasElement));
                    }
                    else {
                        // autodetect
                        renderer = cc.render.autodetectRenderer(ri.width, ri.height, ri.canvasElement);
                    }
                }
                this._director.setRenderer(renderer);
                this._renderer = renderer;
                ri.scaleStrategy = ri.scaleStrategy.toUpperCase();
                ri.canvasPosition = ri.canvasPosition.toUpperCase();
                ri.orientation = ri.orientation.toUpperCase();
                var st = cc.render.ScaleManagerStrategy[ri.scaleStrategy] || 1 /* SCALE_FIT */;
                var sp = cc.render.ScalePosition[ri.canvasPosition] || 1 /* CENTER */;
                var co = cc.render.OrientationStrategy[ri.orientation] || 0 /* BOTH */;
                this._renderer.setScaleStrategy(st, sp);
                this._renderer.setOrientationStrategy(co);
                return this;
            };
            Game.prototype.load = function (assets, _onLoad, _onProgress, _onError) {
                var me = this;
                cc.plugin.asset.AssetManager.load({
                    resources: assets
                }, function onLoad(resources) {
                    if (cc.__BACKWARDS_COMPATIBILITY__) {
                        cc.plugin.asset.AssetManager.mergeResources(resources);
                    }
                    _onLoad(me);
                }, function onProgress(resource, index, size, errored) {
                    if (typeof _onProgress !== "undefined") {
                        _onProgress(resource, index, size, errored);
                    }
                }, function onError(resource) {
                    if (typeof _onError !== "undefined") {
                        _onError(resource);
                    }
                });
            };
            Game.prototype.runScene = function (scene) {
                this._director.runScene(scene);
            };
            /**
             * Return the internal scale management object.
             * This object handles all things relative to Renderer surface scale and on-screen positioning, as well as
             * orientation changes and content scale ratio calculations.
             * @method cc.node.Director#getScaleManager
             * @see cc.game.ScaleManager
             * @returns {cc.game.ScaleManager}
             */
            Game.prototype.getScaleManager = function () {
                return this._renderer.getScaleManager();
            };
            /**
             * Set renderer surface scale strategy.
             * @method cc.node.Director#setScaleStrategy
             * @param ss {cc.render.ScaleManagerStrategy} how renderer surface should me up/down scaled when the window
             *          changes size.
             * @param sp {cc.render.ScalePosition} how to position the renderer surface on the window object.
             */
            Game.prototype.setScaleStrategy = function (ss, sp) {
                this._renderer.setScaleStrategy(ss, sp);
            };
            /**
             * Set internal ratio to adjust screen pixels to game units.
             * A game, usually makes the assumption that one game unit maps directly to one screen pixel.
             * When we want to build better looking games which honor devicePixelRation, retina, etc. we need to undo
             * this direct assumption in favor of other better mechanisms.
             * This method undoes this mapping.
             * For example, my game is 8 by 5 meters and want to see it in a 960x640 pixels screen.
             * The difference between this method and <code>setScaleStrategy</code> is that this one acts in game content,
             * and setScaleStrategy on the renderer generated image.
             * @method cc.node.Director#setScaleContent
             * @see cc.game.ScaleManager
             * @param w {number} game units width
             * @param h {number} game units height
             * @param cw {number=} canvas width
             * @param ch {number=} canvas height
             * @return {number} the scale factor resulting from the map units-pixels.
             */
            Game.prototype.setScaleContent = function (w, h, cw, ch) {
                this._renderer.setScaleContent(w, h, cw, ch);
                return this._renderer.getUnitsFactor();
            };
            /**
             * When <code>setScaleContent</code> has been called this method gives the scale factor for the units-pixel
             * mapping ratio.
             * @method cc.node.Director#getUnitsFactor
             * @returns {number}
             */
            Game.prototype.getUnitsFactor = function () {
                return this._renderer.getUnitsFactor();
            };
            /**
             * Set renderer surface orientation strategy. If set to landscape or portrait, when the window changes size
             * will notify about valid or wrong orientation.
             * Default orientation is set to BOTH.
             * @method cc.node.Director#setOrientationStrategy
             * @param os {cc.render.OrientationStrategy} desired orientation.
             * @param onOk {cc.render.OrientationCallback}
             * @param onError {cc.render.OrientationCallback}
             */
            Game.prototype.setOrientationStrategy = function (os, onOk, onError) {
                this._renderer.forceOrientation(os, onOk, onError);
            };
            /**
             * Get whether the device has fullScreen capabilities
             * @method cc.node.Director#isFullScreenCapable
             * @returns {boolean}
             */
            Game.prototype.isFullScreenCapable = function () {
                return this._renderer.isFullScreenCapable();
            };
            /**
             * Is currently the system in full screen ?
             * @method cc.node.Director#isFullScreen
             * @returns {boolean}
             */
            Game.prototype.isFullScreen = function () {
                return this._renderer.isFullScreen();
            };
            /**
             * Start full screen process. If the system is not full screen capable will silently fail.
             * @method cc.node.Director#startFullScreen
             * @param f {callback=} optional function called when the system enters full screen.
             */
            Game.prototype.startFullScreen = function (f) {
                this._renderer.startFullScreen(f);
            };
            /**
             * End full screen process. If the system is not full screen capable will silently fail.
             * @method cc.node.Director#endFullScreen
             * @param f {callback=} optional function called when the system enters full screen.
             */
            Game.prototype.endFullScreen = function (f) {
                this._renderer.endFullScreen(f);
            };
            return Game;
        })();
        _game.Game = Game;
    })(game = cc.game || (cc.game = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../math/Point.ts"/>
/// <reference path="../math/path/Segment.ts"/>
/// <reference path="../math/path/SegmentBezier.ts"/>
/// <reference path="../math/Path.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/sprite/Animation.ts"/>
/// <reference path="../action/Action.ts"/>
/// <reference path="../action/MoveAction.ts"/>
/// <reference path="../action/RotateAction.ts"/>
/// <reference path="../action/ScaleAction.ts"/>
/// <reference path="../action/PropertyAction.ts"/>
/// <reference path="../action/SequenceAction.ts"/>
/// <reference path="../action/TintAction.ts"/>
/// <reference path="../action/AlphaAction.ts"/>
/// <reference path="../action/AnimateAction.ts"/>
/// <reference path="../action/PathAction.ts"/>
/// <reference path="../action/JumpAction.ts"/>
/// <reference path="../action/TimeInterpolator.ts"/>
var cc;
(function (cc) {
    "use strict";
    cc.__BACKWARDS_COMPATIBILITY__ = true;
    var NodeDirtyFlags = cc.node.NodeDirtyFlags;
    var Action = cc.action.Action;
    var MoveAction = cc.action.MoveAction;
    var RotateAction = cc.action.RotateAction;
    var PropertyAction = cc.action.PropertyAction;
    var SequenceAction = cc.action.SequenceAction;
    var TintAction = cc.action.TintAction;
    var AlphaAction = cc.action.AlphaAction;
    var ScaleAction = cc.action.ScaleAction;
    var AnimateAction = cc.action.AnimateAction;
    var PathAction = cc.action.PathAction;
    var JumpAction = cc.action.JumpAction;
    var SegmentBezier = cc.math.path.SegmentBezier;
    var Path = cc.math.Path;
    var Interpolator = cc.action.Interpolator;
    /**
     * Create a Animate like <code>AnimateAction</code> action.
     * @method cc.animate
     * @param animation {cc.node.sprite.Animation}
     * @returns {Action}
     */
    function animate(animation) {
        return new AnimateAction(animation);
    }
    cc.animate = animate;
    function callFunc(fn, _this, data) {
        return new Action().onEnd(function (action, target) {
            if (typeof _this !== "undefined") {
                fn.call(_this, target, data);
            }
            else {
                fn(target, data);
            }
        });
    }
    cc.callFunc = callFunc;
    function show() {
        return new Action().onEnd(function (action, target) {
            target.setVisible(!action._reversed);
        });
    }
    cc.show = show;
    function toggleVisibility() {
        return new Action().onEnd(function (action, target) {
            target.setVisible(!target.__isFlagSet(8 /* VISIBLE */));
        });
    }
    cc.toggleVisibility = toggleVisibility;
    function hide() {
        return new Action().onEnd(function (action, target) {
            target.setVisible(action._reversed);
        });
    }
    cc.hide = hide;
    function place(v) {
        return new Action().onEnd(function (action, target) {
            target.setPosition(v.x, v.y);
        });
    }
    cc.place = place;
    function blink(timeInSecs, blinks) {
        var originalVisibility = true;
        var action = new Action().timeInfo(0, timeInSecs).onStart(function (action, node) {
            originalVisibility = node.__isFlagSet(8 /* VISIBLE */);
        }).onEnd(function (action, node) {
            node.setVisible(originalVisibility);
        });
        action.update = function (delta, node) {
            delta %= 1 / blinks;
            node.setVisible(delta >= 1 / blinks / 2);
        };
        return action;
    }
    cc.blink = blink;
    function jumpTo(timeInSecs, pos, amplitude, jumps) {
        if (jumps === void 0) { jumps = 1; }
        return __jump(timeInSecs, pos, amplitude, jumps, false);
    }
    cc.jumpTo = jumpTo;
    function jumpBy(timeInSecs, pos, amplitude, jumps) {
        if (jumps === void 0) { jumps = 1; }
        return __jump(timeInSecs, pos, amplitude, jumps, true);
    }
    cc.jumpBy = jumpBy;
    function __jump(timeInSecs, pos, amplitude, jumps, relative) {
        return new JumpAction({
            type: "JumpAction",
            position: pos,
            jumps: jumps,
            amplitude: amplitude,
            relative: relative
        }).timeInfo(0, timeInSecs);
    }
    function __catmull(timeInSecs, p, tension, relative, closed) {
        var segment = new Path().catmullRomTo(p, closed, tension);
        return new PathAction({ type: "PathAction", segment: segment }).setRelative(relative).timeInfo(0, timeInSecs);
    }
    function cardinalSplineTo(timeInSecs, p, tension, closed) {
        if (closed === void 0) { closed = false; }
        return __catmull(timeInSecs, p, tension, false, closed);
    }
    cc.cardinalSplineTo = cardinalSplineTo;
    function cardinalSplineBy(timeInSecs, p, tension, closed) {
        if (closed === void 0) { closed = false; }
        return __catmull(timeInSecs, p, tension, true, closed);
    }
    cc.cardinalSplineBy = cardinalSplineBy;
    function catmullRomTo(timeInSecs, p, closed) {
        if (closed === void 0) { closed = false; }
        return __catmull(timeInSecs, p, 0, false, closed);
    }
    cc.catmullRomTo = catmullRomTo;
    function catmullRomBy(timeInSecs, p, closed) {
        if (closed === void 0) { closed = false; }
        return __catmull(timeInSecs, p, 0, true, closed);
    }
    cc.catmullRomBy = catmullRomBy;
    function __bezier(timeInSecs, p, relative) {
        return new PathAction({
            type: "PathAction",
            segment: new SegmentBezier({
                p0: { x: 0, y: 0 },
                p1: p[0],
                p2: p[1],
                p3: p[2]
            })
        }).setRelative(relative).timeInfo(0, timeInSecs);
    }
    function bezierTo(timeInSecs, p) {
        return __bezier(timeInSecs, p, false);
    }
    cc.bezierTo = bezierTo;
    function bezierBy(timeInSecs, p) {
        return __bezier(timeInSecs, p, true);
    }
    cc.bezierBy = bezierBy;
    function __move(timeInSecs, p, relative) {
        return new MoveAction().to(p).setRelative(relative).timeInfo(0, timeInSecs);
    }
    /**
     * Create a moveTo like <code>MoveAction</code> action.
     * @method cc.moveTo
     * @param timeInSecs {number}
     * @param p {cc.math.Point}
     * @returns {Action}
     */
    function moveTo(timeInSecs, p) {
        return __move(timeInSecs, p, false);
    }
    cc.moveTo = moveTo;
    /**
     * Create a moveBy like <code>MoveAction</code> action.
     * @method cc.moveBy
     * @param timeInSecs {number}
     * @param p {cc.math.Point}
     * @returns {Action}
     */
    function moveBy(timeInSecs, p) {
        return __move(timeInSecs, p, true);
    }
    cc.moveBy = moveBy;
    function __scale(timeInSecs, x, y, relative) {
        return new ScaleAction().to({ x: x, y: y }).setRelative(relative).timeInfo(0, timeInSecs);
    }
    /**
     * Create a scaleTo like <code>ScaleAction</code> action.
     * @method cc.scaleTo
     * @param timeInSecs {number}
     * @param x {number}
     * @param y {number}
     * @returns {Action}
     */
    function scaleTo(timeInSecs, x, y) {
        return __scale(timeInSecs, x, typeof y === "undefined" ? x : y, false);
    }
    cc.scaleTo = scaleTo;
    /**
     * Create a scaleBy like <code>ScaleAction</code> action.
     * @method cc.scaleBy
     * @param timeInSecs {number}
     * @param x {number}
     * @param y {number}
     * @returns {Action}
     */
    function scaleBy(timeInSecs, x, y) {
        return __scale(timeInSecs, x, typeof y === "undefined" ? x : y, true);
    }
    cc.scaleBy = scaleBy;
    function __rotate(timeInSecs, a, relative) {
        return new RotateAction().to(a).setRelative(relative).timeInfo(0, timeInSecs);
    }
    /**
     * Create a rotateTo like <code>RotateAction</code> action.
     * @method cc.rotateTo
     * @param timeInSecs {number}
     * @param a {number}
     * @returns {Action}
     */
    function rotateTo(timeInSecs, a) {
        return __rotate(timeInSecs, a, false);
    }
    cc.rotateTo = rotateTo;
    /**
     * Create a rotateBy like <code>RotateAction</code> action.
     * @method cc.rotateBy
     * @param timeInSecs {number}
     * @param a {number}
     * @returns {Action}
     */
    function rotateBy(timeInSecs, a) {
        return __rotate(timeInSecs, a, true);
    }
    cc.rotateBy = rotateBy;
    /**
     * Create a fadeIn like <code>AlphaAction</code> action.
     * @method cc.fadeIn
     * @param timeInSecs {number}
     * @returns {cc.action.Action}
     */
    function fadeIn(timeInSecs) {
        return new AlphaAction().from(0).to(1).timeInfo(0, timeInSecs);
    }
    cc.fadeIn = fadeIn;
    /**
     * Create a fadeIn like <code>AlphaAction</code> action.
     * @method cc.fadeOut
     * @param timeInSecs {number}
     * @returns {cc.action.Action}
     */
    function fadeOut(timeInSecs) {
        return new AlphaAction().from(1).to(0).timeInfo(0, timeInSecs);
    }
    cc.fadeOut = fadeOut;
    function __fade(timeInSecs, a, relative) {
        return new AlphaAction().to(a / 255).setRelative(relative).timeInfo(0, timeInSecs);
    }
    /**
     * Create a fadeTo like <code>AlphaAction</code> action.
     * @method cc.fadeTo
     * @param timeInSecs {number}
     * @param a {number}
     * @returns {Action}
     */
    function fadeTo(timeInSecs, a) {
        return __fade(timeInSecs, a, false);
    }
    cc.fadeTo = fadeTo;
    /**
     * Create a fadeBy like <code>AlphaAction</code> action.
     * @method cc.fadeBy
     * @param timeInSecs {number}
     * @param a {number}
     * @returns {Action}
     */
    function fadeBy(timeInSecs, a) {
        return __fade(timeInSecs, a, true);
    }
    cc.fadeBy = fadeBy;
    function __tint(timeInSecs, r, g, b, relative) {
        return new TintAction().to({ r: r / 255, g: g / 255, b: b / 255 }).setRelative(relative).timeInfo(0, timeInSecs);
    }
    /**
     * Create a tintTo like <code>TintAction</code> action.
     * @method cc.tintTo
     * @param timeInSecs {number}
     * @param r {number}
     * @param g {number}
     * @param b {number}
     * @returns {Action}
     */
    function tintTo(timeInSecs, r, g, b) {
        return __tint(timeInSecs, r, g, b, false);
    }
    cc.tintTo = tintTo;
    /**
     * Create a tintBy like <code>TintAction</code> action.
     * @method cc.tintBy
     * @param timeInSecs {number}
     * @param r {number}
     * @param g {number}
     * @param b {number}
     * @returns {Action}
     */
    function tintBy(timeInSecs, r, g, b) {
        return __tint(timeInSecs, r, g, b, true);
    }
    cc.tintBy = tintBy;
    /**
     * Reverses the target action
     * @method cc.reverseTime
     * @param action {cc.action.Action}
     * @returns {cc.reverseTime}
     */
    function reverseTime(action) {
        action.setReversedTime(!action.isReversedTime());
        return this;
    }
    cc.reverseTime = reverseTime;
    /**
     * Make an action repeat a number of times.
     * @method cc.repeat
     * @param action {cc.action.Action}
     * @param times {number}
     * @returns {Action}
     */
    function repeat(action, times) {
        if (times < 1) {
            times = 1;
        }
        action.setRepeatTimes(times);
        return action;
    }
    cc.repeat = repeat;
    /**
     * Make an action repeat forever.
     * @method cc.repeatForever
     * @param action {cc.action.Action}
     * @returns {Action}
     */
    function repeatForever(action) {
        action.setRepeatForever();
        return action;
    }
    cc.repeatForever = repeatForever;
    /**
     * Create an action that waits the given time.
     * @method cc.delayTime
     * @param delayInSecs {number}
     * @returns {cc.action.Action}
     */
    function delayTime(delayInSecs) {
        return new PropertyAction().from({}).to({}).timeInfo(0, delayInSecs);
    }
    cc.delayTime = delayTime;
    function __sequence(sequential, actions) {
        var seq = new SequenceAction({ sequential: sequential });
        if (!actions.length) {
            return null;
        }
        for (var i = 0; i < actions.length; i++) {
            seq.addAction(actions[i]);
        }
        return seq;
    }
    cc.__sequence = __sequence;
    /**
     * Set an action speed.
     * @method cc.speed
     * @param action {cc.action.Action}
     * @param speed {number} speed 1 is the default speed. speed 2 will make the action to take twice the time.
     * @returns {Action}
     */
    function speed(action, speed) {
        action.setSpeed(speed);
        return action;
    }
    cc.speed = speed;
    /**
     * Create a Sequence of Actions.
     * Actions can be other Sequences or Spawns.
     * @method cc.sequence
     * @param actions {Array<cc.action.Action>}
     * @returns {SequenceAction}
     */
    function sequence() {
        var actions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            actions[_i - 0] = arguments[_i];
        }
        return __sequence(true, actions);
    }
    cc.sequence = sequence;
    /**
     * Create a Spawn of Actions.
     * Actions can be other Sequences or Spawns.
     * @methos cc.spawn
     * @param actions {Array<cc.action.Action>}
     * @returns {SequenceAction}
     */
    function spawn() {
        var actions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            actions[_i - 0] = arguments[_i];
        }
        return __sequence(false, actions);
    }
    cc.spawn = spawn;
    /**
     * Apply easing to an action time.
     * @method cc.easing
     * @param action {cc.action.Action}
     * @param interpolator {cc.action.TimeInterpolator}
     * @returns {Action}
     */
    function easing(action, interpolator) {
        return action.easing(interpolator);
    }
    cc.easing = easing;
    function __interpolator(interpolator, action) {
        return typeof action !== "undefined" ? easing(action, interpolator) : interpolator;
    }
    /**
     * Apply BackIn easing to an action
     * @method cc.easeBackIn
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeBackIn(action) {
        return __interpolator(Interpolator.EaseBackIn(false, false), action);
    }
    cc.easeBackIn = easeBackIn;
    /**
     * Apply easeBackOut easing to an action.
     * @method cc.easeBackOut
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeBackOut(action) {
        return __interpolator(Interpolator.EaseBackOut(false, false), action);
    }
    cc.easeBackOut = easeBackOut;
    /**
     * Apply easeBackInOut easing to an action.
     * @method cc.easeBackInOut
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeBackInOut(action) {
        return __interpolator(Interpolator.EaseBackInOut(false, false), action);
    }
    cc.easeBackInOut = easeBackInOut;
    /**
     * Apply BounceIn easing to an action
     * @method cc.easeBounceIn
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeBounceIn(action) {
        return __interpolator(Interpolator.EaseBounceIn(false, false), action);
    }
    cc.easeBounceIn = easeBounceIn;
    /**
     * Apply easeBounceOut easing to an action.
     * @method cc.easeBounceOut
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeBounceOut(action) {
        return __interpolator(Interpolator.EaseBounceOut(false, false), action);
    }
    cc.easeBounceOut = easeBounceOut;
    /**
     * Apply easeBounceInOut easing to an action.
     * @method cc.easeBounceInOut
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeBounceInOut(action) {
        return __interpolator(Interpolator.EaseBounceInOut(false, false), action);
    }
    cc.easeBounceInOut = easeBounceInOut;
    /**
     * Apply elasticlIn easing to an action
     * @method cc.easeElasticIn
     * @param action {cc.action.Action|number=}
     * @param period {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeElasticIn(action, period) {
        var int = Interpolator.EaseElasticIn((typeof action === "undefined") ? action : period, false, false);
        return __interpolator(int, action);
    }
    cc.easeElasticIn = easeElasticIn;
    /**
     * Apply elasticOut easing to an action.
     * @method cc.easeElasticOut
     * @param action {cc.action.Action|number=}
     * @param period {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeElasticOut(action, period) {
        var int = Interpolator.EaseElasticOut((typeof action === "undefined") ? action : period, false, false);
        return __interpolator(int, action);
    }
    cc.easeElasticOut = easeElasticOut;
    /**
     * Apply elasticInOut easing to an action.
     * @method cc.easeElasticInOut
     * @param action {cc.action.Action|number}
     * @param period {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeElasticInOut(action, period) {
        var int = Interpolator.EaseElasticInOut((typeof action === "undefined") ? action : period, false, false);
        return __interpolator(int, action);
    }
    cc.easeElasticInOut = easeElasticInOut;
    /**
     * Apply exponentialIn easing to an action. Exponent 2.
     * @method cc.easeIn
     * @param action {cc.action.Action|number}
     * @param exponent {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeIn(action, exponent) {
        var int = Interpolator.EaseIn((typeof action === "undefined") ? action : exponent, false, false);
        return __interpolator(int, action);
    }
    cc.easeIn = easeIn;
    /**
     * Apply exponentialIn easing to an action. Exponent 2.
     * @method cc.easeOut
     * @param action {cc.action.Action}
     * @param exponent {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeOut(action, exponent) {
        var int = Interpolator.EaseOut((typeof action === "undefined") ? action : exponent, false, false);
        return __interpolator(int, action);
    }
    cc.easeOut = easeOut;
    /**
     * Apply exponentialInOut easing to an action. Exponent 2.
     * @method cc.easeInOut
     * @param action {cc.action.Action}
     * @param exponent {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeInOut(action, exponent) {
        var int = Interpolator.EaseInOut((typeof action === "undefined") ? action : exponent, false, false);
        return __interpolator(int, action);
    }
    cc.easeInOut = easeInOut;
    /**
     * Apply exponentialIn easing to an action. Exponent 2.
     * @method cc.easeExponentialIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeExponentialIn(action) {
        return __interpolator(Interpolator.EaseExponentialIn(false, false), action);
    }
    cc.easeExponentialIn = easeExponentialIn;
    /**
     * Apply exponentialOut easing to an action. Exponent 2.
     * @method cc.easeExponentialOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeExponentialOut(action) {
        return __interpolator(Interpolator.EaseExponentialOut(false, false), action);
    }
    cc.easeExponentialOut = easeExponentialOut;
    /**
     * Apply exponentialInOut easing to an action. Exponent 2.
     * @method cc.easeExponentialInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeExponentialInOut(action) {
        return __interpolator(Interpolator.EaseExponentialInOut(false, false), action);
    }
    cc.easeExponentialInOut = easeExponentialInOut;
    /**
     * Apply sineIn easing to an action. Exponent 2.
     * @method cc.easeSineIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeSineIn(action) {
        return __interpolator(Interpolator.EaseSineIn(false, false), action);
    }
    cc.easeSineIn = easeSineIn;
    /**
     * Apply sineOut easing to an action. Exponent 2.
     * @method cc.easeSineOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeSineOut(action) {
        return __interpolator(Interpolator.EaseSineOut(false, false), action);
    }
    cc.easeSineOut = easeSineOut;
    /**
     * Apply sineInOut easing to an action. Exponent 2.
     * @method cc.easeSineInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeSineInOut(action) {
        return __interpolator(Interpolator.EaseSineInOut(false, false), action);
    }
    cc.easeSineInOut = easeSineInOut;
    /**
     * Apply exponentialIn easing to an action. Exponent 2.
     * @method cc.easeQuadraticActionIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeQuadraticActionIn(action) {
        return __interpolator(Interpolator.EaseIn(2, false, false), action);
    }
    cc.easeQuadraticActionIn = easeQuadraticActionIn;
    /**
     * Apply exponentialOut easing to an action. Exponent 2.
     * @method cc.easeQuadraticActionOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeQuadraticActionOut(action) {
        return __interpolator(Interpolator.EaseOut(2, false, false), action);
    }
    cc.easeQuadraticActionOut = easeQuadraticActionOut;
    /**
     * Apply exponentialInOut easing to an action. Exponent 2.
     * @method cc.easeQuadraticActionInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeQuadraticActionInOut(action) {
        return __interpolator(Interpolator.EaseInOut(2, false, false), action);
    }
    cc.easeQuadraticActionInOut = easeQuadraticActionInOut;
    /**
     * Apply exponentialIn easing to an action. Exponent 3.
     * @method cc.easeCubicActionIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeCubicActionIn(action) {
        return __interpolator(Interpolator.EaseIn(3, false, false), action);
    }
    cc.easeCubicActionIn = easeCubicActionIn;
    /**
     * Apply exponentialOut easing to an action. Exponent 3.
     * @method cc.easeCubicActionOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeCubicActionOut(action) {
        return __interpolator(Interpolator.EaseOut(3, false, false), action);
    }
    cc.easeCubicActionOut = easeCubicActionOut;
    /**
     * Apply exponentialInOut easing to an action. Exponent 3.
     * @method cc.easeCubicActionInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeCubicActionInOut(action) {
        return __interpolator(Interpolator.EaseInOut(3, false, false), action);
    }
    cc.easeCubicActionInOut = easeCubicActionInOut;
    /**
     * Apply exponentialIn easing to an action. Exponent 4.
     * @method cc.easeQuarticlActionIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeQuarticlActionIn(action) {
        return __interpolator(Interpolator.EaseIn(4, false, false), action);
    }
    cc.easeQuarticlActionIn = easeQuarticlActionIn;
    /**
     * Apply exponentialOut easing to an action. Exponent 4.
     * @method cc.easeQuarticActionOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeQuarticActionOut(action) {
        return __interpolator(Interpolator.EaseOut(4, false, false), action);
    }
    cc.easeQuarticActionOut = easeQuarticActionOut;
    /**
     * Apply exponentialInOut easing to an action. Exponent 4.
     * @method cc.easeQuarticActionInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeQuarticActionInOut(action) {
        return __interpolator(Interpolator.EaseInOut(4, false, false), action);
    }
    cc.easeQuarticActionInOut = easeQuarticActionInOut;
    /**
     * Apply exponentialIn easing to an action. Exponent 5.
     * @method cc.easeQuinticlActionIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeQuinticActionIn(action) {
        return __interpolator(Interpolator.EaseIn(5, false, false), action);
    }
    cc.easeQuinticActionIn = easeQuinticActionIn;
    /**
     * Apply exponentialOut easing to an action. Exponent 5.
     * @method cc.easeQuinticlActionOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeQuinticActionOut(action) {
        return __interpolator(Interpolator.EaseOut(5, false, false), action);
    }
    cc.easeQuinticActionOut = easeQuinticActionOut;
    /**
     * Apply exponentialInOut easing to an action. Exponent 5.
     * @method cc.easeQuinticlActionInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    function easeQuinticActionInOut(action) {
        return __interpolator(Interpolator.EaseInOut(5, false, false), action);
    }
    cc.easeQuinticActionInOut = easeQuinticActionInOut;
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="./Action.ts"/>
/*
 * Cocos2D HTML5 Version 2 backwards compatibility actions.
 * These symbols are optional to be used in V4 API.
 */
var cc;
(function (cc) {
    "use strict";
    var EaseBackIn;
    (function (EaseBackIn) {
        EaseBackIn.create = cc.easeBackIn;
    })(EaseBackIn = cc.EaseBackIn || (cc.EaseBackIn = {}));
    var EaseBackOut;
    (function (EaseBackOut) {
        EaseBackOut.create = cc.easeBackOut;
    })(EaseBackOut = cc.EaseBackOut || (cc.EaseBackOut = {}));
    var EaseBackInOut;
    (function (EaseBackInOut) {
        EaseBackInOut.create = cc.easeBackInOut;
    })(EaseBackInOut = cc.EaseBackInOut || (cc.EaseBackInOut = {}));
    var EaseBounceIn;
    (function (EaseBounceIn) {
        EaseBounceIn.create = cc.easeBounceIn;
    })(EaseBounceIn = cc.EaseBounceIn || (cc.EaseBounceIn = {}));
    var EaseBounceOut;
    (function (EaseBounceOut) {
        EaseBounceOut.create = cc.easeBounceOut;
    })(EaseBounceOut = cc.EaseBounceOut || (cc.EaseBounceOut = {}));
    var EaseBounceInOut;
    (function (EaseBounceInOut) {
        EaseBounceInOut.create = cc.easeBounceInOut;
    })(EaseBounceInOut = cc.EaseBounceInOut || (cc.EaseBounceInOut = {}));
    var EaseElasticIn;
    (function (EaseElasticIn) {
        EaseElasticIn.create = cc.easeElasticIn;
    })(EaseElasticIn = cc.EaseElasticIn || (cc.EaseElasticIn = {}));
    var EaseElasticOut;
    (function (EaseElasticOut) {
        EaseElasticOut.create = cc.easeElasticOut;
    })(EaseElasticOut = cc.EaseElasticOut || (cc.EaseElasticOut = {}));
    var EaseElasticInOut;
    (function (EaseElasticInOut) {
        EaseElasticInOut.create = cc.easeElasticInOut;
    })(EaseElasticInOut = cc.EaseElasticInOut || (cc.EaseElasticInOut = {}));
    var EaseSineIn;
    (function (EaseSineIn) {
        EaseSineIn.create = cc.easeSineIn;
    })(EaseSineIn = cc.EaseSineIn || (cc.EaseSineIn = {}));
    var EaseSineOut;
    (function (EaseSineOut) {
        EaseSineOut.create = cc.easeSineOut;
    })(EaseSineOut = cc.EaseSineOut || (cc.EaseSineOut = {}));
    var EaseSineInOut;
    (function (EaseSineInOut) {
        EaseSineInOut.create = cc.easeSineInOut;
    })(EaseSineInOut = cc.EaseSineInOut || (cc.EaseSineInOut = {}));
    var CatmullRomTo;
    (function (CatmullRomTo) {
        CatmullRomTo.create = cc.catmullRomTo;
    })(CatmullRomTo = cc.CatmullRomTo || (cc.CatmullRomTo = {}));
    var CatmullRomBy;
    (function (CatmullRomBy) {
        CatmullRomBy.create = cc.catmullRomBy;
    })(CatmullRomBy = cc.CatmullRomBy || (cc.CatmullRomBy = {}));
    var CardinalSplineTo;
    (function (CardinalSplineTo) {
        CardinalSplineTo.create = cc.cardinalSplineTo;
    })(CardinalSplineTo = cc.CardinalSplineTo || (cc.CardinalSplineTo = {}));
    var CardinalSplineBy;
    (function (CardinalSplineBy) {
        CardinalSplineBy.create = cc.cardinalSplineBy;
    })(CardinalSplineBy = cc.CardinalSplineBy || (cc.CardinalSplineBy = {}));
    var BezierTo;
    (function (BezierTo) {
        BezierTo.create = cc.bezierTo;
    })(BezierTo = cc.BezierTo || (cc.BezierTo = {}));
    var BezierBy;
    (function (BezierBy) {
        BezierBy.create = cc.bezierBy;
    })(BezierBy = cc.BezierBy || (cc.BezierBy = {}));
    var MoveTo;
    (function (MoveTo) {
        MoveTo.create = cc.moveTo;
    })(MoveTo = cc.MoveTo || (cc.MoveTo = {}));
    var MoveBy;
    (function (MoveBy) {
        MoveBy.create = cc.moveBy;
    })(MoveBy = cc.MoveBy || (cc.MoveBy = {}));
    var ScaleTo;
    (function (ScaleTo) {
        ScaleTo.create = cc.scaleTo;
    })(ScaleTo = cc.ScaleTo || (cc.ScaleTo = {}));
    var ScaleBy;
    (function (ScaleBy) {
        ScaleBy.create = cc.scaleBy;
    })(ScaleBy = cc.ScaleBy || (cc.ScaleBy = {}));
    var RotateTo;
    (function (RotateTo) {
        RotateTo.create = cc.rotateTo;
    })(RotateTo = cc.RotateTo || (cc.RotateTo = {}));
    var RotateBy;
    (function (RotateBy) {
        RotateBy.create = cc.rotateBy;
    })(RotateBy = cc.RotateBy || (cc.RotateBy = {}));
    var FadeIn;
    (function (FadeIn) {
        FadeIn.create = cc.fadeIn;
    })(FadeIn = cc.FadeIn || (cc.FadeIn = {}));
    var FadeOut;
    (function (FadeOut) {
        FadeOut.create = cc.fadeOut;
    })(FadeOut = cc.FadeOut || (cc.FadeOut = {}));
    var FadeTo;
    (function (FadeTo) {
        FadeTo.create = cc.fadeTo;
    })(FadeTo = cc.FadeTo || (cc.FadeTo = {}));
    var FadeBy;
    (function (FadeBy) {
        FadeBy.create = cc.fadeBy;
    })(FadeBy = cc.FadeBy || (cc.FadeBy = {}));
    var TintTo;
    (function (TintTo) {
        TintTo.create = cc.tintTo;
    })(TintTo = cc.TintTo || (cc.TintTo = {}));
    var TintBy;
    (function (TintBy) {
        TintBy.create = cc.tintBy;
    })(TintBy = cc.TintBy || (cc.TintBy = {}));
    var ReverseTime;
    (function (ReverseTime) {
        ReverseTime.create = cc.reverseTime;
    })(ReverseTime = cc.ReverseTime || (cc.ReverseTime = {}));
    var Repeat;
    (function (Repeat) {
        Repeat.create = cc.repeat;
    })(Repeat = cc.Repeat || (cc.Repeat = {}));
    var RepeatForever;
    (function (RepeatForever) {
        RepeatForever.create = cc.repeatForever;
    })(RepeatForever = cc.RepeatForever || (cc.RepeatForever = {}));
    var DelayTime;
    (function (DelayTime) {
        DelayTime.create = cc.delayTime;
    })(DelayTime = cc.DelayTime || (cc.DelayTime = {}));
    var Speed;
    (function (Speed) {
        Speed.create = cc.speed;
    })(Speed = cc.Speed || (cc.Speed = {}));
    var Sequence;
    (function (Sequence) {
        Sequence.create = cc.sequence;
    })(Sequence = cc.Sequence || (cc.Sequence = {}));
    var Spawn;
    (function (Spawn) {
        Spawn.create = cc.spawn;
    })(Spawn = cc.Spawn || (cc.Spawn = {}));
    var Easing;
    (function (Easing) {
        Easing.create = cc.easing;
    })(Easing = cc.Easing || (cc.Easing = {}));
    var EaseIn;
    (function (EaseIn) {
        EaseIn.create = cc.easeIn;
    })(EaseIn = cc.EaseIn || (cc.EaseIn = {}));
    var EaseOut;
    (function (EaseOut) {
        EaseOut.create = cc.easeOut;
    })(EaseOut = cc.EaseOut || (cc.EaseOut = {}));
    var EaseInOut;
    (function (EaseInOut) {
        EaseInOut.create = cc.easeInOut;
    })(EaseInOut = cc.EaseInOut || (cc.EaseInOut = {}));
    var EaseExponentialIn;
    (function (EaseExponentialIn) {
        EaseExponentialIn.create = cc.easeExponentialIn;
    })(EaseExponentialIn = cc.EaseExponentialIn || (cc.EaseExponentialIn = {}));
    var EaseExponentialOut;
    (function (EaseExponentialOut) {
        EaseExponentialOut.create = cc.easeExponentialOut;
    })(EaseExponentialOut = cc.EaseExponentialOut || (cc.EaseExponentialOut = {}));
    var EaseExponentialInOut;
    (function (EaseExponentialInOut) {
        EaseExponentialInOut.create = cc.easeExponentialInOut;
    })(EaseExponentialInOut = cc.EaseExponentialInOut || (cc.EaseExponentialInOut = {}));
    var EaseQuadraticActionIn;
    (function (EaseQuadraticActionIn) {
        EaseQuadraticActionIn.create = cc.easeQuadraticActionIn;
    })(EaseQuadraticActionIn = cc.EaseQuadraticActionIn || (cc.EaseQuadraticActionIn = {}));
    var EaseQuadraticActionOut;
    (function (EaseQuadraticActionOut) {
        EaseQuadraticActionOut.create = cc.easeQuadraticActionOut;
    })(EaseQuadraticActionOut = cc.EaseQuadraticActionOut || (cc.EaseQuadraticActionOut = {}));
    var EaseQuadraticActionInOut;
    (function (EaseQuadraticActionInOut) {
        EaseQuadraticActionInOut.create = cc.easeQuadraticActionInOut;
    })(EaseQuadraticActionInOut = cc.EaseQuadraticActionInOut || (cc.EaseQuadraticActionInOut = {}));
    var EaseCubicActionIn;
    (function (EaseCubicActionIn) {
        EaseCubicActionIn.create = cc.easeCubicActionIn;
    })(EaseCubicActionIn = cc.EaseCubicActionIn || (cc.EaseCubicActionIn = {}));
    var EaseCubicActionOut;
    (function (EaseCubicActionOut) {
        EaseCubicActionOut.create = cc.easeCubicActionOut;
    })(EaseCubicActionOut = cc.EaseCubicActionOut || (cc.EaseCubicActionOut = {}));
    var EaseCubicInOut;
    (function (EaseCubicInOut) {
        EaseCubicInOut.create = cc.easeCubicActionInOut;
    })(EaseCubicInOut = cc.EaseCubicInOut || (cc.EaseCubicInOut = {}));
    var EaseQuarticActionIn;
    (function (EaseQuarticActionIn) {
        EaseQuarticActionIn.create = cc.easeQuarticlActionIn;
    })(EaseQuarticActionIn = cc.EaseQuarticActionIn || (cc.EaseQuarticActionIn = {}));
    var EaseQuarticActionOut;
    (function (EaseQuarticActionOut) {
        EaseQuarticActionOut.create = cc.easeQuarticActionOut;
    })(EaseQuarticActionOut = cc.EaseQuarticActionOut || (cc.EaseQuarticActionOut = {}));
    var EaseQuarticActionInOut;
    (function (EaseQuarticActionInOut) {
        EaseQuarticActionInOut.create = cc.easeQuarticActionInOut;
    })(EaseQuarticActionInOut = cc.EaseQuarticActionInOut || (cc.EaseQuarticActionInOut = {}));
    var EaseQuinticActionIn;
    (function (EaseQuinticActionIn) {
        EaseQuinticActionIn.create = cc.easeQuinticActionIn;
    })(EaseQuinticActionIn = cc.EaseQuinticActionIn || (cc.EaseQuinticActionIn = {}));
    var EaseQuinticActionOut;
    (function (EaseQuinticActionOut) {
        EaseQuinticActionOut.create = cc.easeQuinticActionOut;
    })(EaseQuinticActionOut = cc.EaseQuinticActionOut || (cc.EaseQuinticActionOut = {}));
    var EaseQuinticActionInOut;
    (function (EaseQuinticActionInOut) {
        EaseQuinticActionInOut.create = cc.easeQuinticActionInOut;
    })(EaseQuinticActionInOut = cc.EaseQuinticActionInOut || (cc.EaseQuinticActionInOut = {}));
    var CallFunc;
    (function (CallFunc) {
        CallFunc.create = cc.callFunc;
    })(CallFunc = cc.CallFunc || (cc.CallFunc = {}));
    var Animate;
    (function (Animate) {
        Animate.create = cc.animate;
    })(Animate = cc.Animate || (cc.Animate = {}));
    var Show;
    (function (Show) {
        Show.create = cc.show;
    })(Show = cc.Show || (cc.Show = {}));
    var Hide;
    (function (Hide) {
        Hide.create = cc.hide;
    })(Hide = cc.Hide || (cc.Hide = {}));
    var Place;
    (function (Place) {
        Place.create = cc.place;
    })(Place = cc.Place || (cc.Place = {}));
    var ToggleVisibility;
    (function (ToggleVisibility) {
        ToggleVisibility.create = cc.toggleVisibility;
    })(ToggleVisibility = cc.ToggleVisibility || (cc.ToggleVisibility = {}));
    var JumpTo;
    (function (JumpTo) {
        JumpTo.create = cc.jumpTo;
    })(JumpTo = cc.JumpTo || (cc.JumpTo = {}));
    var JumpBy;
    (function (JumpBy) {
        JumpBy.create = cc.jumpBy;
    })(JumpBy = cc.JumpBy || (cc.JumpBy = {}));
    var Blink;
    (function (Blink) {
        Blink.create = cc.blink;
    })(Blink = cc.Blink || (cc.Blink = {}));
})(cc || (cc = {}));
/**
 * License: see license.txt file
 */
/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="../node/Director.ts"/>
/// <reference path="../node/sprite/Animation.ts"/>
/// <reference path="../util/Class.ts"/>
/// <reference path="../plugin/audio/AudioManager.ts"/>
var cc;
(function (cc) {
    var Color = cc.math.Color;
    var Vector = cc.math.Vector;
    function rect(x, y, w, h) {
        return new cc.math.Rectangle(x, y, w, h);
    }
    cc.rect = rect;
    /**
     * Create a new Point/Vector object.
     * @param x {number}
     * @param y {number}
     * @returns {cc.math.Vector}
     * @deprecated call <code>new cc.math.Vector(x,y);</code>
     * @see {cc.math.Vector}
     */
    function p(x, y) {
        return new Vector(x, y);
    }
    cc.p = p;
    function size(w, h) {
        return new cc.math.Dimension(w, h);
    }
    cc.size = size;
    /**
     * create a new Color full opaque.
     * @param r {number}
     * @param g {number}
     * @param b {number}
     * @returns {cc.math.Color}
     * @deprecated call <code>new cc.math.Color(r,g,b,a?);</code>
     * @see {cc.math.Color}
     */
    function c3b(r, g, b) {
        return new cc.math.Color(r / 255, g / 255, b / 255);
    }
    cc.c3b = c3b;
    /**
     * create a new Color with RGBA
     * @param r {number}
     * @param g {number}
     * @param b {number}
     * @param a {number}
     * @returns {cc.math.Color}
     * @deprecated call <code>new cc.math.Color(r,g,b,a);</code>
     * @see {cc.math.Color}
     */
    function c4b(r, g, b, a) {
        return new cc.math.Color(r / 255, g / 255, b / 255, a / 255);
    }
    cc.c4b = c4b;
    /**
     *
     * @param r {number|string|{r:number,g:number,b:number,a:number=}}
     * @param g {number} 0..255
     * @param b {number} 0..255
     * @param a {number=} 0..255
     * @returns {*}
     */
    function color(r, g, b, a) {
        if (typeof r === 'undefined') {
            return Color.BLACK;
        }
        if (typeof r === 'string') {
            return Color.fromStringToColor(r);
        }
        if (typeof r === 'object') {
            return Color.createFromRGBA(r);
        }
        if (typeof a === "undefined") {
            a = 255;
        }
        return new Color(r / 255, g / 255, b / 255, a / 255);
    }
    cc.color = color;
    /**
     * @name Director
     * @memberOf cc
     * @deprecated
     */
    var Director;
    (function (Director) {
        var directorInstance = null;
        /**
         * Get always the same director instance.
         * @method cc.Director.getInstance
         * @returns {cc.node.Director}
         */
        function getInstance() {
            if (directorInstance === null) {
                directorInstance = new cc.node.Director();
            }
            return directorInstance;
        }
        Director.getInstance = getInstance;
    })(Director = cc.Director || (cc.Director = {}));
    cc.director = null;
    function scene() {
        return new cc.node.Scene();
    }
    cc.scene = scene;
    cc.Scene = cc.node.Scene;
    function animation() {
        return new cc.node.sprite.Animation();
    }
    cc.animation = animation;
    function sprite(p) {
        return new cc.node.Sprite(p);
    }
    cc.sprite = sprite;
    cc.Sprite = cc.node.Sprite;
    cc.SpriteBatchNode = cc.node.SpriteBatchNode;
    function layer() {
        return new cc.node.Node();
    }
    cc.layer = layer;
    cc.Layer = cc.node.Node;
    cc.Node = cc.node.Node;
    cc.LabelBMFont = cc.widget.Label;
    cc.LabelTTF = cc.widget.LabelTTF;
    function Animation(frames, duration) {
        var animation = new cc.node.sprite.Animation();
        animation.addFrames(frames);
        animation.setDelayPerUnit(duration);
        return animation;
    }
    cc.Animation = Animation;
    Animation.create = cc.animation;
    cc.TransitionSlideInL = function (time_in_secs, scene) {
        return new cc.transition.TransitionSlideInL(time_in_secs * 1000, scene);
    };
    cc.TransitionSlideInR = function (time_in_secs, scene) {
        return new cc.transition.TransitionSlideInR(time_in_secs * 1000, scene);
    };
    cc.TransitionSlideInT = function (time_in_secs, scene) {
        return new cc.transition.TransitionSlideInT(time_in_secs * 1000, scene);
    };
    cc.TransitionSlideInB = function (time_in_secs, scene) {
        return new cc.transition.TransitionSlideInB(time_in_secs * 1000, scene);
    };
    cc.TransitionFade = function (time_in_secs, scene) {
        return new cc.transition.TransitionFade(time_in_secs * 1000, scene);
    };
    cc.TEXT_ALIGNMENT_LEFT = 0;
    cc.TEXT_ALIGNMENT_CENTER = 1;
    cc.TEXT_ALIGNMENT_RIGHT = 2;
    cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
    cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
    cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
    cc.pAdd = cc.math.Vector.add;
    function clampf(value, min_inclusive, max_inclusive) {
        if (min_inclusive > max_inclusive) {
            var temp = min_inclusive;
            min_inclusive = max_inclusive;
            max_inclusive = temp;
        }
        return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
    }
    cc.clampf = clampf;
    function pClamp(p, min_inclusive, max_inclusive) {
        return cc.p(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y));
    }
    cc.pClamp = pClamp;
    cc.audioEngine = (function () {
        var ae = new cc.plugin.audio.AudioManager();
        return {
            playMusic: function (url) {
                ae.setMusic(url, true);
            },
            stopMusic: function () {
                ae.stopMusic();
            },
            stopAllEffects: function () {
                ae.stopEffects();
            },
            playEffect: function (name) {
                var r = cc.plugin.asset.AssetManager._resources[name];
                if (r) {
                    ae.playEffect(r);
                }
            },
            setMusicVolume: function (vol) {
                ae.setMusicVolume(vol);
            }
        };
    })();
    function rectIntersectsRect(r0, r1) {
        return r0.intersectsWith(r1);
    }
    cc.rectIntersectsRect = rectIntersectsRect;
    cc.KEY = cc.input.KEYS;
    // blending constants. Use node.setCompositeOperation instead.
    cc.ONE = 1;
    cc.ZERO = 0;
    cc.SRC_ALPHA = 0x0302;
    cc.SRC_ALPHA_SATURATE = 0x308;
    cc.SRC_COLOR = 0x300;
    cc.DST_ALPHA = 0x304;
    cc.DST_COLOR = 0x306;
    cc.ONE_MINUS_SRC_ALPHA = 0x0303;
    cc.ONE_MINUS_SRC_COLOR = 0x301;
    cc.ONE_MINUS_DST_ALPHA = 0x305;
    cc.ONE_MINUS_DST_COLOR = 0x0307;
    cc.ONE_MINUS_CONSTANT_ALPHA = 0x8004;
    cc.ONE_MINUS_CONSTANT_COLOR = 0x8002;
})(cc || (cc = {}));
/// <reference path="./AssetManager.ts"/>
/// <reference path="../loader/Resource.ts"/>
/// <reference path="../asset/AssetManager.ts"/>
var cc;
(function (cc) {
    var path = {
        join: function () {
            var l = arguments.length;
            var result = "";
            for (var i = 0; i < l; i++) {
                result = (result + (result == "" ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
            }
            return result;
        },
        extname: function (pathStr) {
            var temp = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(pathStr);
            return temp ? temp[1] : null;
        },
        mainFileName: function (fileName) {
            if (fileName) {
                var idx = fileName.lastIndexOf(".");
                if (idx !== -1)
                    return fileName.substring(0, idx);
            }
            return fileName;
        },
        basename: function (pathStr, extname) {
            var index = pathStr.indexOf("?");
            if (index > 0)
                pathStr = pathStr.substring(0, index);
            var reg = /(\/|\\\\)([^(\/|\\\\)]+)$/g;
            var result = reg.exec(pathStr.replace(/(\/|\\\\)$/, ""));
            if (!result)
                return null;
            var baseName = result[2];
            if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() == extname.toLowerCase())
                return baseName.substring(0, baseName.length - extname.length);
            return baseName;
        },
        dirname: function (pathStr) {
            return pathStr.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, '$2');
        },
        changeExtname: function (pathStr, extname) {
            extname = extname || "";
            var index = pathStr.indexOf("?");
            var tempStr = "";
            if (index > 0) {
                tempStr = pathStr.substring(index);
                pathStr = pathStr.substring(0, index);
            }
            index = pathStr.lastIndexOf(".");
            if (index < 0)
                return pathStr + extname + tempStr;
            return pathStr.substring(0, index) + extname + tempStr;
        },
        changeBasename: function (pathStr, basename, isSameExt) {
            if (basename.indexOf(".") == 0)
                return this.changeExtname(pathStr, basename);
            var index = pathStr.indexOf("?");
            var tempStr = "";
            var ext = isSameExt ? this.extname(pathStr) : "";
            if (index > 0) {
                tempStr = pathStr.substring(index);
                pathStr = pathStr.substring(0, index);
            }
            index = pathStr.lastIndexOf("/");
            index = index <= 0 ? 0 : index + 1;
            return pathStr.substring(0, index) + basename + ext + tempStr;
        }
    };
    function getResource(id) {
        var res = cc.plugin.asset.AssetManager._resources;
        return res[id];
    }
    var spriteFrameCache = (function () {
        function spriteFrameCache() {
        }
        spriteFrameCache.addSpriteFrames = function (plist_url_file) {
            var plist = getResource(plist_url_file);
            var imageName = plist[0].metadata.realTextureFileName;
            var imageResFile = path.changeBasename(plist_url_file, imageName || ".png", false);
            var resource = cc.plugin.asset.AssetManager._resources[imageResFile];
            cc.plugin.asset.AssetManager.addImage(resource, imageResFile);
            cc.director._renderer.prepareTexture(cc.plugin.asset.AssetManager.getTexture(imageResFile));
            cc.plugin.asset.AssetManager.addSpriteFramesFromFrameWithPLIST(imageResFile, plist);
        };
        spriteFrameCache.getSpriteFrame = function (name) {
            return cc.plugin.asset.AssetManager.getSpriteFrame(name);
        };
        return spriteFrameCache;
    })();
    cc.spriteFrameCache = spriteFrameCache;
    var textureCache = (function () {
        function textureCache() {
        }
        textureCache.addImage = function (name) {
            var image = getResource(name);
            var texture = cc.plugin.asset.AssetManager.addImage(image, name);
            cc.director._renderer.prepareTexture(texture);
            return texture;
        };
        return textureCache;
    })();
    cc.textureCache = textureCache;
    var animationCache = (function () {
        function animationCache() {
        }
        animationCache.addAnimation = function (animation, name) {
            cc.plugin.asset.AssetManager.addAnimation(animation, name);
        };
        animationCache.getAnimation = function (name) {
            return cc.plugin.asset.AssetManager.getAnimationById(name);
        };
        return animationCache;
    })();
    cc.animationCache = animationCache;
})(cc || (cc = {}));
/**
 * License: see license.txt file.
 */
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="../node/FastSprite.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="../action/Action.ts"/>
var cc;
(function (cc) {
    var initializing = false;
    // The base Class implementation (does nothing)
    var _Class = function () {
    };
    // Create a new Class that inherits from this class
    _Class.extend = function (extendingProt) {
        var _super = this.prototype;
        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;
        // The dummy class constructor
        var CCClass = function () {
            // All construction is actually done in the ctor method
            if (!initializing && typeof this.ctor !== "undefined") {
                this.ctor.apply(this, arguments);
            }
        };
        // Populate our constructed prototype object
        CCClass.prototype = prototype;
        // Enforce the constructor to be what we expect
        CCClass.prototype.constructor = CCClass;
        CCClass.superclass = _super;
        // And make this class extendable
        CCClass.extend = _Class.extend;
        CCClass["__CLASS"] = name;
        extendingProt = (typeof extendingProt === "function" ? extendingProt() : extendingProt);
        for (var fname in extendingProt) {
            var isFunc = typeof extendingProt[fname] === 'function';
            var overrideIsFunc = typeof prototype[fname] === 'function';
            // ctor (wrong) idiom.
            if (fname === 'ctor') {
                prototype[fname] = (function (name, fn, superconstructor) {
                    return function () {
                        var tmp = this._super;
                        this._super = function () {
                            superconstructor.apply(this, arguments);
                        };
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;
                        return ret;
                    };
                })(fname, extendingProt[fname], this);
            }
            else if (isFunc && overrideIsFunc && /\b_super\b/.test(extendingProt[fname])) {
                // function with overriden function that uses _super in code
                prototype[fname] = (function (name, fn) {
                    return function () {
                        var tmp = this._super;
                        // Add a new ._super() method that is the same method
                        // but on the super-Class
                        this._super = _super[name];
                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;
                        return ret;
                    };
                })(fname, extendingProt[fname]);
            }
            else {
                // Check if we're overwriting an existing function
                prototype[fname] = extendingProt[fname];
            }
        }
        return CCClass;
    };
    cc.node.Node.extend = _Class.extend;
    cc.node.Sprite.extend = _Class.extend;
    cc.node.FastSprite.extend = _Class.extend;
    cc.node.SpriteBatchNode.extend = _Class.extend;
    cc.node.Scene.extend = _Class.extend;
    cc.action.Action.extend = _Class.extend;
    cc.Class = _Class;
})(cc || (cc = {}));
