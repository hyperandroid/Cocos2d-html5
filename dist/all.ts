/**
 * License: see license.txt file.
 */

/**
 * @name cc
 * @namespace
 */

/**
 * Namespace for Action related objects.
 * @name action
 * @namespace
 * @memberOf cc
 */

/**
 * Namespace for math related stuff: vector, matrix, color, etc.
 * @name math
 * @namespace
 * @memberOf cc
 */

/**
 * Namespace for path related stuff: Segment, SegmentLine, SegmentBezier, etc.
 * @name path
 * @namespace
 * @memberOf cc.math
 */

/**
 * Namespace for Localization messages and utilities.
 * @name locale
 * @namespace
 * @memberOf cc
 */

/**
 * Namespace for Scene transitions.
 * @name transition
 * @namespace
 * @memberOf cc
 */

/**
 * Debug object.
 * @name Debug
 * @memberOf cc
 * @namespace
 */

/**
 * Namespace for nodes.
 * @name node
 * @namespace
 * @memberOf cc
 */

/**
 * Namespace for Sprite stuff
 * @name sprite
 * @namespace
 * @memberOf cc.node
 */

/**
 * Namespace for utilities.
 * @name util
 * @namespace
 * @memberOf cc
 */

/**
 * Namespace for render related objects.
 * @name render
 * @namespace
 * @memberOf cc
 */

/**
 * Namespace for renderer shader related objects.
 * @name shader
 * @namespace
 * @memberOf cc.render
 */

/**
 * Namespace for system plugins. Plugins are optional pieces of code.
 * @name plugin
 * @namespace
 * @memberOf cc
 */

/**
 * Namespace for resources management.
 * @name loader
 * @namespace
 * @memberOf cc.plugin
 */

/**
 * Namespace for in-game assets.
 * @name asset
 * @namespace
 * @memberOf cc.plugin
 */

/**
 * Namespace for texture related things like TexturePacker, etc.
 * @name texture
 * @namespace
 * @memberOf cc.plugin
 */

/**
 * Namespace for audio related objects.
 * @name audio
 * @memberOf cc.plugin
 * @namespace
 */

/**
 * Namespace for automatic node layout.
 * @name layout
 * @memberOf cc.plugin
 * @namespace
 */

/**
 * Namespace for input subsytem.
 * @name input
 * @namespace
 * @memberOf cc
 */

/**
 * Namespace for game subsytem.
 * @name game
 * @namespace
 * @memberOf cc
 */

/**
 * Namespace for widgets: buttons, labels, etc.
 * @name widget
 * @namespace
 * @memberOf cc
 */

module cc {

    (function() {
        console.log('%c','padding:140px 150px;line-height:300px;background:url(http://files.cocos2d-x.org/images/orgsite/logo.png) no-repeat;');
    })();

    (function() {
        var frameTime = 1000 / 60;
        var lastTime = new Date().getTime();

        var stTime = function (callback) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, frameTime - (currTime - lastTime));
            var id = window.setTimeout(function () {
                    callback();
                },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

        var ctTime = function (id) {
            clearTimeout(id);
        };

        var win:any = window;

        win.requestAnimFrame = win.requestAnimationFrame ||
            win.webkitRequestAnimationFrame ||
            win.mozRequestAnimationFrame ||
            win.oRequestAnimationFrame ||
            win.msRequestAnimationFrame ||
            stTime;

        win.cancelAnimationFrame = win.cancelAnimationFrame ||
            win.cancelRequestAnimationFrame ||
            win.msCancelRequestAnimationFrame ||
            win.mozCancelRequestAnimationFrame ||
            win.oCancelRequestAnimationFrame ||
            win.webkitCancelRequestAnimationFrame ||
            win.msCancelAnimationFrame ||
            win.mozCancelAnimationFrame ||
            win.webkitCancelAnimationFrame ||
            win.oCancelAnimationFrame ||
            ctTime;
    })();
}
/**
 * License: see license.txt file.
 */

module cc.Debug {

    "use strict";


    /**
     * Runtime debug level.
     * if DEBUG, a error message will throw an exception.
     * in RELEASE, the exception is not thrown.
     *
     * @tsenum cc.Debug.RuntimeDebugLevel
     */
    export enum RuntimeDebugLevel {

        DEBUG = 0,
        RELEASE = 1
    }

    var enabled= true;
    export function EnableConsole( b:boolean ) {
        enabled= b;
    }

    /**
     * Current Runtime debug level. DEBUG by default.
     * @member cc.Debug.DEBUG_LEVEL
     * @type {RuntimeDebugLevel}
     */
    export var DEBUG_LEVEL : RuntimeDebugLevel = RuntimeDebugLevel.DEBUG;

    /**
     * Debug message levels.
     *
     * @tsenum cc.Debug.DebugLevel
     */
    export enum DebugLevel {
        Info = 0,
        Warning = 1,
        Error = 2
    }

    var __consoleDecoration = [
        "",
        "background: orange; color: #000",
        "background: #a00; color: #fff",
    ];
    var __defaultDecoration = "background: #fff; color: #000";

    /**
     * Show a message in the console.
     * @method cc.Debug.debug
     * @param level {cc.Debug.RuntimeDebugLevel} debug level criticism
     * @param msg {string} message to show
     * @param rest {Array<any>} other parameters to show in console.
     */
    export function debug( level : DebugLevel, msg : string, rest : Array<any> ) {

        if ( !enabled ) {
            return;
        }

        console.log("%c%s:%c %s", __consoleDecoration[level], DebugLevel[level], __defaultDecoration, msg );
        if ( rest.length ) {
            console.log( rest );
        }

        if ( level===DebugLevel.Error && DEBUG_LEVEL===RuntimeDebugLevel.DEBUG ) {
            throw msg;
        }
    }

    /**
     * Show an error message.
     * @method cc.Debug.error
     * @param msg {string} error message.
     * @param rest {Array<any>} other elements to show in console.
     */
    export function error( msg : string, ...rest : Array<any> ) : void {
        cc.Debug.debug( DebugLevel.Error, msg, rest );
    }

    /**
     * Show a warning message.
     * @method cc.Debug.warn
     * @param msg {string} error message.
     * @param rest {Array<any>} other elements to show in console.
     */
    export function warn( msg : string, ...rest : Array<any> ) : void {
        cc.Debug.debug( DebugLevel.Warning, msg, rest );
    }

    /**
     * Show an info message.
     * @method cc.Debug.info
     * @param msg {string} error message.
     * @param rest {Array<any>} other elements to show in console.
     */
    export function info( msg : string, ...rest : Array<any> ) : void {
        cc.Debug.debug( DebugLevel.Info, msg, rest );
    }

}
/**
 * License: see license.txt file.
 */


module cc.locale {

    "use strict";

    //////////// Nodes

    /**
     * Calling removeFromParent and the Node has no parent.
     * @member cc.locale.NODE_WARN_REMOVEFROMPARENT_WITH_NO_PARENT
     * @type {string}
     */
    export var NODE_WARN_REMOVEFROMPARENT_WITH_NO_PARENT: string = "Calling removeFromParent and the Node has no parent.";

    /**
     * Invalid pattern for naming.
     * @member cc.locale.ERR_NODE_NAME_INVALID
     * @type {string}
     */
    export var ERR_NODE_NAME_INVALID : string = "Node name invalid. Must match [A-Za-z0-9_]+";

    /**
     * Invalid pattern for a call to <code>node.enumerateChildren</code>.
     * @member cc.locale.MSG_WRONG_ENUMERATE_PATTERN
     * @type {string}
     */
    export var MSG_WRONG_ENUMERATE_PATTERN : string = "Wrongly defined search pattern path";

    /**
     * A call to <code>node.enumerateChildren</code> goes beyond root node.
     * @member cc.locale.MSG_ENUMERATE_UNDERFLOW
     * @type {string}
     */
    export var MSG_ENUMERATE_UNDERFLOW : string = "Enumerate path underflow. Trying to go above root node.";

    /**
     * Trying to add a node with parent to another node.
     * @member cc.locale.MSG_ERROR_NODE_WITH_PARENT
     * @type {string}
     */
    export var MSG_ERROR_NODE_WITH_PARENT : string = "A node added as child has already a parent.";

    /**
     * A call to <code>director.runScene</code> is made in an already running scene.
     * @member cc.locale.ERR_RUNNING_ALREADY_EXISTING_SCENE
     * @type {string}
     */
    export var ERR_RUNNING_ALREADY_EXISTING_SCENE : string = "runScene trying to run already existing Scene.";

    /**
     * A call to <code>director.popScene</code> to an empty director.
     * @member cc.locale.ERR_DIRECTOR_POPSCENE_UNDERFLOW
     * @type {string}
     */
    export var ERR_DIRECTOR_POPSCENE_UNDERFLOW : string = "Director popScene underflow.";

    /**
     * A call to <code>director.startAnimation</code> to a director in RUNNING state.
     * @member cc.locale.WARN_START_ANIMATION_ON_RUNNING_DIRECTOR
     * @type {string}
     */
    export var WARN_START_ANIMATION_ON_RUNNING_DIRECTOR : string = "Starting animation on a running director.";

    export var WARN_NODE_ATTRIBUTE_DOES_NOT_EXIST: string = "Attribute does not exist in Node object.";

    export var WARN_DEPRECATED_SETBLENDFUNC:string = "Deprecated call. Use setCompositeOperation instead.";

    //////////// Path tracing

    /**
     * A call to an empty path.getCurrentTracePosition.
     * @member cc.locale.ERR_TRACER_EMPTY
     * @type {string}
     */
    export var WARN_TRACER_EMPTY : string = "Path not initialized so no current trace position. Defaulting to (0,0).";

    /**
     * A tracing operation (lineTo, quadraticTo, etc.) is being performed in a closed SubPath.
     * @member cc.locale.WARN_TRACE_ON_CLOSED_SUBPATH
     * @type {string}
     */
    export var WARN_TRACE_ON_CLOSED_SUBPATH : string = "Tracing on a closed SubPath.";

    /**
     * A closePath call is performed on an empty SubPath. No previous tracing happened on it.
     * @member cc.locale.WARN_CLOSE_EMPTY_SUBPATH
     * @type {string}
     */
    export var WARN_CLOSE_EMPTY_SUBPATH : string = "Closing empty SubPath.";

    /**
     * A moveTo call is made to a SubPath with segments.
     * @member cc.locale.WARN_MOVETO_IN_NON_EMPTY_SUBPATH
     * @type {string}
     */
    export var WARN_MOVETO_IN_NON_EMPTY_SUBPATH: string = "MoveTo in non empty SubPath.";

    /**
     * A getStartingPoint call is made to an empty SubPath.
     * @member cc.locale.ERR_SUBPATH_NOT_STARTED
     * @type {string}
     */
    export var ERR_SUBPATH_NOT_STARTED: string = "getStartingPoint called in an empty path.";

    ///////////// Sprites

    /**
     * An operation is made in a SpriteFrame that has no associated texture.
     * @member cc.locale.ERR_SPRITE_FRAME_NO_TEXTURE
     * @type {string}
     */
    export var ERR_SPRITE_FRAME_NO_TEXTURE: string = "SpriteFrame w/o Texture.";

    /**
     * Trying to create a new Sprite with wrong SpriteInitializer data.
     * @member cc.locale.ERR_SPRITE_CONSTRUCTOR_PARAM_ERROR
     * @type {string}
     */
    export var ERR_SPRITE_CONSTRUCTOR_PARAM_ERROR: string = "No suitable SpriteInitializer to Sprite constructor.";

    /**
     * Calling Sprite constructor with V3 signature.
     * @member cc.locale.WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL
     * @type {string}
     */
    export var WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL: string= "Sprite constructor call deprecated.";

    /**
     * Trying to create a add a SpriteFrame with an existing name in cache.
     * @member cc.locale.WARN_SPRITEFRAME_CREATING_SUBFRAME_WITH_EXISTING_NAME
     * @type {string}
     */
    export var WARN_SPRITEFRAME_CREATING_SUBFRAME_WITH_EXISTING_NAME: string= "Adding a SpriteFrame with existing name in cache.";

    export var SPRITEFRAME_WARN_TEXTURE_NOT_WEBGL_INITIALIZED:string= "Lazily initializing a webgl texture (at draw time).";

    ////////////// Resources

    /**
     * Loaded a resource of unknown type.
     * @member cc.locale.WARN_RESOURCE_OF_UNKNOWN_TYPE
     * @type {string}
     */
    export var WARN_RESOURCE_OF_UNKNOWN_TYPE: string = "Loaded resource of unkown type.";

    export var ASSETMANAGER_WARN_SPRITEFRAME_NOT_FOUND: string= "SpriteFrame with id not found.";

    export var ERR_FONT_GLYPTH_NOT_IN_FRAME: string= "A glitph definition is not in Atlas Spriteframe area.";

    ////////////// Input

    export var INPUT_WARN_WRONG_ROOT_NODE : string= "Adding a path to the wrong root node.";

    ////////////// Loader

    export var LOADER_JSON_PARSE_ERROR:string= "JSON parse error while loading resource.";

    export var WARN_FULLSCREEN_ERROR:string= "Full screen mode error.";

    ////////////// audio

    export var ERR_SOUND_POOL_EMPTY:string= "Can't play, sound pool is empty.";


}
/**
 * License: see license.txt file.
 */


module cc.math {

    "use strict";

    /**
     * @class cc.math.RGBAColor
     * @interface
     * @classdesc
     *
     * Interface for a RGB color with optional alpha value.
     * <br>
     * It is expected that r,g,b,a color components be normalized values [0..1]
     */
    export interface RGBAColor {
        /**
         * Color red component.
         * @member cc.math.RGBAColor#r
         * @type {number}
         */
        r : number;
        /**
         * Color green component.
         * @member cc.math.RGBAColor#r
         * @type {number}
         */
        g : number;
        /**
         * Color blue component.
         * @member cc.math.RGBAColor#r
         * @type {number}
         */
        b : number;
        /**
         * Color alpha component.
         * @member cc.math.RGBAColor#r
         * @type {number}
         */
        a? : number;
    }

    /**
     * @class cc.math.Color
     * @classdesc
     *
     * A color is represented by 4 components: RGBA encapsulated in a Float32Array.
     * <br>
     * Internally, Color components are stored as normalized color values 0..1
     * <br>
     * This object has cache capabilities for internal color string representation so calling repeatedly
     * <code>getFillStyle</code>, <code>getHexRGB</code> and <code>getHexRGBA</code> will always be fast.
     */
    export class Color  {

        /**
         * Should rebuild canvas string representation cache ?
         * @member cc.math.Color#_dirty
         * @type {boolean}
         * @private
         */
        _dirty : boolean = true;

        /**
         * Should rebuild hex string representation cache ?
         * @member cc.math.Color#_dirtyHex
         * @type {boolean}
         * @private
         */
        _dirtyHex : boolean = true;

        /**
         * Color components.
         * @member cc.math.Color#_color
         * @type {Float32Array}
         * @private
         */
        _color : Float32Array;

        /**
         * cached canvas rgba string representation.
         * @member cc.math.Color#_fillStyle
         * @type {string}
         * @private
         */
        _fillStyle : string;

        /**
         * cached hex string representation.
         * @member cc.math.Color#_hexRGB
         * @type {string}
         * @private
         */
        _hexRGB : string;

        /**
         * cached hex rgba string representation.
         * @member cc.math.Color#_hexRGBA
         * @type {string}
         * @private
         */
        _hexRGBA : string;


        /**
         * Instantiate a color.
         * @method cc.math.Color#constructor
         * @param r {number} 0..1
         * @param g {number} 0..1
         * @param b {number} 0..1
         * @param a {number} 0..1
         */
        constructor( r : number=1, g : number = 1, b : number = 1, a : number = 1) {
            this._color= new Float32Array(4);
            this._color[0]= r;
            this._color[1]= g;
            this._color[2]= b;
            this._color[3]= a;
        }

        /**
         * Get the color's RGB representation.
         * @method cc.math.Color#getHexRGB
         * @returns {string} "#RRGGBB" color representation
         */
        getHexRGB() : string {

            if (this._dirtyHex) {
                this.__calculateHexStyle();
            }

            return this._hexRGB;
        }

        /**
         * Get the color's RGB representation.
         * @method cc.math.Color#getHexRGBA
         * @returns {string} "#RRGGBBAA" color representation
         */
        getHexRGBA() : string {
            if ( this._dirtyHex ) {
                this.__calculateHexStyle();
            }

            return this._hexRGBA;
        }

        /**
         * Internal helper to calculate hex string color representation.
         * @method cc.math.Color#__calculateHexStyle
         * @private
         */
        __calculateHexStyle() : void {
            var r= ((255*this._color[0])>>0).toString(16).toUpperCase();
            var g= ((255*this._color[1])>>0).toString(16).toUpperCase();
            var b= ((255*this._color[2])>>0).toString(16).toUpperCase();

            this._hexRGB= "#"+
                    (r.length<2 ? "0" : "")+r+
                    (g.length<2 ? "0" : "")+g+
                    (b.length<2 ? "0" : "")+b;

            var a= ((255*this._color[3])>>0).toString(16).toUpperCase();
            this._hexRGBA=  this._hexRGB + (a.length<2 ? "0" : "")+a;
        }

        /**
         * Internal helper to calculate canvas string color representation.
         * @method cc.math.Color#__calculateFillStyle
         * @private
         */
        __calculateFillStyle() : void {
            this._fillStyle = "rgba(" +
                    ((this._color[0] * 255) >> 0) + "," +
                    ((this._color[1] * 255) >> 0) + "," +
                    ((this._color[2] * 255) >> 0) + "," +
                      this._color[3] +
                    ")";

            this._dirty= false;
        }

        /**
         * Get the color's canvas string representation.
         * If color changed, the string will be recalculated.
         * @method cc.math.Color#getFillStyle
         * @returns {string}
         */
        getFillStyle() : string {
            if ( this._dirty ) {
                this.__calculateFillStyle();
            }
            return this._fillStyle;
        }

        /**
         * Get red color component.
         * @name cc.math.Color#get:r
         * @type {number}
         */
        get r() : number {
            return this._color[0];
        }

        /**
         * Set red color component.
         * @name cc.math.Color#set:r
         * @param v {number} red component. Should be in the range 0..1
         */
        set r(v : number) {
            this._color[0]= v;
            this._dirty= true;
            this._dirtyHex= true;
        }

        /**
         * Get green color component.
         * @name cc.math.Color#get:g
         * @type {number}
         */
        get g() : number {
            return this._color[1];
        }

        /**
         * Set green color component.
         * @name cc.math.Color#set:g
         * @param v {number} green component. Should be in the range 0..1
         */
        set g(v : number) {
            this._color[1]= v;
            this._dirty= true;
            this._dirtyHex= true;
        }

        /**
         * Get blue color component.
         * @name cc.math.Color#get:b
         * @type {number}
         */
        get b() : number {
            return this._color[2];
        }

        /**
         * Set blue color component.
         * @name cc.math.Color#set:b
         * @param v {number} blue component. Should be in the range 0..1
         */
        set b(v : number) {
            this._color[2]= v;
            this._dirty= true;
            this._dirtyHex= true;
        }

        /**
         * Get alpha color component.
         * @name cc.math.Color#get:a
         * @type {number}
         */
        get a() : number {
            return this._color[3];
        }

        /**
         * Set alpha color component.
         * @name cc.math.Color#set:a
         * @param v {number} alpha component. Should be in the range 0..1
         */
        set a(v : number) {
            this._color[3]= v;
            this._dirty= true;
            this._dirtyHex= true;
        }

        static createFromRGBA( c : string ) : Color;
        static createFromRGBA( c : RGBAColor ) : Color;

        /**
         * Crate a Color instance from r,g,b,a or string or RGBAColor
         * @method cc.math.Color.createFromRGBA
         * @param r {cc.math.RGBAColor | string | number} if number, red color component. otherwise, color
         *      representation in string or cc.math.RGBAColor
         * @param g {number=} Color green component,
         * @param b {number=} Color blue component,
         * @param a {number=} Color alpha component,
         * @returns {cc.math.Color}
         */
        static createFromRGBA( r : any, g? : number, b?: number, a? : number ) : Color {
            if ( typeof r === "object" ) {
                var c= <RGBAColor>r;
                return new Color( c.r/255, c.g/255, c.b/255, c.a/255 );
            } else if (typeof r === "number" ) {
                return new Color(r / 255, g / 255, b / 255, a / 255);
            } else if (typeof r === "string" ) {
                return Color.fromStringToColor(r);
            }

            return Color.WHITE;
        }

        /**
         * Parse a color of the from rgb(rrr,ggg,bbb) or rgba(rrr,ggg,bbb,a)
         * This method assumes the color parameter starts with rgb or rgba
         * @method cc.math.Color.fromRGBStringToColor
         * @param color {string}
         */
        static fromRGBStringToColor( color : string ) {
            color= color.toLowerCase();

            var skip= 4;
            if (color.indexOf("rgba")===0) {
                skip=5;
            }

            color= color.substring( skip, color.length-1 );
            var colors= color.split(",");

            var c;
            if ( colors.length===3 ) {
                c= new Color( parseInt(colors[0])/255,parseInt(colors[1])/255,parseInt(colors[2])/255 );
            } else {
                c= new Color( parseInt(colors[0])/255,parseInt(colors[1])/255,parseInt(colors[2])/255, parseInt(colors[3]) );
            }
            return c;
        }

        /**
         * Parse a CSS color. If the color is not recognizable will return MAGENTA;
         * @method cc.math.Color.fromStringToColor
         * @param hex {string} of the form RGB, RGBA, RRGGBB, RRGGBBAA, #RGB, #RGBA, #RRGGBB, #RRGGBBAA, rgb(rrr,ggg,bbb), rgba(rrr,ggg,bbb,a)
         * @returns {cc.math.Color}
         */
        static fromStringToColor( hex : string ) : Color {

            hex= hex.toLowerCase();

            if ( hex.indexOf("rgb")===0 || hex.indexOf("rgba")===0 ) {
                return Color.fromRGBStringToColor(hex);
            }

            if ( hex.charAt(0)==="#") {
                hex = hex.substring(1);
            }

            if ( hex.length!==3 && hex.length!==4 && hex.length!==6 && hex.length!==8 ) {
                return Color.MAGENTA;
            }

            var r,g,b,a;

            if ( hex.length<6 ) {
                r= parseInt(hex.charAt(0), 16);
                g= parseInt(hex.charAt(1), 16);
                b= parseInt(hex.charAt(2), 16);

                if ( hex.length===4 ) {
                    a= parseInt(hex.charAt(3), 16);
                } else {
                    a= 15;
                }

                return new Color( r/15,g/15,b/15,a/15 );

            } else {
                r= parseInt(hex.substring(0,2), 16);
                g= parseInt(hex.substring(2,4), 16);
                b= parseInt(hex.substring(4,6), 16);

                // ALPHA
                if ( hex.length===8 ) {
                    a= parseInt(hex.substring(6,8), 16);
                } else {
                    a= 255;
                }

                return new Color( r/255.0,g/255.0,b/255.0,a/255.0 );
            }
        }

        /**
         * Shamelessly ripped from: http://beesbuzz.biz/code/hsv_color_transforms.php
         * Thanks for the awesome code.
         *
         * Convert a color value based on HSV parameters.
         *
         * @param c {cc.math.Color}
         * @param H {number} angle
         * @param S {number}
         * @param V {number}
         * @returns {cc.math.Color} modified color.
         */
        static HSV( c:cc.math.Color, H:number, S:number, V:number ) : Color {

            var VSU:number = V*S*Math.cos(H*Math.PI/180);
            var VSW:number = V*S*Math.sin(H*Math.PI/180);

            var r = (.299*V+.701*VSU+.168*VSW)*c.r +
                (.587*V-.587*VSU+.330*VSW)*c.g +
                (.114*V-.114*VSU-.497*VSW)*c.b;
            var g = (.299*V-.299*VSU-.328*VSW)*c.r +
                (.587*V+.413*VSU+.035*VSW)*c.g +
                (.114*V-.114*VSU+.292*VSW)*c.b;
            var b = (.299*V-.3*VSU+1.25*VSW)*c.r +
                (.587*V-.588*VSU-1.05*VSW)*c.g +
                (.114*V+.886*VSU-.203*VSW)*c.b;

            c.r= r;
            c.g= g;
            c.b= b;
            return c;
        }

        /**
         * Transparent black color.
         * @member cc.math.Color.TRANSPARENT_BLACK
         * @type {cc.math.Color}
         */
        static TRANSPARENT_BLACK : Color= new Color(0,0,0,0);

        /**
         * Opaque black color.
         * @member cc.math.Color.BLACK
         * @type {cc.math.Color}
         */
        static BLACK : Color= new Color(0,0,0,1.0);

        /**
         * Opaque red color.
         * @member cc.math.Color.RED
         * @type {cc.math.Color}
         */
        static RED : Color= new Color(1.0,0,0,1.0);

        /**
         * Opaque green color.
         * @member cc.math.Color.GREEN
         * @type {cc.math.Color}
         */
        static GREEN : Color= new Color(0,1.0,0,1.0);

        /**
         * Opaque blue color.
         * @member cc.math.Color.BLUE
         * @type {cc.math.Color}
         */
        static BLUE : Color= new Color(0,0,1.0,1.0);

        /**
         * Opaque white color.
         * @member cc.math.Color.WHITE
         * @type {cc.math.Color}
         */
        static WHITE : Color= new Color(1.0,1.0,1.0,1.0);

        /**
         * Opaque magenta color.
         * @member cc.math.Color.MAGENTA
         * @type {cc.math.Color}
         */
        static MAGENTA : Color= new Color(1.0,0,1.0,1.0);

        /**
         * Opaque yellow color.
         * @member cc.math.Color.YELLOW
         * @type {cc.math.Color}
         */
        static YELLOW : Color= new Color(1.0,1.0,0,1.0);

        /**
         * Opaque cyan color.
         * @member cc.math.Color.CYAN
         * @type {cc.math.Color}
         */
        static CYAN : Color= new Color(0,1.0,1.0,1.0);

    }
}
/**
 * License: see license.txt file.
 */


/// <reference path="../node/Node.ts"/>
/// <reference path="../render/RenderingContext.ts"/>

module cc.math {

    "use strict";

    import Node= cc.node.Node;
    import RenderingContext= cc.render.RenderingContext;

    var __m0 : Float32Array= new Float32Array([1,0,0, 0,1,0, 0,0,1]);

    /**
     * @class cc.math.Matrix3
     *
     * @classdesc
     *
     * Affine transformation matrix Object.
     * <br>
     * The Matrix3 <strong>IS NOT</strong> a general purpose matrix calculation package. Do not use for anything else than affine
     * transformation purposes inside the Cocos2D HTML5 engine.
     */
    export class Matrix3 {


        /**
         * Build a new Matrix3 object.
         * @method cc.math.Matrix3#constructor
         */
        static create() : Float32Array {
            var matrix= new Float32Array(9);
            Matrix3.identity(matrix);

            return matrix;
        }

        /**
         * Turn the matrix to identity.
         * @method cc.math.Matrix3.identity
         * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
         * @returns {cc.math.Matrix3}
         */
        static identity(matrix:Float32Array)  {
            matrix[0]= 1.0;
            matrix[1]= 0.0;
            matrix[2]= 0.0;

            matrix[3]= 0.0;
            matrix[4]= 1.0;
            matrix[5]= 0.0;

            matrix[6]= 0.0;
            matrix[7]= 0.0;
            matrix[8]= 1.0;

        }

        static translateBy( matrix:Float32Array, dtx:number, dty:number ) {
            var a= matrix[0];
            var b= matrix[1];
            var c= matrix[3];
            var d= matrix[4];
            var tx= matrix[2];
            var ty= matrix[5];

            matrix[2]= a*dtx + b*dty + tx;
            matrix[5]= c*dtx + d*dty + ty;
        }

        static scaleBy(  matrix:Float32Array, sx:number, sy:number ) {

            matrix[0]*= sx;
            matrix[1]*= sy;

            matrix[3]*= sx;
            matrix[4]*= sy;
        }

        static rotateBy( matrix:Float32Array, angle:number ) {
            cc.math.Matrix3.setRotate( __m0, angle );
            cc.math.Matrix3.multiply( matrix, __m0 );
        }

        /**
         * Copy a source to a destination matrix
         * @method cc.math.Matrix#copy
         * @param source {Float32Array} matrix coefficients. horizontal vectors.
         * @param destination {Float32Array} matrix coefficients. horizontal vectors.
         */
        static copy( source:Float32Array, destination:Float32Array ) : void {
            destination.set( source );
        }

        static set( m:Float32Array, a:number, b:number, c:number, d:number, tx:number, ty:number ) {
            m[0]= a;
            m[1]= b;
            m[2]= tx;
            m[3]= c;
            m[4]= d;
            m[5]= ty;
            m[6]= 0;
            m[7]= 0;
            m[8]= 1;

        }

        /**
         * Given a node, calculate a resulting matrix for position, scale and rotate.
         * @method cc.math.Matrix3.setTransformAll
         * @param mm {Float32Array} matrix coefficients. horizontal vectors.
         * @param node {cc.node.Node} a cc.node.Node instance
         */
        static setTransformAll( mm:Float32Array, node : Node ) {

            var c : number, s: number, _m00: number, _m01: number, _m10: number, _m11: number;
            var m00: number, m01: number, m02: number, m10: number, m11: number, m12: number;

            m00 = 1.0;
            m01 = 0.0;
            m10 = 0.0;
            m11 = 1.0;

            var cs= node._contentSize;

            m02 = node.x - node._positionAnchor.x * cs.width;
            m12 = node.y - node._positionAnchor.y * cs.height;

            var rx: number = node._transformationAnchor.x * cs.width;
            var ry: number = node._transformationAnchor.y * cs.height;

            m02 += m00 * rx + m01 * ry;
            m12 += m10 * rx + m11 * ry;

            var angle: number= -node.rotationAngle * Math.PI / 180.0;

            c = Math.cos(angle);
            s = Math.sin(angle);
            _m00 = m00;
            _m01 = m01;
            _m10 = m10;
            _m11 = m11;
            m00 = _m00 * c + _m01 * s;
            m01 = -_m00 * s + _m01 * c;
            m10 = _m10 * c + _m11 * s;
            m11 = -_m10 * s + _m11 * c;

            m00 = m00 * node.scaleX;
            m01 = m01 * node.scaleY;
            m10 = m10 * node.scaleX;
            m11 = m11 * node.scaleY;

            m02 += -m00 * rx - m01 * ry;
            m12 += -m10 * rx - m11 * ry;

            mm[0] = m00;
            mm[1] = m01;
            mm[3] = m10;
            mm[4] = m11;
            mm[2] = m02;
            mm[5] = m12;
        }

        /**
         * Given a node, calculate a resulting matrix for position and scale.
         * @method cc.math.Matrix3.setTransformScale
         * @param mm {Float32Array} matrix coefficients. horizontal vectors.
         * @param node {cc.node.Node} a cc.node.Node instance
         */
        static setTransformScale( mm:Float32Array, node : Node ) {

            var m00: number, m01: number, m02: number, m10: number, m11: number, m12: number;

            m00 = 1.0;
            m01 = 0.0;
            m10 = 0.0;
            m11 = 1.0;

            var cs= node._contentSize;

            m02 = node.x - node._positionAnchor.x * cs.width;
            m12 = node.y - node._positionAnchor.y * cs.height;

            var rx: number = node._transformationAnchor.x * cs.width;
            var ry: number = node._transformationAnchor.y * cs.height;

            m02 += m00 * rx + m01 * ry;
            m12 += m10 * rx + m11 * ry;

            m00 = m00 * node.scaleX;
            m01 = m01 * node.scaleY;
            m10 = m10 * node.scaleX;
            m11 = m11 * node.scaleY;

            m02 += -m00 * rx - m01 * ry;
            m12 += -m10 * rx - m11 * ry;

            mm[0] = m00;
            mm[1] = m01;
            mm[3] = m10;
            mm[4] = m11;
            mm[2] = m02;
            mm[5] = m12;
        }

        /**
         * Given a node, calculate a resulting matrix for position.
         * @method cc.math.Matrix3.setTransformTranslate
         * @param mm {Float32Array} matrix coefficients. horizontal vectors.
         * @param node {cc.node.Node} a cc.node.Node instance
         */
        static setTransformTranslate( mm:Float32Array, node:Node ) {

            var pa=node._positionAnchor;
            var cs=node._contentSize;
            var x: number = node.x - pa.x * cs.width;
            var y: number = node.y - pa.y * cs.height;
            mm[2] = x;
            mm[5] = y;
            mm[0] = 1.0;
            mm[1] = 0.0;
            mm[3] = 0.0;
            mm[4] = 1.0;
            mm[6] = 0.0;
            mm[7] = 0.0;
            mm[8] = 1.0;
        }

        /**
         * Multiply matrix m0 by matrix m1. modify m0.
         * <br>
         * Both matrices must be Matrix3 instances.
         * @method cc.math.Matrix3.multiply
         * @param m0 {Float32Array} matrix coefficients. horizontal vectors.
         * @param m1 {Float32Array} matrix coefficients. horizontal vectors.
         */
        static multiply(m0:Float32Array, m1:Float32Array ) {

            var mm0 : number = m1[0];
            var mm1 : number = m1[1];
            var mm2 : number = m1[2];
            var mm3 : number = m1[3];
            var mm4 : number = m1[4];
            var mm5 : number = m1[5];

            var tm0 : number = m0[0];
            var tm1 : number = m0[1];
            var tm2 : number = m0[2];

            m0[0] = tm0 * mm0 + tm1 * mm3;
            m0[1] = tm0 * mm1 + tm1 * mm4;
            m0[2] = tm0 * mm2 + tm1 * mm5 + tm2;

            var tm3 : number= m0[3];
            var tm4 : number= m0[4];
            var tm5 : number= m0[5];

            m0[3] = tm3 * mm0 + tm4 * mm3;
            m0[4] = tm3 * mm1 + tm4 * mm4;
            m0[5] = tm3 * mm2 + tm4 * mm5 + tm5;

            m0[6] = 0;
            m0[7] = 0;
            m0[8] = 1;
        }

        static premultiply(m1:Float32Array, m0:Float32Array ) {

            var mm0 : number = m1[0];
            var mm1 : number = m1[1];
            var mm2 : number = m1[2];
            var mm3 : number = m1[3];
            var mm4 : number = m1[4];
            var mm5 : number = m1[5];

            var tm0 : number = m0[0];
            var tm1 : number = m0[1];
            var tm2 : number = m0[2];

            __m0[0] = tm0 * mm0 + tm1 * mm3;
            __m0[1] = tm0 * mm1 + tm1 * mm4;
            __m0[2] = tm0 * mm2 + tm1 * mm5 + tm2;

            var tm3 : number= m0[3];
            var tm4 : number= m0[4];
            var tm5 : number= m0[5];

            __m0[3] = tm3 * mm0 + tm4 * mm3;
            __m0[4] = tm3 * mm1 + tm4 * mm4;
            __m0[5] = tm3 * mm2 + tm4 * mm5 + tm5;

            __m0[6] = 0;
            __m0[7] = 0;
            __m0[8] = 1;

            cc.math.Matrix3.copy( __m0, m1 );
        }

        /**
         * Transform a point by the matrix.
         * <br>
         * The point will be overwritten by the resulting point.
         * @method cc.math.Matrix3.transformPoint
         * @param tm {Float32Array} matrix coefficients. horizontal vectors.
         * @param point {cc.math.Point} Point or Vector to transform.
         */
        static transformPoint( tm:Float32Array, point : Point ) : Point {
            var x  :  number;
            var y  : number;

            x = point.x;
            y = point.y;
            point.x = x * tm[0] + y * tm[1] + tm[2];
            point.y = x * tm[3] + y * tm[4] + tm[5];

            return point;
        }

        /**
         * Set transformation coefficients for a RenderingContext.
         * @method cc.math.Matrix3.setRenderingContextTransform
         * @param mm {Float32Array} matrix coefficients. horizontal vectors.
         * @param ctx {cc.render.RenderingContext} a rendering context.
         */
        static setRenderingContextTransform( mm:Float32Array, ctx : RenderingContext ) {
            // TODO: set optional clamping capabilities. old mobile browsers.
            ctx.setTransform( mm[0], mm[3], mm[1], mm[4], mm[2], mm[5] );
        }

        /**
         * Set the matrix as follows
         * [ a b x ]
         * | c d y |
         * [ 0 0 1 ]
         * @method cc.math.Matrix3.setTransform
         * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
         * @param a {number}
         * @param b {number}
         * @param c {number}
         * @param d {number}
         * @param tx {number}
         * @param ty {number}
         */
        static setTransform( matrix:Float32Array, a : number, b:number, c:number, d:number, tx:number, ty:number ) {

            matrix[0] = a;
            matrix[3] = b;
            matrix[1] = c;
            matrix[4] = d;
            matrix[2] = tx;
            matrix[5] = ty;
            matrix[6] = 0;
            matrix[7] = 0;
            matrix[8] = 1;
        }

        /**
         * Concatenate the matrix with another matrix build of the coefficients set as parameters.
         * @method cc.math.Matrix3.transform
         * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
         * @param a {number}
         * @param b {number}
         * @param c {number}
         * @param d {number}
         * @param tx {number}
         * @param ty {number}
         */
        static transform(matrix:Float32Array, a:number, b:number, c:number, d:number, tx:number, ty:number) {
            Matrix3.setTransform( _workingMatrix, a,b,c,d,tx,ty);
            Matrix3.multiply(matrix, _workingMatrix);
        }

        /**
         * Make the matrix a translation matrix.
         * @method cc.math.Matrix3.setTranslate
         * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
         * @param x {number}
         * @param y {number}
         * @returns {cc.math.Matrix3} the same matrix.
         */
        static setTranslate( matrix:Float32Array, x : number, y : number ) {
            Matrix3.identity(matrix);
            matrix[2] = x;
            matrix[5] = y;
        }

        /**
         * Make the matrix a rotation matrix.
         * @method cc.math.Matrix3.setRotate
         * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
         * @param angle {number} angle in radians.
         * @returns {cc.math.Matrix3} the same matrix.
         */
        static setRotate( matrix:Float32Array, angle:number ) {
            Matrix3.identity(matrix);
            matrix[0] = Math.cos(angle);
            matrix[1] = -Math.sin(angle);
            matrix[3] = Math.sin(angle);
            matrix[4] = Math.cos(angle);
        }

        /**
         * Make the matrix a scale matrix.
         * @method cc.math.Matrix3.setScale
         * @param matrix {Float32Array} matrix coefficients. horizontal vectors.
         * @param x
         * @param y
         * @returns {cc.math.Matrix3}
         */
        static setScale( matrix:Float32Array, x:number, y:number )  {
            Matrix3.identity(matrix);
            matrix[0] = x;
            matrix[4] = y;

        }

        static inverse( matrix:Float32Array, res:Float32Array ) {

            var m00 = matrix[0];
            var m01 = matrix[1];
            var m02 = matrix[2];
            var m10 = matrix[3];
            var m11 = matrix[4];
            var m12 = matrix[5];
            var m20 = matrix[6];
            var m21 = matrix[7];
            var m22 = matrix[8];

            var determinant =   m00 * (m11 * m22 - m21 * m12) -
                                m10 * (m01 * m22 - m21 * m02) +
                                m20 * (m01 * m12 - m11 * m02);

            if (determinant === 0) {
                return Matrix3.identity(Matrix3.IDENTITY);
            }

            determinant = 1 / determinant;

            res[0] = (m11 * m22 - m12 * m21) * determinant;
            res[1] = (m02 * m21 - m01 * m22) * determinant;
            res[2] = (m01 * m12 - m02 * m11) * determinant;
            res[3] = (m12 * m20 - m10 * m22) * determinant;
            res[4] = (m00 * m22 - m02 * m20) * determinant;
            res[5] = (m02 * m10 - m00 * m12) * determinant;
            res[6] = (m10 * m21 - m11 * m20) * determinant;
            res[7] = (m01 * m20 - m00 * m21) * determinant;
            res[8] = (m00 * m11 - m01 * m10) * determinant;
        }

        /**
         * An identity Matrix3 static instance.
         * @member cc.math.Matrix3.IDENTITY
         * @type {cc.math.Matrix3}
         */
        static IDENTITY : Float32Array = Matrix3.create();
    }

    /**
     * Spare working matrix.
     * @member cc.math.Matrix3._workingMatrix
     * @type {cc.math.Matrix3}
     * @private
     */
    var _workingMatrix : Float32Array = cc.math.Matrix3.create();

}
/**
 * License: see license.txt file.
 */


module cc.math {

    export class Matrix4 {

        _matrix : Float32Array;

        constructor() {
            this._matrix= new Float32Array(16);
        }

    }
}
/**
 * License: see license.txt file.
 */


module cc.math {

    "use strict";

    /**
     * @class cc.math.Point
     * @interface
     * @classdesc
     *
     * A 2d or 3d point interface.
     *
     */
    export interface Point {
        /**
         * Point x coordinate.
         * @member cc.math.Point#x
         * @type {number}
         */
        x : number;
        /**
         * Point y coordinate.
         * @member cc.math.Point#y
         * @type {number}
         */
        y : number;

    }

    /**
     * @class cc.math.Vector
     * @classdesc
     *
     * Object represents a 2D or 3D vector.
     */
    export class Vector implements Point {

        /**
         * Point x coordinate.
         * @member cc.math.Vector#x
         * @type {number}
         */

        /**
         * Point y coordinate.
         * @member cc.math.Vector#y
         * @type {number}
         */

        /**
         * Point z coordinate.
         * @member cc.math.Vector#z
         * @type {number}
         */

        /**
         * @method cc.math.Vector#constructor
         * @param x {number} vector x coordinate
         * @param y {number} vector y coordinate
         * @param z {number} vector z coordinate. if not set zero by default.
         */
        constructor(public x:number= 0, public y:number= 0, public z:number= 0) {

        }

        /**
         * Set a Vector with new values.
         *
         * @method cc.math.Vector#set
         * @param x {number} vector x coordinate
         * @param y {number} vector y coordinate
         * @param z {number=} vector z coordinate. if not set zero by default.
         * @returns {cc.math.Vector}
         */
        set( x : number, y: number ) : Vector {
            this.x= x;
            this.y= y;
            this.z= 0;

            return this;
        }

        /**
         * get the vector length.
         * @returns {number}
         */
        length() : number {
            return Math.sqrt( this.x*this.x + this.y*this.y );
        }

        /**
         * get the vector angle.
         * @returns {number}
         */
        angle() : number {
            return Math.atan2( this.y, this.x );
        }

        normalize() : Vector {
            var l= this.length();
            this.x/= l;
            this.y/= l;

            return this;
        }

        /**
         * Calculate distance from the vector to another vector.
         * @param v {cc.math.Vector}
         * @returns {number}
         */
        distance( v : Vector ) : number {
            return Vector.distance( this, v );
        }

        /**
         * Substract a vector from this vector.
         * @param v {cc.math.Vector}
         */
        sub( v : Vector ) : Vector {
            this.x-= v.x;
            this.y-= v.y;
            return this;
        }

        /**
         * Add a vector from this vector.
         * @param v {cc.math.Vector}
         */
        add( v : Vector ) : Vector {
            this.x+= v.x;
            this.y+= v.y;
            return this;
        }

        /**
         * Multiply the vector by a scalar.
         * @param v {number}
         * @returns {cc.math.Vector}
         */
        mult( v : number ) : Vector {
            this.x*=v;
            this.y*=v;
            this.z*=v;
            return this;
        }

        static add( v0:Point,v1:Point ) : Vector {
            return new Vector( v1.x+v0.x, v1.y+v0.y );
        }

        /**
         * Create a Vector with the substraction of two vectors.
         * @param v0 {cc.math.Vector}
         * @param v1 {cc.math.Vector}
         * @returns {Vector}
         */
        static sub( v1:Point,v0:Point ) : Vector {
            return new Vector( v1.x-v0.x, v1.y-v0.y );
        }

        /**
         * Calculate the distance between two vectors
         * @param v0 {cc.math.Vector}
         * @param v1 {cc.math.Vector}
         * @returns {number} distance between vectors.
         */
        static distance( v0 : Point, v1 : Point ) : number {
            var dx= v1.x - v0.x;
            var dy= v1.y - v0.y;

            return Math.sqrt( dx*dx + dy*dy );
        }

        static angleWith( p0:Point, p1:Point ) : number {
            var x= p1.x - p0.x;
            var y= p1.y - p0.y;
            return Math.atan2(y,x);
        }

        static middlePoint( p0:Point, p1:Point ) {
            var x= (p1.x+p0.x)/2;
            var y= (p1.y+p0.y)/2;
            return new Vector(x,y);
        }

        static equals( p0:Point, p1:Point ) {
            return p0.x===p1.x && p0.y===p1.y;
        }

        /**
         * Compare the vector with another vector for equality.
         * @param v {cc.math.Vector}
         * @returns {boolean}
         */
        equals( v : Vector ) {
            return this.x===v.x && this.y===v.y;
        }

        /**
         * Create a new Vetor copy of this vector.
         * @returns {cc.math.Vector}
         */
        clone() : Vector {
            return new Vector( this.x, this.y, this.z );
        }

        perpendicular() {
            var x = this.x;
            this.x = -this.y;
            this.y = x;

            return this;
        }

        invert() {
            this.x = -this.x;
            this.y = -this.y;

            return this;
        }

    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="./Point.ts"/>

module cc.math {

    import Point = cc.math.Point;

    "use strict";

    /**
     * @class cc.math.Rectangle
     * @classdesc
     *
     * Rectangle Object.
     */
    export class Rectangle {

        /**
         * 'right' corner x coord.
         * @member cc.math.Rectangle#x1
         * @type {number}
         */
        x1 : number = 0;

        /**
         * 'right' corner y coord.
         * @member cc.math.Rectangle#y1
         * @type {number}
         */
        y1 : number = 0;

        /**
         * Left-top x coordinate
         * @member cc.math.Rectangle#x
         * @type {number}
         */

        /**
         * Left-top y coordinate
         * @member cc.math.Rectangle#y
         * @type {number}
         */

        /**
         * Rectangle width
         * @member cc.math.Rectangle#w
         * @type {number}
         */

        /**
         * Rectangle height
         * @member cc.math.Rectangle#h
         * @type {number}
         */

        /**
         * Build a new Rectangle instance.
         * @method cc.math.Rectangle#constructor
         * @param x {number=} 'left' corner x coordinate.
         * @param y {number=} 'left' corner y coordinate.
         * @param w {number=} rectangle width.
         * @param h {number=} rectangle height.
         */
        constructor(public x:number=0, public y:number=0, public w:number=0, public h:number=0) {
            this.set(x,y,w,h);
        }

        /**
         * Overwrite the rectangle's coordinates with new values.
         * @method cc.math.Rectangle#set
         * @param x {number} rectangle position x coordinate
         * @param y {number} rectangle position y coordinate
         * @param w {number} rectangle width
         * @param h {number} rectangle height
         * @returns {cc.math.Rectangle} the rectangle instance.
         */
        set( x : number, y : number, w : number, h : number ) : Rectangle {
            this.x= x;
            this.y= y;
            this.w= w;
            this.h= h;
            this.x1= x+w;
            this.y1= y+h;

            return this;
        }

        /**
         * Get whether a Rectangle intersects with this rectangle.
         * @method cc.math.Rectangle#intersects
         * @param r {cc.math.Rectangle}
         * @returns {*}
         */
        intersectsWith( r:Rectangle ) : boolean {
            return this.intersects(r.x,r.y,r.w,r.h);
        }

        /**
         * Gets whether a rectangle of given dimension is inside the rectangle.
         * @method cc.math.Rectangle#intersects
         * @param x {number|Rectangle}
         * @param y {number}
         * @param w {number}
         * @param h {number}
         * @returns {boolean}
         */
        intersects( x:number, y:number, w:number, h:number ) : boolean {

            if ( this.x1 < x ) {
                return false;
            }
            if ( this.y1 < y ) {
                return false;
            }
            if ( this.x >=x+w ) {
                return false;
            }
            if ( this.y >=y+h ) {
                return false;
            }

            return true;
        }

        /**
         * Normalize the rectangle's dimension with the given width and height.
         * @param w {number}
         * @param h {number}
         * @returns {cc.math.Rectangle} reference to this.
         */
        normalizeBy( w : number, h : number ) : Rectangle {
            this.x/=w;
            this.y/=h;
            this.x1/=w;
            this.y1/=h;
            this.w/=w;
            this.h/=h;

            return this;
        }

        /**
         * Set the Rectangle with zero size.
         * @method cc.math.Rectangle#setEmpty
         */
        setEmpty() : void {
            this.x=0;
            this.y=0;
            this.x1=0;
            this.y1=0;
            this.w=0;
            this.h=0;
        }

        translate( x:number, y:number ) : Rectangle {
            this.x+=x;
            this.y+=y;
            this.x1+=x;
            this.y1+=y;

            return this;
        }

        /**
         * Test whether the Rectangle is empty, eg either its width or height is zero.
         * @method cc.math.Rectangle#isEmpty
         * @returns {boolean}
         */
        isEmpty() : boolean {
            return this.w===0 || this.h===0;
        }

        /**
         * Intersect this rectangle with the parameter Rectangle.
         * @param r {cc.math.Rectangle}
         * @return {cc.math.Rectangle} reference to this.
         */
        intersectWith( r : Rectangle ) : Rectangle {

            if ( this.intersectsWith(r) ) {


                if (this.x < r.x) {
                    this.w -= r.x - this.x;
                    this.x = r.x;
                }
                if (this.y < r.y) {
                    this.h -= r.y - this.y;
                    this.y = r.y;
                }

                if (this.w > r.w) {
                    this.w = r.w;
                }
                if (this.h > r.h) {
                    this.h = r.h;
                }

                this.x1 = this.x + this.w;
                this.y1 = this.y + this.h;
            } else {

                this.setEmpty();
            }

            return this;
        }

        contains( x:number, y:number ) : boolean;
        contains( x:Point ) : boolean;
        contains( x:any, y?:number ) : boolean {

            var tx : number;
            var ty : number;

            if ( typeof x !== "number" ) {
                var v : Point = <Point>x;
                tx= v.x;
                ty= v.y;
            } else {
                tx= x;
                ty= y;
            }

            return tx>=this.x && ty>=this.y && tx<this.x1 && ty<this.y1;
        }

        get width() : number {
            return this.w;
        }

        get height() : number {
            return this.h;
        }

        set width( w:number ) {
            this.w= w;
        }

        set height( h:number ) {
            this.h= h;
        }
    }
}
/**
 * License: see license.txt file
 */

module cc.math {

    /**
     * @class cc.math.Dimension
     * @classdesc
     *
     * This Class is for dimension definition.
     */
    export class Dimension {

        /**
         * Dimension width.
         * @member cc.math.Dimension#width
         * @type {number}
         * @public
         */

        /**
         * Dimension height.
         * @member cc.math.Dimension#height
         * @type {number}
         * @public
         */

        /**
         * Build a new Dimension instance.
         * @method cc.math.Dimension#constructor
         * @param width {number}
         * @param height {number}
         */
        constructor( public width:number=0, public height:number=0 ) {

        }

        set( d:Dimension );
        set( w:number, h:number ) : Dimension;

        /**
         * Set the dimension.
         * @param w {any}
         * @param h {number}
         * @returns {cc.math.Dimension}
         */
        set( w:any, h?:number ) : Dimension {

            if ( typeof w==='number' ) {
                this.width= w;
                this.height=h;
            } else {
                var d : Dimension = <Dimension>w;
                this.width= d.width;
                this.height=d.height;
            }

            return this;
        }

        clone() : Dimension {
            return new Dimension( this.width, this.height );
        }
    }
}
/**
 * Created by ibon on 11/20/14.
 */

/// <reference path="../Point.ts"/>
/// <reference path="../Matrix3.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../locale/Locale.ts"/>
/// <reference path="./ContainerSegment.ts"/>

module cc.math.path {

    import Vector= cc.math.Vector;
    import Matrix3= cc.math.Matrix3;

    export var DEFAULT_TRACE_LENGTH : number = 50;

    var __v0 = new Vector();
    var __v1 = new Vector();

    /**
     * Calculate a vector based on a distance and a matrix.
     * @param distance
     * @param matrix
     * @returns {Vector}
     */
    export function getDistanceVector( distance:number, matrix:Float32Array ) : Vector {
        __v0.set(0,0);
        __v1.set(distance,0);
        if ( matrix ) {
            Matrix3.transformPoint(matrix,__v0);
            Matrix3.transformPoint(matrix,__v1);
        }

        return __v1.sub(__v0);
    }

    import Point = cc.math.Point;
    import RenderingContext = cc.render.RenderingContext;

    /**
     * @class cc.math.path.Segment
     * @interface
     * @classdesc
     *
     * Base interface for every path Segment.
     * <br>
     *
     * Segments can be of any type. Simple segments like SegmentLine or SegmentBezier, or compound segments like Path @see {cc.math.Path}.
     *
     * <br>
     * A Segment instance is defined by the following basic capabilities:
     *
     *  + it has a length.
     *  + can be sampled, and a collections of points on the Segment will be returned.
     *  + can get a Point on the Segment represented by a normalized value. The method <code>getValueAt</code> does
     *    all the magic. This happens for any kind of segment, even complex Paths built of SubPaths.
     *  + can identify its starting point.
     *  + can identify its ending point.
     *  + can be cloned. A Segment of any type will create a fresh copy of itself.
     *
     */
    export interface Segment {

        _length : number;

        /**
         * Get the segment parent Segment.
         * @returns {cc.math.path.Segment}
         */
        getParent() : cc.math.path.ContainerSegment;

        /**
         * Set the segment parent Segment.
         */
        setParent( s:cc.math.path.ContainerSegment ) : void;

        /**
         * Get the segment's length. The length is a relative value obtained from adding a sample trace over the
         * segment equation.
         * @method cc.math.path.Segment#getLength
         * @returns {number} Segment's length
         */
        getLength() : number;

        /**
         * Trace the segment and get a collection of points on it.
         * @method cc.math.path.Segment#trace
         * @param numPoints {number=} number of points to sample on the segment. If not set, 30 points will be sampled.
         * @param dstArray {Array<Vector>=} destination array of points. if not set, a new array will be created.
         * @returns {Array<cc.math.Vector>} an array of points on the segment.
         */
        trace( dstArray? : Array<Vector>, numPoints? : number ) : Vector[];

        /**
         * Get a point on the segment. Assuming the Segment will be of size 1, being 0 the origin segment point, and
         * 1 the final segment point, the normalizedPos parameter represents a point on this segment proportional to its
         * value.
         * <br>
         * For segments like beziers, the returned point will be result of solving the curve for the parameter, and not
         * necessarily the point at the proportional curve length position.
         * @method cc.math.path.Segment#getValueAt
         * @param normalizedPos {number} a value in the range 0..1
         * @param out {cc.math.Vector=} an optional point to set the result in.
         * @returns {cc.math.Vector} a point in the path.
         */
        getValueAt( normalizedPos : number, out? : Vector ) : Vector;

        /**
         * Get the first point in the Segment.
         *  + For a SubPath will be its first Segment's starting point.
         *  + For a Path will be its first SubPath's starting point.
         * @method cc.math.path.Segment#getStartingPoint
         * @returns {cc.math.Vector}
         */
        getStartingPoint() : Vector;

        /**
         * Get the last point in the Segment.
         *  + For a SubPath will be its last Segment's end point.
         *  + For a Path will be its last SubPath's end point.
         * @method cc.math.path.Segment#getStartingPoint
         * @returns {cc.math.Vector}
         */
        getEndingPoint() : Vector;

        /**
         * Build a copy of this segment, either a complete path or a line.
         * @method cc.math.path.Segment#clone
         * @returns {cc.math.path.Segment} a copy of the segment.
         */
        clone() : Segment;

        /**
         * Add the Segment control points to the array.
         * If the array is not set, a new one will be created.
         * The actual Segment points are added, so modifying them means modifying the path.
         * @method cc.math.path.Segment#getControlPoints
         * @param arr {Array<cc.math.Vector>}
         * @returns {Array<cc.math.Vector>}
         */
        getControlPoints( arr? : Array<Point> ) : Array<Point>;

        /**
         * Mark a Segment and all its SubSegments are dirty whatever it means.
         * @methodcc.math.path.Segment#setDirty
         */
        setDirty( d:boolean );

        paint( ctx:RenderingContext );
    }

}
/**
 * License: see license.txt file
 */

/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>

module cc.math.path {

    import Point = cc.math.Point;
    import Vector = cc.math.Vector;
    import Segment = cc.math.path.Segment;
    import ContainerSegment = cc.math.path.ContainerSegment;

    /**
     * @class cc.math.path.SegmentLineInitializer
     * @interface
     * @classdesc
     *
     * SegmentLine initialization object.
     *
     */
    export interface SegmentLineInitializer {

        /**
         * Line start point.
         * @member cc.math.path.SegmentLineInitializer#start
         * @type {cc.math.Point}
         */
        start : Point;

        /**
         * Line end point.
         * @member cc.math.path.SegmentLineInitializer#end
         * @type {cc.math.Point}
         */
        end : Point;
    }

    var __v : Vector = new Vector();

    /**
     *
     * @class cc.math.path.SegmentLine
     * @implements cc.math.path.Segment
     * @classdesc
     *
     * Objects of this type represent a line segment.
     * Line segments are added to a Path by calling <code>path.lineTo(x,y)</code>.
     *
     */
    export class SegmentLine implements Segment {

        /**
         * Parent Segment. An instance of <code>ContainerSegment</code>
         * @member cc.math.path.SegmentLine
         * @type {cc.math.path.Segment}
         * @private
         */
        _parent:ContainerSegment = null;

        /**
         * The line segment length.
         * @member cc.math.path.SegmentLine#_length
         * @type {number}
         * @private
         */
        _length:number = 0;

        /**
         * The line start point.
         * @member cc.math.path.SegmentLine#_start
         * @type {cc.math.Vector}
         * @private
         */
        _start : Vector;

        /**
         * The line end point.
         * @member cc.math.path.SegmentLine#_end
         * @type {cc.math.Vector}
         * @private
         */
        _end : Vector;

        _dirty : boolean = true;

        /**
         * Build a new SegmentLine instance.
         * @method cc.math.path.SegmentLine#constructor
         * @param data {SegmentLineInitializer=}
         */
        constructor(data?:SegmentLineInitializer) {
            if ( data ) {
                this.initialize(data.start, data.end);
            }
        }

        /**
         * Get the Segment's parent Segment.
         * @method cc.math.path.SegmentLine#getParent
         * @returns {cc.math.path.Segment}
         */
        getParent() : ContainerSegment {
            return this._parent;
        }

        /**
         * Set the Segment's parent Segment.
         * @method cc.math.path.SegmentLine#setParent
         * @param s {cc.math.path.Segment}
         */
        setParent( s : ContainerSegment ) : void {
            this._parent= s;
        }

        /**
         * Initialize this segment points.
         * This method takes the supplied point references, does not build new points.
         * @method cc.math.path.SegmentLine#setPoints
         * @param start {cc.math.Point} start line point.
         * @param end {cc.math.Point} end line point.
         */
        initialize(start:Point, end:Point) {

            this._start = new Vector(start.x, start.y);
            this._end = new Vector(end.x, end.y);

            this.__calculateLength();
        }

        __calculateLength() {
            this._length= Math.sqrt(
                (this._start.x-this._end.x)*(this._start.x-this._end.x) +
                (this._start.y-this._end.y)*(this._start.y-this._end.y) );

            this._dirty= false;
        }

        /**
         * Get the line length.
         * @override
         * @method cc.math.path.SegmentLine#getLength
         * @returns {number}
         */
        getLength() : number {
            return this._length;
        }

        /**
         * Sample some points on the line segment.
         * This implementation only samples two points, initial and final.
         * It returns the points that conform the line, if they are changed, the line will be changed as well.
         * @method cc.math.path.SegmentLine#trace
         * @param numPoints {number=} number of points traced on the segment.
         * @param dstArray {Array<cc.math.Vector>=} array where to add the traced points.
         * @returns {Array<Vector>} returns the supplied array of points, or a new array of points if not set.
         */
        trace( dstArray? : Array<Vector>, numPoints? : number ) : Vector[] {

            dstArray= dstArray || [];

            //dstArray.push( this._start );
            dstArray.push( this._end );

            return dstArray;
        }

        /**
         * Get a point on the line at the given proportional position.
         * @param normalizedPos {number} value in the range 0..1
         * @param out {cc.math.Vector=} optional out point. if not set, an internal spare point will be used.
         * @returns {cc.math.Vector} a point on the segment at the given position. This point should be copied,
         * successive calls to getValue will return the same point instance.
         */
        getValueAt( normalizedPos : number, out? : Vector ) : Vector {

            out= out || new cc.math.Vector();

            out.x= ( this._end.x - this._start.x )*normalizedPos + this._start.x;
            out.y= ( this._end.y - this._start.y )*normalizedPos + this._start.y;

            return out;
        }

        /**
         * Get the Segment's starting point.
         * It returns the original starting Point reference, not a copy of it.
         * @returns {cc.math.Vector}
         */
        getStartingPoint() : Vector {
            return this._start;
        }

        /**
         * Get the Segment's ending point.
         * It returns the original starting Point reference, not a copy of it.
         * @returns {cc.math.Vector}
         */
        getEndingPoint() : Vector {
            return this._end;
        }

        /**
         * Make a clone of the segment.
         * @method cc.math.path.SegmentLine#clone
         * @returns {cc.math.path.Segment}
         */
        clone() : SegmentLine {

            var sl= new SegmentLine({
                start : {
                    x: this._start.x,
                    y: this._start.y
                },
                end : {
                    x: this._end.x,
                    y: this._end.y
                }
            });

            sl._length= this._length;
            return this;
        }

        /**
         * Add this Segment control points to the array.
         * If the array is not set, a new one will be created.
         * The actual Segment points are added, so modifying them means modifying the path.
         * @method cc.math.path.SegmentLine#getControlPoints
         * @param arr {Array<cc.math.Vector>}
         * @returns {Array<cc.math.Vector>}
         */
        getControlPoints( arr? : Array<Point> ) : Array<Point> {
            arr= arr || [];

            arr.push( this._start );
            arr.push( this._end );

            return arr;
        }

        /**
         * Mark the Segment dirty.
         * No action for lines.
         * @methodcc.math.path.SegmentLine#setDirty
         */

        /**
         * Mark the Segment dirty.
         * No action for Arcs.
         * @method cc.math.path.ContainerSegment#setDirty
         */
        setDirty(d:boolean) {
            this._dirty= d;
            var p : ContainerSegment= this._parent;
            while(p) {
                p.setDirty(d);
                p=p._parent;
            }
        }

        paint( ctx:cc.render.RenderingContext ) {

            ctx.beginPath();
            ctx.moveTo( this._start.x, this._start.y );
            ctx.lineTo( this._end.x, this._end.y );
            ctx.stroke();
        }

    }
}
/**
 * License: see license.txt file
 */

/// <reference path="../Point.ts"/>

module cc.math.path {

    "use strict";

    import Vector= cc.math.Vector;

    /**
     *
     * Original source:
     * http://www.antigrain.com/research/adaptive_bezier/index.html
     *
     */


    /**
     * Recursion limit to calculate curve.
     * @type {number}
     */
    var curve_recursion_limit:number = 8;

    /**
     * 0.2 when stroking is on lines > 1px in width.
     * You set it in radians. The less this value is the more accurate will be the approximation at sharp turns.
     * But 0 means that we don't consider angle conditions at all.
     * @type {number}
     */
    var m_angle_tolerance:number = 0.2;

    /**
     * should not exceed 10-15 degrees (in radians)
     * @type {number}
     */
    var m_cusp_limit:number = 15 * Math.PI / 180;

    /**
     * worlModelView scale factor. (1 by default)
     * @type {number}
     */
    var m_approximation_scale:number = 1;

    /**
     * colinearity threshold.
     * @type {number}
     */
    var curve_collinearity_epsilon:number = 0.001;

    /**
     *
     * @type {number}
     */
    var curve_angle_tolerance_epsilon:number = 0;

    /**
     * calculated by m_approximation_scale
     * @type {number}
     */
    var m_distance_tolerance:number = 0.0001;

    function __recursive_bezier(points:Vector[], x1:number, y1:number, x2:number, y2:number, x3:number, y3:number, x4:number, y4:number, level:number) {

        if (level > curve_recursion_limit) {
            return;
        }

        // Calculate all the mid-points of the line segments
        //----------------------
        var x12 = (x1 + x2) / 2;
        var y12 = (y1 + y2) / 2;
        var x23 = (x2 + x3) / 2;
        var y23 = (y2 + y3) / 2;
        var x34 = (x3 + x4) / 2;
        var y34 = (y3 + y4) / 2;
        var x123 = (x12 + x23) / 2;
        var y123 = (y12 + y23) / 2;
        var x234 = (x23 + x34) / 2;
        var y234 = (y23 + y34) / 2;
        var x1234 = (x123 + x234) / 2;
        var y1234 = (y123 + y234) / 2;

        if (level > 0) { // Enforce subdivision first time

            // Try to approximate the full cubic curve by a single straight line
            //------------------
            var dx = x4 - x1;
            var dy = y4 - y1;

            var d2 = Math.abs(((x2 - x4) * dy - (y2 - y4) * dx));
            var d3 = Math.abs(((x3 - x4) * dy - (y3 - y4) * dx));

            var da1, da2;

            if (d2 > curve_collinearity_epsilon && d3 > curve_collinearity_epsilon) {
                // Regular care
                //-----------------
                if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance * (dx * dx + dy * dy)) {
                    // If the curvature doesn't exceed the distance_tolerance value
                    // we tend to finish subdivisions.
                    //----------------------
                    if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
                        points.push(new Vector(x1234, y1234));
                        return;
                    }

                    // Angle & Cusp Condition
                    //----------------------
                    var a23 = Math.atan2(y3 - y2, x3 - x2);
                    da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
                    da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
                    if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;
                    if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;

                    if (da1 + da2 < m_angle_tolerance) {
                        // Finally we can stop the recursion
                        //----------------------
                        points.push( new Vector(x1234, y1234) );
                        return;
                    }

                    if (m_cusp_limit !== 0.0) {
                        if (da1 > m_cusp_limit) {
                            points.push(new Vector(x2, y2));
                            return;
                        }

                        if (da2 > m_cusp_limit) {
                            points.push(new Vector(x3, y3));
                            return;
                        }
                    }
                }
            }
            else {
                if (d2 > curve_collinearity_epsilon) {
                    // p1,p3,p4 are collinear, p2 is considerable
                    //----------------------
                    if (d2 * d2 <= m_distance_tolerance * (dx * dx + dy * dy)) {
                        if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(new Vector(x1234, y1234));
                            return;
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
                        if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;

                        if (da1 < m_angle_tolerance) {
                            points.push(new Vector(x2, y2));
                            points.push(new Vector(x3, y3));
                            return;
                        }

                        if (m_cusp_limit !== 0.0) {
                            if (da1 > m_cusp_limit) {
                                points.push(new Vector(x2, y2));
                                return;
                            }
                        }
                    }
                }
                else if (d3 > curve_collinearity_epsilon) {
                    // p1,p2,p4 are collinear, p3 is considerable
                    //----------------------
                    if (d3 * d3 <= m_distance_tolerance * (dx * dx + dy * dy)) {
                        if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(new Vector(x1234, y1234));
                            return;
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
                        if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;

                        if (da1 < m_angle_tolerance) {
                            points.push(new Vector(x2, y2));
                            points.push(new Vector(x3, y3));
                            return;
                        }

                        if (m_cusp_limit !== 0.0) {
                            if (da1 > m_cusp_limit) {
                                points.push(new Vector(x3, y3));
                                return;
                            }
                        }
                    }
                }
                else {
                    // Collinear case
                    //-----------------
                    dx = x1234 - (x1 + x4) / 2;
                    dy = y1234 - (y1 + y4) / 2;
                    if (dx * dx + dy * dy <= m_distance_tolerance) {
                        points.push(new Vector(x1234, y1234));
                        return;
                    }
                }
            }
        }

        // Continue subdivision
        //----------------------
        __recursive_bezier(points, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1);
        __recursive_bezier(points, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1);
    }

    /**
     *
     * @param p0 {cc.math.Vector}
     * @param cp0 {cc.math.Vector}
     * @param cp1 {cc.math.Vector}
     * @param p1 {cc.math.Vector}
     * @param points {Array<cc.math.Vector>=}
     *
     * @static
     */
    export function traceBezier(p0:Vector,cp0:Vector,cp1:Vector,p1:Vector, m_points?:Vector[]) {

        var x1:number = p0.x;
        var y1:number = p0.y;
        var x2:number = cp0.x;
        var y2:number = cp0.y;
        var x3:number = cp1.x;
        var y3:number = cp1.y;
        var x4:number = p1.x;
        var y4:number = p1.y;

        var m_points = m_points || [];
        m_distance_tolerance = 0.5 / m_approximation_scale;
        m_distance_tolerance *= m_distance_tolerance;
        m_points.push(new Vector(x1,y1));
        __recursive_bezier(m_points, x1, y1, x2, y2, x3, y3, x4, y4, 0);
        m_points.push(new Vector(x4, y4));
        return m_points;
    }

    /**
     *
     * @param p0 {cc.math.Vector}
     * @param cp0 {cc.math.Vector}
     * @param p1 {cc.math.Vector}
     * @param m_points {Array<cc.math.Vector>=}
     * @static
     */
    export function traceQuadratic(p0:Vector,cp0:Vector,p1:Vector, m_points?:Vector[]) {

        var x1:number = p0.x;
        var y1:number = p0.y;
        var x2:number = cp0.x;
        var y2:number = cp0.y;
        var x3:number = p1.x;
        var y3:number = p1.y;

        m_points = m_points || [];
        m_distance_tolerance = 0.5 / m_approximation_scale;
        m_distance_tolerance *= m_distance_tolerance;

        m_points.push(new Vector(x1,y1));
        __recursive_quadratic(m_points, x1, y1, x2, y2, x3, y3, 0);
        m_points.push(new Vector(x3, y3));
        return m_points;
    }

    /**
     *
     * @param x1 {number}
     * @param y1 {number}
     * @param x2 {number}
     * @param y2 {number}
     * @param x3 {number}
     * @param y3 {number}
     * @param level {number}
     * @private
     * @static
     */
    function __recursive_quadratic(points:Vector[], x1:number, y1:number, x2:number, y2:number, x3:number, y3:number, level:number) {

        if (level > curve_recursion_limit) {
            return;
        }

        // Calculate all the mid-points of the line segments
        //----------------------
        var x12 = (x1 + x2) / 2;
        var y12 = (y1 + y2) / 2;
        var x23 = (x2 + x3) / 2;
        var y23 = (y2 + y3) / 2;
        var x123 = (x12 + x23) / 2;
        var y123 = (y12 + y23) / 2;

        var dx = x3 - x1;
        var dy = y3 - y1;
        var d = Math.abs(((x2 - x3) * dy - (y2 - y3) * dx));

        if (d > curve_collinearity_epsilon) {
            // Regular care
            //-----------------
            if (d * d <= m_distance_tolerance * (dx * dx + dy * dy)) {
                // If the curvature doesn't exceed the distance_tolerance value
                // we tend to finish subdivisions.
                //----------------------
                if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
                    points.push(new Vector(x123, y123));
                    return;
                }

                // Angle & Cusp Condition
                //----------------------
                var da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
                if (da >= Math.PI) da = 2 * Math.PI - da;

                if (da < m_angle_tolerance) {
                    // Finally we can stop the recursion
                    //----------------------
                    points.push(new Vector(x123, y123));
                    return;
                }
            }
        }
        else {
            // Collinear case
            //-----------------
            dx = x123 - (x1 + x3) / 2;
            dy = y123 - (y1 + y3) / 2;
            if (dx * dx + dy * dy <= m_distance_tolerance) {
                points.push(new Vector(x123, y123));
                return;
            }
        }

        // Continue subdivision
        //----------------------
        __recursive_quadratic(points, x1, y1, x12, y12, x123, y123, level + 1);
        __recursive_quadratic(points, x123, y123, x23, y23, x3, y3, level + 1);
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="./BezierTracer.ts"/>
/// <reference path="../Path.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>

module cc.math.path {

    import Vector= cc.math.Vector;
    import Point= cc.math.Point;
    import Segment = cc.math.path.Segment;
    import ContainerSegment = cc.math.path.ContainerSegment;
    import Path = cc.math.Path;

    var __v0 : Vector = new Vector();

    /**
     * @class cc.math.path.SegmentQuadraticInitializer
     * @interface
     * @classdesc
     *
     * A quadratic curve is composed of 2 points (initial=p0 and end point=p2) and a tension control point=p1.
     *
     */
    export interface SegmentQuadraticInitializer {

        /**
         * First curve point.
         * @member cc.math.path.SegmentQuadraticInitializer#p0
         * @type {cc.math.Point}
         */
        p0 : Point;

        /**
         * Curve control point.
         * @member cc.math.path.SegmentQuadraticInitializer#p1
         * @type {cc.math.Point}
         */
        p1 : Point;

        /**
         * last curve point.
         * @member cc.math.path.SegmentQuadraticInitializer#p2
         * @type {cc.math.Point}
         */
        p2 : Point;
    }

    /**
     * @class cc.math.path.SegmentQuadratic
     * @implements cc.math.path.Segment
     * @classdesc
     *
     * This Object is a Quadratic Bezier Segment.
     * <p>
     *     It is composed of two points and a tension control point. Internally, the Segment can cache its contour.
     * <p>
     *     The contour can be of two different types:
     *     + directly traced over the curve. Leaves points at different distances on the curve.
     *     + equi-distant on the curve. Internally traces the points as in the other type, but then creates a polyline
     *       path with the points, and samples the resulting path at regular intervals. This transforms the curve into
     *       a polyline, which is faster for most calculations, but could not be as smooth as the other type.
     * <p>
     * By default, the curve is calculated with the first type, directly tracing on the curve
     *
     */
    export class SegmentQuadratic implements Segment {

        /**
         * Start quadratic curve point.
         * @member cc.math.path.SegmentQuadratic#_p0
         * @type {cc.math.Vector}
         * @private
         */
        _p0 : Vector = null;

        /**
         * Quadratic curve control point.
         * @member cc.math.path.SegmentQuadratic#_cp0
         * @type {cc.math.Vector}
         * @private
         */
        _cp0: Vector = null;

        /**
         * End quadratic curve point.
         * @member cc.math.path.SegmentQuadratic#_p1
         * @type {cc.math.Vector}
         * @private
         */
        _p1 : Vector = null;

        /**
         * Internal flag for cache validity.
         * @member cc.math.path.SegmentQuadratic#_dirty
         * @type {boolean}
         * @private
         */
        _dirty : boolean = true;

        /**
         * Parent segment.
         * @member cc.math.path.SegmentQuadratic#_parent
         * @type {cc.math.path.Segment}
         * @private
         */
        _parent : ContainerSegment = null;

        /**
         * Segment length. It is approximately calculated by subdividing the curve.
         * @member cc.math.path.SegmentQuadratic#_length
         * @type {number}
         * @private
         */
        _length : number = 0;

        /**
         * Create a new Quadratic Segment instance.
         * @param data {cc.math.path.SegmentQuadraticInitializer=}
         */
        constructor( data? : SegmentQuadraticInitializer ) {
            if ( data ) {
                this.initialize( data.p0, data.p1, data.p2 );
            }
        }

        /**
         * Initialize the Segment with the supplied points.
         * @param p0 {cc.math.Point} start curve point.
         * @param p1 {cc.math.Point} curve control point.
         * @param p2 {cc.math.Point} end curve point}
         */
        initialize( p0:Point, p1:Point, p2:Point ) : void {

            this._p0= new Vector( p0.x, p0.y );
            this._cp0= new Vector( p1.x, p1.y );
            this._p1= new Vector( p2.x, p2.y );

            this.__calculateLength();
            this._dirty= false;
        }

        __calculateLength() : void {
            var points= this.trace( null, cc.math.path.DEFAULT_TRACE_LENGTH );
            // calculate distance
            this._length=0;
            for( var i=0; i<points.length-1; i++ ) {
                this._length+= points[i].distance( points[i+1] );
            }

            this._dirty= false;
        }

        /**
         * Get the Segment's parent Segment.
         * @method cc.math.path.SegmentQuadratic#getParent
         * @returns {cc.math.path.Segment}
         */
        getParent() : ContainerSegment {
            return this._parent;
        }

        /**
         * Set the Segment's parent Segment.
         * @method cc.math.path.SegmentQuadratic#setParent
         * @param s {cc.math.path.Segment}
         */
        setParent( s : ContainerSegment ) : void {
            this._parent= s;
        }

        /**
         * Get the Segment length.
         * @override
         * @method cc.math.path.SegmentQuadratic#getLength
         * @returns {number}
         */
        getLength() : number {
            if ( this._dirty ) {
                this.__calculateLength();
            }
            return this._length;
        }

        /**
         * Sample some points on the segment. It will return either the sampled contour, or the flattened version of it.
         * It returns the points that conform the Segment contour, if they are changed, the contour will be changed as well.
         * @method cc.math.path.SegmentQuadratic#trace
         * @param numPoints {number=} number of points traced on the segment.
         * @param dstArray {Array<cc.math.Vector>=} array where to add the traced points.
         * @returns {Array<Vector>} returns the supplied array of points, or a new array of points if not set.
         */
        trace( dstArray? : Array<Vector>, numPoints? : number ) : Vector[] {

            dstArray= dstArray || [];
            cc.math.path.traceQuadratic( this._p0, this._cp0, this._p1, dstArray );

            return dstArray;
        }

        /**
         * Get a point on the Segment at the given proportional position.
         * + If the segment is flattened, the value will be calculated from the internally cached curve contour.
         * + If not, if will be calculated by solving the curve.
         * The first is faster, but could be inaccurate for curves with a los number of flattened cached points.
         * @param normalizedPos {number} value in the range 0..1
         * @param out {cc.math.Vector=} optional out point. if not set, an internal spare point will be used.
         * @returns {cc.math.Vector} a point on the segment at the given position. This point should be copied,
         * successive calls to getValue will return the same point instance.
         */
        getValueAt( normalizedPos : number, out? : Vector ) : Vector {

            // no out point, use a spare internal one. WARNING, will be continuously reused.
            out = out || new cc.math.Vector();

            // fix normalization values, just in case.
            if ( normalizedPos>1 || normalizedPos<-1 ) {
                normalizedPos %= 1;
            }
            if ( normalizedPos<0 ) {
                normalizedPos+=1;
            }

            if ( normalizedPos===1 ) {
                out.set( this._p1.x, this._p1.y );
            } else if ( normalizedPos===0 ) {
                out.set( this._p0.x, this._p0.y );
            } else {
                var t1 = 1 - normalizedPos;
                var t = normalizedPos;

                // solve quadratic
                out.x = SegmentQuadratic.solve( this._p0.x, this._cp0.x, this._p1.x, t, t1 );
                out.y = SegmentQuadratic.solve( this._p0.y, this._cp0.y, this._p1.y, t, t1 );
            }

            return out;
        }

        static solve( v0:number,cv0:number,v1:number,t:number,t1:number) :number {
            return t1 * t1 * v0 + 2 * t1 * t * cv0 + t * t * v1;
        }

        /**
         * Get the Segment's starting point.
         * It returns the original starting Point reference, not a copy of it.
         * @returns {cc.math.Vector}
         */
        getStartingPoint() : Vector {
            return this._p0;
        }

        /**
         * Get the Segment's ending point.
         * It returns the original starting Point reference, not a copy of it.
         * @returns {cc.math.Vector}
         */
        getEndingPoint() : Vector {
            return this._p1;
        }

        /**
         * Make a clone of the segment.
         * @method cc.math.path.SegmentQuadratic#clone
         * @returns {cc.math.path.Segment}
         */
        clone() : SegmentQuadratic {

            var segment = new SegmentQuadratic({
                p0: {
                    x: this._p0.x,
                    y: this._p0.y
                },
                p1: {
                    x: this._cp0.x,
                    y: this._cp0.y
                },
                p2: {
                    x: this._p1.x,
                    y: this._p1.y
                }
            });

            segment._length= this._length;

            return segment;
        }

        /**
         * Add this Segment control points to the array.
         * If the array is not set, a new one will be created.
         * The actual Segment points are added, so modifying them means modifying the path.
         * @method cc.math.path.SegmentQuadratic#getControlPoints
         * @param arr {Array<cc.math.Vector>}
         * @returns {Array<cc.math.Vector>}
         */
        getControlPoints( arr? : Array<Point> ) : Array<Point> {
            arr= arr || [];

            arr.push( this._p0 );
            arr.push( this._cp0 );
            arr.push( this._p1 );

            return arr;
        }


        /**
         * Mark the quadratic as dirty. Mark internal polilyne info as invalid.
         * @methodcc.math.path.SegmentBezier#setDirty
         */

        /**
         * Mark the Segment dirty.
         * No action for Arcs.
         * @method cc.math.path.ContainerSegment#setDirty
         */
        setDirty(d:boolean) {
            this._dirty= d;
            var p : ContainerSegment= this._parent;
            while(p) {
                p.setDirty(d);
                p=p._parent;
            }
        }

        paint( ctx:cc.render.RenderingContext ) {

        }

    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="./BezierTracer.ts"/>
/// <reference path="../Path.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>

module cc.math.path {

    import Vector= cc.math.Vector;
    import Point= cc.math.Point;
    import Segment = cc.math.path.Segment;
    import ContainerSegment = cc.math.path.ContainerSegment;
    import Path = cc.math.Path;

    var __v0 : Vector = new Vector();

    /**
     * @class cc.math.path.SegmentBezierInitializer
     * @interface
     * @classdesc
     *
     * A Cubic curve is composed of 2 points (initial=p0 and end point=p3) and a two tension control points (p1 and p2).
     *
     */
    export interface SegmentBezierInitializer {

        /**
         * First curve point.
         * @member cc.math.path.SegmentBezierInitializer#p0
         * @type {cc.math.Point}
         */
        p0 : Point;

        /**
         * First Curve control point.
         * @member cc.math.path.SegmentBezierInitializer#p1
         * @type {cc.math.Point}
         */
        p1 : Point;

        /**
         * Second Curve control point.
         * @member cc.math.path.SegmentBezierInitializer#p2
         * @type {cc.math.Point}
         */
        p2 : Point;

        /**
         * last curve point.
         * @member cc.math.path.SegmentBezierInitializer#p2
         * @type {cc.math.Point}
         */
        p3 : Point;
    }

    /**
     * @class cc.math.path.SegmentBezier
     * @implements cc.math.path.Segment
     * @classdesc
     *
     * This Object is a Cubic Bezier Segment.
     * <p>
     *     It is composed of two points and a two tension control points. Internally, the Segment can cache its contour.
     * <p>
     *     The contour can be of two different types:
     *     + directly traced over the curve. Leaves points at different distances on the curve.
     *     + equi-distant on the curve. Internally traces the points as in the other type, but then creates a polyline
     *       path with the points, and samples the resulting path at regular intervals. This transforms the curve into
     *       a polyline, which is faster for most calculations, but could not be as smooth as the other type.
     * <p>
     * By default, the curve is calculated with the first type, directly tracing on the curve
     *
     */
    export class SegmentBezier implements Segment {

        /**
         * Start Cubic curve point.
         * @member cc.math.path.SegmentBezier#_p0
         * @type {cc.math.Vector}
         * @private
         */
        _p0 : Vector = null;

        /**
         * First Cubic curve control point.
         * @member cc.math.path.SegmentBezier#_cp0
         * @type {cc.math.Vector}
         * @private
         */
        _cp0: Vector = null;

        /**
         * Second Cubic curve control point.
         * @member cc.math.path.SegmentBezier#_cp1
         * @type {cc.math.Vector}
         * @private
         */
        _cp1: Vector = null;

        /**
         * End Cubic curve point.
         * @member cc.math.path.SegmentBezier#_p1
         * @type {cc.math.Vector}
         * @private
         */
        _p1 : Vector = null;

        /**
         * Internal flag for cache validity.
         * @member cc.math.path.SegmentBezier#_dirty
         * @type {boolean}
         * @private
         */
        _dirty : boolean = true;

        /**
         * Parent segment.
         * @member cc.math.path.SegmentBezier#_parent
         * @type {cc.math.path.Segment}
         * @private
         */
        _parent : ContainerSegment = null;

        /**
         * Segment length. It is approximately calculated by subdividing the curve.
         * @member cc.math.path.SegmentBezier#_length
         * @type {number}
         * @private
         */
        _length : number = 0;

        /**
         * Create a new Cubic Segment instance.
         * @param data {cc.math.path.SegmentBezierInitializer=}
         */
        constructor( data? : SegmentBezierInitializer ) {
            if ( data ) {
                this.initialize( data.p0, data.p1, data.p2, data.p3 );
            }
        }

        /**
         * Initialize the Segment with the supplied points.
         * @param p0 {cc.math.Point} start curve point.
         * @param p1 {cc.math.Point} first curve control point.
         * @param p2 {cc.math.Point} second curve control point.
         * @param p3 {cc.math.Point} end curve point}
         */
        initialize( p0:Point, p1:Point, p2:Point, p3:Point ) : void {

            this._p0= new Vector( p0.x, p0.y );
            this._cp0= new Vector( p1.x, p1.y );
            this._cp1= new Vector( p2.x, p2.y );
            this._p1= new Vector( p3.x, p3.y );

            this._dirty= false;
            this.__calculateLength();
        }

        __calculateLength() : void {
            var points:Vector[]= this.trace( null, cc.math.path.DEFAULT_TRACE_LENGTH );
            // calculate distance
            this._length=0;
            for( var i=0; i<points.length-1; i++ ) {
                this._length+= points[i].distance( points[i+1] );
            }

            this._dirty= false;
        }

        /**
         * Get the Segment's parent Segment.
         * @method cc.math.path.SegmentBezier#getParent
         * @returns {cc.math.path.Segment}
         */
        getParent() : ContainerSegment {
            return this._parent;
        }

        /**
         * Set the Segment's parent Segment.
         * @method cc.math.path.SegmentBezier#setParent
         * @param s {cc.math.path.Segment}
         */
        setParent( s : ContainerSegment ) : void {
            this._parent= s;
        }

        /**
         * Get the Segment length.
         * @override
         * @method cc.math.path.SegmentBezier#getLength
         * @returns {number}
         */
        getLength() : number {
            if ( this._dirty ) {
                this.__calculateLength();
            }
            return this._length;
        }

        /**
         * Sample some points on the segment. It will return either the sampled contour, or the flattened version of it.
         * It returns the points that conform the Segment contour, if they are changed, the contour will be changed as well.
         * @method cc.math.path.SegmentBezier#trace
         * @param numPoints {number=} number of points traced on the segment.
         * @param dstArray {Array<cc.math.Vector>=} array where to add the traced points.
         * @returns {Array<Vector>} returns the supplied array of points, or a new array of points if not set.
         */
        trace( dstArray? : Array<Vector>, numPoints? : number ) : Vector[] {

            dstArray= dstArray || [];

            cc.math.path.traceBezier( this._p0, this._cp0, this._cp1, this._p1, dstArray );

            return dstArray;
        }

        /**
         * Get a point on the Segment at the given proportional position.
         * + If the segment is flattened, the value will be calculated from the internally cached curve contour.
         * + If not, if will be calculated by solving the curve.
         * The first is faster, but could be inaccurate for curves with a los number of flattened cached points.
         * For this kind of segment, the first method is way faster.
         * @param normalizedPos {number} value in the range 0..1
         * @param out {cc.math.Vector=} optional out point. if not set, an internal spare point will be used.
         * @returns {cc.math.Vector} a point on the segment at the given position. This point should be copied,
         * successive calls to getValue will return the same point instance.
         */
        getValueAt( normalizedPos : number, out? : Vector ) : Vector {

            // no out point, use a spare internal one. WARNING, will be continuously reused.
            out = out || new cc.math.Vector();

            // fix normalization values, just in case.
            if ( normalizedPos>1 || normalizedPos<-1 ) {
                normalizedPos %= 1;
            }
            if ( normalizedPos<0 ) {
                normalizedPos+=1;
            }


            if ( normalizedPos===1 ) {
                out.set( this._p1.x, this._p1.y );
            } else if ( normalizedPos===0 ) {
                out.set( this._p0.x, this._p0.y );
            } else {

                var t = normalizedPos;
                var t2 = t * t;
                var t3 = t * t2;

                // solve cubic bezier for nomalized time.
                out.x = SegmentBezier.solve( this._p0.x, this._cp0.x, this._cp1.x, this._p1.x, t, t2, t3 );
                out.y = SegmentBezier.solve( this._p0.y, this._cp0.y, this._cp1.y, this._p1.y, t, t2, t3 );
            }

            return out;
        }

        /**
         * Solve a Bezier for the given t.
         * @method cc.math.path.SegmentBezier.solve
         * @param v0 {number} point 0
         * @param vc0 {number} control point 0
         * @param cv1 {number} control point 1
         * @param v1 {number} point 1
         * @param t {number} normalized 0..1 value.
         * @param t2 {number} square normalized 0..1 value.
         * @param t3 {number} cubic normalized 0..1 value.
         * @returns {number}
         */
        static solve(v0:number, vc0:number, cv1:number, v1:number, t:number, t2:number, t3:number):number {
            return (v0 + t * (-v0 * 3 + t * (3 * v0 - v0 * t))) +
                    t * (3 * vc0 + t * (-6 * vc0 + vc0 * 3 * t)) +
                    t2 * (cv1 * 3 - cv1 * 3 * t) +
                    t3 * v1;
        }

        /**
         * Get the Segment's starting point.
         * It returns the original starting Point reference, not a copy of it.
         * @returns {cc.math.Vector}
         */
        getStartingPoint() : Vector {
            return this._p0;
        }

        /**
         * Get the Segment's ending point.
         * It returns the original starting Point reference, not a copy of it.
         * @returns {cc.math.Vector}
         */
        getEndingPoint() : Vector {
            return this._p1;
        }

        /**
         * Make a clone of the segment.
         * @method cc.math.path.SegmentBezier#clone
         * @returns {cc.math.path.Segment}
         */
        clone() : SegmentBezier {
            var segment= new SegmentBezier({
                p0 : {
                    x: this._p0.x,
                    y: this._p0.y
                },
                p1 : {
                    x: this._cp0.x,
                    y: this._cp0.y
                },
                p2 : {
                    x: this._cp1.x,
                    y: this._cp1.y
                },
                p3 : {
                    x: this._p1.x,
                    y: this._p1.y
                }
            });

            segment._length= this._length;

            return segment;
        }

        /**
         * Add this Segment control points to the array.
         * If the array is not set, a new one will be created.
         * The actual Segment points are added, so modifying them means modifying the path.
         * @method cc.math.path.SegmentBezier#getControlPoints
         * @param arr {Array<cc.math.Vector>}
         * @returns {Array<cc.math.Vector>}
         */
        getControlPoints( arr? : Array<Point> ) : Array<Point> {
            arr= arr || [];

            arr.push( this._p0 );
            arr.push( this._cp0 );
            arr.push( this._cp1 );
            arr.push( this._p1 );

            return arr;
        }

        /**
         * Mark the bezier as dirty. Mark internal polilyne info as invalid.
         * @methodcc.math.path.SegmentBezier#setDirty
         */

        /**
         * Mark the Segment dirty.
         * No action for Arcs.
         * @method cc.math.path.ContainerSegment#setDirty
         */
        setDirty(d:boolean) {
            this._dirty= d;
            var p : ContainerSegment= this._parent;
            while(p) {
                p.setDirty(d);
                p=p._parent;
            }
        }

        paint( ctx:cc.render.RenderingContext ) {

        }

    }
}
/**
 * Created by ibon on 11/23/14.
 */

/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>

module cc.math.path {

    import Vector = cc.math.Vector;
    import Segment = cc.math.path.Segment;
    import ContainerSegment = cc.math.path.ContainerSegment;

    /**
     * @class cc.math.path.SegmentArcInitializer
     * @interface
     * @classdesc
     */
    export interface SegmentArcInitializer {
        x : number;
        y : number;
        radius : number;
        startAngle : number;
        endAngle : number;
        ccw : boolean;
    }

    var __v0 : Vector = new Vector();

    /**
     * @class cc.math.path.SegmentArc
     * @implements cc.math.path.Segment
     * @classdesc
     *
     * This Segment represents a circle's arc.
     * The arc is defined by a position, a radius and two angles. It also specified how the angles should be traversed
     * clock or counter clock wisely.
     * The arc will be the minimum angle between the start and end angles.
     *
     */
    export class SegmentArc implements Segment {

        /**
         * Parent Segment. An instance of <code>ContainerSegment</code>
         * @member cc.math.path.SegmentLine
         * @type {cc.math.path.Segment}
         * @private
         */
        _parent : ContainerSegment;

        /**
         * Arc center x position.
         * @member cc.math.path.SegmentArc#_x
         * @type {number}
         * @private
         */
        _x:number;

        /**
         * Arc center y position.
         * @member cc.math.path.SegmentArc#_y
         * @type {number}
         * @private
         */
        _y:number;

        /**
         * Arc radius.
         * @member cc.math.path.SegmentArc#_radius
         * @type {number}
         * @private
         */
        _radius:number;

        /**
         * Arc starting angle.
         * @member cc.math.path.SegmentArc#_startAngle
         * @type {number}
         * @private
         */
        _startAngle:number;

        /**
         * Arc ending angle.
         * @member cc.math.path.SegmentArc#_endAngle
         * @type {number}
         * @private
         */
        _endAngle:number;

        _dirty:boolean=true;

        /**
         * Arc traversal direction. If true counter clockwise, clockwise otherwise.
         * For example, an arc with startAngle=0 and endAngle=Math.PI/3, if ccw is false will be a PI/3 arc, and a
         * 2PI-PI/3 arc if it is true.
         * @member cc.math.path.SegmentArc#_ccw
         * @type {number}
         * @private
         */
        _ccw:boolean;

        /**
         * Cached arc starting point.
         * @member cc.math.path.SegmentArc#_startingPoint
         * @type {cc.math.Vector}
         * @private
         */
        _startingPoint : Vector= null;

        /**
         * Cached arc ending point.
         * @member cc.math.path.SegmentArc#_endingPoint
         * @type {cc.math.Vector}
         * @private
         */
        _endingPoint : Vector= null;

        /**
         * Cached Segment length value.
         * @member cc.math.path.SegmentArc#_length
         * @type {number}
         * @private
         */
        _length : number = 0;


        /**
         * Build a new SegmentArc instance.
         * @method cc.math.path.SegmentArc#constructor
         * @param data {cc.math.path.SegmentArcInitializer=} optional arc initialization data.
         */
        constructor(data?:SegmentArcInitializer) {
            this.initialize(data);
        }

        /**
         * Initialize the Arc Segment with data.
         * @method cc.math.path.SegmentArc#initialize
         * @param data {cc.math.path.SegmentArcInitializer}
         */
        initialize(data:SegmentArcInitializer) {

            this._x = data.x;
            this._y = data.y;
            this._radius = data.radius;
            this._startAngle = data.startAngle;
            this._endAngle = data.endAngle;
            this._ccw = data.ccw;

            if (!this._ccw && this._endAngle <= this._startAngle) {
                this._endAngle += 2 * Math.PI;
            }
            else if (this._ccw && this._startAngle <= this._endAngle) {
                this._startAngle += 2 * Math.PI;
            }

            if ( this._startAngle>this._endAngle ) {
                var tmp= this._startAngle;
                this._startAngle= this._endAngle;
                this._endAngle= tmp;
            }

            var s:Vector = this.getValueAt(0);
            this._startingPoint = new Vector();
            this._startingPoint.x = s.x;
            this._startingPoint.y = s.y;
            s = this.getValueAt(1);
            this._endingPoint = new Vector();
            this._endingPoint.x = s.x;
            this._endingPoint.y = s.y;
            this.__calculateLength();
        }

        __calculateLength() {
            this._length= Math.abs( this._radius * (this._endAngle - this._startAngle ) );
            this._dirty= false;
        }

        /**
         * Return the Segment's starting point reference. It is the stored one, not a copy.
         * @method cc.math.path.SegmentArc#getStartingPoint
         * @returns {cc.math.Vector}
         */
        getStartingPoint() : Vector {
            return this._startingPoint;
        }

        /**
         * Return the Segment's ending point reference. It is the stored one, not a copy.
         * @method cc.math.path.SegmentArc#getEndingPoint
         * @returns {cc.math.Vector}
         */
        getEndingPoint() : Vector {
            return this._endingPoint;
        }

        /**
         * Get the Segment's arc length.
         * @method cc.math.path.SegmentArc#getLength
         * @returns {number}
         */
        getLength() : number {
            if ( this._dirty ) {
                this.__calculateLength();
            }
            return this._length;
        }

        /**
         * Get a Point in the Arc.
         * @method cc.math.path.SegmentArc#getValueAt
         * @param v {number} Position in path. 0= startingPoint, 1= endingPoint
         * @param out {cc.math.Vector=} an optional out Point. If not set, an internal spare point will be returned.
         * @returns {cc.math.Vector}
         */
        getValueAt( v : number, out? : Vector ) : Vector  {

            var diffAngle : number = ( this._endAngle - this._startAngle ) * v;

            out= out || new cc.math.Vector();

            out.x= this._x + this._radius * Math.cos(this._startAngle + diffAngle);
            out.y= this._y + this._radius * Math.sin(this._startAngle + diffAngle);

            return out;
        }

        /**
         * Sample some points in the Segment.
         * @method cc.math.path.SegmentArc#trace
         * @param numPoints {number=} Number of points. if not set, cc.math.path.DEFAULT_TRACE_LENGTH points will be traced.
         * @param dstArray {Array<cc.math.Vector>=} optional output array of points. If not set, a new one will be created.
         * @returns {Array<Vector>} An array where the traced points have been added.
         */
        trace( dstArray? : Array<Vector>, numPoints? : number ) : Vector[] {

            numPoints = numPoints || cc.math.path.DEFAULT_TRACE_LENGTH;
            dstArray = dstArray || [];

            if ( this._startAngle===this._endAngle || this._radius===0 ) {
                return dstArray;
            }

            for( var i=0; i<=numPoints; i++ ) {
                dstArray.push( this.getValueAt(i/numPoints, new Vector()) );
            }

            return dstArray;
        }

        /**
         * Get the Segment's parent Segment.
         * @method cc.math.path.SegmentArc#getParent
         * @returns {cc.math.path.Segment}
         */
        getParent() : ContainerSegment {
            return this._parent;
        }

        /**
         * Set the Segment's parent Segment.
         * @method cc.math.path.SegmentArc#setParent
         * @param s {cc.math.path.Segment}
         */
        setParent( s : ContainerSegment ) : void {
            this._parent= s;
        }

        /**
         * Make a clone of the segment.
         * @method cc.math.path.SegmentArc#clone
         * @returns {cc.math.path.Segment}
         */
        clone() : SegmentArc {
            return  new SegmentArc({
                x: this._x,
                y: this._y,
                radius : this._radius,
                startAngle : this._startAngle,
                endAngle : this._endAngle,
                ccw : this._ccw
            });
        }

        /**
         * Add the Segment control points to the array.
         * If the array is not set, a new one will be created.
         * The actual Segment points are added, so modifying them means modifying the path.
         * Arc segments have no control points.
         * @method cc.math.path.SegmentArc#getControlPoints
         * @param arr {Array<cc.math.Vector>}
         * @returns {Array<cc.math.Vector>}
         */
        getControlPoints( arr? : Array<Point> ) : Array<Point> {
            arr= arr || [];

            return arr;
        }

        /**
         * Mark the Segment dirty.
         * No action for Arcs.
         * @method cc.math.path.ContainerSegment#setDirty
         */
        setDirty(d:boolean) {
            this._dirty= d;
            var p : ContainerSegment= this._parent;
            while(p) {
                p.setDirty(d);
                p=p._parent;
            }
        }

        paint( ctx:cc.render.RenderingContext ) {


        }

    }
}
/**
 * License: see license.txt file
 */

/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="../Path.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>

module cc.math.path {

    import Vector= cc.math.Vector;
    import Point= cc.math.Point;
    import Segment = cc.math.path.Segment;
    import ContainerSegment = cc.math.path.ContainerSegment;
    import Path = cc.math.Path;

    var __v0 : Vector = new Vector();

    /**
     * @class cc.math.path.SegmentCardinalSplineInitializer
     * @interface
     * @classdesc
     *
     * A cardinal spline is composed of a collection of points to interpolate and a tension parameter.
     * The curve implementation will duplicate some of the points.
     *
     */
    export interface SegmentCardinalSplineInitializer {


        /**
         * First curve point.
         * @member cc.math.path.SegmentCardinalSplineInitializer#p0
         * @type {cc.math.Point}
         */
        p0 : Point;

        /**
         * First Curve control point.
         * @member cc.math.path.SegmentCardinalSplineInitializer#p1
         * @type {cc.math.Point}
         */
        cp0 : Point;

        /**
         * Second Curve control point.
         * @member cc.math.path.SegmentCardinalSplineInitializer#p2
         * @type {cc.math.Point}
         */
        cp1 : Point;

        /**
         * last curve point.
         * @member cc.math.path.SegmentCardinalSplineInitializer#p2
         * @type {cc.math.Point}
         */
        p1 : Point;

        /**
         * curve tension.
         * @member cc.math.path.SegmentCardinalSplineInitializer#tension
         */
        tension? : number;
    }

    /**
     * @class cc.math.path.SegmentCardinalSpline
     * @implements cc.math.path.Segment
     * @classdesc
     *
     * This Object is a Quadratic Bezier Segment.
     * <p>
     *     It is composed of two points and a tension control point. Internally, the Segment can cache its contour.
     * <p>
     *     The contour can be of two different types:
     *     + directly traced over the curve. Leaves points at different distances on the curve.
     *     + equi-distant on the curve. Internally traces the points as in the other type, but then creates a polyline
     *       path with the points, and samples the resulting path at regular intervals. This transforms the curve into
     *       a polyline, which is faster for most calculations, but could not be as smooth as the other type.
     * <p>
     * By default, the curve is calculated with the first type, directly tracing on the curve
     *
     */
    export class SegmentCardinalSpline implements Segment {


        /**
         * Start Cubic curve point.
         * @member cc.math.path.SegmentCardinalSpline#_p0
         * @type {cc.math.Vector}
         * @private
         */
        _p0 : Vector = null;

        /**
         * First Cubic curve control point.
         * @member cc.math.path.SegmentCardinalSpline#_cp0
         * @type {cc.math.Vector}
         * @private
         */
        _cp0: Vector = null;

        /**
         * Second Cubic curve control point.
         * @member cc.math.path.SegmentCardinalSpline#_cp1
         * @type {cc.math.Vector}
         * @private
         */
        _cp1: Vector = null;

        /**
         * End Cubic curve point.
         * @member cc.math.path.SegmentCardinalSpline#_p1
         * @type {cc.math.Vector}
         * @private
         */
        _p1 : Vector = null;

        _tension : number =.5;

        /**
         * Internal flag for cache validity.
         * @member cc.math.path.SegmentCardinalSpline#_dirty
         * @type {boolean}
         * @private
         */
        _dirty:boolean = true;

        /**
         * Parent segment.
         * @member cc.math.path.SegmentCardinalSpline#_parent
         * @type {cc.math.path.Segment}
         * @private
         */
        _parent:ContainerSegment = null;

        /**
         * Segment length. It is approximately calculated by subdividing the curve.
         * @member cc.math.path.SegmentCardinalSpline#_length
         * @type {number}
         * @private
         */
        _length:number = 0;

        /**
         * Whether the Quadratic is internally treated as a polyline.
         * @member cc.math.path.SegmentCardinalSpline#_flattened
         * @type {boolean}
         * @private
         */
        _flattened:boolean = false;

        /**
         * A cache of points on the curve. This is approximation with which the length is calculated.
         * @member cc.math.path.SegmentCardinalSpline#_cachedContourPoints
         * @type {Array<cc.math.Vector>}
         * @private
         */
        _cachedContourPoints:Vector[] = null;

        /**
         * Create a new Quadratic Segment instance.
         * @param data {cc.math.path.SegmentCardinalSplineInitializer=}
         */
        constructor(data?:SegmentCardinalSplineInitializer) {
            if (data) {
                this.initialize(data.p0,data.cp0,data.cp1,data.p1, data.tension);
            }
        }

        /**
         * Initialize the Segment with the supplied points.
         * @param p0 {cc.math.Point}
         * @param cp0 {cc.math.Point}
         * @param cp1 {cc.math.Point}
         * @param p1 {cc.math.Point}
         * @param tension {number}
         */
        initialize(p0:Point,cp0:Point,cp1:Point,p1:Point, tension:number):void {

            this._tension = typeof tension==="undefined" ? 0.5 : tension;
            this._p0= new Vector( p0.x,p0.y );
            this._cp0= new Vector( cp0.x,cp0.y );
            this._cp1= new Vector( cp1.x,cp1.y );
            this._p1= new Vector( p1.x,p1.y );

            this.__calculateLength();
            this._dirty = false;
        }

        /**
         * Set Segment tension. By default it is 0.5
         * Setting a different tension will mark the segment as dirty, nulling all internal caches.
         * @param t {number}
         */
        setTension( t : number ) {
            if ( t!==this._tension ) {
                this._tension= t;
                this.__calculateLength();
                if ( this._parent ) {
                    this._parent.setDirty(true);
                }
            }
        }

        __calculateLength():void {
            var points = this.trace( null, cc.math.path.DEFAULT_TRACE_LENGTH );
            // calculate distance
            this._length = 0;
            for (var i = 0; i < points.length - 1; i++) {
                this._length += points[i].distance(points[i + 1]);
            }

            this._dirty= false;
        }

        /**
         * Get the Segment's parent Segment.
         * @method cc.math.path.SegmentCardinalSpline#getParent
         * @returns {cc.math.path.Segment}
         */
        getParent():ContainerSegment {
            return this._parent;
        }

        /**
         * Set the Segment's parent Segment.
         * @method cc.math.path.SegmentCardinalSpline#setParent
         * @param s {cc.math.path.Segment}
         */
        setParent(s:ContainerSegment):void {
            this._parent = s;
        }

        /**
         * Get the Segment length.
         * @override
         * @method cc.math.path.SegmentCardinalSpline#getLength
         * @returns {number}
         */
        getLength():number {
            if ( this._dirty ) {
                this.__calculateLength();
            }
            return this._length;
        }

        /**
         * Sample some points on the segment. It will return either the sampled contour, or the flattened version of it.
         * It returns the points that conform the Segment contour, if they are changed, the contour will be changed as well.
         * @method cc.math.path.SegmentCardinalSpline#trace
         * @param numPoints {number=} number of points traced on the segment.
         * @param dstArray {Array<cc.math.Vector>=} array where to add the traced points.
         * @returns {Array<Vector>} returns the supplied array of points, or a new array of points if not set.
         */
        trace( dstArray?:Array<Vector>, numPoints?:number ):Vector[] {

            numPoints= numPoints||cc.math.path.DEFAULT_TRACE_LENGTH;

            dstArray = dstArray || [];
            for( var i=0; i<=numPoints; i++ ) {
                dstArray.push( this.getValueAt(i/numPoints) );
            }

            return dstArray;
        }

        /**
         * Get a point on the Segment at the given proportional position.
         * + If the segment is flattened, the value will be calculated from the internally cached curve contour.
         * + If not, if will be calculated by solving the curve.
         * The first is faster, but could be inaccurate for curves with a los number of flattened cached points.
         * @param normalizedPos {number} value in the range 0..1
         * @param out {cc.math.Vector=} optional out point. if not set, an internal spare point will be used.
         * @returns {cc.math.Vector} a point on the segment at the given position. This point should be copied,
         * successive calls to getValue will return the same point instance.
         */
        getValueAt(normalizedPos:number, out?:Vector):Vector {

            // no out point, use a spare internal one. WARNING, will be continuously reused.
            out = out || new cc.math.Vector();

            // fix normalization values, just in case.
            if (normalizedPos > 1 || normalizedPos < -1) {
                normalizedPos %= 1;
            }
            if (normalizedPos < 0) {
                normalizedPos += 1;
            }

            if (normalizedPos === 1) {
                var lp = this.getEndingPoint();
                out.set(lp.x, lp.y);
            } else if (normalizedPos === 0) {

                var fp_ = this.getStartingPoint();
                out.set(fp_.x, fp_.y);
            } else {

                var t= normalizedPos;

                var t2 = t * t;
                var t3 = t2 * t;

                var s = (1.0 - this._tension) / 2.0;

                var b1 = s * ((-t3 + (2.0 * t2)) - t);                      // s(-t3 + 2 t2 - t)P1
                var b2 = s * (-t3 + t2) + (2.0 * t3 - 3.0 * t2 + 1.0);          // s(-t3 + t2)P2 + (2 t3 - 3 t2 + 1)P2
                var b3 = s * (t3 - 2.0 * t2 + t) + (-2.0 * t3 + 3.0 * t2);      // s(t3 - 2 t2 + t)P3 + (-2 t3 + 3 t2)P3
                var b4 = s * (t3 - t2);                                   // s(t3 - t2)P4

                out.x = this._p0.x * b1 + this._cp0.x * b2 + this._cp1.x * b3 + this._p1.x * b4;
                out.y = this._p0.y * b1 + this._cp0.y * b2 + this._cp1.y * b3 + this._p1.y * b4;


            }

            return out;
        }

        /**
         * Get the Segment's starting point.
         * It returns the original starting Point reference, not a copy of it.
         * @returns {cc.math.Vector}
         */
        getStartingPoint():Vector {
            return this._cp0;
        }

        /**
         * Get the Segment's ending point.
         * It returns the original starting Point reference, not a copy of it.
         * @returns {cc.math.Vector}
         */
        getEndingPoint():Vector {
            return this._cp1;
        }

        /**
         * Make a clone of the segment.
         * @method cc.math.path.SegmentCardinalSpline#clone
         * @returns {cc.math.path.Segment}
         */
        clone():SegmentCardinalSpline {

            var segment = new SegmentCardinalSpline({
                p0 : this._p0,
                cp0: this._cp0,
                cp1: this._cp1,
                p1 : this._p1,
                tension: this._tension
            });

            segment._length = this._length;

            return segment;
        }

        /**
         * Add this Segment control points to the array.
         * If the array is not set, a new one will be created.
         * The actual Segment points are added, so modifying them means modifying the path.
         * @method cc.math.path.SegmentCardinalSpline#getControlPoints
         * @param arr {Array<cc.math.Vector>}
         * @returns {Array<cc.math.Vector>}
         */
        getControlPoints(arr?:Array<Point>):Array<Point> {
            arr = arr || [];

            arr.push( this._p0 );
            arr.push( this._cp0 );
            arr.push( this._cp1 );
            arr.push( this._p1 );

            return arr;
        }


        /**
         * Mark the quadratic as dirty. Mark internal polilyne info as invalid.
         * @methodcc.math.path.SegmentCardinalSpline#setDirty
         */

        /**
         * Mark the Segment dirty.
         * No action for Arcs.
         * @method cc.math.path.ContainerSegment#setDirty
         */
        setDirty(d:boolean) {
            this._dirty= d;
            var p : ContainerSegment= this._parent;
            while(p) {
                p.setDirty(d);
                p=p._parent;
            }
        }

        paint( ctx:cc.render.RenderingContext ) {

            var c= this.trace(null, 50);
            ctx.beginPath();
            ctx.moveTo(c[0].x, c[0].y );
            for( var i=1 ; i<c.length; i++ ) {
                ctx.lineTo( c[i].x, c[i].y );
            }
            ctx.stroke();
        }

    }
}
/**
 * Created by ibon on 11/22/14.
 */

/// <reference path="./Segment.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>

module cc.math.path {
    
    import Segment = cc.math.path.Segment;

    var __v0 : Vector = new Vector();

    /**
     * @class cc.math.path.ContainerSegment
     * @implements cc.math.path.Segment
     * @classdesc
     *
     * This object is the base for all Container segments. Container Segments are Path and SubPath, that is, Segments
     * that are build of a collection of Segment objects.
     *
     */
    export class ContainerSegment implements Segment {

        /**
         * Parent Segment. An instance of <code>ContainerSegment</code>
         * @member cc.math.path.SegmentLine
         * @type {cc.math.path.Segment}
         * @private
         */
        _parent : ContainerSegment = null;

        /**
         * The path length
         * @member cc.math.path.ContainerSegment#_length
         * @type {number}
         * @private
         */
        _length:number = 0;

        /**
         * The path segments. Any of the segments can be another path.
         * @member cc.math.path.ContainerSegment#_segments
         * @type {Array<cc.math.path.ContainerSegment.Segment>}
         * @private
         */
        _segments:Segment[] = [];
        
        /**
         * Mark this ContainerSegment as dirty.
         * Dirty means length must be recalculated.
         * @member cc.math.path.ContainerSegment#_dirty
         * @type {boolean}
         * @private
         */
        _dirty : boolean = true;

        constructor() {
        }

        /**
         * Get ContainerSegment's all segments lengths.
         * @returns {number}
         */
        getLength():number {
            if ( this._dirty ) {
                this.__calculateLength();
            }
            return this._length;
        }

        __calculateLength() : number {

            var length : number= 0;

            for( var i=0; i<this._segments.length; i++ ) {
                length+= this._segments[i].getLength();
            }

            this._dirty= false;
            this._length= length;
            return this._length;
        }

        /**
         * Get a Point on the ContainerSegment at a position proportional to normalizedPos.
         * If there's no Point in the path for the normalized position, the result of calling
         * <code>getStartingPoint</code> or <code>getEndingPoint</code> is returned.
         * This is consistent since a value for normalizedPos of 1 means end
         * of the path and a value of 0 the start of it.
         * @param normalizedPos {number} Normalized value between 0..1
         * @param out {cc.math.Vector=} out point. if not set, an internal spare point value will be used.
         * @returns {cc.math.Vector}
         */
        getValueAt(normalizedPos:number, out? : Vector ): Vector {

            if (this._dirty) {
                this.__calculateLength();
                this._dirty= false;
            }

            out= out || new cc.math.Vector();

            // BUGBUG change for binary search

            var pos = normalizedPos * this._length;
            var search = 0;


                for (var i = 0; i < this._segments.length; i++) {
                    if (pos >= search && pos < search + this._segments[i].getLength()) {
                        search = pos - search;
                        search /= this._segments[i].getLength();

                        return this._segments[i].getValueAt( search, out);
                    } else {
                        search += this._segments[i].getLength();
                    }
                }


            var ep= this.getEndingPoint();
            return out.set( ep.x, ep.y );
            //cc.Debug.error( locale.ERR_PATH_GETVALUEAT_HAS_NO_VALUE );
        }

        /**
         * Get sample points on the ContainerSegment.
         * @param numPoints {number=} number of points to sample. If not set, ContainerSegment.DEFAULT_TRACE will be used.
         * @param dstArray {Array<cc.math.Vector>=}
         * @returns {Array<cc.math.Vector>} the supplied array or a newly created one with the traced points .
         */
        trace(dstArray?:Array<Vector>, numPoints?:number):Vector[] {

            dstArray= dstArray || [];

            numPoints = numPoints || cc.math.path.DEFAULT_TRACE_LENGTH;


            this.getLength();
            dstArray.push( this.getStartingPoint() );
            for( var i=0; i<this._segments.length; i++) {
                this._segments[i].trace( dstArray, numPoints );
            }

            return dstArray;
        }

        isClosed() {
            var sp= this.getStartingPoint();
            var ep= this.getEndingPoint();

            if ( sp===ep || sp.equals(ep) ) {
                return;
            }
        }

        /**
         * @see {cc.math.path.Segment#getStartingPoint}
         * @returns {cc.math.Vector}
         */
        getStartingPoint() : Vector {
            return null;
        }

        /**
         * @see {cc.math.path.Segment#getEndingPoint}
         * @returns {cc.math.Vector}
         */
        getEndingPoint() : Vector {
            return null;
        }

        /**
         * Get the Segment's parent Segment.
         * @returns {cc.math.path.Segment}
         */
        getParent() : ContainerSegment {
            return this._parent;
        }

        /**
         * Set the Segment's parent Segment.
         * @method cc.math.path.ContainerSegment#setParent
         * @param s {cc.math.path.Segment}
         */
        setParent( s : ContainerSegment ) : void {
            this._parent= s;
        }

        /**
         * Make a clone of the segment. It will clone all contained segments.
         * ContainerSegments are not allowed to exist by themselves except in the form of Path or SubPath, so cloning
         * one of them will throw an error.
         * @method cc.math.path.ContainerSegment#clone
         * @returns {cc.math.path.Segment}
         */
        clone() : ContainerSegment {
            throw "ContainerSegments can't clone.";
        }

        /**
         * Add this Segment control points to the array.
         * If the array is not set, a new one will be created.
         * The actual Segment points are added, so modifying them means modifying the path.
         * @method cc.math.path.ContainerSegment#getControlPoints
         * @param arr {Array<cc.math.Vector>}
         * @returns {Array<cc.math.Vector>}
         */
        getControlPoints( arr? : Array<Point> ) : Array<Point> {
            arr= arr || [];

            for( var i=0; i<this._segments.length; i++) {
                this._segments[i].getControlPoints( <Array<Point>>arr );
            }

            return arr;
        }

        /**
         * Mark a Segment and all its SubSegments are dirty whatever that means.
         * @methodcc.math.path.ContainerSegment#setDirty
         */

        /**
         * Mark the Segment dirty.
         * No action for Arcs.
         * @method cc.math.path.ContainerSegment#setDirty
         */
        setDirty(b:boolean) {
            this._dirty= b;
            var p : ContainerSegment= <ContainerSegment>this._parent;
            while(p) {
                p.setDirty(b);
                p=p._parent;
            }
        }

        paint( ctx:cc.render.RenderingContext ) {
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../Point.ts"/>
/// <reference path="./Segment.ts"/>
/// <reference path="./SegmentLine.ts"/>
/// <reference path="./SegmentArc.ts"/>
/// <reference path="./SegmentCardinalSpline.ts"/>
/// <reference path="./SegmentQuadratic.ts"/>
/// <reference path="./SegmentBezier.ts"/>
/// <reference path="./ContainerSegment.ts"/>
/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../locale/Locale.ts"/>

module cc.math.path {

    import Vector= cc.math.Vector;
    import Segment= cc.math.path.Segment;
    import SegmentLine = cc.math.path.SegmentLine;
    import SegmentArc = cc.math.path.SegmentArc;
    import SegmentCardinalSpline = cc.math.path.SegmentCardinalSpline;
    import Locale = cc.locale;
    import ContainerSegment = cc.math.path.ContainerSegment;

    /**
     * @class cc.math.path.SubPath
     * @extends cc.math.path.ContainerSegment
     * @classdesc
     *
     * A Subpath is an open or closed Collection of chained Segments.
     * A Segment will share its starting Point with the previous Segment's
     * last Point (or the initial movedTo point) and the final Point with the next Segment's starting Point.
     *
     * A SubPath is considered empty when it has no segments.
     * The length of the SubPath will be the lengths of all its Segments.
     * The results from a call to <code>getValueAt</code> will be proportional to all the Segments it contains.
     * The result from a call to <code>trace</code> will be points proportional to all the Segments it contains.
     * The result from a call to <code>getStartingPoint</code> will be the starting point of the first segment.
     *
     * A SubPath can be closed. When it is in this state, no new Segments can be added to it.
     *
     */
    export class SubPath extends ContainerSegment {

        /**
         * Path current tracing point. When adding segments to the path, this is the reference point.
         * @member cc.math.path.SubPath#_currentPoint
         * @type {cc.math.Vector}
         * @private
         */
        _currentPoint:Vector = null;
        
        /**
         * Is the path closed ? If so, more path tracing operations will require to build anothe SubPath.
         * @member cc.math.path.SubPath#_closed
         * @type {boolean}
         * @private
         */
        _closed:boolean = false;


        /**
         * Build a new SubPath instance.
         * @method cc.math.path.SubPath#constructor
         */
        constructor() {
            super();
        }

        /**
         * Whether the SubPath is closed.
         * @returns {boolean}
         */
        isClosed():boolean {
            return this._closed;
        }

        /**
         * Test whether the SubPath is empty, that is, tracing info has not been set yet.
         * @returns {boolean}
         */
        isEmpty():boolean {
            return this._currentPoint===null;
        }

        /**
         * Number of Segments contained in this SubPath.
         * If a Segment is actually another Path, it will count 1 segment.
         * @returns {number}
         */
        numSegments() : number {
            return this._segments.length;
        }

        /**
         * Add a Segment to the SubPath and set the Segment's parent as the SubPath.
         * @param s {cc.math.path.Segment}
         */
        addSegment( s : Segment ) : void {
            s.setParent( this );
            this._segments.push(s);
        }

        /**
         * Clear all sub-path data, and revert to the original path object status.
         * Make sure this path is not another's path segment.
         *
         * @method cc.math.path.SubPath#beginPath
         */
        beginPath(): SubPath {
            this._segments = [];
            this._length = 0;
            this._currentPoint = null;
            this._closed = false;

            return this;
        }

        /**
         * Move the current path tracer to a position.
         *
         * @method cc.math.path.SubPath#moveTo
         * @param x {number}
         * @param y {number}
         */
        moveTo(x:number, y:number): SubPath {

            if ( this._closed ) {
                cc.Debug.warn( locale.WARN_MOVETO_IN_NON_EMPTY_SUBPATH );
                return;
            }

            if ( null===this._currentPoint ) {
                this._currentPoint = new Vector();
            }

            if ( this.numSegments()===0 ) {
                this._currentPoint.x = x;
                this._currentPoint.y = y;
            }

            return this;
        }

        /**
         * Add a line to the current path.
         * If the current path is not initialized, in will be initialized from 0,0 and a line added.
         *
         * @method cc.math.path.SubPath#lineTo
         * @param x {number}
         * @param y {number}
         */
        lineTo(x:number, y:number): SubPath {

            if ( this._closed ) {
                cc.Debug.warn( locale.WARN_TRACE_ON_CLOSED_SUBPATH, "lineTo" );
                return;
            }

            if ( this.isEmpty() ) {

                this._currentPoint= new Vector();

            } else {

                this.addSegment(new SegmentLine({
                    start: {
                        x: this._currentPoint.x,
                        y: this._currentPoint.y
                    },
                    end: {
                        x: x,
                        y: y
                    }
                }));
            }

            this._currentPoint.x = x;
            this._currentPoint.y = y;

            return this;
        }

        /**
         * Add an arc to the SubPath.
         * An arc is defined by a position, a radius, an start and an end angle and how to traverse from the start to
         * the end angle, eg clock or counter clock wisely.
         * The arc will be the minimum angle between start and end angles.
         * Though not strictly necessary, this method expects the difference between startAngle and endAngle
         * to be <= 2*Math.PI
         * @see {cc.math.path.SegmentArc}
         * @method cc.math.path.SubPath#arc
         * @param x {number}
         * @param y {number}
         * @param radius {number}
         * @param startAngle {number} radians
         * @param endAngle {number} radians
         * @param anticlockwise
         * @param addLineTo {boolean} When adding an arc to a Path, if any SubPath is present a line must be added
         *  to the current SubPath. If true add a line from the current SubPath point to the starting point on the arc.
         * @returns {cc.math.path.SubPath}
         */
        arc( x:number, y:number, radius:number, startAngle:number, endAngle:number, anticlockwise:boolean, addLineTo?:boolean ) : SubPath {

            if ( this._closed ) {
                cc.Debug.warn( locale.WARN_TRACE_ON_CLOSED_SUBPATH, "ClosePath" );
                return;
            }

            var segment= new SegmentArc({
                x: x,
                y: y,
                radius : radius,
                startAngle : startAngle,
                endAngle : endAngle,
                ccw : anticlockwise
            });

            if ( addLineTo ) {

                var sp : Vector = segment.getStartingPoint();
                this.addSegment( new SegmentLine({
                    start : {
                        x: this._currentPoint.x,
                        y: this._currentPoint.y
                    },
                    end : {
                        x : sp.x,
                        y : sp.y
                    }
                }))
            }
            this.addSegment( segment );

            var fp : Vector= segment.getEndingPoint();
            this._currentPoint.set( fp.x, fp.y );
            this._dirty= true;

            return this;

        }

        /**
         * Close the SubPath.
         * If the SubPath was already closed, in DEBUG mode will show a console message. In either case, nothing happens.
         * If the SubPath is empty
         * @returns {cc.math.path.SubPath}
         */
        closePath() : SubPath {

            if ( this._closed ) {
                cc.Debug.warn( locale.WARN_TRACE_ON_CLOSED_SUBPATH, "ClosePath" );
                return;
            }

            if ( this.isEmpty() ) {
                cc.Debug.warn( locale.WARN_CLOSE_EMPTY_SUBPATH, "ClosePath" );
                return;
            }

            var p : Point = this.getStartingPoint();

            var segment : Segment = new SegmentLine({
                    start: { x: this._currentPoint.x, y: this._currentPoint.y },
                    end: { x: p.x, y: p.y }
                });

            this.addSegment(segment);

            this._currentPoint= segment.getEndingPoint();
            this._closed= true;
            this._dirty= true;

            return this;
        }


        /**
         * Get the SubPath's starting point.
         * It will return the original SubPath starting point, not a copy of it.
         * If this SubPath is empty (no points) an error is thrown if in DEBUG mode.
         * @returns {cc.math.Vector}
         */
        getStartingPoint() : Vector {

            if ( !this.isEmpty() ) {
                return this._segments.length ?
                    this._segments[0].getStartingPoint() :
                    this._currentPoint;
            }

            cc.Debug.error( locale.ERR_SUBPATH_NOT_STARTED, "getStartingPoint" );
        }

        /**
         * Get the SubPath's ending point.
         * It will return the original SubPath ending point, not a copy of it.
         * If this SubPath is empty (no points) an error is thrown if in DEBUG mode.
         * @returns {cc.math.Vector}
         */
        getEndingPoint() : Vector {
            if (!this.isEmpty()) {
                return this._segments.length ?
                    this._segments[ this._segments.length-1 ].getEndingPoint() :
                    this._currentPoint;
            }

            cc.Debug.error( locale.ERR_SUBPATH_NOT_STARTED, "getEndingPoint" );
        }

        clone() : SubPath {
            var sp=new SubPath();

            sp._closed= this._closed;

            for( var i=0; i<this._segments.length; i++ ) {
                sp._segments.push( this._segments[i].clone() );
            }

            sp._length= this._length;
            sp._currentPoint= this._currentPoint.clone();

            return sp;
        }

        quadraticTo( x0:number, y0:number, x1:number, y1:number ) {

            if ( this._closed ) {
                cc.Debug.warn(locale.WARN_TRACE_ON_CLOSED_SUBPATH, "lineTo");
                return this;
            }

            this.addSegment( new cc.math.path.SegmentQuadratic({
                p0: { x:this._currentPoint.x, y: this._currentPoint.y },
                p1: { x:x0, y:y0 },
                p2: { x:x1, y:y1 }
            }));

            this._currentPoint.x = x1;
            this._currentPoint.y = y1;

            return this;
        }

        bezierTo( x0:number, y0:number, x1:number, y1:number, x2:number, y2:number ) {

            if ( this._closed ) {
                cc.Debug.warn(locale.WARN_TRACE_ON_CLOSED_SUBPATH, "lineTo");
                return this;
            }

            this.addSegment( new cc.math.path.SegmentBezier({
                p0: { x:this._currentPoint.x, y: this._currentPoint.y },
                p1: { x:x0, y:y0 },
                p2: { x:x1, y:y1 },
                p3: { x:x2, y:y2 }
            }));

            this._currentPoint.x = x2;
            this._currentPoint.y = y2;

            return this;
        }

        catmullRomTo( x0:number, y0:number, x1:number, y1:number, x2:number, y2:number, tension:number ) {

            if ( this._closed ) {
                cc.Debug.warn(locale.WARN_TRACE_ON_CLOSED_SUBPATH, "lineTo");
                return this;
            }

            this.addSegment(new cc.math.path.SegmentCardinalSpline({
                p0: {
                    x: this._currentPoint.x,
                    y: this._currentPoint.y
                },
                cp0: {
                    x: x0,
                    y: y0
                },
                cp1: {
                    x: x1,
                    y: y1
                },
                p1: {
                    x: x2,
                    y: y2
                },
                tension:tension
            }));

            this._currentPoint.x = x0;
            this._currentPoint.y = y0;

            return this;
        }

        paint( ctx:cc.render.RenderingContext ) {

            ctx.beginPath();
            //ctx.strokeStyle="#000";
            for( var i=0; i<this._segments.length; i++ ) {
                this._segments[i].paint(ctx);
            }
            ctx.stroke();
        }

    }
}
/**
 *
 * License: see license.txt file.
 *
 * (c) 2014-2015 @hyperandroid
 *
 */

/// <reference path="../../Point.ts"/>
/// <reference path="../../../render/RenderingContext.ts"/>

module cc.math.path.geometry {

    var EPSILON= 0.0001;

    export interface StrokeGeometryAttributes {
        width? : number;        // 1 if not defined
        cap? : cc.render.LineCap;          // butt, round, square
        join?: cc.render.LineJoin;          // bevel, round, miter
        miterLimit? : number   // for join miter, the maximum angle value to use the miter
    }

    /**
     * Get Stroke geometry for an array of Point objects.
     * The array could be the result of calling 'trace' for a Path object, or an arbitrary cloud of points.
     *
     *
     * @param points {Array.<cc.math.Vector>} contour of the points to trace.
     * @param attrs {cc.math.path.StrokeGeometryAttributes} this object defines stroke attributes like line cap,
     *      line join, line width and miter limit.
     *
     * @returns {Array<number> | Float32Array} Array with pairs of numbers (x,y)
     *
     * @method cc.math.path.geometry.getStrokeGeometry
     */
    export function getStrokeGeometry(points:cc.math.Point[], attrs:StrokeGeometryAttributes) : Float32Array {

        // trivial reject
        if (points.length < 2) {
            return new Float32Array([]);
        }

        var cap:cc.render.LineCap =     attrs.cap || cc.render.LineCap.BUTT;
        var join:cc.render.LineJoin=    attrs.join || cc.render.LineJoin.BEVEL;
        var lineWidth:number =          (attrs.width || 1) / 2;
        var miterLimit:number =         attrs.miterLimit || 10;
        var vertices:Array<number> =    [];
        var middlePoints:Point[] =      [];  // middle points per each line segment.
        var closed:boolean =            false;

        if (points.length === 2) {
            join = cc.render.LineJoin.BEVEL;
            createTriangles(points[0], cc.math.Vector.middlePoint(points[0], points[1]), points[1], vertices, lineWidth, join, miterLimit);

        } else {

            if (points[0] === points[points.length - 1] ||
                 (  points[0].x === points[points.length - 1].x &&
                    points[0].y === points[points.length - 1].y )   ) {

                var p0 = points.shift();
                p0 = cc.math.Vector.middlePoint(p0, points[0]);
                points.unshift(p0);
                points.push(p0);
                closed = true;
            }

            var i;
            for (i = 0; i < points.length - 1; i++) {
                if (i === 0) {
                    middlePoints.push(points[0]);
                } else if (i === points.length - 2) {
                    middlePoints.push(points[points.length - 1])
                } else {
                    middlePoints.push(cc.math.Vector.middlePoint(points[i], points[i + 1]));
                }
            }

            for (i = 1; i < middlePoints.length; i++) {
                createTriangles(middlePoints[i - 1], points[i], middlePoints[i], vertices, lineWidth, join, miterLimit);
            }
        }

        if ( !closed ) {

            if (cap === cc.render.LineCap.ROUND) {

                var p00 = new cc.math.Vector(vertices[0],vertices[1]);
                var p01 = new cc.math.Vector(vertices[2],vertices[3]);
                var p02 = points[1];
                var p10 = new cc.math.Vector( vertices[vertices.length - 2], vertices[vertices.length - 1] );
                var p11 = new cc.math.Vector( vertices[vertices.length - 6], vertices[vertices.length - 5] );
                var p12 = points[points.length - 2];

                createRoundCap(points[0], p00, p01, p02, vertices);
                createRoundCap(points[points.length - 1], p10, p11, p12, vertices);

            } else if (cap === cc.render.LineCap.SQUARE ) {

                var p00 = new cc.math.Vector( vertices[vertices.length - 2], vertices[vertices.length - 1]);
                var p01 = new cc.math.Vector( vertices[vertices.length - 6], vertices[vertices.length - 5]);

                createSquareCap(
                        new cc.math.Vector(vertices[0],vertices[1]),
                        new cc.math.Vector(vertices[2],vertices[3]),
                        cc.math.Vector.sub(points[0], points[1]).normalize().mult(
                            cc.math.Vector.sub(points[0], new cc.math.Vector(vertices[0],vertices[1])).length() ),
                        vertices);
                createSquareCap(
                        p00,
                        p01,
                        cc.math.Vector.sub(points[points.length - 1], points[points.length - 2]).normalize().mult(
                            cc.math.Vector.sub(p01, points[points.length - 1]).length()),
                        vertices);
            }
        }

        return new Float32Array(vertices);
    }

    function __pushVert( v:Array<number>, x:number, y:number ) {
        v.push(x);
        v.push(y);
    }

    function createSquareCap(p0:cc.math.Point, p1:cc.math.Point, dir:cc.math.Point, verts:Array<number>) {

        //p0
        __pushVert(verts, p0.x, p0.y);

        //Point.Add(p0, dir);
        __pushVert(verts, p0.x+dir.x, p0.y+dir.y);

        //Point.Add(p1, dir);
        __pushVert(verts, p1.x+dir.x, p1.y+dir.y);

        //p1;
        __pushVert( verts, p1.x, p1.y );

        //Point.Add(p1, dir);
        __pushVert(verts, p1.x+dir.x, p1.y+dir.y);

        //p0
        __pushVert(verts, p0.x, p0.y);
    }


    function createRoundCap(center:cc.math.Point, _p0:cc.math.Point, _p1:cc.math.Point, nextPointInLine:cc.math.Point, verts:Array<number>) {

        var radius = cc.math.Vector.sub(center, _p0).length();

        var angle0 = Math.atan2((_p1.y - center.y), (_p1.x - center.x));
        var angle1 = Math.atan2((_p0.y - center.y), (_p0.x - center.x));

        var orgAngle0= angle0;

        // make the round caps point in the right direction.

        // calculate minimum angle between two given angles.
        // for example: -Math.PI, Math.PI = 0, -Math.PI/2, Math.PI= Math.PI/2, etc.
        if ( angle1 > angle0) {
       		while ( angle1-angle0>=Math.PI-EPSILON) {
       			angle1=angle1-2*Math.PI;
       		}
       	}
       	else {
       		while ( angle0-angle1>=Math.PI-EPSILON) {
       			angle0=angle0-2*Math.PI;
       		}
       	}

        var angleDiff = angle1-angle0;

        // for angles equal Math.PI, make the round point in the right direction.
        if (Math.abs(angleDiff) >= Math.PI - EPSILON && Math.abs(angleDiff) <= Math.PI + EPSILON) {
            var r1:Vector = cc.math.Vector.sub(center, nextPointInLine);
            if ( r1.x===0 ) {
                if (r1.y>0) {
                    angleDiff= -angleDiff;
                }
            } else if ( r1.x>=-EPSILON ) {
                angleDiff= -angleDiff;
            }
        }

        // calculate points, and make the cap.
        var nsegments = (Math.abs(angleDiff * radius) / 7) >> 0;
        nsegments++;
        nsegments= Math.max( nsegments, 8 );

        var angleInc = angleDiff / nsegments;

        for (var i = 0; i < nsegments; i++) {
            __pushVert( verts, center.x, center.y );

            __pushVert(
                verts,
                center.x + radius * Math.cos(orgAngle0 + angleInc * i),
                center.y + radius * Math.sin(orgAngle0 + angleInc * i) );

            __pushVert(
                verts,
                center.x + radius * Math.cos(orgAngle0 + angleInc * (1 + i)),
                center.y + radius * Math.sin(orgAngle0 + angleInc * (1 + i)) );
        }
    }

    /**
     * Get the signed area of a triangle.
     *
     * @method cc.math.path.geometry.signedArea
     *
     * @param p0x {number}
     * @param p0y {number}
     * @param p1x {number}
     * @param p1y {number}
     * @param p2x {number}
     * @param p2y {number}
     * @returns {number}
     */
    export function signedArea(p0x:number, p0y:number, p1x:number, p1y:number, p2x:number, p2y:number ) : number {
        return (p1x - p0x) * (p2y - p0y) - (p2x - p0x) * (p1y - p0y);
    }

    function lineIntersection(p0:cc.math.Point, p1:cc.math.Point, p2:cc.math.Point, p3:cc.math.Point) {

        var a0 = p1.y - p0.y;
        var b0 = p0.x - p1.x;

        var a1 = p3.y - p2.y;
        var b1 = p2.x - p3.x;

        var det = a0 * b1 - a1 * b0;
        if (det > -EPSILON && det < EPSILON) {
            return null;
        } else {
            var c0 = a0 * p0.x + b0 * p0.y;
            var c1 = a1 * p2.x + b1 * p2.y;

            var x = (b1 * c0 - b0 * c1) / det;
            var y = (a0 * c1 - a1 * c0) / det;
            return new cc.math.Vector(x, y);
        }
    }


    function createTriangles(
        p0:cc.math.Point, p1:cc.math.Point, p2:cc.math.Point,
        verts:Array<number>,
        width:number,
        join:cc.render.LineJoin,
        miterLimit:number) {

        if ( cc.math.Vector.equals(p0,p1) ) {
            p1.x= p0.x + (p2.x-p0.x)/2;
            p1.y= p0.y + (p2.y-p0.y)/2;
        } else if ( cc.math.Vector.equals(p1,p2) ) {
            p2= new cc.math.Vector( p1.x, p1.y );
            p1.x= p0.x + (p2.x-p0.x)/2;
            p1.y= p0.y + (p2.y-p0.y)/2;
        }

        if ( cc.math.Vector.equals(p0,p1) && cc.math.Vector.equals(p1,p2) ) {
            return;
        }

        var t0:cc.math.Vector = cc.math.Vector.sub(p1, p0);
        var t2:cc.math.Vector = cc.math.Vector.sub(p2, p1);

        t0.perpendicular().normalize().mult(width);
        t2.perpendicular().normalize().mult(width);

        // triangle composed by the 3 points if clockwise or couterclockwise.
        // if counterclockwise, we must invert the line threshold points, otherwise the intersection point
        // could be erroneous and lead to odd results.
        if (signedArea(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y) > 0) {
            t0.invert();
            t2.invert();
        }

        var pintersect = lineIntersection(
            cc.math.Vector.add(p0, t0),
            cc.math.Vector.add(p1, t0),
            cc.math.Vector.add(p2, t2),
            cc.math.Vector.add(p1, t2)
        );

        var anchor:cc.math.Vector = null;
        var anchorLength= Number.MAX_VALUE;
        if ( pintersect ) {
            anchor= cc.math.Vector.sub(pintersect, p1);
            anchorLength= anchor.length();
        }

        var dd:number = (anchorLength / width)|0;

        var p0p1:cc.math.Vector= cc.math.Vector.sub( p0,p1 );
        var p0p1Length: number= p0p1.length();

        var p1p2:cc.math.Vector= cc.math.Vector.sub( p1,p2 );
        var p1p2Length:number= p1p2.length();

        /**
         * the cross point exceeds any of the segments dimension.
         * do not use cross point as reference.
         * This case deserves more attention to avoid redraw, currently works by overdrawing large parts.
         */
        if ( anchorLength>p0p1Length || anchorLength>p1p2Length ) {

            __pushVert( verts, p0.x+t0.x, p0.y+t0.y );              // p0+t0
            __pushVert( verts, p0.x-t0.x, p0.y-t0.y );              // p0-t0
            __pushVert( verts, p1.x+t0.x, p1.y+t0.y );              // p1+t0

            __pushVert( verts, p0.x-t0.x, p0.y-t0.y );              // p0-t0
            __pushVert( verts, p1.x+t0.x, p1.y+t0.y );              // p1+t0
            __pushVert( verts, p1.x-t0.x, p1.y-t0.y );              // p1-t0

            if ( join === cc.render.LineJoin.ROUND ) {

                createRoundCap(p1, cc.math.Vector.add(p1,t0), cc.math.Vector.add(p1,t2), p2, verts);

            } else if ( join===cc.render.LineJoin.BEVEL || (join===cc.render.LineJoin.MITER && dd>=miterLimit) ) {

                __pushVert( verts, p1.x, p1.y );                    // p1
                __pushVert( verts, p1.x+t0.x, p1.y+t0.y );          // p1+t0
                __pushVert( verts, p1.x+t2.x, p1.y+t2.y );          // p1+t2

            } else if (join === cc.render.LineJoin.MITER && dd<miterLimit && pintersect) {

                __pushVert( verts, p1.x+t0.x, p1.y+t0.y );          // p1+t0
                __pushVert( verts, p1.x, p1.y );                    // p1
                __pushVert( verts, pintersect.x, pintersect.y );    // pintersect

                __pushVert( verts, p1.x+t2.x, p1.y+t2.y );          // p1+t2
                __pushVert( verts, p1.x, p1.y );                    // p1
                __pushVert( verts, pintersect.x, pintersect.y );    // pintersect
            }

            __pushVert( verts, p2.x+t2.x, p2.y+t2.y );              // p2+t2
            __pushVert( verts, p1.x-t2.x, p1.y-t2.y );              // p1-t2
            __pushVert( verts, p1.x+t2.x, p1.y+t2.y );              // p1+t2

            __pushVert( verts, p2.x+t2.x, p2.y+t2.y );              // p2+t2
            __pushVert( verts, p1.x-t2.x, p1.y-t2.y );              // p1-t2
            __pushVert( verts, p2.x-t2.x, p2.y-t2.y );              // p2-t2

        } else {

            __pushVert( verts, p0.x+t0.x, p0.y+t0.y );              // p0+t0
            __pushVert( verts, p0.x-t0.x, p0.y-t0.y );              // p0-t0
            __pushVert( verts, p1.x-anchor.x, p1.y-anchor.y );      // p1-anchor

            __pushVert( verts, p0.x+t0.x, p0.y+t0.y );              // p0+t0
            __pushVert( verts, p1.x-anchor.x, p1.y-anchor.y );      // p1-anchor
            __pushVert( verts, p1.x+t0.x, p1.y+t0.y );              // p1+t0

            if (join === cc.render.LineJoin.ROUND) {

                var _p0 = cc.math.Vector.add(p1, t0);
                var _p1 = cc.math.Vector.add(p1, t2);
                var _p2 = cc.math.Vector.sub(p1, anchor);

                var center = p1;

                __pushVert( verts, _p0.x, _p0.y );                 // _p0
                __pushVert( verts, center.x, center.y );           // center
                __pushVert( verts, _p2.x, _p2.y );                 // _p2

                createRoundCap(center, _p0, _p1, _p2, verts);

                __pushVert( verts, center.x, center.y );           // center
                __pushVert( verts, _p1.x, _p1.y );                 // _p1
                __pushVert( verts, _p2.x, _p2.y );                 // _p2

            } else {

                if (join === cc.render.LineJoin.BEVEL || (join === cc.render.LineJoin.MITER && dd >= miterLimit)) {

                    __pushVert( verts, p1.x+t0.x, p1.y+t0.y );      // p1+t0
                    __pushVert( verts, p1.x+t2.x, p1.y+t2.y );      // p1+t2
                    __pushVert( verts, p1.x-anchor.x, p1.y-anchor.y ); // p1-anchor
                }

                if (join === cc.render.LineJoin.MITER && dd < miterLimit) {

                    __pushVert( verts, pintersect.x, pintersect.y );// pintersect
                    __pushVert( verts, p1.x+t0.x, p1.y+t0.y );      // p1+t0
                    __pushVert( verts, p1.x+t2.x, p1.y+t2.y );      // p1+t2

                    __pushVert( verts, p1.x-anchor.x, p1.y-anchor.y );      // p1-anchor
                    __pushVert( verts, p1.x+t0.x, p1.y+t0.y );      // p1+t0
                    __pushVert( verts, p1.x+t2.x, p1.y+t2.y );      // p1+t2
                }
            }

            __pushVert( verts, p2.x+t2.x, p2.y+t2.y );              // p2+t2
            __pushVert( verts, p1.x-anchor.x, p1.y-anchor.y );      // p1-anchor
            __pushVert( verts, p1.x+t2.x, p1.y+t2.y );              // p1+t2

            __pushVert( verts, p2.x+t2.x, p2.y+t2.y );              // p2+t2
            __pushVert( verts, p1.x-anchor.x, p1.y-anchor.y );      // p1-anchor
            __pushVert( verts, p2.x-t2.x, p2.y-t2.y );              // p2-t2
        }
    }

    /**
     * ripped from http://www.blackpawn.com/texts/pointinpoly/default.html ;)
     *
     * Identify whether the <code>cc.math.Point</code> p is inside the triangle defined by the 3 point.
     *
     * @method cc.math.path.geometry.isPointInTriangle
     *
     * @param p {cc.math.Point}
     * @param ax {number}
     * @param ay {number}
     * @param bx {number}
     * @param by {number}
     * @param cx {number}
     * @param cy {number}
     * @returns {boolean}
     */
    export function isPointInTriangle(
        p:cc.math.Point,
        ax:number, ay:number,
        bx:number, by:number,
        cx:number, cy:number ) : boolean {

        var v0x = cx - ax;
        var v0y = cy - ay;
        var v1x = bx - ax;
        var v1y = by - ay;
        var v2x = p.x - ax;
        var v2y = p.y - ay;

        // Compute dot products
        var dot00 = Math.sqrt(v0x*v0x + v0y*v0y);
        var dot01 = Math.sqrt(v0x*v1x + v0y*v1y);
        var dot02 = Math.sqrt(v0x*v2x + v0y*v2y);
        var dot11 = Math.sqrt(v1x*v1x + v1y*v1y);
        var dot12 = Math.sqrt(v1x*v2x + v1y*v2y);

        // Compute barycentric coordinates
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1)

    }

    /**
     * Based from Ivank.polyk: http://polyk.ivank.net/polyk.js
     *
     * Turn a cloud of points to triangles.
     * The result of this operation will be an array of numbers, being each two a point, and each 6 a triangle.
     *
     * @method cc.math.path.geometry.tessellate
     * @param contour {Array<cc.math.Point>}
     * @returns {Float32Array}
     */
    export function tessellate( contour:cc.math.Point[] ) {

        var n = contour.length;

        if (n < 3) {
            return null;;
        }

        var triangles = [];

        var available = [];
        for (var i = 0; i < n; i++) {
            available.push(i);
        }

        var i = 0;
        var numPointsToTessellate = n;

        while (numPointsToTessellate > 3) {

            var i0:number = available[(i    ) % numPointsToTessellate];
            var i1:number = available[(i + 1) % numPointsToTessellate];
            var i2:number = available[(i + 2) % numPointsToTessellate];

            var ax = contour[i0].x;
            var ay = contour[i0].y;
            var bx = contour[i1].x;
            var by = contour[i1].y;
            var cx = contour[i2].x;
            var cy = contour[i2].y;

            var earFound = false;

            if (signedArea(ax, ay, bx, by, cx, cy)>=0) {
                earFound = true;
                for (var j = 0; j < numPointsToTessellate; j++) {
                    var vi = available[j];

                    if (vi === i0 || vi === i1 || vi === i2) {
                        continue;
                    }

                    if (isPointInTriangle(contour[vi], ax, ay, bx, by, cx, cy)) {
                        earFound = false;
                        break;
                    }
                }
            }

            if (earFound) {
                triangles.push(i0, i1, i2);
                available.splice((i + 1) % numPointsToTessellate, 1);
                numPointsToTessellate--;
                i = 0;
            } else if (i++ > 3 * numPointsToTessellate) {
                break;
            }
        }

        triangles.push(available[0], available[1], available[2]);

        var trianglesData= new Float32Array( triangles.length*2 );
        for( var i=0; i<triangles.length; i++ ) {
            var p:cc.math.Point= contour[ triangles[i] ];
            trianglesData[i*2  ]=p.x;
            trianglesData[i*2+1]=p.y;
        }

        return new Float32Array(trianglesData);
    }

}
/**
 * License: see license.txt file.
 */

/// <reference path="./path/Segment.ts"/>
/// <reference path="./path/ContainerSegment.ts"/>
/// <reference path="./path/SubPath.ts"/>
/// <reference path="./Point.ts"/>
/// <reference path="./Matrix3.ts"/>
/// <reference path="../util/Debug.ts"/>

module cc.math {

    import Segment = cc.math.path.Segment;
    import SubPath = cc.math.path.SubPath;
    import ContainerSegment = cc.math.path.ContainerSegment;
    import Vector = cc.math.Vector;
    import Matrix3 = cc.math.Matrix3;

    var __v0 : Vector = new Vector();
    var __v1 : Vector = new Vector();
    var __v2 : Vector = new Vector();
    var __v3 : Vector = new Vector();

    var __m0 : Float32Array = new Float32Array([1.0,0,0, 0,1.0,0, 0,0,1.0]);
    var __m1 : Float32Array = new Float32Array([1.0,0,0, 0,1.0,0, 0,0,1.0]);

    /**
     * 
     * @class cc.math.Path
     * @extends cc.math.path.ContainerSegment
     * @classdesc
     *
     * This class represents a Path Object.
     * By definition a Path is a collection of Segment objects. These segments are SubPath objects or other Paths.
     * Polimorphically a Path is a Segment itself, so complete paths can be added to another SubPath or Path as a Segment.
     *
     * A path has tracing capabilities. It differentiates from a SubPath in a few aspects:
     *  + a Path may have a cache of the stroke it represents.
     *  + a Path may have a cache of the fill it represents.
     *  + when tracing a Path, the Segments added are transformed by a transformation matrix.
     *  + a path represents an aggregation of Subpaths (contours)
     */
    export class Path extends ContainerSegment {

        /**
         * Path current sub path to add segments to. Initially, the current sub-path is the path itself.
         * As new sub-paths are created, _currentSubPath will point to that last sub-path.
         * @member cc.math.Path#_currentSubPath
         * @type {null}
         * @private
         */
        _currentSubPath : SubPath = null;

        /**
         * Cached stroke geometry.
         * @member cc.math.Path#_strokeGeometry
         * @type {Float32Array}
         * @private
         */
        _strokeGeometry : Float32Array = null;

        /**
         * Cached fill geometry.
         * @member cc.math.Path#_fillGeometry
         * @type {Float32Array}
         * @private
         */
        _fillGeometry : Float32Array = null;


        /**
         * Flag for stroke geometry cache invalidation.
         * @member cc.math.Path#_strokeDirty
         * @type {boolean}
         * @private
         */
        _strokeDirty= true;

        /**
         * Flag for fill geometry cache invalidation.
         * @member cc.math.Path#_fillDirty
         * @type {boolean}
         * @private
         */
        _fillDirty= true;

        /**
         * Build a new Path instance.
         * @method cc.math.Path#constructor
         */
        constructor() {
            super();
        }

        /**
         * Get the Path's number of SubPaths.
         * @method cc.math.Path#numSubPaths
         * @returns {number}
         */
        numSubPaths() : number {
            return this._segments.length;
        }

        /**
         * Create a new sub path.
         * @method cc.math.Path#__newSubPath
         * @private
         */
        __newSubPath() : void {
            var subpath : SubPath = new SubPath();
            this._segments.push( subpath );
            subpath._parent= this;
            this._currentSubPath = subpath;
        }

        /**
         * Test whether this Path is empty, ie has no sub paths.
         * @method cc.math.Path#isEmpty
         * @returns {boolean}
         */
        isEmpty() : boolean {
            return this._segments.length===0;
        }

        /**
         *
         * Make sure the path has a valid sub-path to trace segments on.
         *
         * If the Path has no current sub-path,
         *   a new sub-path is created and its tracer initialized to 0,0.
         * else
         *   if the current sub-path is closed
         *     a new sub-path is created and its tracer initialized to the current sub-path tracer position
         *   endif
         * endif
         *
         * @param x {number=}
         * @param y {number=}
         *
         * @method cc.math.Path#__ensureSubPath
         * @private
         */
        __ensureSubPath( x:number= 0, y:number= 0 ) : void {
            
            if ( this.isEmpty() ) {
                this.__newSubPath();
                this._currentSubPath.moveTo( x,y );
            }

        }

        /**
         * Chain two contours (subpath) when one is closed. Necessary for closed arcs.
         * @method cc.math.Path#__chainSubPathIfCurrentIsClosed
         * @private
         */
        __chainSubPathIfCurrentIsClosed() : void {

            if ( this._currentSubPath.isClosed() ) {
                var pt= this._currentSubPath._currentPoint;
                this.__newSubPath();
                this._currentSubPath.moveTo( pt.x, pt.y );
            }

        }

        /**
         * Get the Path current position for tracing.
         * This point corresponds to the tracing position of the current SubPath.
         *
         * @method cc.math.Path#getCurrentTracePosition
         * @returns {cc.math.Point}
         */
        getCurrentTracePosition() : Point {
            if ( this._currentSubPath===null ) {
                cc.Debug.warn( locale.WARN_TRACER_EMPTY, "getCurrentTracePosition" );
                return { x:0, y:0 }
            }

            return this._currentSubPath._currentPoint;
        }

        /**
         * Get the Path starting point.
         * It corresponds to the starting point of the first segment it contains, regardless of its type.
         * If there's no current SubPath, an empty Point (0,0) is returned.
         *
         * @method cc.math.Path#getStartingPoint
         * @returns {*}
         */
        getStartingPoint() : Vector {
            if ( this._currentSubPath===null ) {
                cc.Debug.warn( locale.WARN_TRACER_EMPTY, "getStartingPoint" );
                return __v0.set(0,0);
            }

            return this._currentSubPath.getStartingPoint();
        }

        /**
         * Get the Path ending point.
         * It corresponds to the ending point of the last segment it contains, regardless of its type.
         * If there's no current SubPath, an empty Point (0,0) is returned.
         *
         * @method cc.math.Path#getEndingPoint
         * @returns {*}
         */
        getEndingPoint() : Vector {

            if ( this._currentSubPath===null ) {
                cc.Debug.warn( locale.WARN_TRACER_EMPTY, "getEndingPoint" );
                return __v0.set(0,0);
            }

            return this._segments[ this._segments.length-1 ].getEndingPoint();
        }

        /**
         * Create a poli-line path from a set of Points.
         * If no points, or an empty array is passed, no Path is built and returns null.
         * @param points {Array<cc.math.Vector>}
         *
         * @method cc.math.Path.createFromPoints
         * @returns {cc.math.Path} Newly created path or null if the path can't be created.
         * @static
         */
        static createFromPoints( points : Vector[] ) : Path {

            if ( !points || points.length===0 ) {
                return null;
            }

            var closedPath= points[0].equals( points[points.length-1] );

            var path : Path= new Path();
            path.beginPath();
            path.moveTo( points[0].x, points[0].y );

            for( var i=1; i< (closedPath ? points.length-1 : points.length) ; i++ ) {
                path.lineTo( points[i].x, points[i].y );
            }

            if ( closedPath ) {
                path.closePath();
            }

            return path;
        }

        /**
         * Clear all sub-path data, and revert to the original path object status.
         * Make sure this path is not another's path segment.
         *
         * @method cc.math.Path#beginPath
         */
        beginPath() : Path {
            this._segments= [];
            this._length= 0;
            this._currentSubPath= null;
            this.setDirty();

            return this;
        }

        /**
         * Add a quadratic curve to the path.
         * @param x1 {number} control point x position
         * @param y1 {number} control point y position
         * @param x2 {number} second curve point x position
         * @param y2 {number} second curve point y position
         * @param matrix {Float32Array}
         *
         * @method cc.math.Path#quadraticCurveTo
         * @returns {cc.math.Path} the path holding the segment
         */
        quadraticCurveTo( x1:number, y1:number, x2:number, y2:number, matrix?:Float32Array ) : Path {

            __v0.set(x1,y1);
            __v1.set(x2,y2);
            if ( matrix ) {
                Matrix3.transformPoint(matrix,__v0);
                Matrix3.transformPoint(matrix,__v1);
            }

            this.__ensureSubPath();
            this._currentSubPath.quadraticTo( __v0.x, __v0.y, __v1.x, __v1.y );

            this.setDirty();

            return this;
        }

        /**
         * Add a quadratic curve to the path.
         * @param x1 {number} control point x position
         * @param y1 {number} control point y position
         * @param x2 {number} second curve point x position
         * @param y2 {number} second curve point y position
         * @param matrix {Float32Array}
         *
         * @method cc.math.Path#bezierCurveTo
         * @returns {cc.math.Path} the path holding the segment
         */
        bezierCurveTo( x0:number, y0:number, x1:number, y1:number, x2:number, y2:number, matrix?:Float32Array ) : Path {

            __v0.set(x0,y0);
            __v1.set(x1,y1);
            __v2.set(x2,y2);
            if ( matrix ) {
                Matrix3.transformPoint(matrix,__v0);
                Matrix3.transformPoint(matrix,__v1);
                Matrix3.transformPoint(matrix,__v2);
            }

            this.__ensureSubPath();
            this._currentSubPath.bezierTo( __v0.x, __v0.y, __v1.x, __v1.y, __v2.x, __v2.y );

            this.setDirty();

            return this;
        }

        catmullRomTo( points:Point[], closed:boolean, tension:number, matrix?:Float32Array ) : Path;
        catmullRomTo( cp0x:number,cp0y:number,cp1x:number,cp1y:number,p1x:number,p1y:number, tension:number, matrix?:Float32Array ): Path;

        /**
         * Add CatmullRom segments.
         * The segments are defined by an array of numbers, being each two the definition of a Point, or an array of
         * <code>cc.math.Point</code> objects.
         *
         * This method will create in the as much CatmullRom segments as needed based on the number of parameters supplied.
         *
         * @method cc.math.Path#catmullRomTo
         * @param p0
         * @param rest
         * @returns {cc.math.Path}
         */
        catmullRomTo( p0:any, ...rest:Array<any> ): Path {

            if ( typeof p0==="number ") {
                // assume a catmullromTo segment call with 6 numbers and an optional matrix
                if ( arguments.length<6 ) {
                    // not enough arguments
                    return;
                }

                this.__catmullRomTo(
                    p0,rest[0],
                    rest[1],rest[2],
                    rest[3],rest[4],
                    tension,
                    arguments.length>6 ? <Float32Array>rest[5] : null);

            } else if ( Array.isArray(p0) ) {

                var points= <Vector[]>p0;
                var closed= <boolean>rest[0];
                var tension= <number>rest[1];
                var matrix= arguments.length>3 ? <Float32Array>rest[2] : null;

                // create a collection of catmullrom segments.

                // copy array.
                points= points.slice(0);

                if (closed) {
                    points.unshift(points[points.length-1]);
                    points.push(points[1]);
                    points.push(points[2]);
                } else {
                    points.unshift(points[0]);
                    points.push(points[points.length-1]);
                }

                this.moveTo( points[0].x, points[0].y, matrix );
                for( var i=1; i<points.length-2; i++ ) {
                    this.__catmullRomTo(
                        points[ i   ].x,points[ i   ].y,
                        points[ i+1 ].x,points[ i+1 ].y,
                        points[ i+2 ].x,points[ i+2 ].y,
                        tension,
                        matrix );
                }
            } else {
                console.log("invalid signature Path.catmullRomTo");
            }

            this.setDirty();

            return this;
        }

        /**
         * Add a CatmullRom segment implementation.
         *
         * @method cc.math.Path#__catmullRomTo
         * @param cp0x {number}
         * @param cp0y {number}
         * @param cp1x {number}
         * @param cp1y {number}
         * @param p1x {number}
         * @param p1y {number}
         * @param matrix {Float32Array}
         */
        __catmullRomTo(cp0x:number, cp0y:number, cp1x:number, cp1y:number, p1x:number, p1y:number, tension:number, matrix?:Float32Array) {

            __v0.set(cp0x,cp0y);
            __v1.set(cp1x,cp1y);
            __v2.set(p1x,p1y);
            if ( matrix ) {
                Matrix3.transformPoint(matrix,__v0);
                Matrix3.transformPoint(matrix,__v1);
                Matrix3.transformPoint(matrix,__v2);
            }

            this.__ensureSubPath();
            this._currentSubPath.catmullRomTo(__v0.x, __v0.y, __v1.x, __v1.y, __v2.x, __v2.y, tension );

            this.setDirty();
        }

        /**
         * Close the current SubPath.
         *
         * @method cc.math.Path#closePath
         * @returns {cc.math.Path}
         */
        closePath() : Path {
            this._currentSubPath.closePath();
            this.setDirty();
            return this;
        }
        
        /**
         * Move the current path tracer to a position.
         * If the current sub-path is not started,
         *   set this point as the sub-path start point.
         * else
         *   if there are segments,
         *      create a new sub-path
         *   else
         *      set sub-path starting point to the new location
         * endif
         *
         * @method cc.math.Path#moveTo
         * @param x {number}
         * @param y {number}
         * @param matrix {cc.math.Float32Array=}
         */
        moveTo( x: number, y : number, matrix? : Float32Array ) : Path {

            if ( matrix ) {
                __v0.set(x,y);
                Matrix3.transformPoint( matrix, __v0 );
                x= __v0.x;
                y= __v0.y;
            }

            this.__ensureSubPath(x,y);
            if (!this._currentSubPath.isEmpty()) {
                this.__newSubPath();
            }
            this._currentSubPath.moveTo(x,y);

            return this;
        }

        /**
         * Add a line to the current path.
         * If there's no current SubPath, 
         * If the current path is not initialized, in will be initialized from 0,0 and a line added.
         *
         * @method cc.math.Path#lineTo
         * @param x {number}
         * @param y {number}
         * @param matrix {Float32Array=}
         */
        lineTo( x: number, y : number, matrix? : Float32Array ) : Path {

            if (matrix) {
                __v0.set(x, y);
                Matrix3.transformPoint(matrix,__v0);
                x = __v0.x;
                y = __v0.y;
            }

            this.__ensureSubPath(x,y);
            this.__chainSubPathIfCurrentIsClosed();

            this._currentSubPath.lineTo(x, y);

            this.setDirty();

            return this;
        }

        /**
         * Create a rect as a new SubPath. The rect has 4 segments which conform the rect.
         * It also created a new SubPath movedTo (x,y).
         *
         * @method cc.math.Path#rect
         * @param x {number}
         * @param y {number}
         * @param w {number}
         * @param h {number}
         * @param matrix {Float32Array=} transformation matrix.
         * @returns {cc.math.Path}
         */
        rect( x:number, y:number, w:number, h:number, matrix? : Float32Array ): Path {

            this.__ensureSubPath();

            // may reuse the current subpath ? (nosegments, and not empty)
            if ( this._currentSubPath.numSegments()!==0 ) {
                this.__newSubPath();
            }

            __v0.set( x,   y );
            __v1.set( x+w, y );
            __v2.set( x+w, y+h );
            __v3.set( x,   y+h );

            if ( matrix ) {
                Matrix3.transformPoint( matrix,__v0 );
                Matrix3.transformPoint( matrix,__v1 );
                Matrix3.transformPoint( matrix,__v2 );
                Matrix3.transformPoint( matrix,__v3 );
            }

            this.moveTo( __v0.x, __v0.y );
            this.lineTo( __v1.x, __v1.y );
            this.lineTo( __v2.x, __v2.y );
            this.lineTo( __v3.x, __v3.y );
            this.closePath();

            this.__newSubPath();
            this._currentSubPath.moveTo( __v0.x, __v0.y );
            this.setDirty();

            return this;
        }

        /**
         * Create an arc segment and add it to the current SubPath.
         * If a SubPath exists, a straight line to (x,y) is added.
         * if the angle difference is > 2PI the angle will be clampled to 2PI. The angle difference will be
         * endAngle - startAngle if anticlockwise is false, and startAngle - endAngle otherwise.
         * In this implementation if the radius is < 0, the radius will be set to 0.
         * If the radius is 0 or the diffangle is 0, no arc is added.
         *
         * @method cc.math.Path#arc
         * @param x {number}
         * @param y {number}
         * @param radius {number}
         * @param startAngle {number}
         * @param endAngle {number}
         * @param anticlockwise {boolean} arc draw direction
         * @param matrix {Float32Array}
         */
        arc( x:number, y:number, radius:number, startAngle:number, endAngle:number, anticlockwise:boolean, matrix?:Float32Array ) : Path {

            var addLine : boolean = false;

            // transform position (center) based on transformation
            __v0.set( x,y );
            if ( matrix ) {
                Matrix3.transformPoint( matrix, __v0 );
            }
            x= __v0.x;
            y= __v0.y;

            // ensure a valid subpath to add the segment to exists.
            this.__ensureSubPath(x,y);

            // flag add a straight line from the last trace point to the start of the arc (if apply)
            if ( this._currentSubPath.numSegments() ) {
                addLine= true;
            }

            // correct angles. always get the smallest angle on the arc.
            var diffAngle= (endAngle - startAngle);
            if (diffAngle>2*Math.PI) {
                diffAngle=2*Math.PI;
            } else if (diffAngle<-2*Math.PI) {
                    diffAngle=-2*Math.PI;
            }

            // if there's no difference between start and end angles, this will be a single point arc.
            if ( (-.0001<diffAngle && diffAngle<.0001) ) {
                // bugbug should i add a line if flag addLine says so ?
                return this;
            }

            this.__chainSubPathIfCurrentIsClosed();


            // calculate radius based on transformation. the new radius is a segment of radius size transformed
            // by the current matrix.
            radius= cc.math.path.getDistanceVector( radius, matrix ).length();

            // if radius < something visible, do nothing
            if ( radius<=0.1 ) {
                this.__ensureSubPath(x,y);
                return this;
            }

            // calculate start angle based on current matrix
            if ( matrix ) {

                Matrix3.copy( matrix, __m0 );
                Matrix3.setRotate( __m1, startAngle );
                Matrix3.multiply(__m0, __m1);

                startAngle= cc.math.path.getDistanceVector(1,__m0).angle();
            }

            this._currentSubPath.arc( x,y,radius,startAngle,startAngle+diffAngle,anticlockwise,addLine );
            this.setDirty();

            return this;
        }

        /**
         * Deep clone this path, contours and segments.
         * @method cc.math.Path#clone
         * @return {cc.math.Path} a cloned path.
         */
        clone() : Path {
            var path= new Path();

            for( var i=0; i<this._segments.length; i++ ) {
                path._segments.push( this._segments[i].clone() );
            }

            path._currentSubPath = <SubPath>path._segments[ path._segments.length - 1 ];
            path._length= this._length;

            return path;
        }

        /**
         * Mark the path as dirty. Also, the cache for stroke and fill are marked as dirty.
         * @method cc.math.Path#setDirty
         */
        setDirty() {
            this._dirty= true;
            this._fillDirty= true;
            this._strokeDirty= true;
        }

        /**
         * Paint the path in a canvas rendering context.
         * @method cc.math.Path#paint
         * @param ctx {cc.render.RenderingContext}
         */
        paint( ctx:cc.render.RenderingContext ) {
            for( var i=0; i<this._segments.length; i++ ) {
                this._segments[i].paint(ctx);
            }
        }

        /**
         * If needed, calculate the stroke geometry for a path.
         * The stroke mesh will be traced based of line attributes.
         * On average, you will never interact with this method.
         * @method cc.math.Path#getStrokeGeometry
         * @param attributes {cc.math.path.geometry.StrokeGeometryAttributes}
         * @returns {Float32Array}
         */
        getStrokeGeometry( attributes : cc.math.path.geometry.StrokeGeometryAttributes ) {

            if ( this._dirty || this._strokeDirty ) {

                var size : number = 0;
                var buffers : Float32Array[] = [];

                for( var i=0; i<this._segments.length; i++ ) {

                    var subPath = this._segments[i];
                    var contourPoints = subPath.trace();

                    var buffer:Float32Array = cc.math.path.geometry.getStrokeGeometry( subPath.trace(), attributes );

                    if ( null!==buffer ) {
                        size += buffer.length;
                        buffers.push(buffer);
                    }
                };

                this._strokeGeometry= new Float32Array( size );

                var offset= 0;
                for( var i=0; i<buffers.length; i++ ) {
                    this._strokeGeometry.set( buffers[i], offset );
                    offset+= buffers[i].length;
                }

                this._dirty = false;
                this._strokeDirty= false;
            }

            return this._strokeGeometry;
        }

        /**
         * If needed, tessellate the points of the path and create a mesh.
         * On average, you will never interact with this method.
         * @method cc.math.Path#getFillGeometry
         * @returns {Float32Array}
         */
        getFillGeometry( ) {

            if ( this._dirty || this._fillDirty ) {

                var size : number = 0;
                var buffers : Float32Array[] = [];

                for( var i=0; i<this._segments.length; i++ ) {

                    var subPath = this._segments[i];
                    var contourPoints = subPath.trace();

                    var contour= subPath.trace();

                    var buffer:Float32Array = cc.math.path.geometry.tessellate( contour );


                    if ( null!==buffer ) {
                        size += buffer.length;
                        buffers.push(buffer);
                    }
                };

                this._fillGeometry= new Float32Array( size );

                var offset= 0;
                for( var i=0; i<buffers.length; i++ ) {
                    this._fillGeometry.set( buffers[i], offset );
                    offset+= buffers[i].length;
                }

                this._dirty = false;
                this._fillDirty= false;
            }

            return this._fillGeometry;
        }

    }
}
/**
 * License: see license.txt file.
 */


/// <reference path="../math/Point.ts"/>
/// <reference path="../math/Rectangle.ts"/>
/// <reference path="../math/Dimension.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../util/util.ts"/>
/// <reference path="../util/Debug.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../action/SchedulerQueue.ts"/>
/// <reference path="../action/ActionChainContext.ts"/>
/// <reference path="./Scene.ts"/>

module cc.node {

    export var DEFAULT_ANCHOR_POSITION= new cc.math.Vector(0,0);
    export var DEFAULT_ANCHOR_TRANSFORMATION= new cc.math.Vector(0.5,0.5);

    "use strict";

    import Vector=                  cc.math.Vector;
    import Point=                   cc.math.Point;
    import Rectangle=               cc.math.Rectangle;
    import Dimension=               cc.math.Dimension;
    import Matrix3=                 cc.math.Matrix3;
    import Color=                   cc.math.Color;
    import Action=                  cc.action.Action;
    import Scene=                   cc.node.Scene;
    import RenderingContext=        cc.render.RenderingContext;
    import SchedulerQueue=          cc.action.SchedulerQueue;
    import SchedulerQueueTask=      cc.action.SchedulerQueueTask;
    import SchedulerTaskCallback=   cc.action.SchedulerTaskCallback;

    var RADIANS= Math.PI/180;

    /**
     * Node flag values.
     * Instead of managing several boolean properties they are grouped in a number value.
     * @tsenum cc.node.NodeDirtyFlags
     */
    export enum NodeDirtyFlags {

        NONE =                      0x0000,
        CHILDREN_SORT =             0x0001,
        TRANSFORMATION_DIRTY=       0x0002,
        REQUEST_TRANSFORM=          0x0004,
        VISIBLE=                    0x0008,
        INVERSE_MATRIX=             0x0010,
        PAUSED=                     0x0020,
        EVENTS_ENABLED=             0x0040,
        EVENTS_PRIORITY_ENABLED=    0x0080,
        COMPOSITE_ON=               0x0100,
        GLOBAL_ALPHA=               0x0200,
        AABB_DIRTY=                 0x0400
    }

    /**
     * Callback interface for node's that math an enumeration pattern.
     * @memberOf cc.node
     * @callback EnumerateCallback
     * @param node {Node} This callback will be called for each Node that matches the pattern.
     * @see {cc.node.Node#enumerateChildren}
     */
    export interface EnumerateCallback {
        (node:Node):void;
    }

    /**
     * Index sequence variable for node's OrderOfArrival.
     * @type {number}
     * @private
     */
    var _OrderOfArrival : number = 0;

    var DEFAULT_COLOR:Color= new Color(1,1,1,1);

    var __p0= new cc.math.Vector();

    /**
     * @class cc.node.Node
     * @classdesc
     *
     * Node is the base class for all Cocos2d HTML5 elements that are screen entities.
     *
     * A Node is composed by a dimension, and some properties like position, rotation and scale, and a collection of
     * children.
     * Children are divided into two groups: children that are behind the node (z-index<0) and children that are
     * in front of the node (z-index>=0).
     * These transformation properties are hierarchically applied to its children, meaning that if a node is rotated,
     * all its children will show rotated as well.
     * A node can have input routed to it, has drawing capabilities, and can have a collection of actions predefined
     * to be applied to it.
     *
     */
    export class Node {

        /**
         * Hierarchy dependent nodes.
         * @member cc.node.Node#_children
         * @type {Array<cc.node.Node>}
         * @private
         */
        _children:Array<Node> = [];

        /**
         * This node's parent node.
         * <br>
         * Don't set directly.
         * @member cc.node.Node#_parent
         * @type {cc.node.Node}
         * @private
         */
        _parent:Node = null;

        /**
         * This node's position.
         * @member cc.node.Node#_position
         * @type {cc.math.Vector}
         * @private
         */
        _position:Vector = new Vector();

        /**
         * Node's position anchor.
         * The anchor is normalized, meaning 1 to be node's width or height.
         * @member cc.node.Node#_positionAnchor
         * @type {cc.math.Vector}
         * @private
         */
        _positionAnchor:Vector = DEFAULT_ANCHOR_POSITION.clone();

        /**
         * Node's rotation angles for x and y.
         * @member cc.node.Node#_rotation
         * @type {cc.math.Vector}
         * @private
         */
        _rotation:Vector = new Vector(0.0, 0.0);

        /**
         * Node's scale coeficients.
         * @member cc.node.Node#_scale
         * @type {cc.math.Vector}
         * @private
         */
        _scale:Vector = new Vector(0.0, 0.0);

        /**
         * Node's skew values.
         * @member cc.node.Node#_skew
         * @type {cc.math.Vector}
         * @private
         */
        //_skew:Vector = new Vector(0, 0);

        /**
         * Node's transformation anchor. Scale and rotation will be around this anchor value.
         * @member cc.node.Node#_transformationAnchor
         * @type {cc.math.Vector}
         * @private
         */
        _transformationAnchor:Vector = DEFAULT_ANCHOR_TRANSFORMATION.clone();

        /**
         * Node's local transformation matrix.
         * @member cc.node.Node#_modelViewMatrix
         * @type {Float32Array}
         * @private
         */
        _modelViewMatrix:Float32Array = Matrix3.create();

        /**
         * Node's global transformation matrix.
         * @member cc.node.Node#_worldModelViewMatrix
         * @type {Float32Array}
         * @private
         */
        _worldModelViewMatrix:Float32Array = Matrix3.create();

        /**
         * Node's inverse global transformation matrix.
         * @member cc.node.Node#_worldModelViewMatrixI
         * @type {Float32Array}
         * @private
         */
        _worldModelViewMatrixI:Float32Array = Matrix3.create();

        /**
         * Node's color. This color, when drawing images, will be set as tint color.
         * Tinting will only be enabled in webgl renderers though.
         * @member cc.node.Node#_color
         * @type {cc.math.Color}
         * @private
         */
        _color:Color = DEFAULT_COLOR;

        /**
         * opacity value. full opaque by default. opacity values go from 0 full transparent to 1 full opaque.
         * @member cc.node.Node#_alpha
         * @type {number}
         * @private
         */
        _alpha:number = 1;

        /**
         * Compound parent cascade alpha value.
         * @member cc.node.Node#_frameAlpha
         * @type {number}
         * @private
         */
        _frameAlpha:number = 1;

        /**
         * Node's dimension.
         * @member cc.node.Node#_contentSize
         * @type {cc.math.Vector}
         * @private
         */
        _contentSize:Dimension = new Dimension();

        /**
         * Node's z-index values.
         * Nodes with a less than zero z-index will be drawn first, then its parent, and then nodes with a greater or
         * equal than zero z-index value.
         * @member cc.node.Node#_localZOrder
         * @type {number}
         * @private
         */
        _localZOrder:number = 0;

        /**
         * Node's order of arrival to the parent node.
         * When sorting a node's children, first, the z-index is taken into account. But nodes with the same z-index
         * will then be sorted by the order of arrival.
         * The order of arrival is by default set incrementally, but the developer has the option to modify it anytime.
         * @member cc.node.Node#_orderOfArrival
         * @type {number}
         * @private
         */
        _orderOfArrival : number = 0;

        /**
         * internal flag that indicates if the node is rotated (false) or not (true).
         * @member cc.node.Node#_isAA
         * @type {boolean}
         * @private
         */
        _isAA:boolean = false;

        /**
         * Axis aligned bounding box.
         * @member cc.node.Node#_AABB
         * @type {cc.math.Rectangle}
         * @private
         */
        _AABB:Rectangle = new Rectangle();

        /**
         * Bounding Box. May overlap _AABB
         * @member cc.node.Node#_BBVertices
         * @type {Array<cc.math.Vector>}
         * @private
         */
        _BBVertices:Array<Point> = [ {x:0.0,y:0.0},{x:0.0,y:0.0},{x:0.0,y:0.0},{x:0.0,y:0.0} ];

        /**
         * Node tag. Only for backwards compatibility.
         * @member cc.node.Node#_tag
         * @type {any}
         * @private
         * @deprecated
         */
        _tag:any = null;

        /**
         * Node name.
         * @member cc.node.Node#_name
         * @type {string}
         * @private
         */
        _name : string = "";

        /**
         * Internal integer value with some flags that affect a node.
         * Values for this flags variable are defined in cc.node.NodeDirtyFlags.
         * Never set this value manually.
         * @member cc.node.Node#_flags
         * @type {number}
         * @private
         */
        _flags : number = 0;

        /**
         * Scene this node is running in.
         * @member cc.node.Node#_scene
         * @type {cc.node.Scene}
         * @private
         */
        _scene : Scene = null;

        /**
         * When no scene is yet set, this array holds Node's actions.
         * @member cc.node.Node#_actionsToSchedule
         * @type {Array<cc.node.Action>}
         * @private
         */
        _actionsToSchedule : Array<Action> = [];

        /**
         * When no scene is yet set, this array holds Node's scheduled tasks.
         * @member cc.node.Node#_tasksToSchedule
         * @type {Array<cc.node.Action>}
         * @private
         */
        _tasksToSchedule : Array<SchedulerQueueTask> = [];

        /**
         * Node x position.
         * @member cc.node.Node#x
         * @type {number}
         */
        x : number = 0.0;

        /**
         * Node y position.
         * @member cc.node.Node#y
         * @type {number}
         */
        y : number = 0.0;

        /**
         * Node scale X.
         * @member cc.node.Node#scaleX
         * @type {number}
         */
        scaleX : number = 1.0;

        /**
         * Node scale Y.
         * @member cc.node.Node#scaleY
         * @type {number}
         */
        scaleY : number = 1.0;

        /**
         * Node rotation angle in degrees.
         * @member cc.node.Node#rotationAngle
         * @type {number}
         */
        rotationAngle : number = 0.0;

        _compositeOperation : cc.render.CompositeOperation = cc.render.CompositeOperation.source_over;

        _inputEvents : any= {};

        /**
         * Create a new Node object.
         * @method cc.node.Node#constructor
         */
        constructor() {
            this._flags= NodeDirtyFlags.REQUEST_TRANSFORM |
            NodeDirtyFlags.VISIBLE |
            NodeDirtyFlags.AABB_DIRTY;

            // for backwards compatibility, nodes with zero dimension are shown. Not in v4, where everything must have
            // dimension.
            if ( cc.__BACKWARDS_COMPATIBILITY__ ) {
                this._contentSize.set(1, 1);
            }
        }

        /**
         * Internal flag check for sorting children nodes.
         * @method cc.node.Node#__childrenMustSort
         * @returns {boolean}
         * @private
         */
        __childrenMustSort() : boolean {
            return this._children.length>1 && (this._flags&NodeDirtyFlags.CHILDREN_SORT)!==0;
        }

        /**
         * Clear a flag. To avoid managing several different boolean members we pack all of them in a number value.
         * Flag values are {@link cc.node.NodeDirtyFlags}
         * @method cc.node.Node#__clearFlag
         * @param f {number} a flag value.
         * @private
         */
        __clearFlag( f : number ) : void {
            this._flags &= ~f;
        }

        /**
         * Set a flag. To avoid managing several different boolean members we pack all of them in a number value.
         * Flag values are {@link cc.node.NodeDirtyFlags}
         * @method cc.node.Node#__clearFlag
         * @param f {number} a flag value.
         * @private
         */
        __setFlag( f : number ) : void {
            this._flags |= f;
        }

        /**
         * Return whether a flag is set.
         * @method cc.node.Node#__isFlagSet
         * @param f {number}
         * @returns {boolean}
         * @private
         */
        __isFlagSet( f : number ) : boolean{
            return (this._flags&f)!==0;
        }

        /**
         * Enable or disable a flag.
         * @method cc.node.Node#__setFlagValue
         * @param f {number}
         * @param enable {boolean} true to enable, false to disable.
         * @private
         */
        __setFlagValue( f:number, enable:boolean ) {
            if (enable) {
                this._flags|=f;
            } else {
                this._flags &= ~f;
            }
        }

        isGlobalAlpha() : boolean {
            return this.__isFlagSet( NodeDirtyFlags.GLOBAL_ALPHA );
        }

        setGlobalAlpha( b:boolean ) {
            this.__setFlagValue( NodeDirtyFlags.GLOBAL_ALPHA, b );
        }

        /**
         * Set the node composite operation (or blending mode).
         * blending modes available are defined in the cc.render.CompositeOperation enumeration.
         * Pass null to disable custom blending mode, and apply the currently set one.
         * @method cc.node.Node.setCompositeOperation
         * @param o {cc.render.CompositeOperation}
         */
        setCompositeOperation( o:cc.render.CompositeOperation ) {
            if ( o!==null ) {
                this._compositeOperation= o;
                this.__setFlag( cc.node.NodeDirtyFlags.COMPOSITE_ON );
            } else {
                this.__clearFlag( cc.node.NodeDirtyFlags.COMPOSITE_ON );
            }
        }

        /**
         * Set this node position in parent's coordinate space.
         * @method cc.node.Node#setPosition
         * @param x {number} x position.
         * @param y {number} y position.
         * @returns {cc.node.Node}
         */
        setPosition(x:number, y:number) : Node {

            this.x=x;
            this.y=y;
            return this;
        }

        /**
         * Set this node's rotation angle
         * @method cc.node.Node#setRotation
         * @param x {number} rotation angle in degrees.
         * @returns {cc.node.Node}
         */
        setRotation(x:number):Node {

            this.rotationAngle= x;
            return this;
        }

        /**
         * Set this node's scale.
         * If y parameter is not set, the scale will be the same for both axis.
         * @method cc.node.Node#setScale
         * @param x {number} scale for x axis
         * @param y {number=} optional scale for y axis. If not set, x scale will be set for y axis.
         * @returns {cc.node.Node}
         */
        setScale(x:number, y?:number):Node {

            this.scaleX= x;
            this.scaleY= typeof y==="undefined" ? x : y;

            return this;
        }

        /**
         * Set the Node X axis scale value.
         * @param s {number} default scale is 1.
         * @returns {cc.node.Node}
         */
        setScaleX( s : number ) : Node {
            this.scaleX= s;
            return this;
        }

        /**
         * Set the Node Y axis scale value.
         * @param s {number} default scale is 1.
         * @returns {cc.node.Node}
         */
        setScaleY( s : number ) : Node {
            this.scaleY= s;
            return this;
        }

        /**
         * Gets node's parent. The parent is another Node. Some specialized node types like <code>Scene</code> and
         * <code>Director</code> don't have a parent.
         * @method cc.node.Node#getParent
         * @returns {Node} value will be null if no parent, and a Node instance otherwise.
         */
        getParent():Node {
            return this._parent;
        }

        /**
         * Sets node's parent.
         * <br>
         * Never call directly.
         * @method cc.node.Node#__setParent
         * @param node {cc.node.Node}
         * @returns {cc.node.Node}
         * @private
         */
        __setParent(node:Node):Node {
            this._parent = node;
            this.__setFlag( NodeDirtyFlags.REQUEST_TRANSFORM );
            return this;
        }

        /**
         * Set node's positional anchor.
         * <li>By default the node will be position anchored at 0,0.
         * <li>The position anchor is a normalized value. This means it must be set with values between 0 and 1.
         * <li>Calling this method with 0,0 will means the node will be positioned relative to top-left corner.
         * <li>Calling with 0.5, 0.5, means the node will be positioned relative to its center regardless of its size.
         * @method cc.node.Node#setPositionAnchor
         * @param x {number}
         * @param y {number}
         * @returns {cc.node.Node}
         */
        setPositionAnchor(x:number, y:number):Node {
            this._positionAnchor.set(x, y);
            this.__setFlag( NodeDirtyFlags.REQUEST_TRANSFORM );
            return this;
        }

        /**
         * Set node's positional and transformational anchors.
         * <li>By default the node will be position anchored at 0,0.
         * <li>The anchor is a normalized value. This means it must be set with values between 0 and 1.
         * <li>Calling this method with 0,0 will means the node will be positioned relative to top-left corner.
         * <li>Calling with 0.5, 0.5, means the node will be positioned relative to its center regardless of its size.
         * <li>This method is deprecated in favor of setTransformationAnchor and setPositionAnchor.
         * @method cc.node.Node#setAnchorPoint
         * @param x {number}
         * @param y {number}
         * @returns {cc.node.Node}
         * @deprecated
         */
        setAnchorPoint(x:number, y:number):Node {
            this.__setFlag( NodeDirtyFlags.REQUEST_TRANSFORM );
            this.setTransformationAnchor(x,y);
            return this.setPositionAnchor(x,y);
        }

        /**
         * Set node's transformation anchor.
         * By default the node will be transformed (scale/rotate) by the node's center.
         * @method cc.node.Node#setTransformationAnchor
         * @param x {number}
         * @param y {number}
         * @returns {cc.node.Node}
         */
        setTransformationAnchor(x:number, y:number):Node {
            this._transformationAnchor.set(x, y);
            this.__setFlag( NodeDirtyFlags.REQUEST_TRANSFORM );
            return this;
        }

        /**
         * Set this node's tag.
         * @method cc.node.Node#setTag
         * @param t {object}
         * @returns {cc.node.Node}
         */
        setTag(t:any):Node {
            this._tag = t;
            return this;
        }

        /**
         * Set Node opacity. Opacity is alpha value.
         * backwards compatible method. use setAlpha or alpha get/set.
         * @param v {number} value in the range 0..255
         * @deprecated
         * @returns {cc.node.Node}
         */
        setOpacity( v : number ) : Node {
            this.setAlpha( v/255.0 );
            return this;
        }

        /**
         * Setter for node's alpha (transparency) value.
         * Alpha values are from 0 to 1.
         * @name cc.node.Node#set:alpha
         * @param a {number}
         */
        set alpha(a:number) {
            this.setAlpha(a);
        }

        /**
         * Get node's transparency value.
         * Transparency values are from 0 to 1.
         * @name cc.node.Node#get:alpha
         * @returns {number}
         */
        get alpha() {
            return this.getAlpha();
        }

        /**
         * Setter for node's alpha (transparency) value.
         * Alpha values are from 0 to 1.
         * @name cc.node.Node#set:opacity
         * @param a {number}
         */
        set opacity(a:number) {
            this.setOpacity(a);
        }

        /**
         * Get node's transparency value.
         * Transparency values are from 0 to 1.
         * @name cc.node.Node#get:opacity
         * @returns {number}
         */
        get opacity() {
            return (this.getAlpha()*255.0)|0;
        }

        /**
         * Set node's transparency  value.
         * @method cc.node.Node#setAlpha
         * @param a {number} value from 0 to 1.
         * @returns {cc.node.Node}
         */
        setAlpha(a:number):Node {

            this._alpha= a;
            return this;
        }

        /**
         * Get node's transparency value.
         * Transparency values are from 0 to 1.
         * @method cc.node.Node#getAlpha
         * @returns {number}
         */
        getAlpha():number {
            return this._alpha;
        }

        /**
         * Set node's color.
         * <br>
         * Color components are values between 0 and 1.
         * 0 means no color, 1 means full color component.
         *
         *
         * The color, will be Node's color, but for a Sprite, it will be the image's tint color.
         * Tint colors modify visual appearance of the node paint pixels.
         * The tint result is the pixel color multiplied by the tint color.
         * The final tint color will be: [color.red, color.green, color.blue, node.alpha]
         * The default color is solid white, which leaves pixel values unmodified.
         *
         * Alpha color modification comes by calling the opacity/alpha methods.
         *
         * @method cc.node.Node#setColor
         * @param r {number} value between 0 and 1 or a Color object instance.
         * @param g {number} between 0 and 1
         * @param b {number} between 0 and 1
         * @returns {cc.node.Node}
         */
        setColor(r:number, g:number, b:number):Node {

            if ( this._color===DEFAULT_COLOR ) {
                this._color= new Color(r,g,b);
            } else {
                this._color._color[0]= r;
                this._color._color[1]= g;
                this._color._color[2]= b;
            }

            return this;
        }

        /**
         * Set this node's content size.
         * @method cc.node.Node#setContentSize
         * @param w {number} node width
         * @param h {number} node height
         * @returns {cc.node.Node}
         */
        setContentSize(w:number, h:number):Node {

            this._contentSize.width= w;
            this._contentSize.height= h;
            this.__setFlag( NodeDirtyFlags.REQUEST_TRANSFORM );

            return this;
        }

        /**
         * Set node's local and global transformation matrices.
         * The matrices may not change.
         * <br>
         * Do not call directly
         * @method cc.node.Node#__setTransform
         * @returns {cc.node.Node}
         * @private
         */
        __setTransform():Node {
            this.__setLocalTransform();
            this.__setWorldTransform();

            if ( this.__isFlagSet( NodeDirtyFlags.TRANSFORMATION_DIRTY ) ) {
                this.__setFlag( NodeDirtyFlags.INVERSE_MATRIX );
                this.__setFlag( NodeDirtyFlags.AABB_DIRTY );
            }

            return this;
        }

        /**
         * Set the Node local transformation matrix as rotation. Slowest method.
         * @method cc.node.Node#__setLocalTransformRotate
         * @private
         */
        __setLocalTransformRotate() {
            Matrix3.setTransformAll(this._modelViewMatrix, this);
            this.__setFlag( NodeDirtyFlags.TRANSFORMATION_DIRTY );
            this._position.x= this.x;
            this._position.y= this.y;
            this._scale.x= this.scaleX;
            this._scale.y= this.scaleY;
            this._rotation.x= this.rotationAngle;
        }

        /**
         * Set the Node local transformation matrix as scale.
         * @method cc.node.Node#__setLocalTransformScale
         * @private
         */
        __setLocalTransformScale() {
            Matrix3.setTransformScale(this._modelViewMatrix, this);
            this.__setFlag( NodeDirtyFlags.TRANSFORMATION_DIRTY );
            this._position.x= this.x;
            this._position.y= this.y;
            this._scale.x= this.scaleX;
            this._scale.y= this.scaleY;
        }

        /**
         * Set node's local transformation matrix.
         * This method is very specific and calls different code based on the transformation type that has
         * been detected.
         * @method cc.node.Node#__setLocalTransform
         * @private
         */
        __setLocalTransform() {

            if ( this._rotation.x!==this.rotationAngle || (this.rotationAngle%360)!==0 || this.__isFlagSet(NodeDirtyFlags.REQUEST_TRANSFORM) ) {
                this.__setLocalTransformRotate();
            } else if ( this.scaleX!==this._scale.x || this._scale.y!==this.scaleY || this._scale.x!==1 || this._scale.y!==1 ) {
                this.__setLocalTransformScale();
            } else if ( this.x!==this._position.x || this.y!==this._position.y ) {

                var mm=this._modelViewMatrix;
                var pa=this._positionAnchor;
                var cs=this._contentSize;
                var x: number = this.x - pa.x * cs.width;
                var y: number = this.y - pa.y * cs.height;
                mm[2] = x;
                mm[5] = y;
                mm[0] = 1.0;
                mm[1] = 0.0;
                mm[3] = 0.0;
                mm[4] = 1.0;
                mm[6] = 0.0;
                mm[7] = 0.0;
                mm[8] = 1.0;

                this._position.x= this.x;
                this._position.y= this.y;
                this.__setFlag( NodeDirtyFlags.TRANSFORMATION_DIRTY );
            }
        }

        /**
         * Set node's global transformation when the node is not axis aligned.
         * @method cc.node.Node#__setWorldTransformNotAA
         * @private
         */
        __setWorldTransformNotAA() {

            var mm:Float32Array;
            var mmm:Float32Array = this._worldModelViewMatrix;
            var pmm:Float32Array = this._parent._worldModelViewMatrix;

            mmm[0] = pmm[0];
            mmm[1] = pmm[1];
            mmm[2] = pmm[2];
            mmm[3] = pmm[3];
            mmm[4] = pmm[4];
            mmm[5] = pmm[5];

            if (this._isAA) {
                mm = this._modelViewMatrix;
                mmm[2] += (mm[2] * mmm[0]);
                mmm[5] += (mm[5] * mmm[4]);
            } else {
                Matrix3.multiply(this._worldModelViewMatrix, this._modelViewMatrix);
            }

        }

        /**
         * Set node's world transformation when the node is Axis Aligned.
         * An axis aligned Node means that the node, and all its ancestors are axis aligned.
         * @method cc.node.Node#__setWorldTransformAA
         * @private
         */
        __setWorldTransformAA( px:number, py:number ) {
            var wmm:Float32Array = this._worldModelViewMatrix;
            var mmm:Float32Array = this._modelViewMatrix;

            wmm[0] = mmm[0];
            wmm[1] = mmm[1];
            wmm[2] = mmm[2] + px;
            wmm[3] = mmm[3];
            wmm[4] = mmm[4];
            wmm[5] = mmm[5] + py;

            this._isAA = (this._rotation.x % 360.0) === 0.0;
        }

        /**
         * Calculate node's global transformation matrix.
         * @method cc.node.Node#__setWorldTransform
         * @private
         */
        __setWorldTransform() {

            var condition = this.__isFlagSet( NodeDirtyFlags.TRANSFORMATION_DIRTY );
            var isAA= (this._rotation.x % 360.0) === 0.0;
            var px= 0;
            var py= 0;
            if (this._parent) {
                condition = condition || this._parent.__isFlagSet( NodeDirtyFlags.TRANSFORMATION_DIRTY );
                isAA= isAA && this._parent._isAA;
            }

            if (condition) {

                this._isAA= isAA;
                if ( this._parent ) {
                    px= this._parent._worldModelViewMatrix[2];
                    py= this._parent._worldModelViewMatrix[5];
                }

                if (isAA) {
                    this.__setWorldTransformAA(px,py);
                } else {
                    this.__setWorldTransformNotAA();
                }

                this.__setFlagValue(NodeDirtyFlags.TRANSFORMATION_DIRTY,condition);

            }

        }

        getInverseWorldModelViewMatrix( ) : Float32Array {

            if ( this.__isFlagSet(NodeDirtyFlags.INVERSE_MATRIX ) ) {
                Matrix3.inverse( this._worldModelViewMatrix, this._worldModelViewMatrixI );
                this.__clearFlag( NodeDirtyFlags.INVERSE_MATRIX );
            }

            return this._worldModelViewMatrixI;
        }

        /**
         * Visit a node.
         * The process of visiting implies several different steps and is only performed for visible nodes:
         *
         * <li>Calculate (if needed) local and global transformation matrices
         * <li>Prune the node if not showing on screen.
         * <li>Perform children sort.
         * <li>Visit children with z-index < 0
         * <li>Draw this node
         * <li>Visit children with z-index >= 0
         * <li>Reset transformation dirtiness
         *
         * @method cc.node.Node#visit
         * @param ctx {cc.render.RenderingContext}
         */
        visit(ctx:RenderingContext) {

            if (!this.isVisible()) {
                return;
            }

            this.__clearFlag( NodeDirtyFlags.TRANSFORMATION_DIRTY );
            this.__setTransform();

            //if (this.__AABBIntersectsScreen(ctx) || true) {

                if (this.__childrenMustSort()) {
                    this.__sortChildren();
                }

                this.__setAlphaImpl();

                var index:number = 0;

                for (index = 0; index < this._children.length; index++) {
                    var child = this._children[index];
                    if (child._localZOrder < 0) {
                        child.visit(ctx);
                    } else {
                        break;
                    }
                }

                this.__draw(ctx);

                for (; index < this._children.length; index++) {
                    var child = this._children[index];
                    child.visit(ctx);
                }
            //}

            this.__clearFlag( NodeDirtyFlags.REQUEST_TRANSFORM );
        }

        __setAlphaImpl() {

            if ( !this._parent ) {
                this._frameAlpha= this._alpha;
            } else {

                this._frameAlpha= this._parent._frameAlpha * this._alpha;
            }
        }

        /**
         * Calculate if a node is in screen bounds.
         * @param ctx {cc.render.RenderingContext}
         * @method cc.node.Node#__AABBIntersectsScreen
         * @returns {boolean} the node is in screen or not.
         * @private
         */
        __AABBIntersectsScreen(ctx:RenderingContext) {

            this.calculateBoundingBox();
            return this._AABB.intersects(0, 0, ctx.getWidth(), ctx.getHeight());
        }

        /**
         * Calculate a node's Bounding box when the node is not axis aligned.
         * @method cc.node.Node#__calculateNAABBVertices
         * @private
         */
        __calculateNAABBVertices() {
            var vv:Array<Point> = this._BBVertices;
            var _w:number = this._contentSize.width;
            var _h:number = this._contentSize.height;

            // way chepaer to work on properties than vv[0].set
            var v= vv[0];
            v.x= 0;
            v.y= 0;
            this.convertToWorldSpace(v);
            v= vv[1];
            v.x= _w;
            v.y= 0;
            this.convertToWorldSpace(v);
            v=vv[2];
            v.x= _w;
            v.y= _h;
            this.convertToWorldSpace(v);
            v= vv[3];
            v.x= 0;
            v.y= _h;
            this.convertToWorldSpace(v);
        }

        /**
         * Calculate a node's bounding box when the node is axis aligned.
         * @method cc.node.Node#__calculateAABBVertices
         * @private
         */
        __calculateAABBVertices() {
            var vv:Array<Point> = this._BBVertices;
            var x:number, y:number, w:number, h:number;
            var mm = this._worldModelViewMatrix;

            x = mm[2];
            y = mm[5];
            w = this._contentSize.width * mm[0];
            h = this._contentSize.height * mm[4];

            // cheaper than calling set on vectors.
            var v;
            v= vv[0];
            v.x= x;
            v.y= y;
            v= vv[1];
            v.x= x + w;
            v.y= y;
            v= vv[2];
            v.x= x+w;
            v.y= y+h;
            v= vv[3];
            v.x= x;
            v.y= y+h;
        }

        /**
         * Calculate a node's bounding box.
         * @method cc.node.Node#__calculateBoundingBox
         * @returns {cc.node.Node}
         * @private
         */
        calculateBoundingBox() : Rectangle {

            if ( !this.__isFlagSet( NodeDirtyFlags.AABB_DIRTY ) ) {
                return this._AABB;
            }

            var verts:Array<Point> = this._BBVertices;

            if (this._isAA) {
                this.__calculateAABBVertices();
            } else {
                this.__calculateNAABBVertices();
            }

            var xmin : number= Number.MAX_VALUE;
            var ymin : number= Number.MAX_VALUE;
            var xmax : number= -Number.MAX_VALUE;
            var ymax : number= -Number.MAX_VALUE;

            // way faster to do comparison chain than Math.min chain
            var v= verts[0];
            if ( v.x<xmin ) { xmin=v.x; }
            if ( v.x>xmax ) { xmax=v.x; }
            if ( v.y<ymin ) { ymin=v.y; }
            if ( v.y>ymax ) { ymax=v.y; }
            var v= verts[1];
            if ( v.x<xmin ) { xmin=v.x; }
            if ( v.x>xmax ) { xmax=v.x; }
            if ( v.y<ymin ) { ymin=v.y; }
            if ( v.y>ymax ) { ymax=v.y; }
            var v= verts[2];
            if ( v.x<xmin ) { xmin=v.x; }
            if ( v.x>xmax ) { xmax=v.x; }
            if ( v.y<ymin ) { ymin=v.y; }
            if ( v.y>ymax ) { ymax=v.y; }
            var v= verts[3];
            if ( v.x<xmin ) { xmin=v.x; }
            if ( v.x>xmax ) { xmax=v.x; }
            if ( v.y<ymin ) { ymin=v.y; }
            if ( v.y>ymax ) { ymax=v.y; }

            // faster set properties than call.
            var aa= this._AABB;
            aa.x= xmin;
            aa.y= ymin;
            aa.w= xmax-xmin;
            aa.h= ymax-ymin;

            this.__clearFlag( NodeDirtyFlags.AABB_DIRTY );

            return this._AABB;
        }

        /**
         * Convert a coordinate to world (screen) space.
         * @method cc.node.Node#convertToWorldSpace
         * @param p {Vector}
         */
        convertToWorldSpace(p:Point) {
            Matrix3.transformPoint(this._worldModelViewMatrix, p);
        }

        /**
         * Draw a node.
         * @method cc.node.Node#__draw
         * @param ctx {cc.render.RenderingContext}
         * @private
         */
        __draw(ctx:RenderingContext) {

            Matrix3.setRenderingContextTransform(this._worldModelViewMatrix, ctx);

            var compositeSet:boolean= this.__isFlagSet( cc.node.NodeDirtyFlags.COMPOSITE_ON );
            var prevComposite:cc.render.CompositeOperation= ctx.getCompositeOperation();

            compositeSet= compositeSet && this._compositeOperation!==prevComposite;

            if ( compositeSet ) {
                ctx.setCompositeOperation( this._compositeOperation );
            }

            this.draw(ctx);

            if ( compositeSet ) {
                ctx.setCompositeOperation( prevComposite );
            }
        }

        /**
         * Get the node scene reference.
         * Each node belongs to an scene, which is held in this variable. Scenes have scheduling capabilities
         * and director references.
         * @method cc.node.Node#getScene
         * @returns {cc.node.Scene}
         */
        getScene() {
            return this._scene;
        }

        /**
         * Get the path of nodes to the top node, normally a <code>cc.node.Director</node> object.
         * @method cc.node.Node#getPathToRoot
         * @returns {Array<cc.node.Node>}
         */
        getPathToRoot() : Node[] {
            var node:Node= this;
            var ret: Node[]= [];

            do {
                ret.push(node);
                node= node.getParent();
            } while( node );

            return ret;
        }

        /**
         * Get the path of nodes to the cc.node.Scene containing this Node.
         * This method is called by <code>cc.node.Node#enableEventsForNode</code> because
         * the input manager captures input based on a Scene.
         * @method cc.node.Node#getPathToScene
         * @returns {Array<cc.node.Node>}
         */
        getPathToScene() : Node[] {

            if (!this._scene ) {
                return [];
            }

            var node:Node= this;
            var ret: Node[]= [];

            do {
                ret.push(node);
                if (node===this._scene) {
                    break;
                }
                node= node.getParent();
            } while( node!==null );

            return ret;
        }


        /**
         * Register a callback for an event type.
         * @method cc.node.Node#addEventListener
         * @param event {string} event name: mouseup, mousedown, mousemove, mousedrag, mouseover, mouseout, doubleclick
         * @param callback {function} a callback function that will receive an InputManager.Event object.
         */
        addEventListener( event:string, callback:any ) : Node {
            this._inputEvents[event]= callback;
            return this;
        }

        /**
         * Notify an event callback based on the event type.
         * @method cc.node.Node#notifyEvent
         * @param e {cc.event.InputManagerEvent}
         * @returns {boolean} whether the event must bubble.
         */
        notifyEvent( e:any ) : boolean {
            var callback= this._inputEvents[e.type];
            if ( e.type==="touchstart" ) {
                if (!callback) {
                    callback= this._inputEvents["mousedown"];
                }
            } else if ( e.type==="touchend" ) {
                if (!callback) {
                    callback= this._inputEvents["mouseup"];
                }
            } else if ( e.type==="touchmove" ) {
                if (!callback) {
                    callback= this._inputEvents["mousedrag"];
                }
            } else if ( e.type==="touchover" ) {
                if (!callback) {
                    callback= this._inputEvents["mouseover"];
                }
            } else if ( e.type==="touchout" ) {
                if (!callback) {
                    callback= this._inputEvents["mouseout"];
                }
            }

            if ( callback ) {
                return callback(e);
            }

            return false;
        }

        /**
         * Get a point in screen space turned into local node space.
         * When nodes are axis aligned, this is trivial, but for transformed nodes this method is needed.
         * The point will be modified.
         * See input demos.
         * @method cc.node.Node#getScreenPointInLocalSpace
         * @param p {cc.math.Vector}
         */
        getScreenPointInLocalSpace( p:Vector ) {
            var matrix = this.getInverseWorldModelViewMatrix();
            cc.math.Matrix3.transformPoint(matrix, p);
        }

        /**
         * Get a point in local Node space turned into screen space.
         * When nodes are axis aligned, this is trivial, but for transformed nodes this method is needed.
         * The point will be modified.
         * See input demos.
         * @method cc.node.Node#getLocalPointInScreenSpace
         * @param p {cc.math.Vector}
         */
        getLocalPointInScreenSpace( p:Vector ) {
            cc.math.Matrix3.transformPoint( this._worldModelViewMatrix, p );
        }

        /**
         * Get a point in local Node space turned into another Node's local space.
         * When nodes are axis aligned, this is trivial, but for transformed nodes this method is needed.
         * The point will be modified.
         * See input demos.
         * @method cc.node.Node#getLocalPointInNodeSpace
         * @param p {cc.math.Vector}
         */
        getLocalPointInNodeSpace( p:Vector, node:Node ) {
            this.getLocalPointInScreenSpace(p);
            node.getScreenPointInLocalSpace(p);
        }

        /**
         * Get whether a point in screen space lies in the Node's bounds.
         * When nodes are axis aligned, this is trivial, but for transformed nodes this method is needed.
         * See input demos.
         * @method cc.node.Node#isScreenPointInNode
         * @param p {cc.math.Vector}
         */
        isScreenPointInNode( p:Vector ) : boolean {

            if ( !this.isVisible() ) {
                return false;
            }

            this.getScreenPointInLocalSpace(p);
            return p.x>=0 && p.y>=0 && p.x<this._contentSize.width && p.y<this._contentSize.height;
        }

        /**
         * Add a child node to this node.
         * The Node is added immediately and the array of children nodes is flagged for sort at the next call to
         * the <code>visit</code> method.
         *
         * @method cc.node.Node#addChild
         * @param node {cc.node.Node} a Node to add as child.
         * @param localZOrder {number=} an optional zIndex for the Node. If set, this value will overwrite the Node's
         *   previous localZOrder value.
         *
         * @returns {cc.node.Node}
         *
         * @see {cc.node.Node#visit}
         */
        addChild(node:Node, localZOrder? : number ):Node {

            if ( arguments.length>2 ) {
                this.__legacyAddChild.apply( this, Array.prototype.slice.call(arguments) );
                return this;
            }

            if ( node._parent ) {
                cc.Debug.error(cc.locale.MSG_ERROR_NODE_WITH_PARENT)
            }

            node._orderOfArrival = _OrderOfArrival++;
            node._parent = this;

            if (typeof localZOrder !== "undefined") {
                node._localZOrder = localZOrder;
            }

            // there are some nodes to compare index with
            if ( this._children.length>0 ) {
                // node with smaller zindex than the first child.
                if ( node._localZOrder<this._children[0]._localZOrder ) {
                    // add node from the head.
                    this._children.unshift(node);
                } else if ( node._localZOrder>=this._children[ this._children.length-1 ]._localZOrder ) {
                    // node with same localzorder than the last one. add and no sort since orderofarrival is bigger.
                    this._children.push(node);
                } else {
                    // just add the children and mark for sort
                    this.__setFlag(NodeDirtyFlags.CHILDREN_SORT);
                    this._children.push(node);
                }
            } else {
                // first child, just add.
                this._children.push(node);
            }

            // add scheduled actions and tasks
            if ( this.getScene()!==null ) {
                node.setScene(this.getScene());
            }

            // PENDING: running behavior, onEnter and onEnterTransitionDidFinish

            return this;
        }


        __legacyAddChild(child, localZOrder, tag) {
             localZOrder = localZOrder === undefined ? child._localZOrder : localZOrder;
             var name, setTag = false;
             if(typeof tag==="undefined"){
                 tag = undefined;
                 name = child._name;
             } else if(typeof tag==='string'){
                 name = tag;
                 tag = undefined;
             } else if(typeof tag==="number"){
                 setTag = true;
                 name = "";
             }

             if(!this._children)
                 this._children = [];

            this._children.push(child);
            child._localZOrder=localZOrder;

             if(setTag)
                 child.setTag(tag);
             else
                 child.setName(name);

             child._parent=this;
             child._orderOfArrival = _OrderOfArrival++;

            // add scheduled actions and tasks
            if ( this.getScene()!==null ) {
                child.setScene(this.getScene());
            }

            this.__setFlag(NodeDirtyFlags.CHILDREN_SORT);
         }


        /**
         * Change a node's z-index.
         * <br>
         * This will schedule a children sort on next visit call.
         * A call to this method with set orderOfArrival no a new value.
         * @method cc.node.Node#reorderChild
         * @param node {cc.node.Node}
         * @param localZOrder
         */
        reorderChild(node:Node, localZOrder:number ) : void {
            this.__setFlag(NodeDirtyFlags.CHILDREN_SORT);
            node._orderOfArrival= _OrderOfArrival++;
            node._localZOrder= localZOrder;
        }

        /**
         * Sort a node's children.
         * Children are sorted based on zOrder and orderOfArrival.
         * @method cc.node.Node#__sortChildren
         * @private
         */
        __sortChildren() : void {

            this._children.sort( function( n0 : Node, n1 : Node ) : number {
                if ( n0._localZOrder < n1._localZOrder ) {
                    return -1;
                } else if (n0._localZOrder > n1._localZOrder) {
                    return 1;
                }

                return n0._orderOfArrival < n1._orderOfArrival ? -1 : 1;

            });

            this.__clearFlag( NodeDirtyFlags.CHILDREN_SORT );
        }

        /**
         * Remove a child from a node.
         * @method cc.node.Node#removeChild
         * @param node {cc.node.Node} node to remove
         * @param cleanup {boolean=} should clean up ?
         */
        removeChild(node:Node, cleanup?:boolean) : Node {
            var index = this._children.indexOf(node);
            if(index>=0) {
                // PENDING: call onExit() if node is running

                if ( cleanup ) {
                    // do cleanup of actions and/or scheduled callbacks
                    this.stopAllActions();
                    this.unscheduleAllCallbacks();
                }

                this._children.splice(index, 1);
                node._parent = null;
                node._scene = this._scene;
            }

            return this;
        }

        /**
         * Remove the node from its parent.
         * @method cc.node.Node#removeFromParent
         * @param cleanup {boolean} if true, all node's scheduled callbacks will be removed too.
         * @returns {cc.node.Node}
         */
        removeFromParent( cleanup?:boolean ) : Node {
            if ( !this._parent ) {
                cc.Debug.warn( locale.NODE_WARN_REMOVEFROMPARENT_WITH_NO_PARENT );
                return;
            }

            this._parent.removeChild( this, cleanup );

            if ( cleanup ) {
                this.cleanup();
            }

            return this;
        }

        /**
         * Remove all Node's child nodes.
         * @method cc.node.Node#removeAllChildren
         * @returns {cc.node.Node}
         */
        removeAllChildren( cleanup? : boolean ) : Node {
            for( var i=0; i<this._children.length; i++ ) {
                this._children[i]._parent= null;
            }
            this._children= [];
            // PENDING unschedule actions.
            return this;
        }

        /**
         * Get the node's children list.
         * @method cc.node.Node#getChildren
         * @returns {Array<cc.node.Node>}
         */
        getChildren():Array<Node> {
            return this._children;
        }

        /**
         * Get a node's root node.
         * A node's root node normally will be a Scene type node.
         * @method cc.node.Node#getRootNode
         * @returns {cc.node.Node}
         */
        getRootNode() : Node {
            var node : Node = this;
            while( node._parent ) {
                node= node._parent;
            }

            return node;
        }

        /**
         * Enumerate al children of a node that matches a pattern.
         * If a pattern starts with // the search will be recursively performed from the root node. It is only legal
         *  to define // at the beginning of the pattern.
         * If a pattern starts with / the search will be performed from the root node.
         *
         * The pattern accepts the wildcard symbol '*' meaning any value will match.
         * The pattern accepts the symbol '..' meaning it references a node's parent.
         *
         * Example patterns:
         *
         * <li><b>//*</b> . This pattern will get all descendant nodes from a node.
         * <li><b>/child0/grandchild1</b> . This pattern will get all grandchildren of a node with name grandchild1 that have
         * a parent node with name child0.
         * <li><b>/*\/grandchild0</b> . This pattern will get all grandchildren of a node which have the name grandchild0.
         *
         * @method cc.node.Node#enumerateChildren
         * @param patternName {string} a search pattern. Patterns are composed of regular expressions separated by slash / characters.
         * @param callback {EnumerateCallback} a callback function invoked for each node that matches the pattern.
         */
        enumerateChildren(patternName:string, callback:EnumerateCallback):void {

            // no string patternName, nothing to check for.
            if ( typeof patternName!=="string" ) {
                return;
            }

            var node : Node = this;
            var recursive = false;
            if (patternName.indexOf("//") === 0) {
                recursive = true;
                patternName = patternName.substr(2);
                node = this.getRootNode();
            }

            if ( patternName.indexOf("//")!==-1 ) {
                cc.Debug.error( cc.locale.MSG_WRONG_ENUMERATE_PATTERN );
            }

            patternName= cc.util.fromPosixRegularExpression(patternName);

            while ( patternName.indexOf("/")===0 ) {
                node = this.getRootNode();
                patternName = patternName.substr(1);
            }

            var orgPatternData : Array<RegExp>= [];
            var patterns =patternName.split("/");

            for( var i=0; i<patterns.length; i++ ) {
                var pattern= patterns[i];
                if ( pattern==="*" ) {
                    pattern=".*";
                }
                orgPatternData.push( new RegExp( pattern ) );
            }

            node.__enumerateChildrenImpl( orgPatternData, orgPatternData, callback, recursive);
        }

        /**
         * Do the actual enumeration.
         * @method cc.node.Node#__enumerateChildrenImpl
         * @param orgPatternData {Array<RegExp>}
         * @param patternData {Array<RegExp>
         * @param callback {EnumerateCallback} callback function executed for each node that matches the pattern.
         * @param recursive {boolean} is this a recursive enumeration ?
         * @private
         */
        __enumerateChildrenImpl( orgPatternData : Array<RegExp>, patternData : Array<RegExp>, callback : EnumerateCallback, recursive : boolean ) {

            // reached the end of a path
            if ( !patternData.length ) {
                callback(this);
                if (recursive) {
                    this.__enumerateChildrenImpl(orgPatternData, orgPatternData, callback, recursive);
                }
                return;
            } else if ( patternData[0].toString()==="/../" ) {
                if (!this._parent) {
                    cc.Debug.error(cc.locale.MSG_ENUMERATE_UNDERFLOW)
                } else {
                    this._parent.__enumerateChildrenImpl(orgPatternData, patternData.slice(1, patternData.length), callback, recursive);
                }
                return;
            }

            for( var i=0; i<this._children.length; i++ ) {

                var child= this._children[i];


                // the current pattern path is ok.
                if ( patternData[0].test( child._name ) ) {
                    child.__enumerateChildrenImpl( orgPatternData, patternData.slice(1,patternData.length), callback, recursive );
                } else {
                    // current path is not ok, but if recursive, apply whole pattern path from this node.
                    if ( recursive ) {
                        child.__enumerateChildrenImpl( orgPatternData, orgPatternData, callback, recursive );
                    }
                }
            }
        }

        /**
         * Draw a node.
         * Override this method to draw.
         * Draw like a boss w/o worrying of current affine transformation matrix.
         * @method cc.node.Node#draw
         * @param ctx {cc.render.RenderingContext} a rendering context, either canvas or webgl.
         */
        draw(ctx:RenderingContext) {
            if ( this._color!==DEFAULT_COLOR ) {
                ctx.setGlobalAlpha( this._frameAlpha );
                ctx.setTintColor( cc.math.Color.WHITE );
                ctx.setFillStyleColor( this._color );
                ctx.fillRect(0, 0, this._contentSize.width, this._contentSize.height);
            }
        }

        /**
         * Set this node's name. Suitable for identifying and enumerateChildren.
         * @method cc.node.Node#setName
         * @param name {string} must be composed of [A-Za-z0-9_]+ characters.
         * @returns {cc.node.Node}
         */
        setName( name : string ) : Node {
            if ( ! /[A-Za-z0-9_]+/.test( name ) ) {
                cc.Debug.error( cc.locale.ERR_NODE_NAME_INVALID );
            }

            this._name= name;
            return this;
        }

        startActionChain() : cc.action.ActionChainContext {
            return new cc.action.ActionChainContext( this );
        }

        /**
         * Schedule an action to run.
         * By the time an action is meant to be scheduled for running in a Node, there may not yet be a
         * <code>Director</code> or <code>Scene</code>. This method saves locally the actions which will be
         * scheduled in a scene's <code>ActionManager</code> later.
         * @method cc.node.Node#runAction
         * @param action {cc.action.Action}
         * @returns {cc.node.Node}
         */
        runAction( action : Action ) : Node {

            if ( this._scene ) {
                this._scene.scheduleActionForNode( this, action );
            } else {
                this._actionsToSchedule.push(action);
            }

            return this;
        }

        /**
         * Stop a Node action with the given tag.
         * @method cc.node.Node#stopActionByTag
         * @param tag {string} action tag.
         * @returns {cc.node.Node}
         */
        stopActionByTag( tag : string ) : Node {
            if ( this._scene ) {
                this._scene.stopNodeActionByTag( this, tag );
            }
            return this;
        }

        stopAllActions() : Node {
            if ( this._scene ) {
                this._scene.stopActionsForNode(this);
            } else {
                this._actionsToSchedule=[];
            }

            return this;
        }

        /**
         * Set Node's Scene and allow for buffered Actions to be scheduled.
         * This method is called when <code>scene.onEnter</code> is called.
         * @method cc.node.Node#setScene
         * @param scene {cc.node.Scene}
         */
        setScene( scene : Scene ) : void {

            if (!scene) {
                return;
            }

            this._scene= scene;

            for( var i=0; i<this._actionsToSchedule.length; i++ ) {
                scene.scheduleActionForNode( this, this._actionsToSchedule[i] );
            }
            this._actionsToSchedule= [];

            for( var i=0; i<this._tasksToSchedule.length; i++ ) {
                scene.scheduleTask( this._tasksToSchedule[i] );
            }
            this._tasksToSchedule= [];

            if ( this.__isFlagSet( NodeDirtyFlags.EVENTS_ENABLED ) ) {
                this.__clearFlag( NodeDirtyFlags.EVENTS_ENABLED );
                this._scene.enableEventsForNode(this);
            }

            if ( this.__isFlagSet( NodeDirtyFlags.EVENTS_PRIORITY_ENABLED ) ) {
                this.__clearFlag( NodeDirtyFlags.EVENTS_PRIORITY_ENABLED );
                this._scene.enablePriorityEventsForNode(this);
            }

            for( var i=0; i<this._children.length; i++ ) {
                this._children[i].setScene( scene );
            }
        }

        enableEvents( enable:boolean ) : cc.node.Node {
            if ( this._scene ) {
                this._scene.enableEventsForNode(this);
            } else {
                this.__setFlag( NodeDirtyFlags.EVENTS_ENABLED );
            }

            return this;
        }

        enablePriorityEvents( enable:boolean, priority:number ) : cc.node.Node {
            this._inputEvents.priorityEventValue= priority;
            if ( this._scene ) {
                this._scene.enablePriorityEventsForNode(this);
            } else {
                this.__setFlag( NodeDirtyFlags.EVENTS_PRIORITY_ENABLED );
            }

            return this;
        }

        getInputPriority() : number {
            return this._inputEvents.priorityEventValue;
        }

        /**
         * Set the node's visibility.
         * @method cc.node.Node#setVisible
         * @param v {boolean}
         */
        setVisible( v : boolean ) {
            if ( v!==this.__isFlagSet(NodeDirtyFlags.VISIBLE) ) {
                if ( v ) {
                    this.__setFlag(NodeDirtyFlags.VISIBLE);
                } else {
                    this.__clearFlag(NodeDirtyFlags.VISIBLE);
                }
                this.__setFlag( NodeDirtyFlags.TRANSFORMATION_DIRTY );
            }
        }

        isVisible() : boolean {
            return this.__isFlagSet(NodeDirtyFlags.VISIBLE);
        }

        cleanup() {

            this.stopAllActions();
            this.unscheduleAllCallbacks();

            // event
            //cc.eventManager.removeListeners(this);

            for( var i=0; i<this._children.length; i++ ) {
                this._children[i].cleanup();
            }
        }


    /////////////// SCHEDULER METHODS START ////////////////

        /**
         * This method is here for only for backwards compatibility purposes.
         * it exists for historical reasons. Comes from Cocos2d iphone v2.
         * It is called when a call to scheduleUpdate is made.
         * @method cc.node.Node#update
         * @param delta {number}
         * @deprecated
         */
        update( delta:number ) {

        }

        /**
         * Schedule a update call with the given priority. <code>scheduleUpdate</code>,
         * <code>scheduleUpdateWithPriority</code> and <code>unscheduleUpdate</code>
         * methods are just for backwards compatibility.
         * @deprecated
         * @method cc.node.Node#scheduleUpdateWithPriority.
         * @param priority {number}
         */
        scheduleUpdateWithPriority( priority : number ) {
            var task:SchedulerQueueTask= cc.action.SchedulerQueue.createSchedulerTask(this,this.update,0,Number.MAX_VALUE,0);
            task._priority= priority;
            this.__scheduleImpl(task);
        }

        /**
         * Schedule a task to per frame call update for this node.
         * <code>scheduleUpdate</code>,
         * <code>scheduleUpdateWithPriority</code> and <code>unscheduleUpdate</code>
         * methods are just for backwards compatibility.
         * @method cc.node.Node#scheduleUpdate
         * @deprecated
         */
        scheduleUpdate() {
            var task:SchedulerQueueTask= cc.action.SchedulerQueue.createSchedulerTask(this,this.update,0,Number.MAX_VALUE,0);
            this.__scheduleImpl(task);
        }

        __scheduleImpl( task:SchedulerQueueTask ) {

            if ( this._scene ) {
                this._scene.scheduleTask(task);
            } else {
                this._tasksToSchedule.push(task);
            }
        }

        /**
         * Unschedule all update callbacks for this node.
         * <code>scheduleUpdate</code>,
         * <code>scheduleUpdateWithPriority</code> and <code>unscheduleUpdate</code>
         * methods are just for backwards compatibility.
         * @method cc.node.Node#unscheduleUpate
         */
        unscheduleUpate() {
            if (this._scene) {
                this._scene.unscheduleCallbackForTarget(this, this.update);
            }
        }

        /**
         * Schedule a task for the node.
         * This node will be passed as target to the specified callback function.
         * If already exist a task in the scheduler for the same pair of node and callback, the task will be updated
         * with the new data.
         * @method cc.node.Node#schedule
         * @param callback_fn {cc.action.SchedulerTaskCallback} callback to invoke
         * @param interval {number} repeat interval time. the task will be fired every this amount of milliseconds.
         * @param repeat {number=} number of repetitions. if not set, infinite will be used.
         * @param delay {number=} wait this millis before firing the task.
         */
        schedule(callback_fn:SchedulerTaskCallback, interval:number, repeat?:number, delay?:number) {

            var task:SchedulerQueueTask= cc.action.SchedulerQueue.createSchedulerTask(
                                    this,callback_fn,interval,repeat,delay);

            if ( this._scene ) {
                this._scene.scheduleTask(task);
            } else {
                this._tasksToSchedule.push(task);
            }
        }

        /**
         * Schedule a single shot task. Will fired only once.
         * @method cc.node.Node#scheduleOnce
         * @param callback_fn {cc.action.SchedulerTaskCallback} scheduler callback.
         * @param delay {number} milliseconds to wait before firing the task.
         * @returns {cc.node.Node}
         */
        scheduleOnce(callback_fn:SchedulerTaskCallback, delay:number) {
            this.schedule(callback_fn, 0.0, 0, delay);
        }

        /**
         * Unschedule a task for the node.
         * @method cc.node.Node#unschedule
         * @param callback_fn {cc.action.SchedulerTaskCallback} callback to unschedule.
         */
        unschedule(callback_fn:SchedulerTaskCallback) {

            if (!callback_fn)
                return;

            if ( this._scene) {
                this._scene.unscheduleCallbackForTarget(this, callback_fn);
            }
        }

        /**
         * Unschedule all tasks for the node.
         * @method cc.node.Node#unscheduleAllCallbacks
         */
        unscheduleAllCallbacks() {
            if ( this._scene ) {
                this._scene.unscheduleAllCallbacks(this);
            } else {
                this._tasksToSchedule= [];
            }
        }

        /**
         * Resumes all scheduled tasks and actions.
         * This method is called internally by onEnter
         * @method cc.node.Node#resume
         */
        resume() {
            if ( this._scene ) {
                this._scene.resumeTarget(this);
            }

            // PENDING: implement
            //cc.eventManager.resumeTarget(this);
        }

        /**
         * Pauses all scheduled selectors and actions.
         * This method is called internally by onExit.
         * @method cc.node.Node#pause
         *
         */
        pause() {
            if ( this._scene ) {
                this._scene.pauseTarget(this);
            }

            // PENDING: implement
            //cc.eventManager.pauseTarget(this);
        }

        /**
         * V3 compatible method call.
         * The preferred and more powerful way of setting a node's composite operation will be
         * <code>setCompositeOperation</code>.
         *
         * @deprecated
         * @param src_o { number|{src:number, dst:number} } webgl blending source operation or an object with
         *   webgl blending source and destination operations.
         * @param dst {number} webgl blending destination operation.
         *
         * @returns {number} a cc.render.CompositeOperation enumeration value.
         */
        setBlendFunc( src_o: any, dst:number ) {

            cc.Debug.warn( cc.locale.WARN_DEPRECATED_SETBLENDFUNC );

            var src:number;

            if ( typeof dst === "undefined") {
                dst= src_o.dst;
                src= src_o.src;
            } else {
                src= src_o;
            }

            if (( src === cc.SRC_ALPHA && dst === cc.ONE)) {
                this.setCompositeOperation(cc.render.CompositeOperation.lighter);
            } else
            if ( (src === cc.ONE && dst === cc.ONE)) {
                this.setCompositeOperation(cc.render.CompositeOperation.add);
            }
            else if (src === cc.ZERO && dst === cc.SRC_ALPHA) {
                this.setCompositeOperation(cc.render.CompositeOperation.destination_in);
            }
            else if (src === cc.ZERO && dst === cc.ONE_MINUS_SRC_ALPHA) {
                this.setCompositeOperation(cc.render.CompositeOperation.destination_out);
            }
            else {
                this.setCompositeOperation(cc.render.CompositeOperation.source_over);
            }
        }

    /////////////// SCHEDULER METHODS END ////////////////

        /**
         * Set a bunch of properties for the node.
         * If a property does exists in Node, a warning is emitted and nothing will happen.
         * Only for backwards compatibility.
         * @deprecated
         * @method cc.node.Node#attr
         * @param properties {any} Collection of key/value pairs.
         * @returns {cc.node.Node}
         */
        attr( properties : any ) : Node {

            for( var property in properties ) {
                if ( properties.hasOwnProperty(property) ) {
                    var value= properties[ property ];
                        this[property] = value;
                }
            }

            return this;
        }

        /**
         * @deprecated
         * @method cc.node.Node#set:width
         * @param v {number}
         */
        set width( v : number ) {
            this._contentSize.width= v;
            this.__setFlag( NodeDirtyFlags.REQUEST_TRANSFORM );
        }

        get width() : number {
            return this._contentSize.width;
        }

        get height() : number {
            return this._contentSize.height;
        }

        /**
         * @deprecated
         * @method cc.node.Node#set:height
         * @param v {number}
         */
        set height( v : number ) {
            this._contentSize.height= v;
            this.__setFlag( NodeDirtyFlags.REQUEST_TRANSFORM );
        }

        /**
         * @deprecated
         * @method cc.node.Node#set:color
         * @param v {cc.math.Color}
         */
        set color( v : Color ) {
            this.setColor(v._color[0], v._color[1], v._color[2]);
        }

        /**
         * @deprecated
         * @method cc.node.Node#set:rotation
         * @param angle_in_deg {number}
         */
        set rotation( angle_in_deg:number ) {
            this.rotationAngle= angle_in_deg;
        }

        get rotation() {
            return this.rotationAngle;
        }

        /**
         * @deprecated
         * @method cc.node.Node#set:visible
         * @param v {boolean}
         */
        set visible( v: boolean ) {
            this.setVisible(v);
        }

        get visible() : boolean {
            return this.isVisible();
        }

        set anchorX( a:number ) {
            this._positionAnchor.x= a;
            this._transformationAnchor.x= a;
            this.__setFlag( NodeDirtyFlags.REQUEST_TRANSFORM );
        }

        set anchorY( a:number ) {
            this._positionAnchor.y= a;
            this._transformationAnchor.y= a;
            this.__setFlag( NodeDirtyFlags.REQUEST_TRANSFORM );
        }

        set scale( s:number ) {
            this.scaleX= s;
            this.scaleY= s;
        }

        get parent() : Node {
            return this._parent;
        }

        get children() : Node[] {
            return this._children;
        }


/*
            cc.defineGetterSetter(_p, "anchorX", _p._getAnchorX, _p._setAnchorX);
            cc.defineGetterSetter(_p, "anchorY", _p._getAnchorY, _p._setAnchorY);
            cc.defineGetterSetter(_p, "skewX", _p.getSkewX, _p.setSkewX);
            cc.defineGetterSetter(_p, "skewY", _p.getSkewY, _p.setSkewY);
            cc.defineGetterSetter(_p, "zIndex", _p.getLocalZOrder, _p.setLocalZOrder);
            cc.defineGetterSetter(_p, "vertexZ", _p.getVertexZ, _p.setVertexZ);
            cc.defineGetterSetter(_p, "rotationX", _p.getRotationX, _p.setRotationX);
            cc.defineGetterSetter(_p, "rotationY", _p.getRotationY, _p.setRotationY);
            cc.defineGetterSetter(_p, "scale", _p.getScale, _p.setScale);
            cc.defineGetterSetter(_p, "children", _p.getChildren);
            cc.defineGetterSetter(_p, "childrenCount", _p.getChildrenCount);
            cc.defineGetterSetter(_p, "parent", _p.getParent, _p.setParent);
            cc.defineGetterSetter(_p, "running", _p.isRunning);
            cc.defineGetterSetter(_p, "ignoreAnchor", _p.isIgnoreAnchorPointForPosition, _p.ignoreAnchorPointForPosition);
            cc.defineGetterSetter(_p, "actionManager", _p.getActionManager, _p.setActionManager);
            cc.defineGetterSetter(_p, "scheduler", _p.getScheduler, _p.setScheduler);
            cc.defineGetterSetter(_p, "shaderProgram", _p.getShaderProgram, _p.setShaderProgram);
            cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB);
            cc.defineGetterSetter(_p, "cascadeOpacity", _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
            cc.defineGetterSetter(_p, "cascadeColor", _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
*/
    }
}

/**
 * License: see license.txt file.
 */


/// <reference path="./TimeInterpolator.ts"/>
/// <reference path="./ActionManager.ts"/>
/// <reference path="./ActionChainContext.ts"/>


module cc.action {

    /**
     * This value is a time unit divisor constant.
     * CocosJS expects all time units to be in seconds, hence the default value of 1000.
     * But you could easily change time unit values to milliseconds, changing this value to 1, and setting all
     * actions/scheduler time units in millis.
     *
     * @member cc.action.TIMEUNITS
     * @type {number}
     */
    export var TIMEUNITS:number= 1000;

    var SECONDS:number= 1000;
    var MILLISECONDS:number= 1;

    /**
     * Change time units on actions, schedulers, etc to seconds.
     * This is the default type.
     * @name setTimeReferenceInSeconds
     * @memberof cc.action
     */
    export function setTimeReferenceInSeconds() { cc.action.TIMEUNITS= SECONDS; }

    /**
     * Change time units on actions, schedulers, etc to milliseconds.
     * @name setTimeReferenceInMillis
     * @memberof cc.action
     */
    export function setTimeReferenceInMillis() { cc.action.TIMEUNITS=  MILLISECONDS; }

    "use strict";


    /**
     * Callback definition for Action Apply event.
     * @memberOf cc.action
     * @callback ActionCallbackApplicationCallback
     * @param action {cc.action.Action} Executed Action.
     * @param target: {object} target the Action applied to.
     * @param value: {Object} Current target property value set.
     */

    /**
     * Callback definition for Action Start, End, Pause and Resume events.
     * @memberOf cc.action
     * @callback ActionCallbackStartOrEndOrPauseOrResumeCallback
     * @param action {cc.action.Action} Executed Action.
     * @param target: {object} target the Action applied to.
     */

    /**
     * Callback definition for Action Repeat event.
     * @memberOf cc.action
     * @callback ActionCallbackRepeatCallback
     * @param action {cc.action.Action} Executed Action.
     * @param target: {object} target the Action applied to.
     * @param repetitionCount {number} Current repetition count.
     */

    /**
     * Action internal states.
     * <br>
     * Status diagram is:
     *
     * <pre>
     *
     * CREATED ---> RUNNING ---> PAUSED <---> RESUMED
     *    ^          |  ^                           |
     *    |          |  |                           |
     *    |          |  +---------------------------+
     *    |          v
     *    +------> ENDED
     *
     * </pre>
     *
     * @tsenum cc.action.ActionStates
     */
    export enum ActionStates {
        PAUSED = 1,
        RUNNING = 2,
        CREATED = 3,
        ENDED = 4,
        RESUMED = 5
    }

    export interface ActionCallbackStartOrEndOrPauseOrResumeCallback {
        (action:Action, target:any) : void;
    }

    export interface ActionCallbackRepeatCallback {
        (action:Action, target:any, repetitionCount:number) : void;
    }

    export interface ActionCallbackApplicationCallback {
        (action:Action, target:any, value:any) : void;
    }

    /**
     * @class cc.action.RepeatTimesOptions
     * @interface
     * @classdesc
     * Callback definition for Action application repetition events.
     */
    export interface RepeatTimesOptions {

        /**
         * Optional Action after application delay time.
         * @member cc.action.RepeatTimesOptions#withDelay
         * @type {number}
         */
        withDelay? : number;
    }

    /**
     * @class cc.action.ActionInitializer
     * @interface
     * @classdesc
     *
     * This object describes a base Action initializer object. It contains all common information for actions,
     * and can be used as serializable data.
     */
    export interface ActionInitializer {

        /**
         * Action type. A cc.action constructor function name.
         * Type is necessary when deserializing Actions.
         * @member cc.action.ActionInitializer#type
         * @type {string=}
         */
        type? : string;

        /**
         * Action duration. The value must be in the correct Time units.
         * @member cc.action.ActionInitializer#duration
         * @type {number}
         */
        duration? : number;

        /**
         * Action before-application delay. The value must be in the correct Time units.
         * @member cc.action.ActionInitializer#delayBefore
         * @type {number}
         */
        delayBefore? : number;

        /**
         * Action after-application delay. The value must be in the correct Time units.
         * @member cc.action.ActionInitializer#delayAfter
         * @type {number}
         */
        delayAfter? : number;

        /**
         * Start alpha value.
         * @member cc.action.ActionInitializer#interpolator
         * @type {cc.action.InterpolatorInitializer=}
         */
        interpolator? : InterpolatorInitializer;

        /**
         * Start alpha value.
         * @member cc.action.ActionInitializer#from
         * @type {any=}
         */
        from? : any;

        /**
         * End alpha value.
         * @member cc.action.ActionInitializer#to
         * @type {any}
         */
        to? : any;

        /**
         * Make the action relative.
         * @member cc.action.ActionInitializer#relative
         * @type {boolean=}
         */
        relative? : boolean;

        /**
         * Set repetition count.
         * @member cc.action.ActionInitializer#repeatTimes
         * @type {number=}
         */
        repeatTimes? : number;

        /**
         * Set reversed action.
         * @member cc.action.ActionInitializer#reversed
         * @type {boolean=}
         */
        reversed? : boolean;
    }


    /**
     *
     *  @class cc.action.Action
     *  @classdesc
     *
     * Actions are scheduled objects that modify an arbitray object's internal state. It could be a node, or any other
     * object type.
     * For example, schedule a rotation from 0 to 360 degrees, scale from to twice a node's size, or a combination of
     * both.
     * <br>
     * cc.action.Action is an abstract class, and won't affect any target. This Class type must be subclassed.
     * <br>
     *
     * Actions are defined by the following elements:
     *
     *  <li>duration. How long the action will take to end.
     *  <li>delay before application. How long the action will take to start applying.
     *  <li>delay after application. How long the action will take to end after it ended modifying node's properties.
     *  <li>lifecycle. An action has callback functions for: start, pause, resume, end and repeat.
     *  <li>speed. An action has speed modifiers. if an action has speed 2, will take twice the time to execute.
     *  <li>interpolators. An action can have modifiers for time application, like easing functions or curve segments.
     *  <li>relativity. An action can be applied relative to a value, instead of absolutely. For example, rotate by an
     *     angle instead of rotate to.
     *  <li>From. Start values for action application.
     *  <li>To. End values for action application.
     *  <li>Reversability: an action can be set to be played backwards. This is accomplished not by modifying the action
     *      but by modifiying the Interpolator that transforms time into property values.
     *
     * Predefined actions exist for the following node's properties:
     *
     *  <li>AlphaAction. Modifies transparency values.
     *  <li>MoveAction. Modifies position by traversing a straight line.
     *  <li>PathAction. Modifies position by traversing a complex path.
     *  <li>RotateAction. Modifies rotation angle.
     *  <li>ScaleAction. Modifies scale.
     *  <li>TintAction. Modifies s color. This action will only have a visible result when the node is rendered
     *      using WebGL.
     *  <li>SequenceAction. Allows for action sequencing and parallelization.
     *  <li>PropertyAction. Allows for modification of an object's arbitrary property. Either deeply nested or not.
     *
     * There are other type of actions that affect or create a mix of different node properties modification like:
     *
     *  <li>BlinkAction
     *  <li>JumpAction
     *
     *  The current V4 action subsystem is a complete rebuild from the ground up. Although backwards compatible with
     *  Cocos2d HTML5's V2 and V3 action system, this new implementation offers the following features:
     *
     *  <li>Consistent Action naming: easeExponentialIn vs easeQuinticActionIn .
     *  <li>Simplification of cc namespace. From 150+ action objects to a few.
     *  <li>Reduced code complexity.
     *  <li>Offer a new more js-ish code convention via chaining of method calls.
     *  <li>Change concept of easing action. Easing is a property of an Action's time.
     *  <li>Reduce overly class-extension hierarchy from version 2 and 3
     *  <li>Full action lifecycle: START, END, PAUSE, RESUME, REPEAT.
     *
     */
    export class Action {

        /**
         * Default tag value.
         * @member cc.action.Action#DEFAULT_TAG
         * @type {string}
         * @static
         */
        static DEFAULT_TAG:string = "";

        /**
         * Delay to start applying the Action.
         * @member cc.action.Action#_startTime
         * @type {number}
         * @private
         */
        _startTime:number = 0;

        /**
         * Action duration (in seconds). For how long the Action takes to get to the final application result.
         * @member cc.action.Action#_duration
         * @type {number}
         * @private
         */
        _duration:number = 0;

        /**
         * Currently elapsed time.
         * @member cc.action.Action#_currentTime
         * @type {number}
         * @private
         */
        _currentTime:number = 0;

        /**
         * Number of repeat times. 1 by default.
         * @member cc.action.Action#_repeatTimes
         * @type {number}
         * @private
         */
        _repeatTimes:number = 1;

        /**
         * Current repetition count.
         * @member cc.action.Action#_currentRepeatCount
         * @type {number}
         * @private
         */
        _currentRepeatCount:number = 0;

        /**
         * Action speed. Actual Action duration is: ( (_duration + _delayAfterApplication) * _times) / _speed
         * @type {number}
         * @private
         */
        _speed:number = 1;

        /**
         * An action identifier. Defaults to @see(Action.DEFAULT_TAG).
         * @member cc.action.Action#_tag
         * @type {number}
         * @private
         */
        _tag:string = Action.DEFAULT_TAG;

        /**
         * Action status.
         *
         * Status diagram:
         *
         * <pre>
         *
         * CREATED ---> RUNNING ---> PAUSED <---> RESUMED
         *    ^          |  ^                           |
         *    |          |  |                           |
         *    |          |  +---------------------------+
         *    |          v
         *    +------> ENDED
         *
         * </pre>
         *
         * @member cc.action.Action#_status
         * @type {cc.action.ActionStates}
         * @private
         */
        _status:ActionStates = ActionStates.CREATED;

        /**
         * On start application callback. Called when the Action is first executed.
         * @member cc.action.Action#_onStart
         * @type {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
         * @private
         */
        _onStart:ActionCallbackStartOrEndOrPauseOrResumeCallback = null;

        /**
         * On end application callback. Fired each time the Action ends applying.
         * This callback may not be called if _repeatTimes is set too high or is playing forever.
         * @member cc.action.Action#_onEnd
         * @type {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
         * @private
         */
        _onEnd:ActionCallbackStartOrEndOrPauseOrResumeCallback = null;

        /**
         * On repeat application callback. Fired each time the action is repeated.
         * @member cc.action.Action#_onRepeat
         * @type {cc.action.ActionCallbackRepeatCallback}
         * @private
         */
        _onRepeat:ActionCallbackRepeatCallback = null;

        /**
         * On application callback. Fired each time the action is applied. this callback can be called many times
         * during the action life cycle.
         * @member cc.action.Action#_onApply
         * @type {cc.action.ActionCallbackApplicationCallback}
         * @private
         */
        _onApply:ActionCallbackApplicationCallback = null;

        /**
         * On pause callback. Fired each time the action is paused. this callback can be called many times
         * during the action life cycle.
         * @member cc.action.Action#_onPause
         * @type {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
         * @private
         */
        _onPause:ActionCallbackStartOrEndOrPauseOrResumeCallback = null;

        /**
         * On resume callback. Fired each time the action is resumed. this callback can be called many times
         * during the action life cycle.
         * @member cc.action.Action#_onResume
         * @type { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
         * @private
         */
        _onResume:ActionCallbackStartOrEndOrPauseOrResumeCallback = null;

        /**
         * Interpolation/Ease function application
         * @member cc.action.Action#_interpolator
         * @type {cc.action.TimeInterpolator}
         * @private
         */
        _interpolator:cc.action.TimeInterpolator = null;

        /**
         * if the from values for an Action have not been set, a call to __setInitialValues with
         * the target as parameter to have them set.
         * @member cc.action.Action#_fromValuesSet
         * @type {boolean}
         * @private
         */
        _fromValuesSet:boolean = false;

        /**
         * Flag for executing onStart callback. Do not use or modify.
         * @member cc.action.Action#_firstExecution
         * @type {boolean}
         * @private
         */
        _firstExecution:boolean = true;

        /**
         * This delay will be applied after each application.
         * @member cc.action.Action#_delayAfterApplication
         * @type {number}
         * @private
         */
        _delayAfterApplication:number = 0;

        /**
         * This delay will be applied before each application.
         * @member cc.action.Action#_delayBeforeApplication
         * @type {number}
         * @private
         */
        _delayBeforeApplication:number = 0;

        /**
         * Action owner ie the ActionManager this Action executes in.
         * @member cc.action.Action#_owner
         * @type {cc.action.ActionManager}
         * @private
         */
        //_owner:ActionManager = null;

        /**
         * Reference for a chained action. Do not use or modify.
         * @member cc.action.Action#_chainAction
         * @type {cc.action.Action}
         * @private
         */
        _chainAction:Action = null;

        /**
         * If true, the actions must be ActionBy variations.
         * @member cc.action.Action#_relativeAction
         * @type {boolean}
         * @private
         */
        _relativeAction:boolean = false;

        /**
         * Is the action reversed ?
         * A reversed action will be applied from end to begin.
         * @member cc.action.Action#_reversedTime
         * @type {boolean}
         * @private
         */
        _reversedTime:boolean = false;

        /**
         * If this Action belongs to a SequenceAction this variable will be its parent sequence.
         * @member cc.action.Action#_parentSequence
         * @type {cc.action.SequenceAction}
         * @private
         */
        _parentSequence:SequenceAction = null;

        /**
         * Is the action reversed ?
         * This happens by a call to reverse() or setReversed()
         * @member cc.action.Action#_reversed
         * @type {boolean}
         * @private
         */
        _reversed : boolean = false;

        /**
         * When a call to node.startActionChain() is made, an ActionChainContext object is created. It is a fachade
         * for chainable api. apart from that, does nothing to the Action.
         * @member cc.action.Action#_chainContext
         * @type {cc.action.ActionChainContext}
         * @private
         */
        _chainContext : cc.action.ActionChainContext = null;

        /**
         * Build an Action instance.
         * This type of objects must augmented.
         * @constructor
         * @method cc.action.Action#constructor
         * @param initilizer {cc.action.ActionInitializer=} a JSON object describing a base Action info.
         */
        constructor( initializer?:ActionInitializer ) {
            if ( initializer ) {
                this.__createFromInitializer( initializer );
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.Action#__createFromInitializer
         * @param initializer {cc.action.ActionInitializer}
         * @private
         */
        __createFromInitializer(initializer:ActionInitializer ) {
            if ( typeof initializer!=="undefined" ) {
                if ( typeof initializer.relative!=='undefined' ) {
                    this.setRelative( initializer.relative );
                }
                if ( typeof initializer.duration!=='undefined' ) {
                    this.setDuration( initializer.duration );
                }
                if ( typeof initializer.delayBefore!=='undefined' ) {
                    this.setDelay( initializer.delayBefore );
                }
                if ( typeof initializer.delayAfter!=='undefined' ) {
                    this.setDelayAfterApplication( initializer.delayAfter );
                }
                if ( typeof initializer.interpolator!=="undefined" ) {
                    this.setInterpolator( cc.action.ParseInterpolator( initializer.interpolator ) );
                }
                if ( typeof initializer.from!=="undefined" ) {
                    if ( this.from ) {
                        this.from( initializer.from );
                    }
                }
                if ( typeof initializer.to!=="undefined" ) {
                    if ( this.to ) {
                        this.to( initializer.to );
                    }
                }
                if ( typeof initializer.repeatTimes!=="undefined" ) {
                    this.setRepeatTimes(initializer.repeatTimes);
                }
                if ( typeof initializer.reversed!=="undefined" ) {
                    this._reversed= initializer.reversed;
                }
            }
        }

        /**
         * Set an arbitrary tag for an Action.
         * @method cc.action.Action#setTag
         * @param tag {string} a string composed only of [A-Za-z0-9_-]
         * @returns {cc.action.Action}
         */
        setTag(tag:string):Action {
            this._tag = tag;
            return this;
        }

        /**
         * Update an Action's target object.
         * This function must be overriden by Action subclass Objects.
         * @method cc.action.Action#update
         * @param normalizedTime {number} value between 0 and 1.
         * @param target {any} object instance the action will be applied for.
         *
         * @returns {Object} a value descriptive for the action type. For example, ScaleAction will return an object with
         * the scale applied, and MoveAction a <code>cc.math.Vector</code> with object's set position.
         */
        update(normalizedTime:number, target:any):any {

        }

        /**
         * Set an Action's duration. Duration is in milliseconds.
         * @method cc.action.Action#setDuration
         * @param duration {number}
         */
        setDuration(duration:number):Action {
            this._duration = duration*TIMEUNITS;
            this.__updateDuration();
            return this;
        }

        /**
         * Set an action's pre application delay.
         * An action will take this milliseconds to start applying values in a target.
         * @method cc.action.Action#setDelay
         * @param d {number} milliseconds.
         * @returns {cc.action.Action}
         */
        setDelay(d:number):Action {
            this._delayBeforeApplication = d*TIMEUNITS;
            this.__updateDuration();
            return this;
        }

        /**
         * Update this Action's duration.
         * This must be done when a sub Action is updated or when delay times or duration itself have changed.
         * @method cc.action.Action#__updateDuration
         * @private
         */
        __updateDuration() {

            this._startTime = this._delayBeforeApplication + (this._chainAction ? this._chainAction._startTime + this._chainAction.getDuration() : 0);
            if (this._parentSequence) {
                this._parentSequence.__updateDuration();
            }
        }

        /**
         * Restart an action's application.
         * Status gets back to CREATED.
         * First execution set to true.
         * Application times count set to 0.
         * @method cc.action.Action#restart
         * @returns {cc.action.Action}
         */
        restart():Action {
            this._firstExecution = true;
            this._currentRepeatCount = 0;
            this._status = ActionStates.CREATED;
            this._currentTime= 0;
            return this;
        }

        /**
         * Get an action's current State.
         * @method cc.action.Action#getStatus
         * @returns {cc.action.ActionStates}
         */
        getStatus():ActionStates {
            return this._status;
        }

        /**
         * Get an action's application speed.
         * Speed values modify an action duration.
         * A speed value of 2 will make the action to take twice the time to execute.
         * @method cc.action.Action#getSpeed
         * @returns {number}
         */
        getSpeed():number {
            return this._speed;
        }

        /**
         * Set an action's application speed.
         * @method cc.action.Action#setSpeed
         * @param speed {number}
         * @returns {cc.action.Action}
         */
        setSpeed(speed:number):Action {
            this._speed = speed;
            return this;
        }

        /**
         * Make this action repeat a finite number of timer.
         * 0 repeatTimes means repeat forerver.
         * @method cc.action.Action#setRepeatTimes
         * @param repeatTimes {number}
         * @param obj {RepeatTimesOptions}
         * @return Action
         */
        setRepeatTimes(repeatTimes:number, obj?:RepeatTimesOptions):Action {
            this._repeatTimes = repeatTimes;
            this._delayAfterApplication = (obj && obj.withDelay*TIMEUNITS) || 0;
            return this;
        }

        /**
         * Set this action to apply forever.
         * @method cc.action.Action#setRepeatForever
         * @param obj {RepeatTimesOptions}
         * @returns {cc.action.Action}
         */
        setRepeatForever(obj?:RepeatTimesOptions):Action {
            return this.setRepeatTimes(Number.MAX_VALUE, obj);
        }

        /**
         *
         * @method cc.action.Action#repeatForever
         * @deprecated
         * @returns {Action}
         */
        repeatForever() {
            return this.setRepeatForever();
        }

        /**
         * Register a callback notification function fired whenever the Action starts applying.
         * @method cc.action.Action#onStart
         * @param callback { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
         * @returns {cc.action.Action}
         */
        onStart(callback:ActionCallbackStartOrEndOrPauseOrResumeCallback):Action {
            this._onStart = callback;
            return this;
        }

        /**
         * Register a callback notification function fired whenever the action expires applying.
         * If repeats forever, will never be called.
         * @method cc.action.Action#onEnd
         * @param callback { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
         * @return Action
         */
        onEnd(callback:ActionCallbackStartOrEndOrPauseOrResumeCallback):Action {
            this._onEnd = callback;
            return this;
        }

        /**
         * Register a callback notification function fired whenever the action repeats.
         * BUGBUG if setRepeatForever is not fired.
         * @method cc.action.Action#onRepeat
         * @param callback { cc.action.ActionCallbackRepeatCallback }
         * @return Action
         */
        onRepeat(callback:ActionCallbackRepeatCallback):Action {
            this._onRepeat = callback;
            return this;
        }

        /**
         * Register a callback notification function fired whenever the action applies.
         * The action applies once per frame, and allows for getting values that have been set on the target.
         * @method cc.action.Action#onApply
         * @param callback { cc.action.ActionCallbackApplicationCallback }
         * @return Action
         */
        onApply(callback:ActionCallbackApplicationCallback):Action {
            this._onApply = callback;
            return this;
        }

        /**
         * Register a callback notification function fired whenever the action is paused.
         * @method cc.action.Action#onPause
         * @param callback { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
         * @return Action
         */
        onPause(callback:ActionCallbackStartOrEndOrPauseOrResumeCallback):Action {
            this._onPause = callback;
            return this;
        }

        /**
         * Register a callback notification function fired whenever the action is resumed, that it, exits the
         * paused state.
         * @method cc.action.Action#onResume
         * @param callback { cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback }
         * @return Action
         */
        onResume(callback:ActionCallbackStartOrEndOrPauseOrResumeCallback):Action {
            this._onResume = callback;
            return this;
        }

        /**
         * Pause this action.
         * @method cc.action.Action#pause
         * @param target {object=}
         * @returns Action
         */
        pause(target?:any) {
            this._status = ActionStates.PAUSED;
            if (this._onPause) {
                this._onPause(this, target);
            }
            return this;
        }

        /**
         * Resume this action.
         * @method cc.action.Action#resume
         * @returns Action
         */
        resume():Action {
            if (this._status === ActionStates.PAUSED) {
                this._status = ActionStates.RESUMED;
            }
            return this;
        }

        /**
         * Get time to wait after action application to repeat.
         * This time will be spent even if repeat count is 1.
         * @method cc.action.Action#getDelayAfterApplication
         * @returns {number}
         */
        getDelayAfterApplication():number {
            return this._delayAfterApplication;
        }

        /**
         * Set time to wait after action application to repeat.
         * This time will be spent even if repeat count is 1.
         * @method cc.action.Action#setDelayAfterApplication
         * @param d {number} milliseconds to wait after application.
         * @returns {cc.action.Action}
         */
        setDelayAfterApplication(d:number):Action {
            this._delayAfterApplication = d*TIMEUNITS;
            return this;
        }

        /**
         * Get this action's delay time to start applying.
         * @method cc.action.Action#getDelay
         * @returns {number}
         */
        getDelay():number {
            return this._startTime;
        }

        /**
         * Changes default interpolator to another instance of @link{cc.action.TimeInterpolator}.
         * @method cc.action.Action#setInterpolator
         * @param interpolator {cc.action.TimeInterpolator}
         * @returns Action
         */
        setInterpolator(interpolator:cc.action.TimeInterpolator):Action {
            this._interpolator = interpolator;
            return this;
        }

        /**
         * Convert time into a normalized value in the range of the application duration.
         * The values will converted, so that 0 will be just after starting each repetition,
         * and 1 will be just the end of the Action, or the end of each repetition.
         * @method cc.action.Action#__normalizeTime
         * @param time {number}
         * @private
         */
        __normalizeTime(time:number):number {

            // still, initial delay time has not elapsed.
            if (time < this._startTime) {
                time = 0;
            } else {

                time = time - this._startTime;

                if (time >= this.getDuration()) {

                    time = 1;
                } else {
                    time %= this.getOneRepetitionDuration();

                    // time is in duration range
                    if (time < this._duration) {
                        time /= this._duration;
                    } else {
                        // time is in _delayAfterApplicationRange
                        time = 1;
                    }
                }
            }

            if (this._reversedTime) {
                time = 1 - time;
            }

            if (!this._interpolator) {
                return time;
            }
            return this._interpolator(time);
        }

        /**
         * Get whole action duration. Takes into account action speed, duration, delayAfterApplication and repetition times.
         * @method cc.action.Action#getDuration
         * @returns {number}
         */
        getDuration():number {
            return this.getOneRepetitionDuration() * this._repeatTimes;
        }

        /**
         * Calculate one repetition duration.
         * @method cc.action.Action#getOneRepetitionDuration
         * @returns {number}
         */
        getOneRepetitionDuration():number {
            return ( this._duration + this._delayAfterApplication );
        }

        /**
         * Chekcs whether the action is applicable.
         * In case it gets out of scene time, and has not been tagged as expired, the action is expired and observers
         * are notified about that fact.
         * @method cc.action.Action#__isActionApplicable
         * @param time {number} the scene time to check the action against.
         * @return {boolean} whether the action is applicable.
         */
        __isActionApplicable(time:number):boolean {

            // not correct status
            if (this._status === ActionStates.PAUSED || this._status === ActionStates.ENDED) {
                return false;
            }

            // still not in time
            return this._repeatTimes===Number.MAX_VALUE ||
                (time >= this._startTime && time < this._startTime + this.getDuration());
        }

        /**
         * This method must no be called directly.
         * The director loop will call this method in order to apply target actions.
         * @method cc.action.Action#step
         * @param delta {number} elapsed time since last application.
         * @param target {object}  target object the action is being applied to.
         */
        step(delta:number, target:any):void {

            delta*= cc.action.TIMEUNITS;

            this._currentTime += delta * this._speed;

            this.__stepImpl(delta, this._currentTime, target);
        }

        /**
         * Actual step implementation.
         * @method cc.action.Action#__stepImpl
         * @param delta {number} elapsed time since last application.
         * @param time {number} Action accumulated time.
         * @param target {object} target to apply action to.
         * @private
         */
        __stepImpl(delta:number, time:number, target:any):void {


            // if an action is not ended, it has the chance of updating value
            if ( this._status!==ActionStates.ENDED ) {

                // actions can be paused w/o even been started.
                if (this._status === ActionStates.RESUMED) {
                    if (this._onResume) {
                        this._onResume(this, target);
                    }
                }


                // if the action is not ended, but can be executed due to time
                if (this.__isActionApplicable(time)) {
                    this.__actionApply(time, target);
                } else {

                    // if the action is expired, ie, current time is beyong the start and duration
                    if (time >= this._startTime + this.getDuration()) {

                        // apply for final state anyway
                        this.__actionApply(time, target);
                        // set the action as ENDED
                        this.stop(target);
                    }
                }
            }
        }

        /**
         * When an action is in time, and able to be applied to a target, this method does all the necessary steps.
         * Do not call directly.
         * @method cc.action.Action#__actionApply
         * @param time {number} current action's application time.
         * @param target {object} target node.
         * @private
         */
        __actionApply(time:number, target:any) {


            // manage first execution. it gives the chance to the Action of initializing with the target node
            if (this._firstExecution) {

                // callback for onStart. only once. from now on, the action is not first_execution
                if (this._onStart) {
                    this._onStart(this, target);
                }

                this._firstExecution = false;

                // initialize with the target before updating its values.
                this.initWithTarget(target);
            }

            // current status RUNNING
            this._status = ActionStates.RUNNING;

            // normalize the time, transform current time to a value in the range 0..1 proportionally to the
            // action length, start time, etc. it also applies the easing (if any).
            var ntime = this.__normalizeTime(time);

            // update target
            var v = this.update(ntime, target);

            // application callback. called each time the node has changed properties.
            if (this._onApply) {
                this._onApply(this, target, v);
            }

            this.__checkRepetition( time, target );
        }

        /**
         * Do code specific for checking action repetition and callback invocation when it makes sense.
         * @method cc.action.Action#__checkRepetition
         * @param time {number} current action application time .
         * @param target {object} target object the action is being applied to.
         * @private
         */
        __checkRepetition( time:number, target:any ) {

            // if this is a repeating action
            if (this._repeatTimes !== 1) {

                // calculate current repetition value
                var repeatIndex = ((time - this._startTime) / this.getOneRepetitionDuration()) >> 0;

                // if changed
                if (repeatIndex !== this._currentRepeatCount) {
                    if (repeatIndex > this._repeatTimes) {
                        repeatIndex = this._repeatTimes;
                    }
                    this._currentRepeatCount = repeatIndex;

                    // callback about repetition
                    if (this._onRepeat) {
                        this._onRepeat(this, target, repeatIndex);
                    }
                }
            }

        }

        /**
         * Pass in the target node this action will act on.
         * This method must be overriden by each action type.
         * @method cc.action.Action#initWithTarget
         * @param target {object}
         */
        initWithTarget(target:any):void {
        }

        /**
         * Solve Action first application values.
         * Must be overriden.
         * @method cc.action.Action#solveInitialValues
         * @param target {object}
         */
        solveInitialValues(target:any) {
        }

        /**
         * End this action immediately. Will call onEnd callback if set.
         * @method cc.action.Action#stop
         * @param target {object=}
         */
        stop(target?:any) {
            this._status = ActionStates.ENDED;

            if (this._onEnd) {
                this._onEnd(this, target);
            }
        }

        /**
         * Is this action finished ?
         * @method cc.action.Action#isFinished
         * @returns {boolean}
         */
        isFinished():boolean {
            return this._status === ActionStates.ENDED;
        }

        /**
         * Is this action paused ?
         * @method cc.action.Action#isPaused
         * @returns {boolean}
         */
        isPaused():boolean {
            return this._status === ActionStates.PAUSED;
        }

        /**
         * Set origin values for the action.
         * This method MUST be overriden and called from the override function.
         * @method cc.action.Action#from
         * @param obj {Object} any object necessary for the action initialization.
         * @returns {cc.action.Action}
         */
        from(obj:any):Action {
            this._fromValuesSet = true;
            return this;
        }

        /**
         * Set destination values for the action.
         * @method cc.action.Action#to
         * @param obj {Object} any object necessary for the action initialization.
         * @returns {cc.action.Action}
         */
        to(obj:any):Action {
            return this;
        }

        /**
         * Shortcut method for setting an action's duration, delay and easing function.
         * @method cc.action.Action#timeInfo
         * @param delay {number} milliseconds to wait for action start.
         * @param duration {number} milliseconds of this action application.
         * @param interpolator {cc.action.TimeInterpolator} a time interpolator interface object.
         * @returns {cc.action.Action}
         */
        timeInfo(delay:number, duration:number, interpolator?:cc.action.TimeInterpolator):Action {
            this._duration = duration*TIMEUNITS;
            this.setDelay(delay);
            if (typeof interpolator !== "undefined") {
                this._interpolator = interpolator;
            }
            return this;
        }

        /**
         * This method will make actions to be applied relatively instead of absolutely.
         * For example, moveBy will add the position to the current node's position instead of traversing through the
         * path.
         * @method cc.action.Action#setRelative
         * @param relative {boolean} make this action to behave as moveBy
         * @returns {cc.action.MoveAction}
         */
        setRelative(relative:boolean):Action {
            this._relativeAction = relative;
            return this;
        }

        /**
         * @deprecated This method is deprecated because of its semantics. Use createReversed() instead.
         * @method cc.action.Action#reverse
         * @see {cc.action.Action#createReversed}
         */
        reverse():Action {
            return this.createReversed();
        }

        /**
         * Create a new Action which is the reverse of this one.
         * A reverse Action is expected to be the inverse of what it was. In example, getting back from a path,
         * or rotating in the other direction.
         * In this new implementation, a reverse action is just inverting the TimeInterpolation value.
         * @method cc.action.Action#createReversed
         * @returns {cc.action.Action}
         */
        createReversed():Action {
            var action = this.clone();
            return action.setReversed();
        }

        /**
         * Set an action to be its reversed action.
         * This method does not create any new action.
         * @method cc.action.Action#setReversed
         * @returns {cc.action.Action}
         */
        setReversed():Action {

            this._reversed= !this._reversed;
            if (this._interpolator) {
                this._interpolator = this._interpolator.reverse();
            } else {
                this._interpolator = Interpolator.Linear(true,false);
            }
            return this;
        }

        /**
         * Make the actual cloning implementation.
         * This method must be overriden by each action type.
         * @method cc.action.Action#__cloneImpl
         * @returns {cc.action.Action}
         * @private
         */
        __cloneImpl():Action {
            var copy: Action= new Action();
            this.__genericCloneProperties(copy);
            return copy;
        }

        /**
         * Create a copy of an action.
         * @method cc.action.Action#clone
         * @returns {cc.action.Action}
         */
        clone():Action {
            return this.__cloneImpl();
        }

        /**
         * Is action relative.
         * In V2 and V3 language, a relative action corresponds to ActionBy types.
         * Non relative actions are ActionTo types.
         * @method cc.action.Action#isRelative
         * @returns {boolean}
         */
        isRelative():boolean {
            return this._relativeAction;
        }

        /**
         * Copy generic properties when cloning an Action.
         * Action event Callbacks are copied as well.
         * @method cc.action.Action#__genericCloneProperties
         * @param copy {cc.action.Action}
         * @private
         */
        __genericCloneProperties(copy) {
            copy.setInterpolator(this._interpolator).
                setReversedTime(this._reversedTime).
                //__setOwner(this.getOwner()).
                setSpeed(this.getSpeed()).
                setRepeatTimes(this._repeatTimes).
                setRelative(this._relativeAction);

            copy._startTime= this._startTime;
            copy._duration= this._duration;
            copy._delayAfterApplication= this._delayAfterApplication;

            // explictly copy callbacks this way. Sequence overwrites onRepeat.
            copy._onStart= this._onStart;
            copy._onEnd= this._onEnd;
            copy._onApply=this._onApply;
            copy._onRepeat=this._onRepeat;
            copy._onPause=this._onPause;
            copy._onResume=this._onResume;

            copy._reversed = this._reversed;

        }


        /**
         * Backward compatible call.
         * @method cc.action.Action#easing
         * @param i {cc.action.Interpolator} an interpolator/easing function.
         * @returns {cc.action.Action}
         */
        easing(i:cc.action.TimeInterpolator):Action {
            this.setInterpolator(i);
            return this;
        }

        /**
         * Backward compatible call.
         * @method cc.action.Action#speed
         * @param speed
         * @returns {cc.action.Action}
         * @deprecated Use setSpeed(speed)
         */
        speed(speed:number):Action {
            this._speed *= speed;
            return this;
        }

        /**
         * Is time applied in inverse order ?
         * @method cc.action.Action#isReversedTime
         * @returns {boolean}
         */
        isReversedTime():boolean {
            return this._reversedTime;
        }

        /**
         * Set this action's time to be applied inversely.
         * @method cc.action.Action#setReversedTime
         * @param b {boolean} reverse time ?
         * @returns {cc.action.Action}
         */
        setReversedTime(b:boolean):Action {
            this._reversedTime = b;
            return this;
        }

        /**
         * This method is called from a SequenceAction object. It clears current action status info so that it can
         * be restarted.
         * @method cc.action.Action#__recursivelySetCreatedStatus
         * @param target {any}
         * @private
         */
        __recursivelySetCreatedStatus(target:any) {
            if ( this._status!==ActionStates.ENDED ) {
                this.update( this._reversed ? 0 : 1,target);
            }
            this._currentTime= 0;
            this._status= ActionStates.CREATED;
            this._firstExecution= true;
        }

        /**
         * Apply this action in a pingpong way.
         * @method cc.action.Action#pingpong
         */
        pingpong() {
            this.setInterpolator( cc.action.Interpolator.Linear( this._reversed, true ) );
        }

        /**
         * Build an initializer object out of the Action current state and info.
         * Every Action type must override and super.call this method.
         * @method cc.action.Action#getInitializer
         * @returns {cc.action.ActionInitializer}
         */
        getInitializer() : ActionInitializer {

            var obj:any= {};

            if ( this._delayBeforeApplication ) {
                obj.delayBefore= this._delayBeforeApplication/cc.action.TIMEUNITS;
            }
            if ( this._delayAfterApplication ) {
                obj.delayAfter= this._delayAfterApplication/cc.action.TIMEUNITS;
            }
            obj.duration= this._duration/cc.action.TIMEUNITS;
            obj.relative= this._relativeAction;

            if ( this._repeatTimes!==1 ) {
                obj.repeatTimes = this._repeatTimes;
            }

            if ( this._interpolator ) {
                obj.interpolator= this._interpolator.getInitializer();
            }

            obj.reversed= this._reversed;

            return obj;
        }
    }

}
/**
 * License: see license.txt file.
 */


module cc.action {

    "use strict";

    /**
     * @class cc.action.InterpolatorInitializer
     * @interface
     */
    export interface InterpolatorInitializer {

        /**
         * Interpolator type.
         * @member cc.action.InterpolatorInitializer#type
         * @type {string}
         */
        type : string;

        /**
         * Is inverted ?
         * @member cc.action.InterpolatorInitializer#inverse
         * @type {boolean}
         */
        inverse? : boolean;

        /**
         * Is pingpong ?
         * @member cc.action.InterpolatorInitializer#pingpong
         * @type {boolean}
         */
        pingpong? : boolean;

        /**
         * some interpolators need an exponent value.
         * @member cc.action.InterpolatorInitializer#exponent
         * @type {number}
         */
        exponent? : number;

        /**
         * some interpolators need an period value.
         * @member cc.action.InterpolatorInitializer#period
         * @type {number}
         */
        period? : number;
    }

    /**
     * @class cc.action.TimeInterpolator
     * @interface
     * @classdesc
     *
     * Interface for all Interpolator functions.
     * <br>
     * This is a callable interface: <code>(time:number) => number</code>
     *
     */
    export interface TimeInterpolator {
        (time:number) : number;

        /**
         * Reverse the interpolator instance.
         * @method cc.action.TimeInterpolator#reverse
         */
        reverse() : TimeInterpolator;

        getInitializer() : InterpolatorInitializer;
    }

    /**
     *
     * This function creates a new TimeIntepolator object from a JSON object.
     * It can be the result of serializing an interpolator.
     *
     * @name ParseInterpolator
     * @memberOf cc.action
     * @param ii {cc.action.InterpolatorInitializer}
     * @returns {cc.action.TimeInterpolator}
     * @constructor
     */
    export function ParseInterpolator( ii:InterpolatorInitializer ) {
        if ( ii.type==="EaseIn" || ii.type==="EaseOut" || ii.type==="EaseInOut" ) {
            return cc.action.Interpolator[ii.type](ii.exponent, ii.inverse, ii.pingpong);
        } else if ( ii.type==="ElasticIn" || ii.type==="ElasticOut" || ii.type==="ElasticInOut" ) {
            return cc.action.Interpolator[ii.type](ii.period, ii.inverse, ii.pingpong);
        } else {
            return cc.action.Interpolator[ii.type](ii.inverse, ii.pingpong);
        }
    }

    function calcTime( time:number, inverse:boolean, pingpong:boolean ) {

        if (pingpong) {
            if (time < 0.5) {
                time *= 2;
            } else {
                time = 1 - (time - 0.5) * 2;
            }
        }

        if (inverse) {
            time = 1 - time;
        }

        return time;
    }

    function bounceTime(time1) {
        if (time1 < 1 / 2.75) {
            return 7.5625 * time1 * time1;
        } else if (time1 < 2 / 2.75) {
            time1 -= 1.5 / 2.75;
            return 7.5625 * time1 * time1 + 0.75;
        } else if (time1 < 2.5 / 2.75) {
            time1 -= 2.25 / 2.75;
            return 7.5625 * time1 * time1 + 0.9375;
        }

        time1 -= 2.625 / 2.75;
        return 7.5625 * time1 * time1 + 0.984375;
    }

    /**
     * @class cc.action.Interpolator
     *
     * @classdesc
     * Interpolators are functions used to modify a normalized value, commonly an action current time relative to
     * the action's duration.
     * <br>
     * The achieved effect is pretty interesting for animations, from slow acceleration to bounces, elastic behaviors,
     * etc. All interpolators are the same object types, and have same capabilities
     *   <li>inverse {boolean}: make the interpolator apply inversely (time applies from 1 to 0)
     *   <li>pingpong {boolean}: the interpolator will apply half the time non-inverse and the other half of the time
     *       inversely. This is suitable for effects that apply and de-apply. I.e. zoom from scale 1 to 2, and back from
     *       2 to 1. In previous API, two actions were needed for such effects.
     * <br>
     * Some of the interpolators are easing functions, quadratic bezier curves, etc.
     * <br>
     * In V2 and V3 API, interpolators were cc.easing actions, and in V4, they have been turned into an action
     * attribute.
     * <br>
     * An interpolator is set for an action by calling <code>action.setInterpolator</code>.
     */
    export class Interpolator {

        /**
         * Build a linear interpolator.
         * @method cc.action.Interpolator.Linear
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {cc.action.TimeInterpolator}
         */
        static Linear(inverse?:boolean, pingpong?:boolean):TimeInterpolator {

            var fn:any = function LinearImpl(time:number):number {
                return calcTime( time, inverse, pingpong );
            };

            fn.reverse = function () : TimeInterpolator {
                return Interpolator.Linear(!inverse, pingpong);
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "Linear",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;

        }

        /**
         * Build an ease-in interpolator.
         * @param exponent {number} exponent
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseIn
         */
        static EaseIn(exponent:number, inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseInImpl(time:number) : number {

                return Math.pow(calcTime( time, inverse, pingpong ), exponent);
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseIn( exponent, !inverse, pingpong );
            };


            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseIn",
                    inverse : inverse,
                    pingpong : pingpong,
                    exponent : exponent
                };
            };

            return fn;
        }

        /**
         * Build an ease-out interpolator.
         * @param exponent {number} exponent
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseOut
         */
        static EaseOut(exponent:number, inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseOutImpl(time:number) : number {

                return 1 - Math.pow(1 - calcTime( time, inverse, pingpong ), exponent);
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseOut( exponent, !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseOut",
                    inverse : inverse,
                    pingpong : pingpong,
                    exponent : exponent
                };
            };

            return fn;
        }

        /**
         * Build an ease-in-out interpolator.
         * @param exponent {number} exponent
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseInOut
         */
        static EaseInOut(exponent:number, inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseInOutImpl(time:number) : number {

                time= calcTime( time, inverse, pingpong );

                if (time * 2 < 1) {
                    return Math.pow(time * 2, exponent) / 2;
                }

                return 1 - Math.abs(Math.pow(time * 2 - 2, exponent)) / 2;
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseInOut( exponent, !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseInOut",
                    inverse : inverse,
                    pingpong : pingpong,
                    exponent : exponent
                };
            };

            return fn;
        }


        /**
         * Build an exponential-in interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialIn
         */
        static EaseExponentialIn(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseInImpl(time:number) : number {

                time= calcTime( time, inverse, pingpong );
                return time===0 ? 0 : Math.pow(2, 10 * (time - 1));
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseExponentialIn( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseExponentialIn",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an exponential-out interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialOut
         */
        static EaseExponentialOut(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseOutImpl(time:number) : number {

                time= calcTime( time, inverse, pingpong );

                return time === 1 ? 1 : 1-Math.pow(2, -10 * time);
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseExponentialOut( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseExponentialOut",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an exponential-in-out interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialInOut
         */
        static EaseExponentialInOut(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseInOutImpl(time:number) : number {

                var dt= calcTime( time, inverse, pingpong );
                dt *= 2;
                if (dt < 1) {
                    return 0.5 * Math.pow(2, 10 * (dt - 1));
                }
                else {
                    return 0.5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
                    //return 0.5 * (1 -Math.pow(2, -10 * (dt - 2)) );
                }
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseExponentialInOut( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseExponentialInOut",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an sine-in interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialIn
         */
        static EaseSineIn(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseSineInImpl(time:number) : number {
                time= calcTime( time, inverse, pingpong );
                return time===0 || time===1 ? time : 1 - Math.cos(time * Math.PI / 2);
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseSineIn( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseSineIn",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an sine-out interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialOut
         */
        static EaseSineOut(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseSineOutImpl(time:number) : number {
                time = calcTime(time, inverse, pingpong);
                return time === 1 || time === 0 ? time : Math.sin(time * Math.PI / 2);
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseSineOut( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseSineOut",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an sine-inout interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialOut
         */
        static EaseSineInOut(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseSineInOutImpl(time:number) : number {
                var dt = calcTime(time, inverse, pingpong);
                return dt===0 || dt===1 ? dt : -0.5 * (Math.cos(Math.PI * dt) - 1);
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseSineInOut( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseSineInOut",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an EaseElasticIn interpolator.
         * @param period {number=}
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialIn
         */
        static EaseElasticIn(period?:number, inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseElasticInImpl(time:number) : number {

                period = typeof period==='undefined' ? 0.3 : period;

                var dt= calcTime( time, inverse, pingpong );

                if (dt === 0 || dt === 1) {
                    return dt;
                } else {
                    var s = period / 4;
                    dt = dt - 1;
                    return -Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / period);
                }
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseElasticIn( period, !inverse, pingpong );
            };


            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseElasticIn",
                    inverse : inverse,
                    pingpong : pingpong,
                    period: period
                };
            };

            return fn;
        }

        /**
         * Build an EaseElasticOut interpolator.
         * @param period {number=}
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialOut
         */
        static EaseElasticOut(period?:number, inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseElasticOutImpl(time:number) : number {

                period = typeof period==='undefined' ? 0.3 : period;

                var dt = calcTime(time, inverse, pingpong);

                if (dt === 0 || dt == 1) {
                    return dt;
                } else {
                    var s = period / 4;
                    return Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / period) + 1;
                }
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseElasticOut( period, !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseElasticOut",
                    inverse : inverse,
                    pingpong : pingpong,
                    period: period
                };
            };

            return fn;
        }

        /**
         * Build an EaseElasticInOut interpolator.
         * @param period {number=}
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialOut
         */
        static EaseElasticInOut(period?:number, inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseElasticInOutImpl(time:number) : number {

                period = typeof period==='undefined' ? 0.3 : period;

                var dt = calcTime(time, inverse, pingpong);

                if (dt === 0 || dt == 1) {
                    return dt;
                } else {
                    dt = dt * 2;
                    var s = period / 4;
                    dt = dt - 1;
                    if (dt < 0)
                        return -0.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / period);
                    else
                        return Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / period) * 0.5 + 1;
                }
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseElasticInOut( period, !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseElasticInOut",
                    inverse : inverse,
                    pingpong : pingpong,
                    period: period
                };
            };

            return fn;
        }

        /**
         * Build an EaseBounceIn interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialIn
         */
        static EaseBounceIn(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseBounceInImpl(time:number) : number {
                var dt= calcTime( time, inverse, pingpong );
                return 1 - bounceTime(1 - dt);
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseBounceIn( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseBounceIn",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an EaseBounceOut interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialOut
         */
        static EaseBounceOut(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseBounceOutImpl(time:number) : number {
                return bounceTime( calcTime(time, inverse, pingpong) );
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseBounceOut( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseBounceOut",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an EaseBounceInOut interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialOut
         */
        static EaseBounceInOut(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseBounceInOutImpl(time:number) : number {

                var dt = calcTime(time, inverse, pingpong);
                if (dt < 0.5) {
                    dt = dt * 2;
                    return (1 - bounceTime(1 - dt)) * 0.5;
                } else {
                    return bounceTime(dt * 2 - 1) * 0.5 + 0.5;
                }
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseBounceInOut( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseBounceInOut",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an EaseBackIn interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialIn
         */
        static EaseBackIn(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseBackInImpl(time:number) : number {
                var dt= calcTime( time, inverse, pingpong );
                var overshoot = 1.70158;
                return dt===0 || dt===1 ?
                    dt :
                    dt * dt * ((overshoot + 1) * dt - overshoot);
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseBackIn( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseBackIn",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an EaseBackOut interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialOut
         */
        static EaseBackOut(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseBackOutImpl(time:number) : number {
                var dt= calcTime(time, inverse, pingpong);
                var overshoot = 1.70158;
                dt = dt - 1;
                return 1 + dt * dt * ((overshoot + 1) * dt + overshoot);
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseBackOut( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseBackOut",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

        /**
         * Build an EaseBackInOut interpolator.
         * @param inverse {boolean=}
         * @param pingpong {boolean=}
         * @returns {TimeInterpolator}
         * @method cc.action.Interpolator.EaseExponentialOut
         */
        static EaseBackInOut(inverse?:boolean, pingpong?:boolean) : TimeInterpolator {

            var fn : any = function EaseBounceInOutImpl(time:number) : number {

                var dt = calcTime(time, inverse, pingpong);
                var overshoot = 1.70158;
                dt = dt * 2;
                    if (dt < 1) {
                        return (dt * dt * ((overshoot + 1) * dt - overshoot)) / 2;
                    } else {
                        dt = dt - 2;
                        return 1 + (dt * dt * ((overshoot + 1) * dt + overshoot)) / 2;
                    }
            };

            fn.reverse = function() : TimeInterpolator {
                return Interpolator.EaseBackInOut( !inverse, pingpong );
            };

            fn.getInitializer = function() : InterpolatorInitializer {
                return {
                    type : "EaseBackInOut",
                    inverse : inverse,
                    pingpong : pingpong
                };
            };

            return fn;
        }

    }
}
/**
 * License: see license.txt file.
 */



/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>
"use strict";

module cc.action {

    import        Node = cc.node.Node;
    import        Action = cc.action.Action;

    /**
     * @class cc.action.AlphaActionInitializer
     * @extends cc.action.ActionInitializer
     * @interface
     * @classdesc
     *
     * AlphaAction initializer object.
     *
     */
    export interface AlphaActionInitializer extends ActionInitializer {

        /**
         * Start alpha value.
         * @member cc.action.AlphaActionInitializer#start
         * @type {number}
         */
        from? : number;

        /**
         * End alpha value.
         * @member cc.action.AlphaActionInitializer#end
         * @type {number}
         */
        to? : number;

    }

    /**
     * @class cc.action.AlphaAction
     * @extends cc.action.Action
     * @classdesc
     *
     * This action applies to a node's transparency.
     * <br>
     * Transparency values are defined by a number between 0 (fully transparent) and 1 (fully opaque).
     */
    export class AlphaAction extends Action {


        /**
         * When the action is initialized with a target, this value is the original transparency value.
         * @member cc.action.AlphaAction#_originalAlpha
         * @type {number}
         * @private
         */
        _originalAlpha:number = 0;

        /**
         * Action start alpha.
         * @member cc.action.AlphaAction#_startAlpha
         * @type {number}
         * @private
         */
        _startAlpha:number = 0;

        /**
         * Action end alpha.
         * @member cc.action.AlphaAction#_endAlpha
         * @type {number}
         * @private
         */
        _endAlpha:number = 0;

        /**
         * AlphaAction constructor.
         * @method cc.action.AlphaAction#constructor
         * @param data {cc.action.AlphaActionInitializer=}
         */
        constructor( data? : AlphaActionInitializer ) {
            super();
            if (data) {
                this.__createFromInitializer(data);
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.AlphaAction#__createFromInitializer
         * @param data {cc.action.AlphaActionInitializer}
         * @private
         */
        __createFromInitializer(data?:AlphaActionInitializer ) {
            super.__createFromInitializer( data );
            if ( typeof data!=="undefined" ) {
                this._startAlpha = data.to;
                this._endAlpha = data.from;
            }
        }

        /**
         * Update target Node's transparency.
         * {@link cc.action.Action#update}
         * @method cc.action.AlphaAction#update
         * @override
         * @return {number} Applied transparency value.
         */
        update(delta:number, node:Node):any {

            var r:number = this._startAlpha + delta * (this._endAlpha - this._startAlpha);

            if (this._relativeAction) {
                r += this._originalAlpha;
                if ( this._reversed ) {
                    r-= this._endAlpha;
                }
            }

            node._alpha= r;

            return r;
        }

        /**
         * Capture before-application Node's property values.
         * {@link cc.action.Action#solveInitialValues}
         * @method cc.action.AlphaAction#solveInitialValues
         * @override
         */
        solveInitialValues(node:Node) {
            if (this._relativeAction && !this._fromValuesSet) {
                this._startAlpha = 0;
            } else if (!this._fromValuesSet ) {
                this._startAlpha = node._alpha;
            }

        }

        /**
         * {@link cc.action.Action#initWithTarget}
         * @method cc.action.AlphaAction#initWithTarget
         * @override
         */
        initWithTarget(node:Node):void {
            this._originalAlpha = node._alpha;
            this.solveInitialValues(node);
        }

        /**
         * {@link cc.action.Action#from}
         * @method cc.action.AlphaAction#from
         * @override
         */
        from(alpha:number):Action {
            super.from(alpha);
            this._startAlpha = alpha;
            return this;
        }

        /**
         * {@link cc.action.Action#to}
         * @method cc.action.AlphaAction#to
         * @override
         */
        to(alpha:number):Action {
            this._endAlpha = alpha;
            return this;
        }

        /**
         * {@link cc.action.Action#__cloneImpl}
         * @method cc.action.AlphaAction#__cloneImpl
         * @override
         */
        __cloneImpl():Action {

            var copy : AlphaAction = new AlphaAction();
            copy.to(this._endAlpha);

            if (this._fromValuesSet) {
                copy.from(this._startAlpha);
            }

            copy._originalAlpha= this._originalAlpha;

            this.__genericCloneProperties(copy);

            return copy;
        }

        /**
         * Serialize the action current definition.
         * @method cc.action.AlphaAction#getInitializer
         * @returns {cc.action.AlphaActionInitializer}
         */
        getInitializer() : AlphaActionInitializer {
            var init:AlphaActionInitializer= <AlphaActionInitializer>super.getInitializer();
            if ( this._fromValuesSet ) {
                init.from = this._startAlpha;
            }
            init.to= this._endAlpha;
            init.type="AlphaAction";

            return init;
        }
    }

}

/**
 * License: see license.txt file.
 */


/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>

module cc.action {

    "use strict";

    import Point = cc.math.Point;
    import Vector= cc.math.Vector;

    import Node = cc.node.Node;
    import Action = cc.action.Action;

    var __moveActionUpdateValue : cc.math.Point= { x : 0, y : 0 };

    /**
     * @class cc.action.MoveActionInitializer
     * @extends cc.action.ActionInitializer
     * @interface
     * @classdesc
     *
     * MoveAction initializer object.
     */
    export interface MoveActionInitializer extends ActionInitializer {

        /**
         * Move from point.
         * @member cc.action.MoveActionInitializer#from
         * @type {cc.math.Point}
         */
        from? : cc.math.Point;

        /**
         * Move to point.
         * @member cc.action.MoveActionInitializer#to
         * @type {cc.math.Point}
         */
        to : cc.math.Point;

    }

    /**
     * @class cc.action.MoveAction
     * @extends cc.action.Action
     * @classdesc
     * This action applies to a node's position.
     * The action will traverse a line path.
     */
    export class MoveAction extends Action {

        /**
         * Node's original x position.
         * @member cc.action.MoveAction#_originalX
         * @type {number}
         * @private
         */
        _originalX : number = 0;

        /**
         * Node's original y position.
         * @member cc.action.MoveAction#_originalX
         * @type {number}
         * @private
         */
        _originalY : number = 0;

        /**
         * Action initial X
         * @member cc.action.MoveAction#_x0
         * @type {number}
         * @private
         */
        _x0 : number = 0;

        /**
         * Action initial Y
         * @member cc.action.MoveAction#_y0
         * @type {number}
         * @private
         */
        _y0 : number = 0;

        /**
         * Action final X
         * @member cc.action.MoveAction#_x1
         * @type {number}
         * @private
         */
        _x1 : number = 0;

        /**
         * Action final Y
         * @member cc.action.MoveAction#_y1
         * @type {number}
         * @private
         */
        _y1 : number = 0;

        /**
         * Build a new MoveAction
         * @method cc.action.MoveAction#constructor
         * @param data {cc.action.MoveActionInitializer=}
         */
        constructor( data? : MoveActionInitializer ) {
            super();

            if ( data ) {
                this.__createFromInitializer(data);
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.MoveAction#__createFromInitializer
         * @param initializer {cc.action.MoveActionInitializer}
         * @private
         */
        __createFromInitializer(initializer?:MoveActionInitializer ) {
            super.__createFromInitializer(initializer);
        }

        /**
         * Update target Node's position.
         * {@link cc.action.Action#update}
         * @method cc.action.MoveAction#update
         * @override
         * @return {cc.math.Point} new Node position.
         */
        update(delta:number, node : Node ) : any {

            var x = this._x0 + delta * (this._x1 - this._x0);
            var y = this._y0 + delta * (this._y1 - this._y0);

            if ( this._relativeAction ) {
                x+= this._originalX;
                y+= this._originalY;
                if ( this._reversed ) {
                    x-= this._x1;
                    y-= this._y1;
                }
            }

            node.setPosition( x, y );

            __moveActionUpdateValue.x= x;
            __moveActionUpdateValue.y= y;

            return __moveActionUpdateValue;
        }

        /**
         * Capture before-application Node's property values.
         * {@link cc.action.Action#solveInitialValues}
         * @method cc.action.MoveAction#solveInitialValues
         * @override
         */
        solveInitialValues(node : Node) {

            if (this._relativeAction && !this._fromValuesSet) {
                this._x0=0;
                this._y0=0;
            } else if (!this._fromValuesSet) {
                this._x0 = node.x;
                this._y0 = node.y;
            }
        }

        /**
         * {@link cc.action.Action#initWithTarget}
         * @method cc.action.MoveAction#initWithTarget
         * @override
         */
        initWithTarget( node : Node ) {
            this._originalX = node.x;
            this._originalY = node.y;

            this.solveInitialValues(node);
        }

        /**
         * {@link cc.action.Action#from}
         * @method cc.action.MoveAction#from
         * @override
         */
        from(point:Point):Action {
            super.from(point);
            this._x0 = point.x;
            this._y0 = point.y;

            return this;
        }

        /**
         * {@link cc.action.Action#to}
         * @method cc.action.MoveAction#to
         * @override
         */
        to(point:Point):Action {
            this._x1 = point.x;
            this._y1 = point.y;
            return this;
        }

        /**
         * {@link cc.action.Action#__cloneImpl}
         * @method cc.action.MoveAction#__cloneImpl
         * @override
         */
        __cloneImpl() : Action {

            var copy= new MoveAction().
                to({ x: this._x1, y: this._y1});

            if ( this._fromValuesSet ) {
                copy.from( { x: this._x0, y: this._y0 } );
            }

            this.__genericCloneProperties( copy );

            return copy;
        }

        /**
         * Serialize the action current definition.
         * @method cc.action.MoveAction#getInitializer
         * @returns {cc.action.MoveActionInitializer}
         */
        getInitializer() : MoveActionInitializer {
            var init:MoveActionInitializer= <MoveActionInitializer>super.getInitializer();

            if ( this._fromValuesSet ) {
                init.from = { x: this._x0, y:this._y0 };
            }

            init.to= { x: this._x1, y:this._y1 };

            init.type="MoveAction";

            return init;
        }

    }
}
/**
 * License: see license.txt file.
 */


/// <reference path="../node/Node.ts"/>
/// <reference path="../action/Action.ts"/>

module cc.action {

    "use strict";

    import Node = cc.node.Node;
    import Action = cc.action.Action;

    /**
     * @class cc.action.PropertyActionInitializer
     * @extends cc.action.ActionInitializer
     * @interface
     */
    export interface PropertyActionInitializer extends ActionInitializer {

    }

    /**
     * @class cc.action.PropertyInfo
     * @classdesc
     *
     * Internal helper Object to store a property information.
     * It stores:
     * <li>a property name, for example 'x' or 'p0.x'
     * <li>the property path. For example ['x'] or ['p0','x']
     * <li>original property value for a target object
     *
     * It is responsible for setting and getting the deep property path values too.
     *
     * Referenced properties MUST be numeric.
     */
    export class PropertyInfo {


        /**
         * Property Units. For example, when the property is not a numeric value but something like '250px'.
         * @member cc.action.PropertyInfo#_units
         * @type {string}
         * @private
         */
        _units : string = "";

        /**
         * If the property is a deep property, like 'p0.x' or 'a.b.c.d.value' this property will indicate it.
         * @member cc.action.PropertyInfo#_nested
         * @type {boolean}
         * @private
         */
        _nested : boolean = false;

        /**
         * A split('.') of the _property value.
         * @member cc.action.PropertyInfo#_propertyPath
         * @type {Array<string>}
         * @private
         */
        _propertyPath : string[];

        /**
         * Original property value.
         * @member cc.action.PropertyInfo#_original
         * @type {number}
         * @private
         */
        _original : number;

        /**
         * Property name.
         * @member cc.action.PropertyInfo#_property
         * @type {string}
         * @private
         */

        /**
         * Property start value.
         * @member cc.action.PropertyInfo#_start
         * @type {number}
         * @private
         */

        /**
         * Property end value.
         * @member cc.action.PropertyInfo#_end
         * @type {number}
         * @private
         */

        /**
         *
         * @param _property {string} property name.
         * @param _start {number} start value.
         * @param _end {number=} end value.
         */
        constructor(public _property:string, public _start?:number, public _end?:number) {
            this._nested= _property.indexOf('.')!==-1;
            this._propertyPath= _property.split('.');
        }

        /**
         * Set the property value in a target object
         * @method cc.action.PropertyInfo#setTargetValue
         * @param target {any}
         * @param v {number}
         */
        setTargetValue( target:any, v:number ) {
            var cursor= target;
            for( var i=0; i<this._propertyPath.length-1; i++ ) {
                if ( typeof cursor[ this._propertyPath[i] ]!=="undefined" ) {
                    cursor= cursor[ this._propertyPath[i] ];
                } else {
                    // error, no deep path found on object
                    return;
                }
            }

            cursor[ this._propertyPath[i] ]= v;
        }

        /**
         * Get the property value from a target object
         * @method cc.action.PropertyInfo#getTargetValue
         * @param target {any}
         * @returns {number}
         */
        getTargetValue( target:any ) : number {
            var cursor= target;
            for( var i=0; i<this._propertyPath.length; i++ ) {
                if ( typeof cursor[ this._propertyPath[i] ]!=="undefined" ) {
                    cursor= cursor[ this._propertyPath[i] ];
                } else {
                    // error, no deep path found on object
                    return null;
                }
            }

            return cursor;
        }

        /**
         * Set PropertyInfo original target value.
         * @param n {number}
         * @returns {cc.action.PropertyInfo}
         */
        setOriginal( n : number ) : PropertyInfo {
            this._original= n;
            return this;
        }

        /**
         * Get property original value in the original target object.
         * @method cc.action.PropertyInfo#getOriginal
         * @returns {number}
         */
        getOriginal() : number {
            return this._original;
        }

        /**
         * Clone the PropertyInfo object.
         * @method cc.action.PropertyInfo#clone
         * @returns {cc.action.PropertyInfo}
         */
        clone() : PropertyInfo {
            return new PropertyInfo( this._property, this._start, this._end );
        }

        /**
         * Get the property path.
         * @method cc.action.PropertyInfo#getPath
         * @returns {string[]}
         */
        getPath() : string[] {
            return this._propertyPath;
        }
    }

    /**
     * @class cc.action.PropertyAction
     * @extends cc.action.Action
     * @classdesc
     *
     * This action applies to any arbitrary Object's properties. Could apply to multiple properties at the same time.
     * AlphaAction and RotateAction fit in the model of a PropertyInfo, but they are complete Actions for the shake of
     * clarity and performance.
     *
     * The properties a PropertyAction will handle must be simple properties, not Objects, only composed of a number and
     * an optional unit.
     *
     * A different set of properties can be specified in a call to <code>from</code> and <code>to</code>. Properties
     * specified not in both <code>from</code> and <code>to</code> at the same time, will get values either 'from' or
     * 'to' values when a call to <code>initWithTarget</code> is made.
     */
    export class PropertyAction extends Action {

        /**
         * Properties the action manages.
         * @member cc.action.PropertyAction#_propertiesInfo
         * @type {Array<Object>}
         * @private
         */
        _propertiesInfo : Array<PropertyInfo>;

        /**
         * From properties values.
         * @member cc.action.PropertyAction#_from
         * @type {Object}
         * @private
         */
        _from : any;

        /**
         * To properties values.
         * @member cc.action.PropertyAction#_to
         * @type {Object}
         * @private
         */
        _to : any;

        /**
         * PropertyAction constructor.
         * @method cc.action.PropertyAction#constructor
         */
        constructor( data? : PropertyActionInitializer ) {
            super();

            this._propertiesInfo= [];

            if ( data ) {
                this.__createFromInitializer(data);
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.PropertyAction#__createFromInitializer
         * @param data {cc.action.PropertyActionInitializer}
         * @private
         */
        __createFromInitializer(initializer?:PropertyActionInitializer ) {
            super.__createFromInitializer(initializer);
        }

        /**
         * {@link cc.action.Action#initWithTarget}
         * @method cc.action.PropertyAction#initWithTarget
         * @override
         */
        initWithTarget( node : any ) {
            this.solveInitialValues(node);
        }

        /**
         * Update target Node's properties.
         * {@link cc.action.Action#update}
         * @method cc.action.PropertyAction#update
         * @override
         * @returns {Object} an Object with all the modified properties.
         */
        update(delta:number, node : any ) : any {

            var ret = {};

            for( var i=0; i<this._propertiesInfo.length; i++ ) {
                var pr= this._propertiesInfo[i];
                var v = pr._start + delta * (pr._end - pr._start);

                if ( this.isRelative() ) {
                    v+= pr.getOriginal();
                }

                pr.setTargetValue( node, v );
                //node[pr._property] = pr.getValue(v);

                // register applied values only if theres someone interested.
                if ( this._onApply ) {
                    ret[pr._property] = v;
                }
            }

            return ret;
        }

        /**
         * Capture before-application Node's property values.
         * {@link cc.action.Action#solveInitialValues}
         * @method cc.action.PropertyAction#solveInitialValues
         * @override
         */
        solveInitialValues( node : any ) {

            for (var i = 0; i < this._propertiesInfo.length; i++) {
                var pr = this._propertiesInfo[i];
                if (typeof pr._start === "undefined") {
                    pr._start = pr.getTargetValue( node );
                }
                if (typeof pr._end === "undefined") {
                    pr._end = pr.getTargetValue( node );
                }

                pr._original= pr.getTargetValue( node );
            }
        }


        /**
         * {@link cc.action.Action#from}
         * @method cc.action.PropertyAction#from
         * @override
         */
        from( props : any ) : Action {

            this._from= props;

            if ( props ) {
                for (var pr in props) {
                    if (props.hasOwnProperty(pr)) {
                        var propertyInfo = new PropertyInfo(pr, props[pr]);
                        this._propertiesInfo.push(propertyInfo);
                    }
                }
            }

            return this;
        }

        /**
         * {@link cc.action.Action#to}
         * @method cc.action.PropertyAction#to
         * @override
         */
        to( props : any ) : Action {

            this._to= props;

            var i;

            for( var pr in props ) {

                if (props.hasOwnProperty(pr)) {
                    // if no property set, create a property w/o initial value. will be filled automagically by a call to
                    // __setInitialValues
                    var property = null;
                    for (i = 0; i < this._propertiesInfo.length; i++) {
                        if (this._propertiesInfo[i]._property === pr) {
                            property = this._propertiesInfo[i];
                            break;
                        }
                    }

                    if (!property) {
                        property = new PropertyInfo(pr);
                        this._propertiesInfo.push(property);
                    }

                    property._end = props[ pr ];
                }
            }

            return this;
        }

        /**
         * Helper function for cloning this property.
         * @memver cc.action.PropertyAction#__cloneProperties
         * @returns {Array<PropertyInfo>}
         * @private
         */
        __cloneProperties() : Array<PropertyInfo> {
            var pr : Array<PropertyInfo> = [];

            for (var i = 0; i < this._propertiesInfo.length; i++) {
                pr.push( this._propertiesInfo[i].clone() );
            }

            return pr;
        }

        /**
         * {@link cc.action.Action#__cloneImpl}
         * @method cc.action.PropertyAction#__cloneImpl
         * @override
         */
        __cloneImpl() : Action {

            var copy= new PropertyAction().
                to(this.__cloneProperties());

            this.__genericCloneProperties( copy );

            return copy;
        }

        /**
         * Serialize the action current definition.
         * @method cc.action.PropertyAction#getInitializer
         * @returns {cc.action.PropertyActionInitializer}
         */
        getInitializer() : PropertyActionInitializer {
            var init:PropertyActionInitializer= <PropertyActionInitializer>super.getInitializer();

            if ( this._fromValuesSet ) {
                init.from = this._from;
            }
            init.to= this._to;
            init.type="PropertyAction";

            return init;
        }

    }

}
/**
 * License: see license.txt file.
 */

/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>

module cc.action {

    "use strict";

    import Node = cc.node.Node;
    import Action = cc.action.Action;

    /**
     * @class cc.action.RotateActionInitializer
     * @extends cc.action.ActionInitializer
     * @interface
     * @classdesc
     *
     * RotateAction initializer object
     */
    export interface RotateActionInitializer extends ActionInitializer {

        /**
         * Start rotation angle value
         * @member cc.action.RotateActionInitializer#from
         * @type {number}
         */
        from? : number;

        /**
         * End rotation angle value
         * @member cc.action.RotateActionInitializer#to
         * @type {number}
         */
        to : number;
    }

    /**
     * @class cc.action.RotateAction
     * @extends cc.action.Action
     * @classdesc
     *
     * This action applies to a node's rotation angle.
     * The rotation angle is defined in degrees.
     */
    export class RotateAction extends Action {

        /**
         * Node's original rotation angle.
         * @member cc.action.RotateAction#_originalAngle
         * @type {number}
         * @private
         */
        _originalAngle:number = 0;

        /**
         * Action start angle
         * @member cc.action.RotateAction#_startAngle
         * @type {number}
         */
        _startAngle:number = 0;

        /**
         * Action end angle
         * @member cc.action.RotateAction#_endAngle
         * @type {number}
         */
        _endAngle:number = 360;

        /**
         * Build a new RotateAction instance.
         * @method cc.action.RotateAction#constructor
         * @param data {cc.action.RotateActionInitializer=}
         */
        constructor( data? : RotateActionInitializer ) {
            super();

            if ( data ) {
                this.__createFromInitializer(data);
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.RotateAction#__createFromInitializer
         * @param initializer {cc.action.RotateActionInitializer}
         * @private
         */
        __createFromInitializer(initializer?:RotateActionInitializer ) {
            super.__createFromInitializer(initializer);
        }

        /**
         * Update target Node's rotation angle.
         * {@link cc.action.Action#update}
         * @method cc.action.RotateAction#update
         * @override
         * @return {number} new Node rotation angle.
         */
        update(delta:number, node:Node):any {

            var r:number = this._startAngle + delta * (this._endAngle - this._startAngle);

            if (this._relativeAction) {
                r += this._originalAngle;
                if ( this._reversed ) {
                    r-=this._endAngle;
                }
            }

            node.rotationAngle = r;

            return r;
        }

        /**
         * Capture before-application Node's rotation angle.
         * {@link cc.action.Action#solveInitialValues}
         * @method cc.action.RotateAction#solveInitialValues
         * @override
         */
        solveInitialValues(node:Node) {
            if (this._relativeAction && !this._fromValuesSet) {
                this._startAngle = 0;

                if ( this._startAngle === this._endAngle ) {
                    this._startAngle= this._originalAngle;
                    this._originalAngle= 0;
                }

            } else if (!this._fromValuesSet) {
                this._startAngle = node.rotationAngle;
            }
        }

        /**
         * {@link cc.action.Action#initWithTarget}
         * @method cc.action.RotateAction#initWithTarget
         * @override
         */
        initWithTarget(node:Node) {
            this._originalAngle = node.rotationAngle;
            this.solveInitialValues(node);
        }

        /**
         * {@link cc.action.Action#from}
         * @method cc.action.RotateAction#from
         * @override
         */
        from(angle:number):Action {
            super.from(angle);
            this._startAngle = angle;
            return this;
        }

        /**
         * {@link cc.action.Action#to}
         * @method cc.action.RotateAction#to
         * @override
         */
        to(angle:number):Action {
            this._endAngle = angle;
            return this;
        }


        /**
         * {@link cc.action.Action#__cloneImpl}
         * @method cc.action.RotateAction#__cloneImpl
         * @override
         */
        __cloneImpl():Action {

            var copy = new RotateAction().
                to(this._endAngle);

            if (this._fromValuesSet) {
                copy.from(this._startAngle);
            }

            this.__genericCloneProperties(copy);

            return copy;
        }

        /**
         * Serialize the action current definition.
         * @method cc.action.RotateAction#getInitializer
         * @returns {cc.action.RotateActionInitializer}
         */
        getInitializer() : RotateActionInitializer {
            var init:RotateActionInitializer= <RotateActionInitializer>super.getInitializer();

            if ( this._fromValuesSet ) {
                init.from = this._startAngle;
            }
            init.to= this._endAngle;
            init.type="RotateAction";

            return init;
        }
    }

}
/**
 * License: see license.txt file.
 */


/// <reference path="./Action.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Node.ts"/>

module cc.action {

    "use strict";

    import Point = cc.math.Point;
    import Vector= cc.math.Vector;

    import Node = cc.node.Node;
    import Action = cc.action.Action;

    var __scaleActionUpdateValue = new Vector();

    /**
     * @class cc.action.ScaleActionInitializer
     * @extends cc.action.ActionInitializer
     * @interface
     * @classdesc
     *
     * Scale action initializer object.
     *
     */
    export interface ScaleActionInitializer extends ActionInitializer {

        /**
         * Start scale value. The scale is for x and y axis.
         * @member cc.action.ScaleActionInitializer#from
         * @type {cc.math.Point=}
         */
        from? : cc.math.Point;

        /**
         * End scale value. The scale is for x and y axis.
         * @member cc.action.ScaleActionInitializer#to
         * @type {cc.math.Point}
         */
        to : cc.math.Point;
    }

    /**
     * @class cc.action.ScaleAction
     * @extends cc.action.Action
     * @classdesc
     *
     * This action applies to a Node's scale values.
     */
    export class ScaleAction extends Action {

        /**
         * Node's original x axis scale.
         * @member cc.action.ScaleAction#_originalScaleX
         * @type {number}
         * @private
         */
        _originalScaleX:number = 1;

        /**
         * Node's original y axis scale.
         * @member cc.action.ScaleAction#_originalScaleY
         * @type {number}
         * @private
         */
        _originalScaleY:number = 1;

        /**
         * Action start x axis Scale.
         * @member cc.action.ScaleAction#_scaleX0
         * @type {number}
         */
        _scaleX0:number = 1;

        /**
         * Action start y axis Scale.
         * @member cc.action.ScaleAction#_scaleY0
         * @type {number}
         */
        _scaleY0:number = 1;

        /**
         * Action end x axis Scale.
         * @member cc.action.ScaleAction#_scaleX1
         * @type {number}
         */
        _scaleX1:number = 1;

        /**
         * Action end y axis Scale.
         * @member cc.action.ScaleAction#_scaleY1
         * @type {number}
         */
        _scaleY1:number = 1;

        /**
         * Build a new ScaleAction instance.
         * @param data {cc.action.ScaleActionInitializer=}
         */
        constructor( data? : ScaleActionInitializer ) {
            super();

            if ( data ) {
                this.__createFromInitializer(data);
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.ScaleAction#__createFromInitializer
         * @param data {cc.action.ScaleActionInitializer}
         * @private
         */
        __createFromInitializer(initializer?:ScaleActionInitializer ) {
            super.__createFromInitializer(initializer);
        }

        /**
         * Update target Node's scale.
         * {@link cc.action.Action#update}
         * @method cc.action.ScaleAction#update
         * @override
         * @returns {cc.math.Vector} new node's scale values.
         */
        update(delta:number, node:Node):any {

            var x = this._scaleX0 + delta * (this._scaleX1 - this._scaleX0);
            var y = this._scaleY0 + delta * (this._scaleY1 - this._scaleY0);

            if (this._relativeAction) {
                x += this._originalScaleX;
                y += this._originalScaleY;
                if ( this._reversed ) {
                    x-= this._scaleX1;
                    y-= this._scaleY1;
                }
            }

            node.setScale(x, y);

            return __scaleActionUpdateValue.set(x, y);
        }

        /**
         * Capture before-application Node's scale for both axis x and y.
         * {@link cc.action.Action#solveInitialValues}
         * @method cc.action.ScaleAction#solveInitialValues
         * @override
         */
        solveInitialValues(node:Node) {

            if (this._relativeAction && !this._fromValuesSet) {
                this._scaleX0 = 0;
                this._scaleY0 = 0;
            } else if (!this._fromValuesSet) {
                this._scaleX0 = node.scaleX;
                this._scaleY0 = node.scaleY;
            }
        }

        /**
         * {@link cc.action.Action#initWithTarget}
         * @method cc.action.ScaleAction#initWithTarget
         * @override
         */
        initWithTarget(node:Node) {
            this._originalScaleX = node.scaleX;
            this._originalScaleY = node.scaleY;

            this.solveInitialValues(node);
        }

        /**
         * {@link cc.action.Action#from}
         * @method cc.action.ScaleAction#from
         * @override
         */
        from(point:Point):Action {
            super.from(point);
            this._scaleX0 = point.x;
            this._scaleY0 = point.y;

            return this;
        }

        /**
         * {@link cc.action.Action#to}
         * @method cc.action.ScaleAction#to
         * @override
         */
        to(point:Point):Action {
            this._scaleX1 = point.x;
            this._scaleY1 = point.y;
            return this;
        }

        /**
         * {@link cc.action.Action#__cloneImpl}
         * @method cc.action.ScaleAction#__cloneImpl
         * @override
         */
        __cloneImpl():Action {

            var copy = new ScaleAction().
                to({ x: this._scaleX1, y: this._scaleY1});

            if (this._fromValuesSet) {
                copy.from({ x: this._scaleX0, y: this._scaleY0 });
            }

            this.__genericCloneProperties(copy);

            return copy;
        }

        /**
         * Serialize the action current definition.
         * @method cc.action.ScaleAction#getInitializer
         * @returns {cc.action.ScaleActionInitializer}
         */
        getInitializer() : ScaleActionInitializer {
            var init:ScaleActionInitializer= <ScaleActionInitializer>super.getInitializer();

            if ( this._fromValuesSet ) {
                init.from = { x: this._scaleX0, y: this._scaleY0 };
            }
            init.to= { x: this._scaleX1, y: this._scaleY1 };
            init.type="ScaleAction";

            return init;
        }
    }

}
/**
 * License: see license.txt file.
 */


/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>
/// <reference path="./MoveAction.ts"/>
/// <reference path="./RotateAction.ts"/>
/// <reference path="./ScaleAction.ts"/>
/// <reference path="./PropertyAction.ts"/>
/// <reference path="./AlphaAction.ts"/>
/// <reference path="./TintAction.ts"/>


module cc.action {

    "use strict";

    import Node= cc.node.Node;
    import Action = cc.action.Action;

    /**
     * @class cc.action.SequenceActionInitializer
     * @extends cc.action.ActionInitializer
     * @interface
     * @classdesc
     *
     * Sequence action initializer object.
     */
    export interface SequenceActionInitializer extends ActionInitializer {

        /**
         * Is this Action Sequence or Spawn ?
         * @member cc.action.SequenceActionInitializer#sequential
         * @type {boolean}
         */
        sequential? : boolean;

        actions? : ActionInitializer[];
    }

    /**
     * @class cc.action.SequenceAction
     * @extends cc.action.Action
     * @classdesc
     *
     * SequenceAction is a collection of either parallel or sequential actions.
     * It is useful for grouping actions in a more convenient way.
     * <br>
     * This action maps to previous API versions' Sequence and Spawn, but internally works in a complete different way.
     * <br>
     * A Sequence, constraints its contained Actions to its own duration. That means that if the Sequence Actions are not
     * well setup relatively to the Sequence timing, Actions could not end playing, or callbacks could not be notified
     * appropriately.
     *
     * <li>Internally, a Sequence does not modify a Node's properties. It just choreographs the time for its children
     *  Actions. Hece there's no need to call <code>from</code> or <code>to</code> methods. This means that setting
     *  a Sequence as relative has no impact.
     * <li>A Sequence can contain other Sequences to the desired nesting level.
     * <li>A repeating ActionSequence will repeat its contained actions.
     * <li>A Sequence, if is sequential=true, will sequentialize contained actions, making one start when the previous one
     * ends. If it is sequential=false, Actions will happen at the same time.
     * <li>By default a Sequence Action will conform its duration to the one resulting of the contained Actions. It will
     * have special heuristics for sequential and not sequential behaviors.
     */
    export class SequenceAction extends Action {

        /**
         * Collection of Sequenced actions.
         * @member cc.action.SequenceAction#_actions
         * @type {Array<cc.action.Action>}
         * @private
         */
        _actions:Array<Action> = [];

        /**
         * Configures this action as Sequence or Spawn.
         * @member cc.action.SequenceAction#_sequential
         * @type {boolean}
         */
        _sequential:boolean = true;

        _prevOnRepeat : ActionCallbackRepeatCallback= null;

        /**
         * Build a new Sequence action.
         * @method cc.action.SequenceAction#constructor
         * @param data {cc.action.SequenceActionInitializer=}
         */
        constructor( data? : SequenceActionInitializer ) {
            super();

            if (typeof data !== "undefined") {
                this.__createFromInitializer(data);
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.SequenceAction#__createFromInitializer
         * @param data {cc.action.SequenceActionInitializer}
         * @private
         */
        __createFromInitializer(data?:SequenceActionInitializer ) {
            super.__createFromInitializer( data );

            if ( typeof data.sequential!=="undefined" ) {
                this._sequential = data.sequential;
            }

            if ( data.actions ) {
                for( var i=0; i<data.actions.length; i++ ) {
                    this.addAction( cc.action.ParseAction( data.actions[i] ) );
                }
            }

            this._onRepeat= function(action:Action, target:any, repetitionCount:number) {
                var seq : SequenceAction= <SequenceAction>action;
                seq.recursivelySetCreatedStatus(target);
                if ( seq._prevOnRepeat ) {
                    seq._prevOnRepeat( action, target, repetitionCount );
                }
            };
        }

        /**
         * Set onRepeat callback. This method is overridden since repeating sequences must have a custom onRepeat
         * implementation.
         * @method cc.action.SequenceAction#onRepeat
         * @param callback {cc.action.ActionCallbackRepeatCallback}
         * @returns {cc.action.SequenceAction}
         */
        onRepeat( callback : ActionCallbackRepeatCallback ) : Action {
            this._prevOnRepeat= callback;
            return this;
        }

        /**
         * When a Sequence repeats, it must recursively clear the status of all its children Actions.
         * @method cc.action.SequenceAction#recursivelySetCreatedStatus
         * @param target
         */
        recursivelySetCreatedStatus(target:any) {
            for( var i=0; i<this._actions.length; i++ ) {
                this._actions[i].__recursivelySetCreatedStatus(target);
            }
        }

        /**
         * Get the last Action on the sequence.
         * @method cc.action.SequenceAction#getLastAction
         * @returns {cc.action.Action}
         */
        getLastAction() {
            if ( this._actions.length===0 ) {
                return null;
            }

            return this._actions[ this._actions.length-1 ];
        }

        /**
         * Recursive set created status implementation.
         * @method cc.action.SequenceAction#__recursivelySetCreatedStatus
         * @param target {object}
         * @private
         */
        __recursivelySetCreatedStatus(target:any) {
            // first my children actions. !!!
            for( var i=0; i<this._actions.length; i++ ) {
                this._actions[i].__recursivelySetCreatedStatus(target);
            }
            super.__recursivelySetCreatedStatus(target);
        }

        /**
         * When an action is added, or has its duration, start time, or delay modified, the Sequence duration will be
         * recalculated.
         * @method cc.action.SequenceAction#__updateDuration
         * @override
         * @private
         */
        __updateDuration() {

            if (!this._actions ) {
                return;
            }

            var duration= 0;

            this.__sequentializeStartAndDuration();

            for( var i=0; i<this._actions.length; i++ ) {
                var nd= this._actions[i]._startTime + this._actions[i].getDuration();

                if ( nd>duration ) {
                    duration= nd;
                }
            }

            this._duration = duration;

            super.__updateDuration();
        }

        /**
         * If this sequence has sequential behavior, this method will sequentialize in time all the Actions.
         * @method cc.action.SequenceAction#__sequentializeStartAndDuration
         * @private
         */
        __sequentializeStartAndDuration() {
            var actions= this._actions;
            if ( this._sequential ) {
                for( var i=0; i<actions.length; i++ ) {
                    var curr= actions[ i ];

                    if ( i>0 ) {
                        var prev= actions[ i-1 ];
                        curr._startTime= prev.getDuration() + prev._startTime;
                    } else {
                        curr._startTime= 0;
                    }
                }
            }

        }

        /**
         * Add an Action to the Sequence.
         * <br>
         * Added Actions can be other Sequences.
         * <br>
         * Adding actions triggers upwards recursive duration recalculation.
         * @method cc.action.SequenceAction#addAction
         * @param a {cc.action.Action}
         * @returns {cc.action.SequenceAction}
         */
        addAction(a:Action):Action {
            this._actions.push(a);

            a._chainContext= this._chainContext;
            a._parentSequence= this;

            this.__updateDuration();

            return this;
        }

        /**
         * Do Sequence application process.
         * <br>
         * Do not call directly.
         *
         * @param delta {number} elapsed time between frames.
         * @param time {number} absolute Action time.
         * @param node {cc.node.Node} target node.
         * @private
         * @method cc.action.SequenceAction#__stepImpl
         */
        __stepImpl( delta : number, time: number, node : Node ) {


            if ( this._status!==ActionStates.ENDED ) {

                if (this.__isActionApplicable(time)) {


                    // absolute time for this action relative to its start time.
                    var ntime = (time - this._startTime) % this.getOneRepetitionDuration();

                    for (var i = 0; i < this._actions.length; i++) {
                        var caction= this._actions[i];
                        caction._currentTime = (caction._currentTime + caction._speed*delta) % this.getOneRepetitionDuration();
                        caction.__stepImpl(delta, ntime, node);
                    }

                    super.__actionApply(time, node);

                } else {

                    // apply all sub-actions for the final state.
                    if (time >= this._startTime + this.getDuration()) {

                        this._status = ActionStates.ENDED;

                        // set all sub actions to its final state.
                        for (var i = 0; i < this._actions.length; i++) {
                            this._actions[i]._currentTime = (this._actions[i]._currentTime + delta);
                            this._actions[i].__stepImpl(1/cc.action.TIMEUNITS, time, node);
                        }

                        this.__actionApply(time, node);
                        if (this._onEnd) {
                            this._onEnd(this, node);
                        }
                    }
                }
            }
        }

        /**
         * Internal method to apply children actions to a target Node.
         * @method cc.action.SequenceAction#__actionApply
         * @param time {number} Time relative to the Sequence to apply a child Action at.
         * @param node {cc.node.Node} target Node to apply actions to.
         * @private
         */
        __actionApply( time : number, node : Node ) {

        }

        /**
         * Clone the Action and all its children Actions.
         * @method cc.action.SequenceAction#__cloneImpl
         * @override
         * @inheritDoc
         */
        __cloneImpl():Action {
            var action = new SequenceAction( {sequential : this._sequential} );

            this.__genericCloneProperties(action);
            action._prevOnRepeat= this._prevOnRepeat;
            action._duration= 0;

            for (var i = 0; i < this._actions.length; i++) {
                action.addAction(this._actions[i].clone());
            }

            return action;
        }

        /**
         * Get Sequence's number of actions.
         * @method cc.action.SequenceAction#getNumActions
         * @returns {number}
         */
        getNumActions():number {
            return this._actions.length;
        }

        /**
         * Get action at index.
         * @method cc.action.SequenceAction#getAction
         * @param i {number}
         * @returns {cc.action.Action}
         */
        getAction(i:number):Action {
            return this._actions[i];
        }

        /**
         * @override
         * @inheritDoc
         */
        setReversed( ) : Action {

            super.setReversed();

            this._actions= this._actions.reverse();
            for( var i=0; i<this._actions.length; i++ ) {
                this._actions[i].setReversed();
            }

            this.__sequentializeStartAndDuration();

            return this;
        }

        /**
         * Set the Sequence as Sequence (sequential=true) or Spawn (sequential=false).
         * @method cc.action.SequenceAction#setSequential
         * @param b {boolean}
         */
        setSequential( b:boolean ) {
            this._sequential= b;
        }

        /**
         * Serialize the action current definition.
         * @method cc.action.SequenceAction#getInitializer
         * @returns {cc.action.SequenceActionInitializer}
         */
        getInitializer() : SequenceActionInitializer {
            var init:SequenceActionInitializer= <SequenceActionInitializer>super.getInitializer();

            init.type="SequenceAction";
            init.sequential= this._sequential;

            init.actions= [];

            for( var i=0; i<this._actions.length; i++ ) {
                init.actions.push( this._actions[i].getInitializer() );
            }

            return init;
        }
    }

}
/**
 * License: see license.txt file.
 */



/// <reference path="../node/Node.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="./Action.ts"/>

module cc.action {

    "use strict";

    import        RGBAColor = cc.math.RGBAColor;
    import        Color = cc.math.Color;

    import        Node = cc.node.Node;
    import        Action = cc.action.Action;

    var __updateRGB : RGBAColor = { r : 1, g: 1,  b: 1};

    /**
     * @class cc.action.TintActionInitializer
     * @extends cc.action.ActionInitializer
     * @interface
     * @classdesc
     *
     * TintAction initializer object.
     *
     */
    export interface TintActionInitializer extends ActionInitializer {

        /**
         * Tint initial color
         * @method cc.action.TintActionInitializer#from
         * @type {cc.math.RGBAColor}
         */
        from? : RGBAColor;

        /**
         * Tint final color
         * @method cc.action.TintActionInitializer#to
         * @type {cc.math.RGBAColor}
         */
        to : RGBAColor;
    }

    /**
     * @class cc.action.TintAction
     * @extends cc.action.Action
     * @classdesc
     *
     * This action applies to a Node's color.
     * The tint color is not the actual node's color, it is a multiplicative value for color or texture.
     * Tint components are values between 0 and 1.
     */
    export class TintAction extends Action {

        /**
         * Node's original color.
         * @member cc.action.TintAction#_originalColor
         * @type {cc.math.RGBAColor}
         * @private
         */
        _originalColor : RGBAColor = { r : 1, g: 1, b: 1 };

        /**
         * Action start color.
         * @member cc.action.TintAction#_startColor
         * @type {cc.math.RGBAColor}
         */
        _startColor: RGBAColor = { r : 1, g: 1, b: 1 };

        /**
         * Action end color.
         * @member cc.action.TintAction#_endColor
         * @type {cc.math.RGBAColor}
         */
        _endColor: RGBAColor = { r : 1, g: 1, b: 1 };

        /**
         * Build a new TintAction.
         * @method cc.action.TintAction#constructor
         * @param data {cc.action.TintActionInitializer=}
         */
        constructor( data? : TintActionInitializer )  {
            super();

            if ( data ) {
                this.__createFromInitializer(data);
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.TintAction#__createFromInitializer
         * @param data {cc.action.TintActionInitializer}
         * @private
         */
        __createFromInitializer(initializer?:TintActionInitializer ) {
            super.__createFromInitializer(initializer);
        }

        /**
         * Update target Node's tint color.
         * {@link cc.action.Action#update}
         * @method cc.action.TintAction#update
         * @override
         * @returns {cc.math.RGBAColor} new node's tint values.
         */
        update(delta:number, node:Node):any {

            var r:number = this._startColor.r + delta * (this._endColor.r - this._startColor.r);
            var g:number = this._startColor.g + delta * (this._endColor.g - this._startColor.g);
            var b:number = this._startColor.b + delta * (this._endColor.b - this._startColor.b);

            if (this._relativeAction) {
                r += this._originalColor.r;
                g += this._originalColor.g;
                b += this._originalColor.b;
                if ( this._reversed ) {
                    r-= this._endColor.r;
                    g-= this._endColor.g;
                    b-= this._endColor.b;
                }
            }

            node.setColor(r,g,b);

            // update returned value only if someone is interested on it.
            if ( this._onApply ) {
                __updateRGB.r = r;
                __updateRGB.g = g;
                __updateRGB.b = b;
            }

            return __updateRGB;
        }

        /**
         * Capture before-application Node's tint color.
         * {@link cc.action.Action#solveInitialValues}
         * @method cc.action.TintAction#solveInitialValues
         * @override
         */
        solveInitialValues(node:Node) {
            if (this._relativeAction && !this._fromValuesSet) {
                this._startColor.r= 0;
                this._startColor.g= 0;
                this._startColor.b= 0;
            } else {
                var color= node._color._color;
                this._startColor.r = color[0];
                this._startColor.g = color[1];
                this._startColor.b = color[2];
            }
        }

        /**
         * {@link cc.action.Action#initWithTarget}
         * @method cc.action.TintAction#initWithTarget
         * @override
         */
        initWithTarget(node:Node) {
            var color= node._color._color;
            this._originalColor.r = color[0];
            this._originalColor.g = color[1];
            this._originalColor.b = color[2];

            this.solveInitialValues(node);
        }

        /**
         * {@link cc.action.Action#from}
         * @method cc.action.TintAction#from
         * @override
         */
        from(color:RGBAColor):Action {
            super.from(color);
            this._startColor = {r : color.r, g : color.g, b : color.b};;
            return this;
        }

        /**
         * {@link cc.action.Action#to}
         * @method cc.action.TintAction#to
         * @override
         */
        to(color:RGBAColor):Action {
            this._endColor = {r : color.r, g : color.g, b : color.b};
            return this;
        }

        /**
         * {@link cc.action.Action#__cloneImpl}
         * @method cc.action.TintAction#__cloneImpl
         * @override
         */
        __cloneImpl():Action {

            var copy : TintAction = new TintAction();
            copy.to({r : this._endColor.r, g : this._endColor.g, b : this._endColor.b});

            if (this._fromValuesSet) {
                copy.from( {r : this._startColor.r, g : this._startColor.g, b : this._startColor.b} );
            }

            this.__genericCloneProperties(copy);

            return copy;
        }

        /**
         * Serialize the action current definition.
         * @method cc.action.TintAction#getInitializer
         * @returns {cc.action.TintActionInitializer}
         */
        getInitializer() : TintActionInitializer {
            var init:TintActionInitializer= <TintActionInitializer>super.getInitializer();

            if ( this._fromValuesSet ) {
                init.from = { r: this._startColor.r, g: this._startColor.g, b: this._startColor.b };
            }
            init.to= { r: this._endColor.r, g: this._endColor.g, b: this._endColor.b };
            init.type="TintAction";

            return init;
        }
    }

}

/**
 * License: see license.txt file
 */

/// <reference path="./Action.ts"/>
/// <reference path="../node/sprite/Animation.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Sprite.ts"/>

module cc.action {

    import Action= cc.action.Action;
    import Node= cc.node.Node;
    import Sprite= cc.node.Sprite;
    import SpriteFrame= cc.node.sprite.SpriteFrame;
    import Animation= cc.node.sprite.Animation;

    /**
     * @class cc.action.AnimateActionInitializer
     * @extends ActionInitializer
     * @interface
     * @classdesc
     *
     * AnimateAction initializer object.
     * AnimateAction objects don't have a from and to clauses, but a animation name.
     *
     */
    export interface AnimateActionInitializer extends ActionInitializer {

        /**
         * Animation name.
         * The animation must exist in the AssetManager.
         * @member cc.action.AnimateActionInitializer#animationName
         */
        animationName : string;
    }

    /**
     * @class cc.action.AnimateAction
     * @extends cc.action.Action
     * @classdesc
     * 
     * This action changes Sprite's images in a time basis.
     * <p>
     *     It handles an instance of <code>cc.node.sprite.Animation</code> which is collection of SpriteFrame objects.
     *     Each SpriteFrame references an image and a rect on the image. The action, selects a SpriteFrame on
     *     the Animation based on time keyframing.
     * <p>
     *     Even though an Animation object has control over how many times the animation will be repeated, calling
     *     <code>action.setRepeatTimes(times);</code> or <code>action.setRepeatForever();</code> will override the
     *     Animation value in favor of the newly set one.
     * <p>
     *     Warning. This action expects as its target a @link {cc.node.Sprite} instance and not a @link {cc.node.Node}
     *     like the other actions. The target supplied to this Action must have a <code>setSpriteFrame</code> method
     *     otherwise an undefined error will be thrown.
     *
     *
     * 
     * @see {cc.node.sprite.Animation}
     * 
     */
    export class AnimateAction extends Action {

        /**
         * Original SpriteFrame for the Action target node. 
         * @member cc.action.AnimateAction#_originalSpriteFrame
         * @type {cc.node.sprite.SpriteFrame}
         * @private
         */
        _originalSpriteFrame : SpriteFrame = null;

        /**
         * Animation.
         * @member cc.action.AnimateAction#_animation
         * @type {cc.node.sprite.Animation}
         * @private
         */
        _animation: Animation = null;

        /**
         * Create a new Animate action instance.
         * @method cc.action.AnimateAction#constructor
         * @param data {cc.node.sprite.Animation}
         */
        constructor( data? : AnimateActionInitializer|Animation ) {
            super();

            if(data) {
                if (data instanceof cc.node.sprite.Animation) {
                    this.setAnimation(<Animation>data);
                } else {
                    this.__createFromInitializer(<AnimateActionInitializer>data);
                }
            }
        }

        /**
         * Initialize the action with an initializer Object
         * @method cc.action.AnimateAction#__createFromInitializer
         * @param data {cc.action.AnimateActionInitializer}
         */
        __createFromInitializer(data?:AnimateActionInitializer ) {
            super.__createFromInitializer( data );
            this.setAnimation( cc.plugin.asset.AssetManager.getAnimationById( data.animationName ) );
        }

        /**
         * Set the Animation object instance.
         * @method cc.action.AnimateAction#setAnimation
         * @param data {cc.node.sprite.Animation}
         */
        setAnimation( data : Animation ) : AnimateAction {
            this._animation= data;
            this.setDuration(0);
            this.setRepeatTimes(data._loops);

            return this;
        }

        /**
         * Set the Animate action duration.
         * Will always fallback to set the Animation duration.
         * @method cc.action.AnimateAction##setDuration
         * @param d
         */
        setDuration( d : number ) :AnimateAction {
            if ( this._animation ) {
                super.setDuration( this._animation.getDuration() );
            }

            return this;
        }

        /**
         * Update target Node's SpriteFrame.
         * {@link cc.action.Action#update}
         * @method cc.action.AnimateAction#update
         * @override
         * @return {number} Applied transparency value.
         */
        update(normalizedTime:number, target:Node):any {

            var index:number = ((normalizedTime * this._animation.getSize())|0)%this._animation.getSize();

            if ( index>=0 && index<this._animation.getSize() ) {
                (<Sprite>target).setSpriteFrame(this._animation.getSpriteFrameAtIndex(index));
            }

            return index;
        }

        /**
         * Calculate one repetition duration. Must be explictly set for V3 bacwards compatiblity and
         * a call to Animate with an still loading animation. This is messy and wrong, but must be.
         * @method cc.action.AnimateAction#getOneRepetitionDuration
         * @returns {number}
         */
        getOneRepetitionDuration():number {
            return ( this._animation.getDuration() + this._delayAfterApplication ) * this._speed * cc.action.TIMEUNITS;
        }

        /**
         * This method does nothing.
         * {@link cc.action.Action#solveInitialValues}
         * @method cc.action.AnimateAction#solveInitialValues
         * @override
         */
        solveInitialValues(node:Node) {
        }

        /**
         * Initialize the action with a target node.
         * {@link cc.action.Action#initWithTarget}
         * @method cc.action.AnimateAction#initWithTarget
         * @override
         */
        initWithTarget(node:Node):void {
            this._originalSpriteFrame = (<Sprite>node)._spriteFrame;
            this.solveInitialValues(node);
        }

        /**
         * {@link cc.action.Action#to}
         * @method cc.action.AnimateAction#to
         * @override
         */
        to(a:Animation):AnimateAction {
            this.setAnimation(a);
            return this;
        }

        /**
         * Specific clone implementation function
         * {@link cc.action.Action#__cloneImpl}
         * @method cc.action.AnimateAction#__cloneImpl
         * @override
         * @private
         */
        __cloneImpl():AnimateAction {

            var copy : AnimateAction = new AnimateAction();
            copy.to(this._animation.clone());
            copy._originalSpriteFrame= this._originalSpriteFrame;

            this.__genericCloneProperties(copy);

            return copy;
        }

        /**
         * Stop the Action. If at Action initialization time a originalSpriteFrame was set, and the Animation specifies
         * restore original frame, the original SpriteFrame is set.
         * @param node
         */
        stop( node : Node ) {
            super.stop(node);
            if ( this._animation._restoreOriginalFrame ) {
                (<Sprite>node).setSpriteFrame( this._originalSpriteFrame );
            }
        }

        /**
         * Get current action state initializer object.
         * @method cc.action.AnimateAction#getInitializer
         * @returns {cc.action.AnimateActionInitializer}
         */
        getInitializer() : AnimateActionInitializer {
            var init:AnimateActionInitializer= <AnimateActionInitializer>super.getInitializer();
            init.type="AnimateAction";
            init.animationName= this._animation._name;

            return init;
        }

    }

}
/**
 * License: see license.txt file
 */

/// <reference path="../math/Point.ts"/>
/// <reference path="../math/path/Segment.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>

module cc.action {

    "use strict";

    import Point = cc.math.Point;
    import Vector= cc.math.Vector;
    import Segment= cc.math.path.Segment;

    import Node = cc.node.Node;
    import Action = cc.action.Action;

    var __PathActionUpdateValue : cc.math.Point= { x : 0, y : 0 };

    /**
     * @class cc.action.PathActionInitializer
     * @extends cc.action.ActionInitializer
     * @interface
     * @classdesc
     *
     * PathAction initializer object.
     */
    export interface PathActionInitializer extends ActionInitializer {

        /**
         * Path traversal segment
         * pending: SegmentInitializer
         * @member cc.action.PathActionInitializer#segment
         * @type {cc.math.path.Segment}
         */
        segment : Segment;

    }

    /**
     * @class cc.action.PathAction
     * @extends cc.action.Action
     * @classdesc
     *
     * This action applies to a node's position.
     * The action will traverse a Segment path which can be a simple line or a complex path built out of a collection
     * of Segments and Paths. When traversing through out a simple linear path, prefer MoveAction in favor of this one.
     *
     * <p>
     *     Warning
     * <p>
     * The behavior for relative PathAction (equivalent for example to BezierBy in CocosJS V3 API) is intuitive: the
     * node will add the resulting traversal path to the Node position.
     * For non relative PathActions (for example, the older V3 BezierTo action) is not that clear:
     * + upon a call to <code>initWithNode</code> the Path points will have substracted the current node position and
     *   the first path point will be 0,0 (like in relative actions).
     * + upon a call to <code>update</code> the Path will be solved, and then will have added the node's position
     *   captured during the call to <code>initWithNode</code>.
     *
     * This means, the absolute PathAction will be treated as a relative action, with a modified path.
     *
     * @see cc.action.MoveAction
     */
    export class PathAction extends Action {

        /**
         * Node's original x position.
         * @member cc.action.PathAction#_originalX
         * @type {number}
         * @private
         */
        _originalX : number = 0;

        /**
         * Node's original y position.
         * @member cc.action.PathAction#_originalX
         * @type {number}
         * @private
         */
        _originalY : number = 0;

        /**
         * Segment to traverse.
         * @member cc.action.PathAction#_segment
         * @type {cc.math.path.Segment}
         * @private
         */
        _segment : Segment = null;

        /**
         * Has the path been adjusted.
         * @member cc.action.PathAction#_pathAdjusted
         * @type {boolean}
         * @private
         */
        _pathAdjusted : boolean = false;

        /**
         * Is the target node tangentially rotated while traversing the path ?
         * @member cc.action.PathAction#_adjustTangentialRotation
         * @type {boolean}
         * @private
         */
        _adjustTangentialRotation : boolean = false;

        /**
         * If the target node is tangentially rotated, will rotation angles be -PI..PI or constrained to always show
         * the target vertically not flipped ?
         * @member cc.action.PathAction#_tangentialRotationFullAngle
         * @type {boolean}
         * @private
         */
        _tangentialRotationFullAngle : boolean = false;

        /**
         * Tangential rotation must know whether the animation sprite frames are left-to-right drawn or right-to-left.
         * By default left-to-right is assumed, but in case it is not, this variable must be set to false.
         * @member cc.action.PathAction#_spriteOrientationLR
         * @type {boolean}
         * @private
         */
        _spriteOrientationLR:boolean= true;

        /**
         * Build a new PathAction
         * @method cc.action.PathAction#constructor
         * @param data {cc.action.PathActionInitializer=}
         */
        constructor( data? : PathActionInitializer ) {
            super();

            if (typeof data !== "undefined") {
                this.__createFromInitializer(data);
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.PathAction#__createFromInitializer
         * @param data {cc.action.PathActionInitializer}
         * @private
         */
        __createFromInitializer(data?:PathActionInitializer ) {
            super.__createFromInitializer( data );

            // BUGBUG initializer must have serializable data.
            console.log("Path initializer not yet implemented.");
            this._segment= data.segment;

        }

        /**
         * Update target Node's position.
         * {@link cc.action.Action#update}
         * @method cc.action.PathAction#update
         * @override
         * @return {cc.math.Point} new Node position.
         */
        update(delta:number, node : Node ) : any {

            var pos: Point= this._segment.getValueAt(delta);
            var x = pos.x;
            var xx= x;
            var y = pos.y;
            var yy= y;

            x+= this._originalX;
            y+= this._originalY;

            //if ( this._relativeAction ) {
                if ( this._reversed ) {
                    var fp= this._segment.getEndingPoint();
                    x-= fp.x;
                    y-= fp.y;
                }
            //}

            node.setPosition( x, y );

            __PathActionUpdateValue.x= x;
            __PathActionUpdateValue.y= y;

            if ( (<any>node).setFlippedX && this._adjustTangentialRotation ) {
                var delta2= delta-.001;
                if ( delta2>=0 ) {
                    var pos2 = this._segment.getValueAt(delta2);
                    var angle = Math.PI - Math.atan2(pos2.y - yy, pos2.x - xx);

                    node.rotationAngle = this.__getTangentialAngle(node, xx > pos2.x, angle);
                }
            }

            return __PathActionUpdateValue;
        }

        /**
         * Calculate a tangential angle based on the current path position.
         * It the node is a sprite, it will also flip the node if necessary based on the property:
         * _tangentialRotationFullAngle and _spriteOrientationLR
         *
         * @method cc.action.PathAction#__getTangentialAngle
         * @param node {cc.node.Node|cc.node.Sprite}
         * @param lefttoright {boolean}
         * @param angle {number}
         * @returns {number}
         * @private
         */
        __getTangentialAngle( node:Node, lefttoright:boolean, angle:number ) {

            if ( !this._tangentialRotationFullAngle ) {
                if (this._spriteOrientationLR) {
                    if (lefttoright) {
                        (<any>node).setFlippedX(false);
                    } else {
                        (<any>node).setFlippedX(true);
                        angle += Math.PI;
                    }
                } else {
                    if (lefttoright) {
                        (<any>node).setFlippedX(true);
                        angle -= Math.PI;
                    } else {
                        (<any>node).setFlippedX(false);
                    }
                }
            }

            return angle*180/Math.PI;
        }

        /**
         * Restart the action.
         * @method cc.action.PathAction#restart
         * @returns {cc.action.PathAction}
         */
        restart() : PathAction {
            super.restart();
            this._pathAdjusted= false;
            return this;
        }

        /**
         * Capture before-application Node's property values.
         * {@link cc.action.Action#solveInitialValues}
         * @method cc.action.PathAction#solveInitialValues
         * @override
         */
        solveInitialValues(node : Node) {

            if ( !this.isRelative() && !this._pathAdjusted ) {

                this._pathAdjusted= true;

                // older Cocos2D implelentation expects the following:
                // current node position will be the first control point of the Segment.
                // all other segment points will have node's position substracted.
                var points : Array<Point> = this._segment.getControlPoints();

                this._segment.setDirty(true);
                this._segment.getLength();

                // if tangential rotation is enabled, calculate initial rotation angle.
                if ( this._adjustTangentialRotation && (<any>node).setFlippedX ) {

                    var pos= this._segment.getValueAt(.001);
                    var xx= pos.x;
                    var yy= pos.y;

                    pos = this._segment.getValueAt(0);
                    var angle = Math.PI - Math.atan2(pos.y - yy, pos.x - xx);

                    node.rotationAngle = this.__getTangentialAngle(node, xx > pos.x, angle);
                }


            }
        }

        /**
         * {@link cc.action.Action#initWithTarget}
         * @method cc.action.PathAction#initWithTarget
         * @override
         */
        initWithTarget( node : Node ) {

            if ( this.isRelative() ) {
                this._originalX = node.x;
                this._originalY = node.y;
            } else {
                this._originalX = 0;
                this._originalY = 0;
                var points= this._segment.getControlPoints();
                points[0].x= node.x;
                points[0].y= node.y;
            }

            this.solveInitialValues(node);
        }

        /**
         * {@link cc.action.Action#from}
         * @method cc.action.PathAction#from
         * @override
         */
        from(segment:Segment):Action {
            super.from(segment);
            this._segment= segment;

            return this;
        }

        /**
         * {@link cc.action.Action#to}
         * @method cc.action.PathAction#to
         * @override
         */
        to(point:Point):Action {

            return this;
        }

        /**
         * {@link cc.action.Action#__cloneImpl}
         * @method cc.action.PathAction#__cloneImpl
         * @override
         */
        __cloneImpl() : Action {

            var copy= new PathAction();
            copy._segment= this._segment.clone();

            this.__genericCloneProperties( copy );

            return copy;
        }

        /**
         * Sets tangential rotation and optionally whether the rotation will be of 360 degrees, or the sprite won't be
         * vertically flipped.
         * @method cc.action.PathAction#adjustRotation
         * @param a {boolean} enable tangential rotation.
         * @param fullAngles {boolean=} allow vertically flipping angles or not.
         * @returns {cc.action.PathAction}
         */
        adjustRotation( a:boolean, fullAngles?:boolean ) : PathAction {
            this._adjustTangentialRotation= a;
            this._tangentialRotationFullAngle= typeof fullAngles!=="undefined" ? fullAngles : false;
            return this;
        }

        /**
         * By default, tangential rotation assumes left-to-right sprites.
         * @method cc.action.PathAction#setSpriteOrientationIsLeftToRight
         * @param v {boolean} left-to-right or not.
         * @returns {cc.action.PathAction}
         */
        setSpriteOrientationIsLeftToRight( v:boolean ) : PathAction {
            this._spriteOrientationLR= v;
            return this;
        }

        /**
         * Serialize the action current definition.
         * @method cc.action.PathAction#getInitializer
         * @returns {cc.action.PathActionInitializer}
         */
        getInitializer() : PathActionInitializer {
            var init:PathActionInitializer= <PathActionInitializer>super.getInitializer();

            init.type="PathAction";

            // bugbug pathAction can not serialize path object.

            return init;
        }

    }
}
/**
 * License: see license.txt file
 */

/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="./Action.ts"/>

"use strict";

module cc.action {

    import  Node = cc.node.Node;
    import  Action = cc.action.Action;
    import  Vector= cc.math.Vector;

    var __v0= new Vector();

    /**
     * @class cc.action.JumpActionInitializer
     * @extends cc.action.ActionInitializer
     * @interface
     * @classdesc
     *
     * JumpAction initialization helper object.
     *
     */
    export interface JumpActionInitializer extends ActionInitializer {

        /**
         * Number of jumps
         * @member cc.action.JumpActionInitializer#jumps
         * @type {number}
         */
        jumps : number;

        /**
         * Jump amplitude (max height)
         * @member cc.action.JumpActionInitializer#amplitude
         * @type {number}
         */
        amplitude : number;

        /**
         * Start jump position.
         * @member cc.action.JumpActionInitializer#position
         * @type {cc.math.Vector}
         */
        position : cc.math.Point;

    }

    /**
     * @class cc.action.JumpAction
     * @extends cc.action.Action
     * @classdesc
     *
     * This action applies to a node's position by bouncing up to a given altitude.
     */
    export class JumpAction extends Action {


        /**
         * Node's original x position.
         * @member cc.action.MoveAction#_originalX
         * @type {number}
         * @private
         */
        _originalX : number = 0;

        /**
         * Node's original y position.
         * @member cc.action.JumpAction#_originalX
         * @type {number}
         * @private
         */
        _originalY : number = 0;

        /**
         * Action jump height.
         * @member cc.action.JumpAction#_amplitude
         * @type {number}
         * @private
         */
        _amplitude:number = 80;

        /**
         * Number of jumps to perform.
         * @member cc.action.JumpAction#_jumps
         * @type {number}
         * @private
         */
        _jumps:number = 1;

        _jumpTo : Vector = null;

        /**
         * JumpAction constructor.
         * @method cc.action.JumpAction#constructor
         * @param data {cc.action.JumpActionInitializer=}
         */
        constructor(data?:JumpActionInitializer) {
            super();

            if (data) {
                this.__createFromInitializer(data);
            }
        }

        /**
         * Initialize the action with an initializer object.
         * @method cc.action.JumpAction#__createFromInitializer
         * @param data {cc.action.JumpActionInitializer}
         * @private
         */
        __createFromInitializer(data?:JumpActionInitializer ) {
            super.__createFromInitializer( data );

            if (typeof data !== "undefined") {
                this._amplitude = data.amplitude;
                this._jumps= data.jumps;
                this._jumpTo= new Vector( data.position.x, data.position.y );
            }
        }

        /**
         * Update target Node's position.
         * {@link cc.action.Action#update}
         * @method cc.action.JumpAction#update
         * @override
         * @return {number} Applied transparency value.
         */
        update(delta:number, node:Node):any {

            var frac = delta * this._jumps % 1.0;
            var y = this._amplitude* 4 * frac * (1 - frac);
            y += this._jumpTo.y * delta;

            var x = this._jumpTo.x * delta;

            x += this._originalX;
            y += this._originalY;

            if (this._relativeAction) {
                if (this._reversed) {
                    x -= this._jumpTo.x;
                    y -= this._jumpTo.y;
                }
            }

            node.setPosition( x, y );

            return __v0.set(x,y);
        }

        /**
         * Capture before-application Node's property values.
         * {@link cc.action.Action#solveInitialValues}
         * @method cc.action.JumpAction#solveInitialValues
         * @override
         */
        solveInitialValues(node:Node) {

        }

        /**
         * {@link cc.action.Action#initWithTarget}
         * @method cc.action.JumpAction#initWithTarget
         * @override
         */
        initWithTarget(node:Node):void {
            this._originalX = node.x;
            this._originalY = node.y;

            if (!this._relativeAction) {
                this._jumpTo.x-= this._originalX;
                this._jumpTo.y-= this._originalY;
            }

            this.solveInitialValues(node);
        }

        /**
         * {@link cc.action.Action#__cloneImpl}
         * @method cc.action.JumpAction#__cloneImpl
         * @override
         */
        __cloneImpl():Action {

            var copy:JumpAction = new JumpAction();

            copy._amplitude= this._amplitude;
            copy._jumps= this._jumps;
            copy._jumpTo= new Vector( this._jumpTo.x, this._jumpTo.y );

            this.__genericCloneProperties(copy);

            return copy;
        }

        /**
         * Serialize the action current definition.
         * @method cc.action.JumpAction#getInitializer
         * @returns {cc.action.JumpActionInitializer}
         */
        getInitializer() : JumpActionInitializer {
            var init:JumpActionInitializer= <JumpActionInitializer>super.getInitializer();
            init.type="JumpAction";

            init.jumps= this._jumps;
            init.amplitude= this._amplitude;
            init.position= {
                x : this._jumpTo.x,
                y : this._jumpTo.y
            };

            return init;
        }

    }

}

/**
 * License: see license.txt file.
 */

/// <reference path="./Action.ts"/>
/// <reference path="./SequenceAction.ts"/>
/// <reference path="../node/Node.ts"/>

module cc.action {

    "use strict";

    import Node= cc.node.Node;
    import Action = cc.action.Action;
    import SequenceAction = cc.action.SequenceAction;

    var __index = 0;

    /**
     * @class cc.action.ActionInfo
     * @classdesc
     *
     * This class is the information an <code>ActionManager</code> manages and keeps track of an
     * <code>Action</code> and a <code>Target</code>. It is an internal class for ActionManagers
     * <p>
     * You will have no direct interaction with this class.
     *
     */
    export class ActionInfo {

        _chain:ActionInfo = null;

        constructor(public _actionManager:ActionManager, public _target:Node, public _action?:Action) {
        }

        __action(bh:Action):Action {

            //bh.__setOwner(this._actionManager);
            if (this._chain !== null) {
                bh._chainAction= this._chain._action;
            }
            this._action = bh;
            bh.setTag("tag"+__index++);
            return bh;
        }

        action(action:Action):Action {
            var a : Action= this.__action(action);
            /**
             * When calling this method, there's no explicit action duration set, which solves time chaining whith a previous action.
             * This naive operation, forces chain solve.
             * BUGBUG refactor.
             */
            a.setDelay( a._startTime/cc.action.TIMEUNITS );
            return a;
        }

        step(elapsedTime:number):void {
            this._action.step(elapsedTime, this._target);
        }

        isFinished():boolean {
            return this._action.isFinished();
        }

        pause():void {
            this._action.pause(this._target);
        }

        resume():void {
            this._action.resume();
        }

        setChain(actionInfo:ActionInfo):void {
            this._chain = actionInfo;
        }

        stop() {
            this._action.stop(this._target);
        }
    }

    /**
     * @class cc.action.ActionManager
     * @classdesc
     *
     * An <code>ActionManager</code> object manages and handles Actions ({@link cc.action.Action}).
     * Each <code>Scene</code> has an instance for managing its nodes Actions, and each <code>Director</code> has
     * another instance for handling Scene <code>Transitions</code> ({@link cc.transition.Transition}).
     * <br>
     * The ActionManager has a virtual timeline fed by Directors or Scenes.
     * On average, no direct interaction with this class will happen.
     * <br>
     * <p>
     *     ActionManager instances have a scheduler implementation as an Action of type: SchedulerQueue
     */
    export class ActionManager {

        /**
         * Collection of pairs of Node-Action to execute.
         * @member cc.action.ActionManager#_actionInfos
         * @type {Array<cc.action.ActionInfo>}
         * @private
         */
        _actionInfos:Array<ActionInfo> = [];

        /**
         * In V4 a scheduler is an Action, integrated in the ActionManager.
         * This is the SchedulerQueue implementation.
         * @member cc.action.ActionManager#_scheduler
         * @type {cc.action.SchedulerQueue}
         * @private
         */
        _scheduler:SchedulerQueue= null;

        /**
         * Create a new ActionManager instance object.
         * The developer will surely never interact directly with this object.
         * The why to work with it is by calling Node Action/Scheduler methods.
         * @member cc.action.ActionManager#constructor
         */
        constructor() {
            this._scheduler= new SchedulerQueue();
            this.scheduleActionForNode(null, this._scheduler);
        }

        /**
         * Get the Scheduler instance.
         * @member cc.action.ActionManager#getScheduler
         * @returns {cc.action.SchedulerQueue}
         */
        getScheduler() : SchedulerQueue {
            return this._scheduler;
        }

        /**
         * Associate a target with an action.
         * This method is useful when you pretend to reuse predefined behavior objects.
         * @method cc.action.ActionManager#scheduleActionForNode
         * @param target {cc.node.Node}
         * @param action {cc.action.Action}
         * @returns {ActionInfo}
         */
        scheduleActionForNode(target:any, action:Action):ActionManager {

            var tw = new ActionInfo(this, target);
            tw.action( action );
            this._actionInfos.push(tw);

            return this;
        }

        /**
         * PENDING use binary search.
         * Stop an action for a node with the given tag.
         * @param target {cc.node.Node} node with action.
         * @param tag {string} action tag.
         * @returns {cc.action.ActionManager}
         */
        stopNodeActionByTag( target:any, tag:string ) : ActionManager {

            for( var i=0; i<this._actionInfos.length; i++ ) {
                if ( this._actionInfos[i]._target===target && this._actionInfos[i]._action._tag===tag ) {
                    this._actionInfos[i].stop();
                }
            }

            return this;
        }

        /**
         * Stop the Action objects associated with a target object.
         * @param target
         * @returns {cc.action.ActionManager}
         */
        stopActionsForNode( target:any ) : ActionManager {

            for( var i=0; i<this._actionInfos.length; i++ ) {
                if ( this._actionInfos[i]._target===target ) {
                    this._actionInfos[i].stop();
                }
            }

            return this;
        }

        /**
         * Helper method to build a new ActionInfo with basic information.
         * @method cc.action.ActionManager#__newActionInfo
         * @returns {cc.action.ActionInfo}
         * @private
         */
        __newActionInfo() : ActionInfo {
            var ai = new ActionInfo(this, this._actionInfos[ this._actionInfos.length - 1 ]._target);
            this._actionInfos.push(ai);
            return ai;
        }

        /**
         * Execute all scheduled Actions in this ActionManager.
         * The elapsed time is translated into the desired game time units.
         * @see cc.action.TIMEUNITS
         * @method cc.action.ActionManager#step
         * @param elapsedTime {number} milliseconds.
         */
        step(elapsedTime:number):void {

            //elapsedTime/= cc.action.TIMEUNITS;

            var i;
            var someActionsFinished = false;

            // prevent that added actions from callbacks from messing around.
            var len = this._actionInfos.length;

            for (i = 0; i < len; i++) {
                this._actionInfos[i].step(elapsedTime);
                if (this._actionInfos[i].isFinished()) {
                    someActionsFinished = true;
                }
            }

            if (someActionsFinished) {
                var actions = [];
                for (i = 0; i < this._actionInfos.length; i++) {
                    if (!this._actionInfos[i].isFinished()) {
                        actions.push(this._actionInfos[i]);
                    }
                }
                this._actionInfos = actions;
            }
        }

        /**
         * Pause all Actions.
         * @method cc.action.ActionManager#pauseAll
         */
        pauseAll():void {
            for (var i = 0; i < this._actionInfos.length; i++) {
                this._actionInfos[i].pause();
            }
        }

        /**
         * Resume all Paused Actions.
         * @method cc.action.ActionManager#resumeAll
         */
        resumeAll():void {
            for (var i = 0; i < this._actionInfos.length; i++) {
                this._actionInfos[i].resume();
            }
        }

        /**
         * Get the number of scheduled actions (in any state).
         * @method cc.action.ActionManager#getNumActions
         * @returns {number} number of actions.
         */
        getNumActions() : number {
            return this._actionInfos.length;
        }

        /**
         * Get the number of scheduled actions (in any state) for a target.
         * @method cc.action.ActionManager#getNumActionsForTarget
         * @param target {object} target to check for actions.
         * @returns {number} number of actions for the target.
         */
        getNumActionsForTarget( target : any ) : number {

            var count : number = 0;

            for( var i=0; i<this._actionInfos.length; i++ ) {
                if ( this._actionInfos[i]._target===target ) {
                    count++;
                }
            }

            return count;
        }

        /**
         * Get the number of scheduled actions (in any state).
         * @method cc.action.ActionManager#getNumActionsForNode
         * @param node {object} target to check for actions.
         * @returns {number} number of actions for the Node.
         *
         * @deprecated use getNumActionsForTarget instead.
         */
        getNumActionsForNode( node : any ) : number {
            return this.getNumActionsForTarget(node);
        }
    }
}
/**
 * License: see license.txt file
 */

/// <reference path="./Action.ts"/>
/// <reference path="../node/Node.ts"/>

module cc.action {

    import Action= cc.action.Action;
    import Node= cc.node.Node;

    /**
     * @name SchedulerQueueTaskStatus
     * @memberof cc.action
     * @enum
     * @tsenum
     */
    export enum SchedulerQueueTaskStatus {
        RUNNING = 0,
        PAUSED = 1,
        ENDED = 2
    }

    /**
     * Callback definition for a scheduler task.
     * @memberOf cc.action
     * @callback SchedulerTaskCallback
     * @param delta {number} elsapsed time since last call
     * @param target {object=} target object for which the callback was invoked
     */
    export interface SchedulerTaskCallback {
        (delta:number, target?:any) : void;
    }

    /**
     * @class cc.action.SchedulerQueueTask
     * @classdesc
     *
     * This object represents a Scheduler task.
     * <p>
     * It holds information for an object and a function on that object, as well as time info such as expected
     * repetitions, delay before time count, and the interval between repetitions.
     * <p>
     * It also holds logic for knowing whether the task should be fired or not.
     * A task is fired by calling a function in the context of a target object ie <code>callback.call(target)</code>.
     * <p>
     *     A task without target, will only invoke the callback function.
     */
    export class SchedulerQueueTask {

        /**
         * Target object.
         * @member cc.action.SchedulerQueueTask#_target
         * @type {object}
         * @private
         */
        _target : any;

        /**
         * Fire this callback whenever the elapsed time mets.
         * @member cc.action.SchedulerQueueTask#_callback
         * @type {cc.action.SchedulerTaskCallback}
         * @private
         */
        _callback : any;

        /**
         * wait this milliseconds before account time.
         * @member cc.action.SchedulerQueueTask#_startTime
         * @type {function}
         * @private
         */
        _startTime : number = 0.0;

        /**
         * Custom interval call for a Task
         * @member cc.action.SchedulerQueueTask#_interval
         * @type {number}
         * @private
         */
        _interval : number= 0.0;

        /**
         * Repetition multishot task. Will repeat until paused or cancelled or shot count ends.
         * @member cc.action.SchedulerQueueTask#_repeat
         * @type {number}
         * @private
         */
        _repeat : number;

        /**
         * Time to wait before counting time.
         * @member cc.action.SchedulerQueueTask#_delay
         * @type {number}
         * @private
         */
        _delay : number = 0.0;

        /**
         * Internal task state
         * @member cc.action.SchedulerQueueTask#_status
         * @see {cc.action.SchedulerQueueTaskStatus}
         * @type {cc.action.SchedulerQueueTaskStatus}
         * @private
         */
        _status : SchedulerQueueTaskStatus = null;

        /**
         * Time when the last task repetition was executed.
         * @member cc.action.SchedulerQueueTask#_prevCallbackNotificationTime
         * @type {number}
         * @private
         */
        _prevCallbackNotificationTime : number = 0.0;

        /**
         * Previous task tick time.
         * @member cc.action.SchedulerQueueTask#_prevTime
         * @type {number}
         * @private
         */
        _prevTime : number = 0.0;

        /**
         * Task priority.
         * Tasks are sorted by this value. First in execution will be negative values.
         * @member cc.action.SchedulerQueueTask#_priority
         * @type {number}
         * @private
         */
        _priority : number = 0;

        /**
         * Build a new SchedulerQueueTask instance.
         * @method cc.action.SchedulerQueueTask#constructor
         */
        constructor() {
        }

        /**
         * Execute a task.
         * The execution takes into account whether the task repeats and the interval repetition.
         * @method cc.action.SchedulerQueueTask#step
         * @param currentTime {number} current scheduler time
         * @returns {boolean} whether the task must de deleted.
         */
        step( currentTime:number ) : void {

            // marked as ended or is paused ?, do not execute and delete.
            if ( this._status===SchedulerQueueTaskStatus.ENDED || this._status===SchedulerQueueTaskStatus.PAUSED ) {
                return;
            }

            if ( currentTime>=this._startTime ) {

                // if repeats and interval is not 0 (fire every frame)
                if ( this._repeat>0 && this._interval!==0.0 ) {
                    this.__stepForRepetition( currentTime );
                } else {

                    // either repeats with 0 interval, or is a single shot task
                    this.__doCallback( currentTime - this._prevCallbackNotificationTime );
                    this._prevCallbackNotificationTime= currentTime;

                    // single shot tasks must be recycled
                    if ( !this._repeat ) {
                        this.end();
                    }
                }

            }
        }

        __stepForRepetition( currentTime:number ) {

            // identify whether the task has fired in another interval boundary time
            var shotIndex:number= ((currentTime-this._startTime)/this._interval)|0;
            var prevshotIndex:number= ((this._prevTime-this._startTime)/this._interval)|0;
            if ( shotIndex>prevshotIndex && shotIndex>0 ) {
                //this._prevShotIndex= shotIndex;
                this.__doCallback( currentTime-this._prevCallbackNotificationTime );
                this._prevCallbackNotificationTime= currentTime;
            }
            this._prevTime= currentTime;

            // so the task is expired ?
            if ( currentTime>=this._startTime + this._interval * this._repeat ) {
                // end the task
                this.end();
            }
        }

        /**
         * Invoke the callback.
         * If target is specified for the task<br>
         *    the callback is invoked like: callback.call( target, elapsedTime, target )<br>
         * else<br>
         *    the callback is invoked like: callback(elapsedTime, target);
         *
         * @method cc.action.SchedulerQueueTask#__doCallback
         * @param elapsedTime {number} time between two consecutive task fires.
         * @private
         */
        __doCallback( elapsedTime : number ) {

            if ( null===this._target ) {
                this._callback(elapsedTime, this._target);
            } else {
                this.__doCallCallback(elapsedTime);
            }
        }

        __doCallCallback(elapsedTime:number) {
            this._callback.call( this._target, elapsedTime/cc.action.TIMEUNITS, this._target );
        }

        /**
         * Pause the task. If in this state, the task is not fired.
         * @method cc.action.SchedulerQueueTask#pause
         */
        pause() {
            this._status= SchedulerQueueTaskStatus.PAUSED;
        }

        /**
         * Resume the current task.
         * @method cc.action.SchedulerQueueTask#resume
         */
        resume() {
            this._status= SchedulerQueueTaskStatus.RUNNING;
        }

        /**
         * End the task. Ending turns the task to be elligible for unscheduling and recycling.
         * @method cc.action.SchedulerQueueTask#end
         */
        end() {
            this._status= SchedulerQueueTaskStatus.ENDED;
        }

        /**
         * Whether the task is ended.
         * @method cc.action.SchedulerQueueTask#isEnded
         * @returns {boolean}
         */
        isEnded() : boolean {
            return this._status===SchedulerQueueTaskStatus.ENDED;
        }

        /**
         * Adjust the task time with the Queue time the task is running in.
         * @method cc.action.SchedulerQueueTask#adjustTime
         * @param time {number}
         */
        adjustTime( time:number ) {
            this._startTime= time+ (this._delay||0);
            this._prevCallbackNotificationTime= this._startTime;
        }

    }

    /**
     * @class cc.action.SchedulerQueueUpdateTask
     * @classdesc
     * @extends SchedulerQueueTask
     *
     * This object represents a scheduler task which calls the update method for a given Object, does not have to be
     * a <code>cc.node.Node</code> object.
     *
     * This task type extends a <code>cc.action.SchedulerQueueTask</code> object and only calls the update method,
     * that is, there must be a target object (mandatory at construction) and the callback parameter is omitted.
     * <p>
     * This object makes calling <code>cc.node.Node#scheduleUpdate</code> and then changing the update method safe.
     *
     */
    export class SchedulerQueueUpdateTask extends SchedulerQueueTask {

        constructor() {
            super();
        }

        __doCallCallback(elapsedTime:number) {
            this._target.update.call(this._target, elapsedTime/cc.action.TIMEUNITS, this._target );
        }
    }

    /**
     * @class cc.action.SchedulerQueue
     * @extends cc.action.Action
     * @classdesc
     *
     * <p>
     * A scheduler queue manages a collection of Tasks. The tasks are scheduled for single or multi shot execution and
     * are guaranteed to execute at the closest schedule interval time. Internally, a SchedulerQueue is an Action.
     * <p>
     * A task is composed of a target, a function (which is a function the target object has) and some time data.
     * The scheduler will take no action to control whether the supplied function exists for the target object.
     * <p>
     * If a task already exists with the data supplied to the <code>schedule</code> function the task interval will be
     * updated with the new data supplied.
     * <p>
     * Unscheduled actions are removed in the next tick of execution, but actions that are ended are not executed
     * nonetheless.
     * <p>
     * Tasks scheduled from other task execution, are added and executed in the next tick of execution.
     * <p>
     *     Tasks are kept sorted in ascending priority order. A new task added to the scheduler with a priority
     *     equals to any other task will be added after the existing one.
     *
     * @see {cc.action.Action}
     */
    export class SchedulerQueue extends Action {

        /**
         * The collection of scheduled tasks.
         * @type {Array<cc.action.SchedulerQueueTask>}
         * @member cc.action.SchedulerQueue#_tasks
         * @private
         */
        _tasks : SchedulerQueueTask[] = [];

        /**
         * Build a new SchedulerQueue instance.
         * These objects are managed automatically by scenes and should not need to be built manually.
         * @method cc.action.SchedulerQueue#constructor
         */
        constructor() {
            super();
            this._repeatTimes= Number.MAX_VALUE;
            this._duration= 0;
            this._status= ActionStates.RUNNING;
            this._firstExecution= false;
        }

        /**
         * SchedulerQueue repeats forever by default.
         * @method cc.action.SchedulerAction#setRepeatForever
         * @returns {cc.action.SchedulerQueue}
         */
        setRepeatForever() : Action { return this; }

        /**
         * SchedulerQueue repeats forever by default.
         * @method cc.action.SchedulerAction#setRepeatTimes
         * @param n {number}
         * @returns {cc.action.SchedulerQueue}
         */
        setRepeatTimes( n:number ) : Action { return this; }

        /**
         * SchedulerQueue have 0 duration.
         * @method cc.action.SchedulerAction#setDuration
         * @param d {number}
         * @returns {cc.action.SchedulerQueue}
         */
        setDuration( d : number ) : Action { return this; }

        /**
         * SchedulerQueue can't have time info redefined.
         * @method cc.action.SchedulerAction#timeInfo
         * @param delay {number}
         * @param duration {number}
         * @returns {cc.action.SchedulerQueue}
         */
        timeInfo( delay:number, duration:number ) : Action {return this;}

        /**
         * Create a schedulable task.
         *
         * @method cc.action.SchedulerQueue.createSchedulerTask
         *
         * @param target {object} this object will be supplied as context to the callback function.
         * @param callback {cc.action.SchedulerTaskCallback}
         * @param interval {number} interval time to elapse between scheduler calls. Can't be less than 16ms. If the
         *   value is less, it will be fired at every frame anyway.
         * @param repeat {number} multi-shot task. Should this event repeat over time ?
         * @param delay {boolean} schedule the task and wait this time before firing the event.
         */
        static createSchedulerTask( target:any, callback:SchedulerTaskCallback, interval:number, repeat:number, delay:number ) {

            var task : SchedulerQueueTask = new SchedulerQueueTask();
            task._target= target;
            task._delay= (delay || 0) * cc.action.TIMEUNITS;
            task._callback= callback;
            task._interval= (interval || 0) * cc.action.TIMEUNITS;
            task._repeat = typeof repeat!=="undefined" ? repeat : Number.MAX_VALUE;
            task._status = SchedulerQueueTaskStatus.RUNNING;

            return task;
        }

        /**
         * Create a schedulable task to call the update method on a cc.node.Node instance.
         * This special factory method prevents errors when calling scheduleUpdate and then changing the update function.
         *
         * @param target {object} this object will be supplied as context to the callback function.
         * @param interval {number} interval time to elapse between scheduler calls. Can't be less than 16ms. If the
         *   value is less, it will be fired at every frame anyway.
         * @param repeat {number} multi-shot task. Should this event repeat over time ?
         * @param delay {boolean} schedule the task and wait this time before firing the event.
         */
        static createSchedulerUpdateTask( target:any, interval:number, repeat:number, delay:number ) {

            var task : SchedulerQueueUpdateTask = new SchedulerQueueUpdateTask();
            task._target= target;
            task._delay= (delay || 0) * cc.action.TIMEUNITS;
            task._interval= (interval || 0) * cc.action.TIMEUNITS;
            task._repeat = typeof repeat!=="undefined" ? repeat : Number.MAX_VALUE;
            task._status = SchedulerQueueTaskStatus.RUNNING;

            return task;
        }

        /**
         * Schedule a task.
         * @method cc.action.SchedulerQueue#scheduleTask
         * @param target {Object}
         * @param callback {SchedulerTaskCallback}
         * @param interval {number}
         * @param repeat {number}
         * @param delay {number}
         */
        scheduleTask( target:any, callback?:SchedulerTaskCallback, interval?:number, repeat?:number, delay?:number ) {

            var worktask : SchedulerQueueTask = null;
            var task : SchedulerQueueTask = null;

            // large form
            if ( arguments.length>1 ) {
                worktask= SchedulerQueue.createSchedulerTask(target, callback, interval, repeat, delay );
            } else {
                worktask = <SchedulerQueueTask>target;
            }

            task= this.__findTask( worktask._target, worktask._callback );
            if ( null===task ) {
                worktask.adjustTime( this._currentTime );
                this.insertTask( worktask );
            } else {
                task._interval= worktask._interval;
                // in case it is paused.
                task._status =  SchedulerQueueTaskStatus.RUNNING;
            }

        }

        /**
         * Insert a task in priority order.
         * It uses binary search to find out the correct position.
         * If already exists a task with the same priority, the new task will be inserted after the existing ones.
         * @param task {cc.node.SchedulerQueueTask}
         */
        insertTask( task : SchedulerQueueTask ) {

            // trivial case: empty queue or task priority >= last task in queue's priority
            if ( this._tasks.length===0 || task._priority>=this._tasks[ this._tasks.length-1 ]._priority ) {
                this._tasks.push( task );
                return;
            }

            // binay insert
            var left=0;
            var right= this._tasks.length-1;

            while( left!==right ) {

                var middle= (right+left)>>1;
                var midtask= this._tasks[middle];

                if ( task._priority > midtask._priority ) {
                    left= middle+1;
                } else if ( task._priority < midtask._priority ) {
                    right= middle-1;
                } else {
                    left+= 1;
                }
            }

            // insert at left position.
            this._tasks.splice( left, 0, task );

        }

        /**
         * Find whether a task composed of a given object and callback already exists.
         * @method cc.action.SchedulerQueue#__findTask
         *
         * @param target {object}
         * @param method {cc.action.SchedulerTaskCallback}
         * @returns {*}
         * @private
         */
        __findTask( target:any, method:SchedulerTaskCallback ) : SchedulerQueueTask {

            for( var i=0; i<this._tasks.length; i++ ) {
                var task= this._tasks[i];
                if ( task._target===target && task._callback===method ) {
                    return task;
                }
            }

            return null;
        }

        /**
         * Pause all tasks for a given target.
         *
         * @method cc.action.SchedulerQueue#pauseTarget
         * @param target {object}
         */
        pauseTarget( target:any ) {

            for( var i=0; i<this._tasks.length; i++ ) {
                var task= this._tasks[i];
                if ( task._target===target ) {
                    task.pause();
                }
            }
        }

        /**
         * Pause a concrete task for a target.
         * @method cc.action.SchedulerQueue#pauseTask
         * @param target {object}
         * @param callback {cc.action.SchedulerTaskCallback}
         */
        pauseTask( target:any, callback:SchedulerTaskCallback ) {

            for( var i=0; i<this._tasks.length; i++ ) {
                var task= this._tasks[i];
                if ( task._target===target && task._callback===callback ) {
                    task.pause();
                    return;
                }
            }
        }

        /**
         * End a task for a target.
         * @param target {object}
         * @param callback {cc.action.SchedulerTaskCallback}
         */
        endTask( target:any, callback:SchedulerTaskCallback ) {

            for( var i=0; i<this._tasks.length; i++ ) {
                var task= this._tasks[i];
                if ( task._target===target && task._callback===callback ) {
                    task.end();
                    return;
                }
            }
        }

        /**
         * Resume a paused task for a target. If it was not paused, nothing happens.
         * @method cc.action.SchedulerQueue#resumeTask
         * @param target {object}
         * @param callback {cc.action.SchedulerTaskCallback}
         */
        resumeTask( target:any, callback:SchedulerTaskCallback ) {

            for( var i=0; i<this._tasks.length; i++ ) {
                var task= this._tasks[i];
                if ( task._target===target && task._callback===callback ) {
                    task.resume();
                    return;
                }
            }
        }

        /**
         * Resume all tasks for a target.
         * @method cc.action.SchedulerQueue#resumeTarget
         * @param target {object}
         */
        resumeTarget( target:any ) {

            for( var i=0; i<this._tasks.length; i++ ) {
                var task= this._tasks[i];
                if ( task._target===target ) {
                    task.resume();
                }
            }
        }

        /**
         * Remove all tasks for a target.
         * @method cc.action.SchedulerQueue#unscheduleAllCallbacks
         * @param target {object}
         */
        unscheduleAllCallbacks(target:any) {

            for( var i=0; i<this._tasks.length; i++ ) {
                var task= this._tasks[i];
                if ( task._target===target ) {
                    task.end();
                }
            }
        }

        /**
         * Unschedule a concrete task for a target.
         * Unschedule means set it as ended, w/o further execution.
         * @method cc.action.SchedulerQueue#unscheduleCallbackForTarget
         * @param target {object}
         * @param callback {cc.action.SchedulerTaskCallback}
         */
        unscheduleCallbackForTarget( target:any, callback:SchedulerTaskCallback ) {
            //this.pauseTask(target,callback);
            this.endTask(target,callback);
        }

        /**
         * Action update.
         * Traverse the task list and execute events.
         * @method cc.action.SchedulerQueue#update
         * @param normalizedTime {number} normalized action time.
         * @param target {cc.node.Node} node object for which the action executes. For Scheduler queues, no target exists.
         */
        update( normalizedTime : number, target : Node ) {

            // prevent that tasks schedules from a firing scheduled task be checked during this tick.
            var len= this._tasks.length;
            for( var i=0; i<len; i++ ) {
                this._tasks[i].step( this._currentTime );
            }

            // we can not make sure that the only marked for deletion tasks will be the ones that have been
            // time expired during this tick.
            // for example, a callback action could request unscheduling for other tasks.
            // so the whole list must be traversed and checked for ENDED (marked for deletion) tasks.
            for( var i=len-1; i>=0; i-=1 ) {
                if ( this._tasks[i].isEnded() ) {
                    this._tasks.splice( i, 1 );
                }
            }
        }
    }
}
/**
 * License: see license.txt file
 */

/// <reference path="../node/Node.ts"/>
/// <reference path="./MoveAction.ts"/>
/// <reference path="./JumpAction.ts"/>
/// <reference path="./RotateAction.ts"/>
/// <reference path="./PropertyAction.ts"/>
/// <reference path="./AlphaAction.ts"/>
/// <reference path="./TintAction.ts"/>
/// <reference path="./ScaleAction.ts"/>
/// <reference path="./SequenceAction.ts"/>
/// <reference path="./PathAction.ts"/>

module cc.action {

    /**
     * This function parses an Action based on an initializer object.
     * Initializer objects are just JSON objects which could got from a call to action.getInitializer().
     * @name ParseAction
     * @memberOf cc.action
     * @param actionDef {cc.action.ActionInitializer}
     * @returns {cc.action.Action}
     */
    export function ParseAction( actionDef:ActionInitializer ) : Action {

        if ( cc.action[actionDef.type]!=="undefined" ) {
            var action:Action= new cc.action[actionDef.type]( );
            action.__createFromInitializer(actionDef);
            return action;
        }

        console.log("Error, action initializer w/o type.");
        console.log(JSON.stringify(actionDef, null, 2 ) );

        return null;
    }

    /**
     * @class cc.action.ActionChainContext
     * @classdesc
     *
     * An ActionChainContext is an object whose only purpose is offer a chainable Action construction API.
     * It keeps track of the last created action and its type. It is a fachade to the last created action for a Node
     * so that calling the chain context methods will forward calls to such Action.
     * It is expected to execute in the context of a cc.node.Node object only.
     * For example, this object allows for an api call like this:
     *
     * <code>
     *     actionSequence().
     *        setRepeatForever().
     *        onEnd( function() {
     *            console.log("end");
     *        }).
     *        actionRotate().
     *            to(180).
     *            setRelative(true).
     *            setDuration(1).
     *        actionScale().
     *            to( {x:0, y:1 }).
     *            setRelative(true).
     *            setDuration(1.5).
     *        actionScale().
     *            to( {x:1, y:1}).
     *            setRelative(true).
     *            setDuration(1.5).
     *        actionTint().
     *            to( {r: -.5, g: -.5, b: -.5 } ).
     *            setRelative(true).
     *            setDuration( 2).
     *    endSequence();
     * </code>
     *
     */
    export class ActionChainContext {

        /**
         * When a call to .then() is made, this property keeps track of the previously built action.
         * @member cc.action.ActionChainContext#_chainAction
         * @type {cc.action.Action}
         * @private
         */
        _chainAction : Action = null;

        /**
         * The current action the chain context methods will forward calls to.
         * @member cc.action.ActionChainContext#_currentAction
         * @type {cc.action.Action}
         * @private
         */
        _currentAction: Action = null;

        /**
         * Stack which tracks how many actionSequence calls have been done.
         * @member cc.action.ActionChainContext#_sequenceStack
         * @type {Array<cc.action.SequenceAction>}
         * @private
         */
        _sequenceStack : SequenceAction[] = [];

        /**
         * Last SequenceAction tracked.
         * @member cc.action.ActionChainContext#_currentSequence
         * @type {cc.action.SequenceAction}
         * @private
         */
        _currentSequence : SequenceAction = null;

        /**
         * Node for which the chain actions are being performed.
         * @name _target
         * @memberof cc.action.ActionChainContext
         * @type {cc.node.Node}
         */

        /**
         * Create a new ActionChainContext object instance.
         * @method cc.action.ActionChainContext#constructor
         * @constructor
         * @param _target {cc.node.Node}
         */
        constructor( public _target:cc.node.Node ) {

        }

        /**
         * Create an Action from a constructor function.
         * If a new SequenceAction is to be build, it will be pushed to the SequenceAction stack.
         * The resulting action will be set as the current chain context Action so that all context calls will be forwarded
         * to this action.
         * @method cc.action.ActionChainContext#__action
         * @param ctor {object} a constructor function
         * @returns {cc.action.ActionChainContext}
         * @private
         */
        __action( ctor ) {

            this.action(<Action>new ctor());

            if ( ctor===cc.action.SequenceAction ) {
                this._sequenceStack.push( <SequenceAction>this._currentAction );
                this._currentSequence= <SequenceAction>this._currentAction;
            }

            return this;
        }

        /**
         * Chain a complete action or an action built form an ActionInitializer object.
         * @method cc.action.ActionChainContext#action
         * @param _currentAction {cc.action.Action|cc.action.ActionInitializer}
         * @returns {cc.action.ActionChainContext}
         */
        action( _currentAction:Action|ActionInitializer ) : ActionChainContext {

            var currentAction:Action;

            if ( _currentAction instanceof cc.action.Action ) {
                currentAction= <Action>_currentAction;
            } else {
                currentAction= cc.action.ParseAction( <ActionInitializer>_currentAction );
            }

            if ( this._currentSequence ) {
                this._currentSequence.addAction(currentAction);
            } else {
                this._target.runAction( currentAction );
            }

            if ( this._chainAction ) {
                currentAction._chainAction= this._chainAction;
                this._chainAction= null;
            }

            this._currentAction= currentAction;

            currentAction.__updateDuration();

            return this;
        }

        /**
         * Start chaining for a new PathAction.
         * @method cc.action.ActionChainContext#actionPath
         * @returns {cc.action.ActionChainContext}
         */
        actionPath() : ActionChainContext {
            return this.__action(cc.action.PathAction);
        }

        /**
         * Start chaining for a new MoveAction.
         * @method cc.action.ActionChainContext#actionMove
         * @returns {cc.action.ActionChainContext}
         */
        actionMove() : ActionChainContext {
            return this.__action(cc.action.MoveAction);
        }

        /**
         * Start chaining for a new RotateAction.
         * @method cc.action.ActionChainContext#actionRotate
         * @returns {cc.action.ActionChainContext}
         */
        actionRotate() : ActionChainContext {
            return this.__action(cc.action.RotateAction);
        }

        /**
         * Start chaining for a new PropertyAction.
         * @method cc.action.ActionChainContext#actionProperty
         * @returns {cc.action.ActionChainContext}
         */
        actionProperty() : ActionChainContext {
            return this.__action(cc.action.PropertyAction);
        }

        /**
         * Start chaining for a new AlphaAction.
         * @method cc.action.ActionChainContext#actionAlpha
         * @returns {cc.action.ActionChainContext}
         */
        actionAlpha() : ActionChainContext {
            return this.__action(cc.action.AlphaAction);
        }

        /**
         * Start chaining for a new TintAction.
         * @method cc.action.ActionChainContext#actionTint
         * @returns {cc.action.ActionChainContext}
         */
        actionTint() : ActionChainContext {
            return this.__action(cc.action.TintAction);
        }

        /**
         * Start chaining for a new ScaleAction.
         * @method cc.action.ActionChainContext#actionScale
         * @returns {cc.action.ActionChainContext}
         */
        actionScale() : ActionChainContext {
            return this.__action(cc.action.ScaleAction);
        }

        /**
         * Start chaining for a new SequenceAction.
         * @method cc.action.ActionChainContext#actionSequence
         * @returns {cc.action.ActionChainContext}
         */
        actionSequence() : ActionChainContext {
            return this.__action(cc.action.SequenceAction);
        }


        /**
         * End a Sequence Action context.
         * This will pop the latest Sequence from the stack.
         * If the stack gets empty, actions will be added in the context of the Target node, and not the sequence.
         * @method cc.action.ActionChainContext#endSequence
         * @returns {cc.action.ActionChainContext}
         */
        endSequence() : ActionChainContext {

            if ( this._sequenceStack.length ) {
                this._sequenceStack.pop();
                if ( this._sequenceStack.length ) {
                    this._currentSequence = this._sequenceStack[ this._sequenceStack.length-1 ];
                } else {
                    this._currentSequence = null;
                }

                this._currentAction= this._currentSequence;
            }

            return this;
        }

        /**
         * Set action 'from' value for the current action.
         * @method cc.action.ActionChainContext#from
         * @param obj {object} the value to set for 'from' action property.
         * @returns {cc.action.ActionChainContext}
         */
        from( obj:any ) : ActionChainContext {
            if ( this._currentAction ) {
                this._currentAction.from(obj);
            }
            return this;
        }

        /**
         * Set action 'to' value for the current action.
         * @method cc.action.ActionChainContext#from
         * @param obj {object} the value to set for 'from' action property.
         * @returns {cc.action.ActionChainContext}
         */
        to( obj:any ) : ActionChainContext {
            if ( this._currentAction ) {
                this._currentAction.to(obj);
            }
            return this;
        }

        /**
         * Set action interpolator value for the current action.
         * @method cc.action.ActionChainContext#setInterpolator
         * @param i {cc.action.TimeInterpolator} a interpolator (easing function).
         * @returns {cc.action.ActionChainContext}
         */
        setInterpolator( i:cc.action.TimeInterpolator ) : ActionChainContext {
            if ( this._currentAction ) {
                this._currentAction.setInterpolator(i);
            }
            return this;
        }

        /**
         * Set action as relative.
         * @method cc.action.ActionChainContext#setRelative
         * @param b {boolean}
         * @returns {cc.action.ActionChainContext}
         */
        setRelative( b:boolean ) : ActionChainContext {
            if ( this._currentAction ) {
                this._currentAction.setRelative(b);
            }
            return this;
        }

        /**
         * Set action duration.
         * @method cc.action.ActionChainContext#setDuration
         * @param d {number}
         * @returns {cc.action.ActionChainContext}
         */
        setDuration( d:number ) : ActionChainContext {
            if ( this._currentAction ) {
                this._currentAction.setDuration(d);
            }
            return this;
        }

        /**
         * Set action repetition forever.
         * @method cc.action.ActionChainContext#setRepeatForever
         * @param obj {cc.action.RepeatTimesOptions=} some repetition attributes.
         * @returns {cc.action.ActionChainContext}
         */
        setRepeatForever(obj?:cc.action.RepeatTimesOptions) : ActionChainContext {
            if ( this._currentAction ) {
                this._currentAction.setRepeatForever(obj);
            }
            return this;
        }

        /**
         * Set action repetition times.
         * @method cc.action.ActionChainContext#setRepeatTimes
         * @param n {number} repetition count
         * @returns {cc.action.ActionChainContext}
         */
        setRepeatTimes(n:number) : ActionChainContext {
            if ( this._currentAction ) {
                this._currentAction.setRepeatTimes(n);
            }
            return this;
        }

        /**
         * Chain two actions. After a call to then, any of the actionXXX methods should be called. The newly
         * created action will be chained with the current one. Chain means that will start when the preivous ends.
         * @method cc.action.ActionChainContext#then
         * @returns {cc.action.ActionChainContext}
         */
        then() : ActionChainContext {
            this._chainAction= this._currentAction;
            return this;
        }

        /**
         * Set duration and interpolator into in one call.
         * @method cc.action.ActionChainContext#timeInfo
         * @param delay {number} delay before application
         * @param duration {number} action duration in time units.
         * @param interpolator {cc.action.TimeInterpolator=} optional interpolator
         * @returns {cc.action.ActionChainContext}
         */
        timeInfo(delay:number, duration:number, interpolator?:cc.action.TimeInterpolator) : ActionChainContext {
            this._currentAction.timeInfo( delay, duration, interpolator );

            return this;
        }

        /**
         * Set action onEnd callback.
         * @method cc.action.ActionChainContext#onEnd
         * @param f {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
         * @returns {cc.action.ActionChainContext}
         */
        onEnd( f:ActionCallbackStartOrEndOrPauseOrResumeCallback ) {
            if ( this._currentAction ) {
                this._currentAction.onEnd(f);
            }
            return this;
        }

        /**
         * Set action onStart callback.
         * @method cc.action.ActionChainContext#onStart
         * @param f {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
         * @returns {cc.action.ActionChainContext}
         */
        onStart( f:ActionCallbackStartOrEndOrPauseOrResumeCallback ) {
            if ( this._currentAction ) {
                this._currentAction.onStart(f);
            }
            return this;
        }

        /**
         * Set action onRepeat callback.
         * @method cc.action.ActionChainContext#onRepeat
         * @param f {cc.action.ActionCallbackRepeatCallback}
         * @returns {cc.action.ActionChainContext}
         */
        onRepeat( f:ActionCallbackRepeatCallback ) {
            if ( this._currentAction ) {
                this._currentAction.onRepeat(f);
            }
            return this;
        }

        /**
         * Set action onPause callback.
         * @method cc.action.ActionChainContext#onPause
         * @param f {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
         * @returns {cc.action.ActionChainContext}
         */
        onPause( f:ActionCallbackStartOrEndOrPauseOrResumeCallback ) {
            if ( this._currentAction ) {
                this._currentAction.onPause(f);
            }
            return this;
        }

        /**
         * Set action onResume callback.
         * @method cc.action.ActionChainContext#onResume
         * @param f {cc.action.ActionCallbackStartOrEndOrPauseOrResumeCallback}
         * @returns {cc.action.ActionChainContext}
         */
        onResume( f:ActionCallbackStartOrEndOrPauseOrResumeCallback ) {
            if ( this._currentAction ) {
                this._currentAction.onResume(f);
            }
            return this;
        }

        /**
         * Set action onApply callback.
         * @method cc.action.ActionChainContext#onApply
         * @param f {cc.action.ActionCallbackApplicationCallback}
         * @returns {cc.action.ActionChainContext}
         */
        onApply( f:ActionCallbackApplicationCallback) {
            if ( this._currentAction ) {
                this._currentAction.onApply(f);
            }
            return this;
        }

        /**
         * If the current action is a sequence, set the Sequence as sequential or spawn.
         * @method cc.action.ActionChainContext#setSequential
         * @param b {boolean}
         * @returns {cc.action.ActionChainContext}
         */
        setSequential( b:boolean ) {
            if ( (<any>this._currentAction).setSequential ) {
                (<any>this._currentAction).setSequential(b);
            }

            return this;
        }
    }

}
/**
 * License: see license.txt file
 */

module cc.Performance {

    function __startPerformance() : number {
        return performance.now();
    }

    function __startTime() : number {
        return new Date().getTime();
    }

    var _units:number = typeof performance!=="undefined" ? 1000 : 1;
    var __start:()=>number = typeof performance!=="undefined" ? __startPerformance : __startTime;

    var MEASURE_CACHE_SIZE= 500;

    export class Measure {

        _prevValues:number[]= [];
        _accumulatedValue:number= 0;

        _name:string= null;
        _value:number=0;
        _start:number= 0;

        constructor( name ) {
            this._name= name;
        }

        increment() {
            this._value++;
        }

        clear() {
            this._start= 0;
            this._value= 0;
            this._accumulatedValue= 0;
        }

        clearCache() {
            this._prevValues= [];
        }

        setValue( v:number ) {
            this._value= v;
            this._accumulatedValue+= v;
        }

        getValue() {
            return this._value;
        }

        start() {
            this._start= __start();
        }

        end() {
            this._value+= __start()-this._start
        }

        save() {
            if ( this._prevValues.length>MEASURE_CACHE_SIZE ) {
                this._prevValues.shift();
            }
            this._prevValues.push( this.getValue() );
        }
    }

    export class TimeMeasure extends Measure {

        constructor( name ) {
            super(name);
        }

        getValue() {
            return this._value/_units;
        }
    }

    export class Performance {

        _measures: {[id:string]:Measure} = {
            draws : new Measure("draws"),
            loop  : new TimeMeasure("loop")
        };

        constructor() {

        }

        start( id:string ) {
            this._measures[id].start();
        }

        end(id:string) {
            this._measures[id].end();
        }

        increment(id:string) {
            this._measures[id].increment();
        }

        setValue(id:string, v:number) {
            this._measures[id].setValue(v);
        }

        clear() {
            for( var id in this._measures ) {
                if ( this._measures.hasOwnProperty(id) ) {
                    this._measures[id].clear();
                }
            }
        }

        clearCache() {
            for( var id in this._measures ) {
                if ( this._measures.hasOwnProperty(id) ) {
                    this._measures[id].clearCache();
                }
            }
        }

        save() {
            for( var id in this._measures ) {
                if ( this._measures.hasOwnProperty(id) ) {
                    this._measures[id].save();
                }
            }
        }

    }
}
/**
 * License: see license.txt file.
 */


/// <reference path="../action/Action.ts"/>
/// <reference path="../action/SchedulerQueue.ts"/>
/// <reference path="./Node.ts"/>
/// <reference path="../action/ActionManager.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../input/InputManager.ts"/>

module cc.node {

    "use strict";

    import Node = cc.node.Node;
    import Action = cc.action.Action;
    import ActionManager = cc.action.ActionManager;
    import RenderingContext = cc.render.RenderingContext;
    import SchedulerQueue= cc.action.SchedulerQueue;
    import SchedulerQueueTask= cc.action.SchedulerQueueTask;
    import SchedulerTaskCallback= cc.action.SchedulerTaskCallback;

    /**
     * Callback invoked when a Transition Enter/Exit/DidFinishExit/DidStartEnter
     * @memberOf cc.node
     * @callback CallbackSceneTransition
     * @param scene {cc.node.Scene} This callback will be called when a transition ends.
     */
    export interface CallbackSceneTransition {
        (scene : Scene) : void;
    }

    /**
     * @class cc.node.Scene
     * @extends cc.node.Node
     * @classdesc
     *
     * Scenes are specialized Nodes useful for separating in-game functional pieces.
     * For example, a Scene can be the game menu, another scene can be the game and another scene the results window.
     *
     * <li>At any given moment, only one scene can be running.
     *
     * <li>A Scene can not contain other Scenes, or any Director instance.
     * <li>The size of the scene will by default be the same as the Director, and hence, equal to the Canvas size.
     *
     * <li>A Scene manages all the Actions of all the Node's it contains.
     * <li>A scene manages chronometers/events independently to any other scene.
     *
     * <li>Every Node that hierarchically belongs to this Scene will have a reference to the Scene. This reference will be
     * set when the <code>Director</code> the Scene is running in calls <code>onEnter</code> on the scene.
     *
     * <li>There no limitation on how many Scenes can be in a game.
     *
     * <li>Scenes have no parent Node. This means that a call to <code>enumerateChildren</code> will take a Scene as the
     * root search point.
     * <li>An Scene logical parent is a Director object. Scenes have a Director instance in _parent variable.
     *
     * <p>
     *     Scenes are the source point for input routing to the nodes it contains. It contains two members:
     *     <ul>
     *      <li>_sceneGraphPriorityTree: for nodes sorted in scene graph priority. This priority is the natural
     *       way nodes are organized.
     *      <li>_priorityTree: artificial priority were nodes are sorted by value. lower value means higher priority.
     *     </ul>
     *     Each time a scene is set as running by a director, the InputSystem sets that scene as input target.
     *
     * <p>
     *     One important thing about scenes is that they contain an ActionManager which at the same time, manages a
     *     Scheduler.
     *     Scheduling actions or tasks for a Node is as straighforward as calling <code>runAction</code> or
     *     <code>schedule|scheduleUpdate</code>.
     *     These methods expect a time parameter for scheduling, which by default is in seconds. The engine will internally
     *     treat all time measures in milliseconds (makes sense since the animation loop is scheduled every 16ms approx),
     *     but the developer can instrument to set time measurements in seconds (default) by calling
     *     <code>cc.action.setTimeReferenceInSeconds</code> or milliseconds <code>setTimeReferenceInMillis</code>.
     *     Callback notifications with a time parameter will be in the developer desired time units.
     *
     */
    export class Scene extends Node {

        /**
         * Node's ActionManager.
         * @member cc.node.Scene#_actionManager
         * @type {cc.action.ActionManager}
         * @private
         */
        _actionManager : ActionManager = new ActionManager();

        /**
         * Callback reference for onEnter event.
         * @member cc.node.Scene#_onEnter
         * @type {cc.node.CallbackSceneTransition}
         * @private
         */
        _onEnter : CallbackSceneTransition = null;

        /**
         * Callback reference for onExit event.
         * @member cc.node.Scene#_onExit
         * @type {cc.node.CallbackSceneTransition}
         * @private
         */
        _onExit : CallbackSceneTransition = null;

        /**
         * Callback reference for enter transition end event.
         * @member cc.node.Scene#_onEnterTransitionDidFinish
         * @type {cc.node.CallbackSceneTransition}
         * @private
         */
        _onEnterTransitionDidFinish : CallbackSceneTransition = null;

        /**
         * Callback reference for exit transition start event.
         * @member cc.node.Scene#_onExitTransitionDidStart
         * @type {cc.node.CallbackSceneTransition}
         * @private
         */
        _onExitTransitionDidStart : CallbackSceneTransition = null;

        _scheduler : SchedulerQueue = null;

        _sceneGraphPriorityTree : cc.input.SceneGraphInputTreeNode = null;
        _priorityTree : cc.input.PriorityInputNode[] = null;

        /**
         * Create a new Scene instance.
         * @method cc.node.Scene#constructor
         */
        constructor() {
            super();

            this._scheduler= this._actionManager.getScheduler();

            this._sceneGraphPriorityTree= new cc.input.SceneGraphInputTreeNode(this);
            this._priorityTree= [];

            this.setGlobalAlpha(true);

            this.setPositionAnchor(0,0);
        }

        enableEvents( enable:boolean ) : Scene {
            super.enableEvents(enable);
            this.enableEventsForNode(this);
            return this;
        }

        enablePriorityEvents( enable:boolean, priority:number ) : Scene {
            super.enablePriorityEvents(enable,priority);
            this.enableEventsForNode( this );
            return this;
        }

        /**
         * Enable events in scene-graph order for a node.
         * If the node is not attached to this scene, nothing will happen.
         * @method cc.node.Scene#enableEvents
         * @param node {cc.node.Node}
         */
        enableEventsForNode( node:Node ) : Scene {
            this._sceneGraphPriorityTree.insert( node.getPathToScene() );
            return this;
        }

        getPathToScene() : Node[] {
            return [this];
        }

        /**
         * Enable events in priority order for a node.
         * The priority is something external to the Node,
         * @method cc.node.Scene#enablePriorityEvents
         * @param node {cc.node.Node}
         */
        enablePriorityEventsForNode( node:Node ) : Scene {

            var pin:cc.input.PriorityInputNode;

            var pinIndex= -1;
            // Pending: speed search
            for( var i=0; i<this._priorityTree.length; i++ ) {
                if ( this._priorityTree[i].node === node) {
                    pinIndex= i;
                    break;
                }
            }

            if ( pinIndex!==-1 ) {
                pin= this._priorityTree[ pinIndex ];
                if ( pin.priority===node.getInputPriority() ) {
                    // node added with the same priority
                    return;
                }
            } else {
                // node does not exist. create descriptor, and insert.
                this._priorityTree.push(new cc.input.PriorityInputNode(node, node.getInputPriority() ) );
            }

            this._priorityTree.sort( function( n0:cc.input.PriorityInputNode, n1:cc.input.PriorityInputNode ) : number {

                if ( n0.priority<n1.priority ) {
                    return -1;
                } else if ( n0.priority>n1.priority ) {
                    return 1;
                }

                return 0;
            });

            return this;
        }

        findNodeAtScreenPoint( p:cc.math.Vector, callback?:(node:Node)=>boolean ) : Node {

            var pp= new cc.math.Vector();
            pp.set( p.x, p.y );

            // first, check on priority input
            for( var i=0; i<this._priorityTree.length; i++ ) {
                var node:Node= this._priorityTree[i].node;

                p.set( pp.x, pp.y );
                if ( node.isScreenPointInNode( p ) ) {
                    if (callback) {
                        if (!callback(node)) {
                            return node;
                        }
                    } else {
                        return node;
                    }
                }
            }

            // now, for scene-graph priority.
            p.set( pp.x, pp.y );
            return this._sceneGraphPriorityTree.findNodeAtScreenPoint( p, callback );
        }

        /**
         * Increment scene's timeline.
         * This time is local to this scene, and independent to other Scene's time.
         * This local time is handled by the Scene's ActionManager, which translate the delta milliseconds into
         * the desired game time measurement unit, which are seconds by default.
         * @method cc.node.Scene#step
         * @param delta {number} elapsed time in milliseconds.
         * @param ctx {cc.render.RenderingContext} where node's will render.
         */
        step( delta : number, ctx : RenderingContext ) : void {

            // allow for this scene's nodes actions to run.
            this._actionManager.step( delta );

            // draw scene and its children.
            this.visit( ctx );
        }

        /**
         * Register Scene onEnter callback.
         * @method cc.node.Scene#onEnter
         * @param c {cc.node.CallbackSceneTransition}
         * @returns {cc.node.Scene}
         */
        onEnter( c : CallbackSceneTransition ) : Scene {
            this._onEnter= c;
            return this;
        }

        /**
         * Register Scene onExit callback.
         * @method cc.node.Scene#onExit
         * @param c {cc.node.CallbackSceneTransition}
         * @returns {cc.node.Scene}
         */
        onExit( c : CallbackSceneTransition ) : Scene {
            this._onExit= c;
            return this;
        }

        /**
         * Register onExitTransitionStart callback. Called when scenes are switched by Transition objects.
         * @method cc.node.Scene#onExitTransitionDidStart
         * @param c {cc.node.CallbackSceneTransition}
         * @returns {cc.node.Scene}
         */
        onExitTransitionDidStart( c : CallbackSceneTransition ) : Scene {
            this._onExitTransitionDidStart= c;
            return this;
        }

        /**
         * Register onEnterTransitionFinish callback. Called when scenes are switched by Transition objects.
         * @method cc.node.Scene#onEnterTransitionDidFinish
         * @param c {cc.node.CallbackSceneTransition}
         * @returns {cc.node.Scene}
         */
        onEnterTransitionDidFinish( c : CallbackSceneTransition ) : Scene {
            this._onEnterTransitionDidFinish= c;
            return this;
        }

        /**
         * Notifiy event registered callback.
         * @method cc.node.Scene#callOnEnterTransitionDidFinish
         */
        callOnEnterTransitionDidFinish() : void {
            if ( this._onEnterTransitionDidFinish ) {
                this._onEnterTransitionDidFinish( this );
            }
        }

        /**
         * Notifiy event registered callback.
         * @method cc.node.Scene#callOnExitTransitionDidStart
         */
        callOnExitTransitionDidStart() : void {

            if ( this._onExitTransitionDidStart) {
                this._onExitTransitionDidStart( this );
            }
        }

        /**
         * Notifiy event registered callback.
         *
         *
         * @method cc.node.Scene#callOnEnter
         */
        callOnEnter() : void {

            var scene : Scene = this;

            // recursively set scene for nodes.
            this.enumerateChildren( "//*", function( node : Node ) {
                node.setScene( scene );
            });

            if ( this._onEnter ) {
                this._onEnter( this );
            }

            this.resetScene();
        }

        /**
         * Notify event registered callback.
         * @method cc.node.Scene#callOnExit
         */
        callOnExit() : void {
            if ( this._onExit ) {
                this._onExit( this );
            }
        }

        /**
         * Overriden Node's method for set scene reference.
         * A scene does not need a scene reference.
         * @method cc.node.Scene#setScene
         * @param scene {cc.node.Scene}
         */
        setScene( scene : Scene ) : void {
            // assert scene===this
        }

        /**
         * Overriden Node's method for setting a parent.
         * Scenes have no parent reference so this method does nothing.
         * @method cc.node.Scene#setParent
         * @param node {cc.node.Node}
         * @returns {cc.node.Scene}
         */
        setParent( node : Node ) : Node {
            return this;
        }

        /**
         * Reset this scene's properties.
         * Needed if the scene is managed by a Transition since position/scale/rotate can be changed.
         * @method cc.node.Scene#resetScene
         * @returns {cc.node.Scene}
         */
        resetScene() : Scene {
            this.alpha = 1;
            this.setScale(1,1);
            this.setPositionAnchor(0,0);
            this.setTransformationAnchor(0.5,0.5);
            this.__setFlag( NodeDirtyFlags.VISIBLE );

            return this;
        }

        /**
         * Run an Action for a Node.
         * @method cc.node.Scene#scheduleActionForNode
         * @param node {cc.node.Node}
         * @param action {cc.action.Action}
         * @returns {cc.node.Scene}
         */
        scheduleActionForNode( node : Node, action : Action ) : Scene {
            this._actionManager.scheduleActionForNode( node, action );
            return this;
        }

        /**
         * Clear all this scene contents.
         * + all children are removed.
         */
        clear() : void {
            this.removeAllChildren();
        }

        /**
         * Schedule an action to run.
         * By the time an action is meant to be scheduled for running in a Node, there may not yet be a
         * <code>Director</code> or <code>Scene</code>. This method saves locally the actions which will be
         * scheduled in a scene's <code>ActionManager</code> later.
         * @method cc.node.Node#runAction
         * @param action {cc.action.Action}
         * @returns {cc.node.Node}
         */
        runAction( action : Action ) : Node {
            this.scheduleActionForNode(this, action);
            return this;
        }

        stopNodeActionByTag( node:Node, tag:string ) : Node {
            this._actionManager.stopNodeActionByTag(node,tag);

            return this;
        }

        stopActionsForNode( node:Node ) {
            this._actionManager.stopActionsForNode(node);
        }

        getScheduler() : SchedulerQueue {
            return this._scheduler;
        }

        getScene() {
            return this;
        }


        /////////////// SCHEDULER METHODS BEGIN ////////////////

        scheduleTask( task:SchedulerQueueTask ) {
            this._scheduler.scheduleTask(task);
        }

        scheduleUpdateWithPriority( priority : number ) {
            var task:cc.action.SchedulerQueueUpdateTask= cc.action.SchedulerQueue.createSchedulerUpdateTask(this,0,Number.MAX_VALUE,0);
            task._priority= priority;
            this._scheduler.scheduleTask(task);
        }

        /**
         * Schedule a task to per frame call update for this node.
         *
         * @method cc.node.Node#scheduleUpdate
         * @deprecated
         */
        scheduleUpdate() {
            var task:cc.action.SchedulerQueueUpdateTask= cc.action.SchedulerQueue.createSchedulerUpdateTask(this,0,Number.MAX_VALUE,0);
            this._scheduler.scheduleTask(task);
        }

        unscheduleUpate() {
            this._scheduler.unscheduleCallbackForTarget(this, this.update);
        }

        /**
         * Schedule a task for the node.
         * This node will be passed as target to the specified callback function.
         * If already exist a task in the scheduler for the same pair of node and callback, the task will be updated
         * with the new data.
         * @method cc.node.Node#schedule
         * @param callback_fn {cc.action.SchedulerTaskCallback} callback to invoke
         * @param interval {number} repeat interval time. the task will be fired every this amount of milliseconds.
         * @param repeat {number=} number of repetitions. if not set, infinite will be used.
         * @param delay {number=} wait this millis before firing the task.
         */
        schedule(callback_fn:SchedulerTaskCallback, interval:number, repeat?:number, delay?:number) {

            var task:SchedulerQueueTask= cc.action.SchedulerQueue.createSchedulerTask(
                                    this,callback_fn,interval,repeat,delay);

            this._scheduler.scheduleTask(task);
        }

        /**
         * Schedule a single shot task. Will fired only once.
         * @method cc.node.Node#scheduleOnce
         * @param callback_fn {cc.action.SchedulerTaskCallback} scheduler callback.
         * @param delay {number} milliseconds to wait before firing the task.
         * @returns {cc.node.Node}
         */
        scheduleOnce(callback_fn:SchedulerTaskCallback, delay:number) {
            this.schedule(callback_fn, 0.0, 0, delay);
        }

        /**
         * Unschedule a task for the node.
         * @method cc.node.Node#unschedule
         * @param callback_fn {cc.action.SchedulerTaskCallback} callback to unschedule.
         */
        unschedule(callback_fn:SchedulerTaskCallback) {

            if (!callback_fn)
                return;

            this._scheduler.unscheduleCallbackForTarget(this, callback_fn);
        }

        unscheduleCallbackForTarget(target:Node, task:SchedulerTaskCallback) {
            this._scheduler.unscheduleCallbackForTarget(target,task);
        }

        /**
         * Unschedule all tasks for the node.
         * @method cc.node.Node#unscheduleAllCallbacks
         */
        unscheduleAllCallbacks(target?:Node) {
            this._scheduler.unscheduleAllCallbacks(target?target:this);
        }

        /**
         * Resumes all scheduled tasks and actions.
         * This method is called internally by onEnter
         * @method cc.node.Node#resume
         */
        resume() {
            this._scheduler.resumeTarget(this);

            // PENDING: implement
            //this.actionManager && this.actionManager.resumeTarget(this);
            //cc.eventManager.resumeTarget(this);
        }

        /**
         * Pauses all scheduled selectors and actions.
         * This method is called internally by onExit.
         * @method cc.node.Node#pause
         *
         */
        pause() {
            this._scheduler.pauseTarget(this);

            // PENDING: implement
            //this.actionManager && this.actionManager.pauseTarget(this);
            //cc.eventManager.pauseTarget(this);
        }

        pauseTarget( target:Node ) {
            this._scheduler.pauseTarget( target );
        }

        resumeTarget( target:Node ) {
            this._scheduler.resumeTarget( target );
        }

        /////////////// SCHEDULER METHODS END ////////////////
    }

}

/**
 * License: see license.txt file.
 */


/// <reference path="./Node.ts"/>
/// <reference path="./Scene.ts"/>
/// <reference path="../math/Dimension.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../transition/Transition.ts"/>
/// <reference path="../action/ActionManager.ts"/>
/// <reference path="../action/SchedulerQueue.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../util/Debug.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../render/Renderer.ts"/>
/// <reference path="../render/ScaleManager.ts"/>
/// <reference path="../input/InputManager.ts"/>
/// <reference path="../input/MouseInputManager.ts"/>
/// <reference path="../render/ScaleManager.ts"/>

module cc.node {

    "use strict";

    import Node= cc.node.Node;
    import Scene= cc.node.Scene;
    import Debug= cc.Debug;
    import Locale= cc.locale;
    import ActionManager= cc.action.ActionManager;
    import RenderingContext = cc.render.RenderingContext;
    import Renderer= cc.render.Renderer;
    import Dimension = cc.math.Dimension;

    /**
     * Enumeration of Director status.
     *
     * @tsenum cc.node.DirectorStatus
     */
    export enum DirectorStatus {
        CREATED = 0,
        RUNNING = 1,
        PAUSED = 2,
        STOPPED = 3
    }

    var __window:any = window;

    /**
     * @class cc.node.Director
     * @extends cc.node.Node
     * @classdesc
     *
     * A Director object is the root node of a game.
     * <li>As the primary component, it is a glue which puts together platform features such as Input routing or Texture
     * and image caching, and Scenes and game logic.
     * <li>Each Director has a renderer, which acts on its own Canvas Object. Since V4, Cocos2D HTML5 allows for multiple
     * <li>Director instances and each one can have a different renderer type.
     *
     * <li>Every Director present in a Document, will share a common Texture and Image cache for better resource management.
     *
     * <li>A Director object runs Scenes. The process of switching scenes is handled using a <code>Transition</code> object.
     * <li>The preferred way of building scenes is by calling <code>director.createScene() -> Scene</code>
     *
     * @see{cc.node.Scene}
     * @see{cc.node.Transition}
     *
     */
    export class Director extends Node {

        /**
         * Director status
         * @member cc.node.Director#_status
         * @type {number}
         * @private
         */
        _status:cc.node.DirectorStatus = cc.node.DirectorStatus.CREATED;

        /**
         * Director's renderer.
         * @member cc.node.Director#_renderer
         * @type {cc.render.RenderingContext}
         * @private
         */
        _renderer:Renderer = null;

        /**
         * Scenes available in this Director.
         * @member cc.node.Director#_scenes
         * @type {Array}
         * @private
         */
        _scenes:Array<cc.node.Scene> = [];

        /**
         * requestAnimationFrame shim id.
         * @member cc.node.Director#_animFrame
         * @type {number}
         * @private
         */
        _animFrame:number = null;

        /**
         * Ideal milliseconds between two frames.
         * @member cc.node.Director#_animationInterval
         * @type {number}
         * @private
         */
        _animationInterval:number = 1000 / 60;

        /**
         * Currently running Scene.
         * @member cc.node.Director#_currentScene
         * @type {cc.node.Scene}
         * @private
         */
        _currentScene:Scene = null;

        /**
         * If <code>runAction</code> is called with a Transition, _exitingScene will be the currently moving out scene.
         * For internal usage only.
         * @member cc.node.Director#_exitingScene
         * @type {cc.node.Scene}
         * @private
         */
        _exitingScene:Scene = null;

        /**
         * Scenes action manager that manages Transition objects.
         * @member cc.node.Director#_scenesActionManager
         * @type {cc.action.ActionManager}
         * @private
         * @see {cc.transition.Transition}
         */
        _scenesActionManager:ActionManager = null;

        /**
         * Timer management. This value is the previous time the director run at.
         * @member cc.node.Director#_prevPerf
         * @type {number}
         * @private
         */
        _prevPerf:number = 0;

        /**
         * General input management system
         * @member cc.node.Director#_inputManager
         * @type {cc.input.InputManager}
         * @private
         */
        _inputManager : cc.input.InputManager = null;

        _scheduler : cc.action.SchedulerQueue= null;

        /**
         * Create a new Director instance.
         * @method cc.node.Director#constructor
         */
        constructor() {
            super();

            this._scenesActionManager = new ActionManager();
            this._scheduler= this._scenesActionManager.getScheduler();
            this._inputManager= new cc.input.InputManager();

            // BUGBUG deprecated
            (<any>cc).director= this;
        }

        /**
         * Get the current renderer.
         * @method cc.node.Director#getRenderer
         * @returns {Renderer}
         */
        getRenderer():Renderer {
            return this._renderer;
        }

        /**
         * Set the Director's renderer.
         * It will also enable input on the renderer surface.
         * @method cc.node.Director#setRenderingContext
         * @param renderer {cc.render.Renderer}
         * @returns {cc.node.Director}
         */
        setRenderer(renderer:Renderer):Director {
            this._renderer = renderer;
            this._contentSize.set(renderer.getContentSize());

            this._modelViewMatrix= this._renderer.getScaleContentMatrix();
            this._worldModelViewMatrix= this._renderer.getScaleContentMatrix();

            this._inputManager.enable( renderer._surface );

            var me= this;
            renderer.onContentScaled( function(
                unitsWidth:number, unitsHeight:number,
                preferredUnitsWidth:number, preferredUnitsHeight:number,
                canvasWidth:number, canvasHeight:number,
                sceneHint:cc.render.ScaleContentSceneHint ) {

                me.setContentSize( canvasWidth, canvasHeight );

                if ( sceneHint&cc.render.ScaleContentSceneHint.CENTER ) {
                    me._currentScene.setContentSize(unitsWidth, unitsHeight);
                    me._currentScene.setPosition((preferredUnitsWidth - unitsWidth) / 2, (preferredUnitsHeight - unitsHeight) / 2);
                } else if ( sceneHint&cc.render.ScaleContentSceneHint.STRETCH ) {
                    me._currentScene.setContentSize(preferredUnitsWidth, preferredUnitsHeight);
                    me._currentScene.setPosition(0,0);
                } else {

                    var x=0;
                    var y=0;

                    if ( sceneHint&cc.render.ScaleContentSceneHint.RIGHT ) {
                        x= preferredUnitsWidth-unitsWidth;
                    }

                    if ( (cc.render.RENDER_ORIGIN===cc.render.ORIGIN_TOP && sceneHint&cc.render.ScaleContentSceneHint.BOTTOM) ||
                         (cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM && sceneHint&cc.render.ScaleContentSceneHint.TOP) ) {

                        y= preferredUnitsHeight-unitsHeight;
                    }

                    me._currentScene.setContentSize(unitsWidth, unitsHeight);
                    me._currentScene.setPosition(x,y);
                }
            });

            return this;
        }

        __setTransform():Node {
            return this;
        }

        __setLocalTransform() {

        }

        __setWorldTransform() {

        }

        /**
         * Get the system input manager object.
         * @method cc.node.Director#getInputManager
         * @returns {cc.input.InputManager}
         */
        getInputManager() : cc.input.InputManager {
            return this._inputManager;
        }

        /**
         * Pause the Director.
         * The animation loop is stopped.
         * @method cc.node.Director#pause
         */
        pause():void {
            if (this._status === cc.node.DirectorStatus.PAUSED) {
                return;
            }

            this.stopAnimation();

            this._status = cc.node.DirectorStatus.PAUSED;
        }

        /**
         * Resume a paused director.
         * The animation loop restarts.
         * @method cc.node.Director#resume
         */
        resume():void {
            if (this._status !== cc.node.DirectorStatus.PAUSED) {
                return;
            }

            this.startAnimation();
        }

        /**
         * Make the renderer visible in the document.
         * @method cc.node.Director#addToDOM
         */
        addToDOM() {
            this._renderer.addToDOM();
        }

        __sceneExitedDirector( scene:Scene ) {
            if (scene) {
                scene.callOnExit();
                scene.cleanup();
                scene._parent= null;
            }
        }

        /**
         * Run a Scene.
         * Optionally use a transition for switching between scenes.
         * @method cc.node.Director#runScene
         * @param scene {cc.node.Scene}
         * @param transition {cc.transition.Transition}
         */
        runScene(scene_or_transition: Scene|cc.transition.Transition, transition?:cc.transition.Transition):void {

            var scene:Scene;

            if (scene_or_transition instanceof Scene) {
                scene= <Scene>scene_or_transition;
            } else if (scene_or_transition instanceof cc.transition.Transition) {
                // v3 style call
                transition= <cc.transition.Transition>scene_or_transition;
                scene= transition._sceneIn;

                if (!scene) {
                    throw "director.runAction(transition) has no scene set.";
                }

            } else {
                throw "Director.runScene with wrong object type.";
            }

            // wtf. zero sized containers should have no content.
            // the scene-graph will discard them immediately. This code here for backwards compatibility only.
            if ( scene.width===0 || scene.height===0 ) {
                var pw:Dimension= this.getRenderer()._preferredUnits;
                scene.setContentSize( pw.width, pw.height );
            }

            scene._parent= this;

            // the renderer will check whether it is already added.
            this.addToDOM();

            // if there's a transition, let the transition handle onExit.
            if (typeof transition !== "undefined") {
                this._exitingScene = this._currentScene;
                transition.initialize(scene, this._currentScene).
                    onDirectorTransitionEnd((tr:cc.transition.Transition) => {
                        //if ( this._exitingScene ) {
                        //    this.__sceneExitedDirector(this._exitingScene);
                        //}
                        this._exitingScene = null;
                    });
            } else {
                // if not, and there's a current scene
                if (this._currentScene) {
                    // call onExit.
                    this.__sceneExitedDirector(this._currentScene);
                }

                // scene entered w/o transition.
                scene.callOnEnter();
            }

            this._currentScene = scene;

            cc.input.MouseInputManager.enableInputForScene( scene );

            // check for valid orientation.
            this._renderer.checkOrientation();

            if ( this._status!==cc.node.DirectorStatus.RUNNING ) {
                this.startAnimation();
            }

        }

        /**
         * Push a new running scene on top of the stack.
         * @method cc.node.Director#pushScene
         * @param scene {cc.node.Scene}
         */
        pushScene(scene:Scene):void {

            if (this._scenes.indexOf(scene) !== -1) {
                Debug.error(Locale.ERR_RUNNING_ALREADY_EXISTING_SCENE);
                return;
            }

            this._scenes.push(scene);

            this.runScene(scene);
        }

        /**
         * Pop a scene from the running stack.
         * @method cc.node.Director#popScene
         * @throws cc.locale.Locale.ERR_DIRECTOR_POPSCENE_UDERFLOW if DEBUG_LEVEL is RuntimeDebugLevel.DEBUG.
         */
        popScene():void {

            if (this._scenes.length === 0) {
                Debug.error(Locale.ERR_DIRECTOR_POPSCENE_UNDERFLOW);
                return;
            }

            var exitScene:Scene = this._scenes.pop();
            this.__sceneExitedDirector(exitScene);

            if (this._scenes.length > 0) {
                this._currentScene = this._scenes[this._scenes.length - 1];
                this._currentScene.callOnEnter();
            } else {

                // PENDING end director.
            }

        }

        /**
         * Pop all scenes but one.
         * @method cc.node.Director#popToRootScene
         */
        popToRootScene():void {
            this.popToSceneStackLevel(1);
        }

        /**
         * Remove scenes from the stack until reaching 'level' scenes stack length.
         * @method cc.node.Director#popToSceneStackLevel
         * @param level {number}
         */
        popToSceneStackLevel(level:number):void {

            level = this._scenes.length - level;

            if (level <= 0) {
                Debug.error(Locale.ERR_DIRECTOR_POPSCENE_UNDERFLOW);
                return;
            }

            while (level) {
                this.popScene();
                level--;
            }
        }

        /**
         * Start Director's animation loop.
         * Don't call directly, or only call after manually calling <code>stopAnimation</code>
         * @method cc.node.Director#startAnimation
         */
        startAnimation():void {

            if (this._status === cc.node.DirectorStatus.RUNNING) {
                Debug.warn(Locale.WARN_START_ANIMATION_ON_RUNNING_DIRECTOR);
                return;
            }

            this._status = cc.node.DirectorStatus.RUNNING;

            var fn = this.mainLoop.bind(this);
            var me = this;

            function raf(perf:number) {
                fn(perf);
                me._animFrame = __window.requestAnimFrame(raf);
            }

            this._animFrame = __window.requestAnimFrame(raf);

            if ( this._currentScene ) {
                cc.input.MouseInputManager.enableInputForScene( this._currentScene );
            }
        }

        /**
         * Stop Director's animation loop.
         * The Director status will be STOPPED.
         * @method cc.node.Director#stopAnimation
         */
        stopAnimation():void {

            if (this._status !== cc.node.DirectorStatus.RUNNING) {
                return;
            }

            this._status = cc.node.DirectorStatus.STOPPED;
            if (this._animFrame!==null) {
                __window.cancelAnimationFrame(this._animFrame);
                this._animFrame = null;
            }

            if ( this._currentScene ) {
                cc.input.MouseInputManager.disableInputForScene();
            }
        }

        /**
         * Throttle animation loop.
         * This value will be the minimum millis to wait between two frames.
         * Currently does nothing.
         * @method cc.node.Director#setAnimationInterval
         * @param interval {number}
         */
        setAnimationInterval(interval:number):void {
            this._animationInterval = interval;
        }

        /**
         * Main director animation Loop.
         * Don't call directly this method. It is called by startAnimation when the first scene is scheduled in the
         * Director object.
         *
         * PENDING: throttle FPS with _animationInterval value.
         *
         * @method cc.node.Director#mainLoop
         * @param perf {number=} performance time elapsed between two RAF calls.
         */
        mainLoop(perf?:number):void {

            if (this._status !== cc.node.DirectorStatus.RUNNING) {
                return;
            }

            var deltaTime;

            if (typeof perf === "undefined") {
                perf = new Date().getTime();
            }

            deltaTime = perf - this._prevPerf;

            // prevent feeding huge time increments. Useful for debugging.
            if (deltaTime > 250) {
                deltaTime = 250;
            }

            this._prevPerf = perf;

            var ctx = this._renderer.getRenderingContext();
            ctx.clear();

            // do director's paint as a node.
            // A director does not have any action associated, so just paint.
            this.visit(ctx);

            // Step time for active scenes.
            // At any given moment, as much as two scenes can be active.
            // If a transition is in place, two scenes will be active.
            // If not, only one scene is active.
            this._scenesActionManager.step(deltaTime/cc.action.TIMEUNITS);

            // do current scene's visit when
            // transitions end.
            if (this._exitingScene) {
                this._exitingScene.step(deltaTime/cc.action.TIMEUNITS, ctx);
            }
            this._currentScene.step(deltaTime/cc.action.TIMEUNITS, ctx);

            if (this._renderer.flush) {
                this._renderer.flush();
            }
        }

        /**
         * Create an scene object.
         * The created Scene will have the size of this director object and have a reference to the director.
         * @method cc.node.Director#createScene
         * @returns {cc.node.Scene}
         */
        createScene():Scene {
            var scene = new Scene();
            scene.setContentSize(this._contentSize.width, this._contentSize.height);

            return scene;
        }

        /**
         * Get director size as a dimension object.
         * The object is a copy of the internal contentSize variable.
         * This method is for backwards compatibility
         * @method cc.node.Director#getWinSize
         * @returns {cc.math.Dimension}
         */
        getWinSize():Dimension {
            return this._contentSize.clone();
        }


        scheduleTask( task:cc.action.SchedulerQueueTask ) {
            this._scheduler.scheduleTask(task);
        }


        /**
         * Schedule a task for the node.
         * This node will be passed as target to the specified callback function.
         * If already exist a task in the scheduler for the same pair of node and callback, the task will be updated
         * with the new data.
         * @method cc.node.Node#schedule
         * @param callback_fn {cc.action.SchedulerTaskCallback} callback to invoke
         * @param interval {number} repeat interval time. the task will be fired every this amount of milliseconds.
         * @param repeat {number=} number of repetitions. if not set, infinite will be used.
         * @param delay {number=} wait this millis before firing the task.
         */
        schedule(callback_fn:cc.action.SchedulerTaskCallback, interval:number, repeat?:number, delay?:number) {

            var task:cc.action.SchedulerQueueTask= cc.action.SchedulerQueue.createSchedulerTask(
                                    this,callback_fn,interval,repeat,delay);

            this._scheduler.scheduleTask(task);
        }

        /**
         * Schedule a single shot task. Will fired only once.
         * @method cc.node.Node#scheduleOnce
         * @param callback_fn {cc.action.SchedulerTaskCallback} scheduler callback.
         * @param delay {number} milliseconds to wait before firing the task.
         * @returns {cc.node.Node}
         */
        scheduleOnce(callback_fn:cc.action.SchedulerTaskCallback, delay:number) {
            this.schedule(callback_fn, 0.0, 0, delay);
        }

        /**
         * Unschedule a task for the node.
         * @method cc.node.Node#unschedule
         * @param callback_fn {cc.action.SchedulerTaskCallback} callback to unschedule.
         */
        unschedule(callback_fn:cc.action.SchedulerTaskCallback) {

            if (!callback_fn)
                return;

            this._scheduler.unscheduleCallbackForTarget(this, callback_fn);
        }

        /**
         * Unschedule all tasks for the node.
         * @method cc.node.Node#unscheduleAllCallbacks
         */
        unscheduleAllCallbacks(target?:Node) {
            this._scheduler.unscheduleAllCallbacks(target?target:this);
        }

    }
}
/**
 * Created by ibon on 11/17/14.
 */

/// <reference path="./WebGLState.ts"/>
/// <reference path="./Renderer.ts"/>

module cc.render {

    /**
     * @class cc.render.Texture2D
     * @classdesc
     *
     * This Object encapsulated a rendering texture, either for Canvas or WebGL.
     * The texture will handle all the burden of creating a webgl texture when needed.
     * Since renderers have different needs for different types of images a call to Renderer.prepareTexture must be
     * performed. This will automatically happen for every pre-loaded texture in the AssetManager by the time a renderer
     * is being built.
     *
     */
    export class Texture2D {

        _name: string= null;

        _webglState : WebGLState = null;

        _glId : WebGLTexture= null;
        _textureWidth : number = 0;
        _textureHeight : number = 0;

        /**
         * A texture2D, is bound to a given renderer.
         * @member cc.render.Texture2D#_image
         * @type {Image|WebGLTexture}
         * @private
         */
        _image : any = null;

        _hasMipmaps : boolean = false;

        _u0 : number = 0;
        _v0 : number = 0;
        _u1 : number = 0;
        _v1 : number = 0;

        // offset in image.
        _offsetX : number = 0;
        _offsetY : number = 0;

        // when image is set to texture, the original image is dismissed in favor of a new dummy image.
        // from then, calling image.width or image.height will give wrong values.
        _imageWidth : number = 0;
        _imageHeight : number = 0;

        _isLoaded : boolean = false;

        _invertedY : boolean = false;

        constructor( el : any, name : string) {
            if (el) {
                this.initWithElement(el);
                this._name= name;
            }
        }

        initWithElement( el : string );
        initWithElement( el : HTMLCanvasElement );
        initWithElement( el : HTMLImageElement );
        initWithElement( el : any ) {

            if ( typeof el === "string" ) {

                var image= new Image();
                image.onload= (function(me) {
                    return function(e) {
                        me.initWithElement(e.target);
                    }
                })(this);
                image.src= el;

            } else {
                this._image = el;
                this._imageWidth = el.width;
                this._imageHeight = el.height;
                this._image._textureInfo = this;

                this._isLoaded = true;
            }


            function POT( v : number ) {
                var current : number = 1;
                while( current<v ) {
                    current<<=1;
                }
                return current;
            }

            this._textureWidth = POT(this._image.width);
            this._textureHeight = POT(this._image.height);

            this._u1 = this._imageWidth / this._textureWidth;
            this._v1 = this._imageHeight / this._textureHeight;

        }

        get width() {
            return this.getPixelsWide();
        }

        get height() {
            return this.getPixelsHigh();
        }

        getPixelsWide() : number {
            return this._imageWidth;
        }

        getPixelsHigh() : number {
            return this._imageHeight;
        }

        getImage() : any {
            return this._glId ? this._glId : this._image;
        }

        isWebGLEnabled() : boolean {
            return this._glId!==null;
        }

        release() {
            if ( this._glId && this._webglState ) {
                this._webglState._gl.deleteTexture( this._glId );
                this._glId= null;
            }
        }

        /**
         * Turn an Image texture into a WebGL Texture.
         * The Image object reference will be set to null (gc friendly).
         * If the Texture is already a gl texture, nothing will happen.
         * @param webglstate {cc.render.WebGLState}
         * @returns {cc.render.Texture2D}
         * @private
         */
        __setAsGLTexture( webglstate : WebGLState ) : Texture2D {

            // already set as texture, do nothing.
            if ( !webglstate || this.isWebGLEnabled() ) {
                return this;
            }

            var gl= webglstate._gl;

            this._webglState= webglstate;
            this._glId= gl.createTexture();

            webglstate.bindTexture(gl.TEXTURE_2D, this._glId);
            webglstate.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            if (cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM) {
                this._invertedY = true;
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
            }
            gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,this._textureWidth,this._textureHeight,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
            gl.texSubImage2D( gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this._image);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            this._image= null;

            return this;
        }

        setTexParameters(texParams : number, magFilter : number, wrapS : number, wrapT : number ) : void;
        setTexParameters(texParams : any, magFilter : number, wrapS : number, wrapT : number ) : void {

            if (!this._webglState) {
                return;
            }

            var gl= this._webglState._gl;

            var minFilter : number;

            if ( typeof magFilter === "undefined") {
                magFilter = texParams.magFilter;
                wrapS = texParams.wrapS;
                wrapT = texParams.wrapT;
                minFilter = texParams.minFilter
            } else {
                minFilter = texParams;
            }

            this._webglState.bindTexture(gl.TEXTURE_2D, this._glId);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);

        }

        setAntiAliasTexParameters() : void {

            if (!this._webglState) {
                return;
            }
            var gl= this._webglState._gl;

            this._webglState.bindTexture(gl.TEXTURE_2D, this._glId);

            if (!this._hasMipmaps) {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            }

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }

        setAliasTexParameters() {

            if (!this._webglState) {
                return;
            }
            var gl= this._webglState._gl;

            this._webglState.bindTexture(gl.TEXTURE_2D, this._glId);

            if (!this._hasMipmaps){
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
            }
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }

        generateMipmap() {

            if (!this._webglState || this._hasMipmaps ) {
                return;
            }
            var gl= this._webglState._gl;

            this._webglState.bindTexture(gl.TEXTURE_2D, this._glId);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);

            this._hasMipmaps = true;
        }

    }
}
/**
 * Created by ibon on 11/26/14.
 */

/// <reference path="../../math/Point.ts"/>
/// <reference path="../../math/Rectangle.ts"/>
/// <reference path="../Sprite.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
/// <reference path="../../render/DecoratedWebGLRenderingContext.ts"/>
/// <reference path="../../render/Texture2D.ts"/>
/// <reference path="../../locale/Locale.ts"/>
/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../plugin/asset/AssetManager.ts"/>


module cc.node.sprite {

    import Vector = cc.math.Vector;
    import Rectangle = cc.math.Rectangle;
    import RenderingContext = cc.render.RenderingContext;
    import DecoratedWebGLRenderingContext = cc.render.DecoratedWebGLRenderingContext;
    import Texture2D = cc.render.Texture2D;
    import Sprite = cc.node.Sprite;

    function __createSpriteFrame( from:SpriteFrame, x, y, w, h, name:string, rotated:boolean, offsetx:number, offsety:number ) : SpriteFrame {

        var frame = from.createSubSpriteFrame( parseFloat(x), parseFloat(y), parseFloat(w), parseFloat(h), name, offsetx, offsety );
        frame.rotated= rotated;

        return frame;
    }

    /**
     * @class cc.node.sprite.SpriteFrame
     * @classdesc
     *
     * This Object defines a pixels source (image, canvas, texture, etc.) and an associated Rect for image blitting
     * operations.
     * It has parent-child capabilities. A SpriteFrame can create subFrames. SubFrames will have a parent reference,
     * share the same Texture instance and will apply the appropriate offset.
     *
     */
    export class SpriteFrame {

        /**
         * Parent's SpriteFrame. When creating Frames from an image, a call to <code>spriteFrame.createFrame</code>
         * will create a child of a frame, set its parent, and inherit the offseting based on parent's chain.
         * Both frames will share the same Texture2D instance.
         * @type {cc.node.SpriteFrame}
         * @member cc.node.sprite.SpriteFrame#_parent
         * @private
         */
        _parent : SpriteFrame = null;

        /**
         * Offset position in texture.
         * When setting parents, the offset will be the parent's position.
         * @member cc.node.sprite.SpriteFrame#_offset
         * @type {cc.math.Vector}
         * @private
         */
        _offset: Vector = new Vector();

        /**
         * Displacement to add to position the spriteframe on screen.
         * Nothing to do with uv coords.
         * @member cc.node.sprite.SpriteFrame#_offsetFromCenter
         * @type {cc.math.Vector}
         * @private
         */
        _offsetFromCenter : Vector = null;

        /**
         * Is the frame rotated ?. Not by default.
         * @member cc.node.sprite.SpriteFrame#_rotated
         * @type {boolean}
         * @private
         */
        _rotated: boolean = false;

        /**
         * Recatangle in pixels the SpriteFrame represents.
         * @member cc.node.sprite.SpriteFrame#_rect
         * @type {cc.math.Rectangle}
         * @private
         */
        _rect: Rectangle = null;

        /**
         * Recatangle in uv the SpriteFrame represents.
         * @member cc.node.sprite.SpriteFrame#_normalizedRect
         * @type {cc.math.Rectangle}
         * @private
         */
        _normalizedRect: Rectangle = new Rectangle();

        /**
         * Texture data. Texture is a source of pixels, either Image, Canvas or a GLTexture
         * @member cc.node.sprite.SpriteFrame#_texture
         * @type {cc.render.Texture2D}
         * @private
         */


        /**
         *
         * @type {null}
         * @private
         */
        _name : string = null;

        /**
         * Create a new SpriteFrame instance.
         * @method cc.node.sprite.SpriteFrame#constructor
         * @param _texture {Texture2D} an string or Texture2D
         * @param rect {cc.math.Rectangle=} an optional rect on the texture. If not set, the whole image will be used.
         */
        constructor(public _texture? : Texture2D, rect? : Rectangle ) {

            this._rect= rect ?
                rect :
                (_texture!==null ?
                    new Rectangle( 0,0,_texture._imageWidth, _texture._imageHeight ) :
                    new Rectangle() );
            this.__calculateNormalizedRect();
            this._name= _texture && _texture._name ? _texture._name : "root";
        }

        getWidth() : number {
            return this._rect.w;
        }

        getHeight() : number {
            return this._rect.h;
        }

        getX() : number {
            return this._rect.x;
        }

        getY() : number {
            return this._rect.y;
        }

        get x() {
            return this._rect.x;
        }

        get y() {
            return this._rect.y;
        }

        get width() {
            return this._rect.w;
        }

        get height() {
            return this._rect.h;
        }

        /**
         * Create a new SpriteFrame from this one. The rect will be relative to this SpriteFrame's rect and offset.
         * The rect supplied is clipped against this SpriteFrame's rect. If the resulting rect is Empty (has no dimension)
         * null will be returned.
         * The caller is responsible from storing the resulting SpriteFrame object.
         * @method cc.node.sprite.SpriteFrame#createSubSpriteFrame
         * @param x {number}
         * @param y {number}
         * @param w {number}
         * @param h {number}
         * @param name {string} a frame's name. If not set, "frameXXX" where XXX is a sequence value will be set.
         * @returns {SpriteFrame} a new SubSpriteFrame created from this one or null if the supplied rect does not
         *  intersect this SpriteFrame's rect.
         */
        createSubSpriteFrame( x:number, y:number, w:number, h:number, name:string, centerOffsetX?:number, centerOffsetY?:number ) : SpriteFrame {

            var newRect:Rectangle = new Rectangle(x, y, w, h);
            newRect.translate( this._rect.x, this._rect.y );

            if (this._rect.intersectsWith(newRect)) {

                var sf:SpriteFrame = new SpriteFrame(this._texture, newRect);
                sf._name = name;
                sf._parent = this;
                sf.setOffset(this._offset.x + this._rect.x, this._offset.y + this._rect.y);
                sf.setOffsetFromCenter( centerOffsetX||0, centerOffsetY||0 );

                return sf;
            }

            return null;
        }

        needsSpecialMatrix() : boolean {
            return this._offsetFromCenter!==null || this._rotated;
        }

        setOffsetFromCenter( x:number, y:number ) {
            if (this._offsetFromCenter===null) {
                this._offsetFromCenter= new Vector(0,0);
            }
            this._offsetFromCenter.set( x, y );
        }

        createSubSpriteFrames( rows:number, columns:number ) : SpriteFrame[] {

            var sfwidth= this._rect.w/columns;
            var sfheight= this._rect.h/rows;
            var frames= [];

            for( var i=0; i<rows; i++) {
                for( var j=0; j<columns; j++ ) {
                    frames.push(
                        this.createSubSpriteFrame(
                            j*sfwidth, i*sfheight, sfwidth, sfheight, this._name+(j+i*columns) ) );
                }
            }

            return frames;
        }

        /**
         * Set the SpriteFrame offset. This is useful to properly position a Frame inside a frame. For example, a texture
         * atlas with a font, which effectively another atlas.
         * If the offset position is not contained the SpriteFrame's rect, the offset operation does nothing.
         * @method cc.node.sprite.SpriteFrame#setOffset
         * @param x {number}
         * @param y {number}
         */
        setOffset( x:number, y:number ) : void {
            if (!this._texture) {
                cc.Debug.error(locale.ERR_SPRITE_FRAME_NO_TEXTURE, "setOffset");
            }
            //if ( this._rect.contains( x,y ) ) {
                this._offset.set(x, y);
                this.__calculateNormalizedRect();
            //}
        }

        /**
         * Set this SpriteFrame to have the image rotated.
         * @method cc.node.sprite.SpriteFrame#set:rotated
         * @param v {boolean}
         */
        set rotated( v : boolean ) {
            this._rotated= v;
        }

        /**
         * Is this SpriteFrame rotated ?
         * @method cc.node.sprite.SpriteFrame#get:rotated
         * @returns {boolean}
         */
        get rotated() {
            return this._rotated;
        }

        /**
         * Calculate WebGL rect based on the current frame info.
         * @member cc.node.sprite.SpriteFrame#__calculateNormalizedRect
         * @private
         */
        __calculateNormalizedRect() : void {

            if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM ) {
                this._normalizedRect.set(
                    this._rect.x,
                    this._texture._imageHeight - this._rect.y - this._rect.h,
                    this._rect.w,
                    this._rect.h).
                    normalizeBy(this._texture._textureWidth, this._texture._textureHeight);

            } else {
                this._normalizedRect.set(
                    this._rect.x,
                    this._rect.y,
                    this._rect.w,
                    this._rect.h).
                    normalizeBy(this._texture._textureWidth, this._texture._textureHeight);
            }
        }

        /**
         * Get this SpriteFrame associated texture 2d object.
         * @method cc.node.sprite.SpriteFrame#getTexture
         * @returns {cc.render.Texture2D}
         */
        getTexture() : Texture2D {
            return this._texture;
        }

        /**
         * Draw the SpriteFrame.
         * This method takes care of drawing the Frame with the correct rotation and Sprite's status of flip axis values.
         * @method cc.node.sprite.SpriteFrame#draw
         * @param ctx {cc.render.RenderingContext}
         * @param w {number}
         * @param h {number}
         */
        draw( ctx : RenderingContext, w:number, h:number ) : void {

            if ( ctx.type===cc.render.RENDERER_TYPE_WEBGL ) {

                if (!this._texture.isWebGLEnabled()) {
                    cc.Debug.warn(cc.locale.SPRITEFRAME_WARN_TEXTURE_NOT_WEBGL_INITIALIZED, "SpriteFrame.draw");
                    this._texture.__setAsGLTexture((<DecoratedWebGLRenderingContext>ctx)._webglState);
                    this.__calculateNormalizedRect();
                }

                ctx.drawTexture(
                    this._texture,
                    this._rect.x, this._rect.y, this._rect.w, this._rect.h,
                    0, 0, w, h);

            } else {

                ctx.drawTextureUnsafe(
                    this._texture,
                    this._rect.x, this._rect.y, this._rect.w, this._rect.h,
                    0, 0, w, h);
            }
        }

        /**
         * Create a set of new SpriteFrames from this SpriteFrame area, and defined by a JSON object.
         * The JSON object is typically the result of a ResourceLoaderJSON with parse flag enabled.
         * The JSON structure is the result from the tool TexturePacker, exporting content as JSON.
         * The function will create an array of newly created SpriteFrames. It is not this function's responsibility
         * to add the new frames to a cache or anything but creating them.
         *
         * @param map {object} a TexturePacker JSON exported file.
         * @param frames {Array<cc.node.sprite.SpriteFrame>=} array of newly created SpriteFrames. if this parameter is
         *      not set, a new array will be created and returned.
         * @returns {SpriteFrame[]}
         */
        createSpriteFramesFromJSON( map:any, frames?:SpriteFrame[] ) : SpriteFrame[] {

            frames= frames || [];

            map = map.frames || map;

            for (var element in map) {
                if (map.hasOwnProperty(element)) {

                    var frameRect= map[element].frame;
                    frames.push( __createSpriteFrame(
                        this,
                        frameRect.x, frameRect.y,
                        frameRect.w, frameRect.h,
                        element,
                        map[element].rotated,
                        0, 0) );
                }
            }

            return frames;
        }

        /**
         * Create a set of new SpriteFrames from this SpriteFrame area, and defined by a 'plist' object.
         * The plist object is typically the result of a ResourceLoaderXML.
         * The plist structure is the result from the tool TexturePacker, exporting content as Cocos2d.
         * The function will create an array of newly created SpriteFrames. It is not this function's responsibility
         * to add the new frames to a cache or anything but creating them.
         *
         * @param obj {object} plist loaded file content in the form of a javascript array.
         * @returns {SpriteFrame[]}
         */
        createSpriteFramesFromPLIST( obj:Array<any> ) : SpriteFrame[] {

            var ret:SpriteFrame[] = [];

            var frames= obj[0].frames;
            for( var id in frames ) {

                if ( frames.hasOwnProperty(id) ) {
                    var frameInfo = frames[id];

                    if ( frameInfo.frame ) {

                        // frame info is of the form {{x,y},{w,h}}
                        var fi= frameInfo.frame.substring(1,frameInfo.frame.length-1);
                        var fis= fi.substring(1,fi.length-1).split('},{');
                        var xy= fis[0].split(',');
                        var wh= fis[1].split(',');

                        // frame info offset {0,0}
                        var foffset= frameInfo.offset.substring(1,fi.length-1).split('},{');
                        var offsetxy= foffset[0].split(',');

                        // WFT!!!
                        // the file format specifies if rotated, the frame size in inverted.
                        var w, h;
                        w= parseFloat(frameInfo.rotated ? wh[1] : wh[0]);
                        h= parseFloat(frameInfo.rotated ? wh[0] : wh[1]);

                        var ox, oy;
                        //ox= parseFloat(frameInfo.rotated ? offsetxy[1] : offsetxy[0]);
                        //oy= parseFloat(frameInfo.rotated ? offsetxy[0] : offsetxy[1]);
                        ox= parseFloat(offsetxy[0]);
                        oy= parseFloat(offsetxy[1]);

                        ret.push(__createSpriteFrame(
                            this,
                            parseFloat(xy[0]), parseFloat(xy[1]),
                            w,h,
                            id,
                            frameInfo.rotated,
                            ox, oy)
                        );

                    } else {

                        ret.push(__createSpriteFrame(
                            this, frameInfo.x, frameInfo.y,
                            frameInfo.width, frameInfo.height,
                            id,
                            frameInfo.rotated,
                            0, 0));
                    }
                }

            }

            return ret;
        }

    }

}
/**
 * License: see license.txt file.
 */

/// <reference path="./SpriteFrame.ts"/>
/// <reference path="../../render/Texture2D.ts"/>

module cc.node.sprite {

    import Texture2D= cc.render.Texture2D;

    export interface AnimationCacheData {
        [v:string] : Animation;
    }

    /**
     * @class cc.node.sprite.AnimationCache
     */
    export class AnimationCache {

        _animations : AnimationCacheData= {};

        constructor() {
        }

        addAnimation( ) {

        }
    }

    var __index : number= 0;

    /**
     * @class cc.node.sprite.Animation
     * @classdesc
     *
     * An animation is a set of SpriteFrames, playback duration and a loop value. A <code>cc.action.AnimateAction</code>
     * will play the sequence that the animation defines.
     * SpriteFrames roughly define rectangles in images. So if each of these frames is set for a node at a given speed,
     * we get the notion of a sprite animation.
     */
    export class Animation {

        /**
         * A collection of SpriteFrames to define an animation.
         * @type {Array<cc.node.sprite.SpriteFrame>}
         * @member cc.node.sprite.Animation#_frames
         * @private
         */
        _frames:SpriteFrame[] = [];

        /**
         * How many times the sequence will be played.
         * @type {number}
         * @member cc.node.sprite.Animation#_loops
         * @private
         */
        _loops:number = 1;

        /**
         * Set the sprite back to the original frame after the animation ends playing.
         * @type {number}
         * @member cc.node.sprite.Animation#_restoreOriginalFrame
         * @private
         */
        _restoreOriginalFrame:boolean = false;

        /**
         * Time to change to the next frame. Defaults to 0.150 seconds. Value in milliseconds.
         * @member cc.node.sprite.Animation#_delayPerUnit
         * @type {number}
         * @private
         */
        _delayPerUnit:number = 150/cc.action.TIMEUNITS;

        /**
         * Animation name. By default will be "animationXXX" where XXX is an index sequence value.
         * @member cc.node.sprite.Animation#_name
         * @type {string}
         * @private
         */
        _name : string = null;

        /**
         * Create a new Animation instance.
         * @method cc.node.sprite.Animation#constructor
         */
        constructor() {

        }

        /**
         * Add an animation frame.
         * @method cc.node.sprite.Animation#addFrame
         * @param f {cc.node.sprite.SpriteFrame}
         */
        addFrame( f : SpriteFrame ) : Animation {
            this._frames.push( f );
            return this;
        }

        /**
         * Add a collection of animation frames.
         * @method cc.node.sprite.Animation#addFrames
         * @param f {Array<cc.node.sprite.SpriteFrame>}
         */
        addFrames( f : SpriteFrame[] ) : Animation {
            for( var i=0; i<f.length; i++ ) {
                this.addFrame( f[i] );
            }
            return this;
        }

        /**
         * Set the amount of time each frame of the animation will be shown.
         * @method cc.node.sprite.Animation#setDelayPerUnit
         * @param d {number} delay in seconds.
         */
        setDelayPerUnit( d : number ) : Animation {
            this._delayPerUnit= d;
            return this;
        }

        /**
         * Set the number of animation repetitions. If <1, it will be set to 1.
         * @method cc.node.sprite.Animation#setLoops
         * @param l {number} number of loops
         */
        setLoops( l :number ) : Animation {
            if ( l<1 ) {
                l= 1;
            } else {
                l=l|0;
            }
            this._loops= l;

            return this;
        }

        /**
         * Restore the original frame when the animation ends.
         * @method cc.node.sprite.Animation#setRestoreOriginalFrame
         * @param r {boolean}
         */
        setRestoreOriginalFrame( r : boolean ) :Animation{
            this._restoreOriginalFrame= r;
            return this;
        }

        /**
         * Load an image, create a texture, a frame and then add the resulting SpriteFrame to the animation.
         * @method cc.node.sprite.Animation#addSpriteFrameWithFile
         * @deprecated
         * @param f {string} valid url string for an image resource.
         */
        addSpriteFrameWithFile( f : string ) {
            var me= this;
            var img= new Image();
            img.onload= function(e) {
                var t2d : Texture2D= new Texture2D(img, f);
                var sf= new SpriteFrame(t2d);
                me.addFrame(sf);
            };
            img.src= f;
        }

        /**
         * Get the animation duration. It is the number of frames * delayPerUnit
         * @method cc.node.sprite.Animation#getDuration
         * @returns {number} animation duration in seconds.
         */
        getDuration() : number {
            return this._delayPerUnit * this._frames.length;
        }

        /**
         * Get the number of frames in the Animation.
         * @method cc.node.sprite.Animation#getSize
         * @returns {number}
         */
        getSize() : number {
            return this._frames.length;
        }

        /**
         * Get an SpriteFrame from the array at an index.
         * @method cc.node.sprite.Animation#getSpriteFrameAtIndex
         * @param i {number}
         * @returns {cc.node.sprite.SpriteFrame}
         */
        getSpriteFrameAtIndex( i : number ) : SpriteFrame {
            return this._frames[i];
        }

        /**
         * Set this animation to loop forever.
         * @method cc.node.sprite.Animation#setLoopForever
         * @returns {cc.node.sprite.Animation}
         */
        setLoopForever() : Animation {
            this._loops= Number.MAX_VALUE;
            return this;
        }

        /**
         * Create a copy of this Animation.
         * The new Animation name will be the original+<an index sequence value>
         * @method cc.node.sprite.Animation#clone
         * @returns {cc.node.sprite.Animation}
         */
        clone() : Animation {

            var animation : Animation = new Animation();
            animation._frames= Array.prototype.slice.call(this._frames);
            animation._delayPerUnit= this._delayPerUnit;
            animation._loops= this._loops;
            animation._restoreOriginalFrame= this._restoreOriginalFrame;
            animation._name= this._name+__index++;

            return animation;
        }

        /**
         * Reverse this animation. The SpriteFrame collection is reversed.
         * @method cc.node.sprite.Animation#reverse
         * @returns {cc.node.sprite.Animation}
         */
        reverse() : Animation {
            this._frames= this._frames.reverse();
            return this;
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="Node.ts"/>
/// <reference path="./sprite/SpriteFrame.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="../math/Rectangle.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../render/DecoratedWebGLRenderingContext.ts"/>
/// <reference path="../render/Texture2D.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../util/Debug.ts"/>
/// <reference path="../plugin/loader/Loader.ts"/>
/// <reference path="../plugin/loader/Resource.ts"/>
/// <reference path="../plugin/asset/AssetManager.ts"/>

module cc.node {

    "use strict";

    import Vector = cc.math.Vector;
    import Rectangle = cc.math.Rectangle;
    import Node = cc.node.Node;
    import RenderingContext = cc.render.RenderingContext;
    import DecoratedWebGLRenderingContext = cc.render.DecoratedWebGLRenderingContext;
    import Texture2D = cc.render.Texture2D;
    import SpriteFrame = cc.node.sprite.SpriteFrame;
    import Color= cc.math.Color;

    /**
     * @class cc.node.Sprite.SpriteInitializer
     * @classdesc
     *
     * Sprite initializer object.
     */
    export interface SpriteInitializer {
        texture? : Texture2D;
        frame? : SpriteFrame;
        rect? : Rectangle;
        frameName? : string;
    }

    var __m0= new Float32Array([1,0,0, 0,1,0, 0,0,1]);

    /**
     * @class cc.node.Sprite
     * @extend cc.node.Node
     * @classdesc
     * Sprite creates an sprite, a Node that shows images with animations.
     */
    export class Sprite extends Node {

        static create(d:any):Sprite {
            return new cc.node.Sprite(d);
        }

        /**
         * Set this frame horizontally flipped.
         * @member cc.node.Sprite#_flippedX
         * @type {boolean}
         * @private
         */
        _flippedX : boolean = false;

        /**
         * Set this frame horizontally flipped.
         * @member cc.node.Sprite#_flippedY
         * @type {boolean}
         * @private
         */
        _flippedY : boolean = false;

        /**
         * @union
         * @type {cc.render.Texture2D|cc.node.sprite.SpriteFrame}
         * @private
         */
        _spriteFrame : cc.node.sprite.SpriteFrame = null;

        _resizeOnSpriteFrameSet:boolean = true;

        _spriteMatrix : Float32Array = new Float32Array([1,0,0, 0,1,0, 0,0,1]);
        _spriteMatrixDirty : boolean = false;
        _spriteMatrixSet : boolean = false;

        /**
         * @method cc.node.Sprite#constructor
         * @param ddata {cc.node.SpriteInitializer}
         * @param rect {cc.math.Rectangle}
         */
        constructor( ddata : any, rect?:cc.math.Rectangle ) {
            super();
            this.__init( ddata, rect);
        }

        __init(ddata : any, rect?:cc.math.Rectangle ) {

            if ( ddata instanceof cc.node.sprite.SpriteFrame ) {
                // V3 call.
                this.setSpriteFrame( <SpriteFrame>ddata );
                cc.Debug.warn( locale.WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL );
            } else if ( ddata instanceof cc.render.Texture2D ) {
                // V3 call
                this.setSpriteFrame( new SpriteFrame(<Texture2D>ddata, arguments[1]) );
                cc.Debug.warn( locale.WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL );
            } else if ( typeof ddata==="string" ) {
                // V3 call
                if ( ddata.charAt(0)==="#") {

                    this.setSpriteFrame( cc.plugin.asset.AssetManager.getSpriteFrame( (<string>ddata).substr(1) ) );
                } else {
                    this.__createFromURL(<string>ddata, rect);
                }
                cc.Debug.warn( locale.WARN_SPRITE_CONSTRUCTOR_DEPRECATED_CALL );
            } else {

                var data= <SpriteInitializer>ddata;
                // V4 call

                if ( data ) {
                    if (data.texture) {
                        this.setSpriteFrame(new SpriteFrame(data.texture, data.rect));
                    } else if (data.frame) {
                        this.setSpriteFrame(data.frame);
                    } else if ( data.frameName ) {
                        this.setSpriteFrame( cc.plugin.asset.AssetManager.getSpriteFrame(data.frameName) );
                    } else {
                        cc.Debug.warn(locale.ERR_SPRITE_CONSTRUCTOR_PARAM_ERROR);
                    }
                }
            }

        }

        /**
         * Backwards compatibility method.
         * Never use directly.
         * ugh!.
         *
         * @param url
         * @param rect
         * @private
         */
        __createFromURL( url : string, rect?:cc.math.Rectangle ) {

            // me sangran los ojos poniendo esto aqui !!!
            var resource= cc.plugin.asset.AssetManager._resources[url] || null;

            // resource exists in the backwards compatibility resources list ?.
            if ( resource ) {
                // if not texture associated, create texture and main sprite frame
                if (!cc.plugin.asset.AssetManager.getTexture(url)) {
                    cc.plugin.asset.AssetManager.addImage(resource, url);
                }

                var mainSpriteFrame= cc.plugin.asset.AssetManager.getSpriteFrame(url);
                this.setSpriteFrame( !rect ?
                    mainSpriteFrame :
                    mainSpriteFrame.createSubSpriteFrame(rect.x, rect.y, rect.w, rect.h, url ));

            } else {

                // image is not even loaded.
                var me = this;

                // load asynchronously and create sprite frame + texture.
                new cc.plugin.loader.Loader({
                    resources: [url]
                }).startLoading(
                    function finished(resources:cc.plugin.asset.ResourcesMap) {

                        cc.plugin.asset.AssetManager.mergeResources( resources );

                        var sf:SpriteFrame = new SpriteFrame(new Texture2D(resources[url], url));
                        if (rect) {
                            sf = sf.createSubSpriteFrame(rect.x, rect.y, rect.w, rect.h, url);
                        }
                        me.setSpriteFrame(sf);
                    }
                );
            }
        }

        /**
         * Specialized Sprite draw function.
         * The Sprite must have a SpriteFrame, which references a region of an Image.
         * @method cc.node.Sprite#draw
         * @param ctx {cc.render.RenderingContext}
         */
        draw(ctx:RenderingContext):void {
            if ( this._spriteFrame ) {
                ctx.setGlobalAlpha( this._frameAlpha );
                ctx.setTintColor( this._color );
                this._spriteFrame.draw( ctx, this.width, this.height );
            }
        }

        /**
         * Set this Sprite's frame. Until a frame is set the Sprite won't be drawn on screen.
         * When the frame is set, the Node will have its dimension changed to fit that of the frame.
         * @param s {cc.node.sprite.SpriteFrame}
         */
        setSpriteFrame( s : SpriteFrame ) {
            if ( s!==this._spriteFrame ) {
                this._spriteFrame = s;
                if (this._resizeOnSpriteFrameSet) {
                    this.setContentSize(s._rect.w, s._rect.h);
                }

                this._spriteMatrixDirty= true;
            }
        }

        /**
         *
         *           cc.math.Matrix3.identity( this._spriteMatrix );

                     if (this._flippedX && this._flippedY) {
                         cc.math.Matrix3.translateBy(this._spriteMatrix, w, h);
                         cc.math.Matrix3.scaleBy(this._spriteMatrix, -1, -1);
                         this._spriteMatrixSet= true;
                     } else if (this._flippedX) {
                         cc.math.Matrix3.translateBy(this._spriteMatrix, w, 0);
                         cc.math.Matrix3.scaleBy(this._spriteMatrix, -1, 1);
                         this._spriteMatrixSet= true;
                     } else if (this._flippedY) {
                         cc.math.Matrix3.translateBy(this._spriteMatrix, 0, h);
                         cc.math.Matrix3.scaleBy(this._spriteMatrix, 1, -1);
                         this._spriteMatrixSet= true;
                     }

                     if ( this._spriteFrame.needsSpecialMatrix() ) {
                         cc.math.Matrix3.translateBy(this._spriteMatrix,
                             this._spriteFrame._offsetFromCenter.x,
                             this._spriteFrame._offsetFromCenter.y);

                         if (this._spriteFrame._rotated) {
                             cc.math.Matrix3.translateBy(this._spriteMatrix, w / 2, h / 2);
                             cc.math.Matrix3.rotateBy(this._spriteMatrix, Math.PI / 2);
                             cc.math.Matrix3.translateBy(this._spriteMatrix, -w / 2, -h / 2);
                         }

                         this._spriteMatrixSet = true;
                     }

         *
         * @private
         */
        __createMatrix() {

            var w= this.width;
            var h= this.height;

            this._spriteMatrixSet= false;

            var mat= this._spriteMatrix;

            if (this._flippedX && this._flippedY) {
                cc.math.Matrix3.set( mat, -1.0, 0.0, 0.0, -1.0, w, h );
                this._spriteMatrixSet= true;
            } else if (this._flippedX) {
                cc.math.Matrix3.set( mat, -1.0, 0.0, 0.0, 1.0, w, 0.0 );
                this._spriteMatrixSet= true;
            } else if (this._flippedY) {
                cc.math.Matrix3.set( mat, 1.0, 0.0, 0.0, -1.0, 0.0, h );
                this._spriteMatrixSet= true;
            } else {
                cc.math.Matrix3.identity( mat );
            }

            var sf= this._spriteFrame;

            if ( sf.needsSpecialMatrix() ) {
                mat[2]+= mat[0]*sf._offsetFromCenter.x;
                mat[5]+= mat[4]*sf._offsetFromCenter.y;

                if (sf._rotated) {
                    mat[2]+= mat[0]*w/2.0;
                    mat[5]+= mat[4]*h/2.0;

                    var t= mat[0];
                    mat[0]= mat[1];
                    mat[1]= -t;
                    t= mat[3];
                    mat[3]= mat[4];
                    mat[4]= -t;

                    cc.math.Matrix3.translateBy(mat, -w / 2.0, -h / 2.0);
                }

                this._spriteMatrixSet = true;
            }

            this._spriteMatrixDirty= false;
        }

        __setLocalTransform() {
            //super.__setLocalTransform();


            if ( this._rotation.x!==this.rotationAngle || (this.rotationAngle%360)!==0 || this.__isFlagSet(NodeDirtyFlags.REQUEST_TRANSFORM) ) {
                this.__setLocalTransformRotate();
            } else if ( this.scaleX!==this._scale.x || this._scale.y!==this.scaleY || this._scale.x!==1 || this._scale.y!==1 ) {
                this.__setLocalTransformScale();
            } else if ( this.x!==this._position.x || this.y!==this._position.y ) {

                var mm=this._modelViewMatrix;
                var pa=this._positionAnchor;
                var cs=this._contentSize;
                var x: number = this.x - pa.x * cs.width;
                var y: number = this.y - pa.y * cs.height;
                mm[2] = x;
                mm[5] = y;
                mm[0] = 1.0;
                mm[1] = 0.0;
                mm[3] = 0.0;
                mm[4] = 1.0;
                mm[6] = 0.0;
                mm[7] = 0.0;
                mm[8] = 1.0;

                this._position.x= this.x;
                this._position.y= this.y;
                this.__setFlag( NodeDirtyFlags.TRANSFORMATION_DIRTY );
            }

            if ( this.__isFlagSet(cc.node.NodeDirtyFlags.TRANSFORMATION_DIRTY ) ) {
                if ( this._spriteMatrixDirty ) {
                    this.__createMatrix();
                }
                if ( this._spriteMatrixSet ) {
                    cc.math.Matrix3.multiply(this._modelViewMatrix, this._spriteMatrix);
                }
            }
        }

        /**
         * Make the sprite to be horizontally mirrored.
         * @method cc.node.Sprite#setFlippedX
         * @param f {boolean} true to mirror, false by default.
         * @returns {cc.node.Sprite}
         */
        setFlippedX( f:boolean ) : Sprite {
            this._flippedX=f;
            this._spriteMatrixDirty= true;
            this.__setFlag(cc.node.NodeDirtyFlags.TRANSFORMATION_DIRTY );
            return this;
        }

        /**
         * Make the sprite to be vertically mirrored.
         * @method cc.node.Sprite#setFlippedY
         * @param f {boolean} true to mirror, false by default.
         * @returns {cc.node.Sprite}
         */
        setFlippedY( f:boolean ) : Sprite {
            this._flippedY=f;
            this._spriteMatrixDirty= true;
            this.__setFlag(cc.node.NodeDirtyFlags.TRANSFORMATION_DIRTY );
            return this;
        }

        resizeOnSpriteFrameSet( b:boolean ) : Sprite {
            this._resizeOnSpriteFrameSet= b;
            return this;
        }

        setTextureRect( r:cc.math.Rectangle ) {
            if ( this._spriteFrame ) {
                this.setSpriteFrame( this._spriteFrame.createSubSpriteFrame(r.x, r.y, r.w, r.h, this._name ) );
            }
        }

        set flippedX( b:boolean ) {
            this.setFlippedX(b);
        }

        set flippedY( b:boolean ) {
            this.setFlippedY(b);
        }
    }

    export class SpriteBatchNode extends Sprite {

        constructor( ddata : any, rect?:cc.math.Rectangle ) {
            super(null);
            this._resizeOnSpriteFrameSet= false;
            this.__init(ddata, rect);
        }
    }
}

/**
 * License: see license.txt file.
 */

/// <reference path="./Node.ts"/>
/// <reference path="./Sprite.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../render/DecoratedWebGLRenderingContext.ts"/>

module cc.node {

    import Node= cc.node.Node;
    import Sprite= cc.node.Sprite;
    import RenderingContext= cc.render.RenderingContext;

    /**
     * @class cc.node.FastSprite
     * @extends cc.node.Sprite
     * @classdesc
     *
     * While Nodes in general are heavy weight visual components, a Fast sprite is a very lightweight Node. In opposition
     * to a Node, a FastSprite:
     *   + scene graph does not discard it
     *   + expects to have no children. hierarchies are not handled.
     *   + get no input routed to it, such as mouse, touch, etc.
     *   + does not calculate a local bounding box, unless explicitly stated.
     *   + like old nodes, they expect than transformation and positional anchor point to be the same.
     *
     * <p>
     *     FastSprites aim at super fast management and rendering, specially in WebGL where a modern mobile phone could
     *     deliver several thousand of them at steady 60 fps.
     * <p>
     *     FastSprites are ideal for particle rendering, or for visually massive amount of nodes.
     * <p>
     *     If rendering in canvas, a FastSprite will be as fast a Sprite node. (way slower than FastSprite)
     *
     */
    export class FastSprite extends cc.node.Sprite {

        constructor( ddata : any ) {
            super(ddata);
        }

        visit(ctx:RenderingContext) {

            if (!this.__isFlagSet(NodeDirtyFlags.VISIBLE)) {
                return;
            }

            if (this._spriteFrame) {
                //ctx.globalAlpha = this._frameAlpha;
                //ctx.setTintColor(this._color);

                if ( ctx.type===cc.render.RENDERER_TYPE_WEBGL ) {
                    (<cc.render.DecoratedWebGLRenderingContext>ctx).batchGeometryWithSpriteFast(this);
                } else {
                    super.visit(ctx);
                }

            }
        }

    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../node/Node.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="../input/InputManager.ts"/>
/// <reference path="../input/MouseInputManager.ts"/>
/// <reference path="../render/RenderingContext.ts"/>

module cc {

    export module widget {
        import SpriteFrame= cc.node.sprite.SpriteFrame;


        export enum ButtonStatus {
            NORMAL= 0,
            PRESSED= 1,
            OVER= 2,
            DISABLED= 3
        }

        /**
         * @class cc.widget.Button
         * @classdesc
         *
         * @extends cc.node.Node
         *
         * A button is a special Node type that reacts to touch/mouse events.
         * It is described by 4 SpriteFrame objects of which only one is mandatory to set.
         * This are associated with the button states: normal, over, down and disabled. If any of the images is not defined,
         * they will fallback to use the normal-state image.
         */
        export class Button extends cc.node.Node {

            /**
             * Button images in this order: normal, pressed, over, disabled
             * @type {Array<cc.node.sprite.SpriteFrame>}
             * @private
             */
            _frames:SpriteFrame[] = [null, null, null, null];

            _status:ButtonStatus = ButtonStatus.NORMAL;

            _callback:()=>any = null;

            constructor() {
                super();

                this.enableEvents(true);

                var down = function (e:cc.input.MouseInputManagerEvent) {
                    if ( e.target._status===ButtonStatus.DISABLED ) {
                        return;
                    }
                    e.target.setStatus( ButtonStatus.PRESSED );
                };

                var click = function (e:cc.input.MouseInputManagerEvent) {
                    if ( e.target._status===ButtonStatus.DISABLED ) {
                        return;
                    }
                    e.target.setStatus( ButtonStatus.NORMAL );
                    if (e.target._callback) {
                        e.target._callback();
                    }
                };

                var over = function (e:cc.input.MouseInputManagerEvent) {
                    if ( e.target._status===ButtonStatus.DISABLED ) {
                        return;
                    }
                    e.target.setStatus( ButtonStatus.OVER );

                };

                var out = function (e:cc.input.MouseInputManagerEvent) {
                    if ( e.target._status===ButtonStatus.DISABLED ) {
                        return;
                    }
                    e.target.setStatus( ButtonStatus.NORMAL );
                };

                this.addEventListener("mousedown", down);
                this.addEventListener("touchstart", down);

                this.addEventListener("touchend", click);
                this.addEventListener("mouseclick", click);

                this.addEventListener("mouseover", over);
                this.addEventListener("touchover", over);

                this.addEventListener("mouseout", out);
                this.addEventListener("touchout", out);
            }

            disable() {
                this._status= ButtonStatus.DISABLED;
                this.enableEvents(false);
            }

            enable() {
                this._status= ButtonStatus.NORMAL;
                this.enableEvents(true);
            }

            setEnabled( b:boolean ) {
                if (b) {
                    this.enable();
                } else {
                    this.disable();
                }
            }

            draw( ctx:cc.render.RenderingContext ) {
                var sf= this.__getCurrentFrame();
                if ( sf ) {
                    ctx.setGlobalAlpha( this._frameAlpha );
                    ctx.setTintColor(this._color);
                    sf.draw( ctx, this.width, this.height );
                }
            }

            init( obj ) {
                if ( obj.normal ) {
                    this._frames[ ButtonStatus.NORMAL ]= obj.normal;
                }
                if ( obj.pressed ) {
                    this._frames[ ButtonStatus.PRESSED ]= obj.pressed;
                }
                if ( obj.over ) {
                    this._frames[ ButtonStatus.OVER ]= obj.over;
                }
                if ( obj.disabled ) {
                    this._frames[ ButtonStatus.DISABLED ]= obj.disabled;
                }

                this._status= ButtonStatus.NORMAL;

                if ( obj.callback ) {
                    this._callback= obj.callback;
                }

                this.width= obj.normal.getWidth();
                this.height= obj.normal.getHeight();
            }

            __getCurrentFrame() : SpriteFrame {
                return this._frames[this._status] || this._frames[ ButtonStatus.NORMAL ];
            }

            setStatus( st:ButtonStatus ) {
                this._status= st;

                var frame= this.__getCurrentFrame();

                this.setContentSize( frame.getWidth(), frame.getHeight() );
            }
        }

    }

    export function MenuItemSprite( normal, selected, disabled, callback, context ) {
        var button:cc.widget.Button = new cc.widget.Button();

        button.setAnchorPoint(.5,.5);

        var obj:any= {
            normal: normal._spriteFrame
        };

        if (selected) {
            obj.pressed= selected._spriteFrame;
        }
        if (disabled) {
            obj.disabled= disabled._spriteFrame;
        }
        if (callback) {
            obj.callback= context ? callback.bind(context) : callback;
        }

        button.init(obj);

        return button;
    }

    export function MenuItemLabel( label:cc.widget.Label, callback:any ) {

        if ( callback ) {
            label.enableEvents(true);

            label.addEventListener("mouseclick", function (e) {
                if (e.target._enabled) {
                    callback();
                }
            });

            label.addEventListener("touchend", function (e) {
                if (e.target._enabled) {
                    callback();
                }
            });
        }

        return label;
    }

    export class MenuItemFont extends cc.node.Node {

        _label:cc.widget.LabelTTF = null;
        _callback:()=>any = null;
        _enabled:boolean = true;

        constructor(_initializer:cc.widget.LabelTTFInitializer|string, callback:()=>any, target:any) {

            super();

            var label:cc.widget.LabelTTF;

            if ( typeof _initializer==="string" ) {

                label = new cc.widget.LabelTTF( <string>_initializer, cc.MenuItemFont.DEFAULT_FONT, cc.MenuItemFont.DEFAULT_SIZE );

            } else {
                label = new cc.widget.LabelTTF();
                label.initialize(<cc.widget.LabelTTFInitializer>_initializer);
            }
            this._label = label;

            if (callback) {

                this._callback = target ? callback.bind(target) : callback;

                this._label.enableEvents(true);
                this._label.addEventListener("mouseup", (e)=> {
                    if (this._enabled) {
                        this._callback();
                    }
                });
                this._label.addEventListener("touchend", (e)=> {
                    if (this._enabled) {
                        this._callback();
                    }
                });
            }

            this.addChild(this._label);
            this._label.setPositionAnchor(0, 0);
            this.setContentSize(this._label.width, this._label.height);
        }

        setFontSize(s) {
            this._label.setFontSize(s);
        }

        getFontSize() {
            return this._label.getFontSize()
        }

        setFontName(name) {
            this._label.setFont(name);
        }

        getFontName() {
            return this._label.getFont();
        }

        setEnabled(b:boolean) {
            this._label.setEnabled(b);
        }

        get fontSize():number {
            return this._label._size;
        }

        set fontSize(v:number) {
            this._label._size = v;
        }

        get fontName():string {
            return this._label._font;
        }

        set fontName(v:string) {
            this._label._font = v;
        }

        static DEFAULT_SIZE : number= 16;
        static DEFAULT_FONT : string= "Arial";

        static setFontSize(fontSize) {
            cc.MenuItemFont.DEFAULT_SIZE = fontSize;
        }

        static fontSize() {
            return cc.MenuItemFont.DEFAULT_SIZE;
        }

        static setFontName(name) {
            cc.MenuItemFont.DEFAULT_FONT = name;
        }
    }


    export class Menu extends cc.node.Node {

        _buttons: cc.widget.Button[];
        _padding: number;

        constructor( ...buttons:cc.widget.Button[] ) {
            super();

            for( var i=0; i<buttons.length; i++ ) {
                this.addChild( buttons[i] );
            }

            this.setPositionAnchor(0,0);

            var winSize= cc.director.getWinSize();
            this.setPosition(winSize.width / 2, winSize.height / 2);
            this.setContentSize(winSize.width,winSize.height);
        }

        alignItemsVerticallyWithPadding(padding) {

            this._padding= padding + this.y;

            var height = -padding, locChildren = this._children, len, i, locScaleY, locHeight, locChild;
            if (locChildren && locChildren.length > 0) {
                for (i = 0, len = locChildren.length; i < len; i++)
                    height += locChildren[i].height * locChildren[i].scaleY + padding;

                var y = height / 2.0;

                for (i = 0, len = locChildren.length; i < len; i++) {
                    locChild = locChildren[i];
                    locHeight = locChild.height;
                    locScaleY = locChild.scaleY;
                    locChild.setPosition(0, y - locHeight * locScaleY / 2);
                    y -= locHeight * locScaleY + padding;
                }
            }
        }

        alignItemsInColumns(/*Multiple Arguments*/) {

            var rows = [];
            for (var i = 0; i < arguments.length; i++) {
                rows.push(arguments[i]);
            }
            var height = -5;
            var row = 0;
            var rowHeight = 0;
            var columnsOccupied = 0;
            var rowColumns, tmp, len;
            var locChildren = this._children;
            if (locChildren && locChildren.length > 0) {
                for (i = 0, len = locChildren.length; i < len; i++) {
                    if (row >= rows.length)
                        continue;

                    rowColumns = rows[row];
                    // can not have zero columns on a row
                    if (!rowColumns)
                        continue;

                    tmp = locChildren[i].height;
                    rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);

                    ++columnsOccupied;
                    if (columnsOccupied >= rowColumns) {
                        height += rowHeight + 5;

                        columnsOccupied = 0;
                        rowHeight = 0;
                        ++row;
                    }
                }
            }
            // check if too many rows/columns for available menu items
            //cc.assert(!columnsOccupied, "");    //?
            var winSize = cc.director.getWinSize();

            row = 0;
            rowHeight = 0;
            rowColumns = 0;
            var w = 0.0;
            var x = 0.0;
            var y = (height / 2);

            if (locChildren && locChildren.length > 0) {
                for (i = 0, len = locChildren.length; i < len; i++) {
                    var child = locChildren[i];
                    if (rowColumns == 0) {
                        rowColumns = rows[row];
                        w = winSize.width / (1 + rowColumns);
                        x = w;
                    }

                    tmp = child.height;
                    rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);
                    child.setPosition(x - winSize.width / 2, y - tmp / 2);

                    x += w;
                    ++columnsOccupied;

                    if (columnsOccupied >= rowColumns) {
                        y -= rowHeight + 5;
                        columnsOccupied = 0;
                        rowColumns = 0;
                        rowHeight = 0;
                        ++row;
                    }
                }
            }
        }
    }

    export class MenuItemToggle extends cc.node.Node {

        _currentOptionIndex : number= -1;
        _options : cc.node.Node[]= [];
        _callback : (m:cc.node.Node)=>any = null;
        _enabled : boolean = true;

        constructor() {
            super();

            this.setAnchorPoint(.5,.5);

            this.enableEvents(true);
            this.addEventListener( "mouseup", (e) => {
                if ( this._enabled ) {
                    this.__nextOption();
                }
            });
            this.addEventListener( "touchup", (e) => {
                if ( this._enabled ) {
                    this.__nextOption();
                }
            });

            this.__init.call( this, Array.prototype.slice.call(arguments) );
        }

        setEnabled(b:boolean) {
            this._enabled= b;
            for( var i=0; i<this._options.length; i++ ) {
                var node=<any>this._options[i];
                if ( typeof node.setEnabled!=="undefined" ) {
                    node.setEnabled(b);
                }
            }
        }

        initWithItems() {
            this.__init.call( this, Array.prototype.slice.call(arguments) );
        }

        __init( args:any[] ) {
            var len= args.length;
            if (typeof args[args.length - 2]==='function') {
                len-=2;
                this._callback= args[args.length-2].bind( args[args.length-1] );
            } else if (typeof args[args.length - 1]==='function') {
                len-=1;
                this._callback=args[args.length-1];
            }

            for( var i=0; i<len; i++ ) {
                this.addItem( args[i] );
            }

            this.setSelectedIndex(0);
        }

        addItem( node:cc.node.Node ) {

            node.setAnchorPoint(0.5, 0.5);
            node.visible= false;

            this._options.push( node );

            this.addChild(node);
            if ( this._children.length===1 ) {
                this.setSelectedIndex( 0 );
            }
        }

        setCallback( callback:(m:cc.node.Node)=>any ) {
            this.onClick(callback);
        }

        onClick( callback:(m:cc.node.Node)=>any ) {
            this._callback= callback;
        }

        setSelectedIndex( index:number ) {
            if ( this._options.length===0 ) {
                return;
            }

            index%=this._children.length;
            if ( index!==this._currentOptionIndex ) {
                if ( this._currentOptionIndex!==-1 ) {
                    this._options[ this._currentOptionIndex ].visible= false;
                }
                this._currentOptionIndex= index;
                var co:cc.node.Node= this._options[ this._currentOptionIndex ];
                co.setPosition( co.width/2, co.height/2 );
                co.visible= true;
                this.setContentSize( co.width, co.height );
            }
        }

        __emit() {
            if ( this._callback ) {
                this._callback( this._currentOptionIndex!==-1 ? this._options[this._currentOptionIndex] : null );
            }
        }

        __nextOption() {
            if ( this._children.length===0 ) {
                return;
            }

            this.setSelectedIndex( this._currentOptionIndex===-1 ? 0 : this._currentOptionIndex+1 );
            this.__emit();
        }

    }
}

/**
 * License: see license.txt file
 */

/// <reference path="../math/Dimension.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="../render/RenderingContext.ts"/>
/// <reference path="../render/Texture2D.ts"/>
/// <reference path="../plugin/font/SpriteFont.ts"/>

module cc.widget {

    export enum VALIGN  {
        TOP= 0,
        MIDDLE=1,
        BOTTOM= 2
    }

    export enum HALIGN  {
        LEFT= 0,
        CENTER=1,
        RIGHT= 2
    }

    /**
     * @class cc.widget.Label
     * @extends cc.node.Node
     * @classdesc
     *
     * This object represents a label widget which simply writes text.
     * The text is written using a SpriteFont object which must be in the AssetManager cache.
     *
     * The label text can be drawn freely, that is each text line will span as much width as needed (method
     * or flow constrained by calling <code>setFlowWidth</code where the text will be drawn to a fixed width.
     *
     * For both methods, the label will calculate its bounds upon text or font change. You can override this behavior
     * by calling <code>setResizeContentSize(bool)</code>
     *
     * The text can be multiline text separated by \n characters.
     *
     *
     *
     */
    export class Label extends cc.node.Node {

        _text : string = '';
        _textSize : cc.math.Dimension= null;
        _font : cc.plugin.font.SpriteFont = null;
        _resizeContentSize : boolean = true;

        _valign : cc.widget.VALIGN = cc.widget.VALIGN.MIDDLE;
        _halign : cc.widget.HALIGN = cc.widget.HALIGN.CENTER;

        _enabled:boolean = true;

        _flowWidth:number= 0;

        /**
         * Build a new LabelBM object instance.
         * @param text {string} label text.
         * @param fontName {string} a cc.plugin.font.SpriteFont in the AssetManager cache object name.
         */
        constructor( text:string, fontName:string ) {
            super();

            this._text= text;
            this._font= cc.plugin.asset.AssetManager.getSpriteFont( fontName );
            this.__measureText();
        }

        setResizeContentSize( b:boolean ) : Label {
            this._resizeContentSize= b;
            return this;
        }

        __measureText() {
             if ( this._font ) {
                 var d:cc.math.Dimension = this._font.getTextSize(this._text, this._flowWidth);
                 this._contentSize.width = this._flowWidth ? this._flowWidth : d.width;
                 this._contentSize.height = d.height;
                 this._textSize = d;
             }
        }

        setFont( fontName:string ) {
            var fn= cc.plugin.asset.AssetManager.getSpriteFont( fontName );
            if ( null!==fn ) {
                this._font= fn;
                if ( this._resizeContentSize ) {
                    this.__measureText();
                }
            }
        }

        setText( text:string ) {
            this._text= text;
            if ( this._resizeContentSize ) {
                this.__measureText();
            }
        }

        setHAlign( a : cc.widget.HALIGN ) : Label {
            this._halign= a;
            return this;
        }

        setVAlign( a : cc.widget.VALIGN ) : Label {
            this._valign= a;
            return this;
        }

        draw( ctx:cc.render.RenderingContext ) {
            super.draw( ctx );
            if ( this._font ) {
                this._font.drawTextInRect( ctx,
                    this._text,
                    0,0,
                    this._contentSize.width, this._contentSize.height,
                    this._halign, this._valign );
            }
        }

        get textAlign() : cc.widget.HALIGN {
            return this._halign;
        }

        set textAlign( v:cc.widget.HALIGN ) {
            this._halign= v;
        }

        get textVerticalAlign() : cc.widget.VALIGN {
            return this._valign;
        }

        set textVerticalAlign( v:cc.widget.VALIGN ) {
            this._valign= v;
        }

        /**
         *
         * @param text
         * @deprecated
         */
        setString( text:string ) {
            this.setText(text);
        }

        setEnabled(e:boolean) {
            this._enabled= e;
        }

        flowWidth( f:number ) : Label {
            this._flowWidth= f;
            this.__measureText();
            return this;
        }
    }

    var __index=0;

    export interface LabelTTFInitializer {
        text : string;
        font : string;
        size : number;

        flowWidth? : number;

        fillColor?: any;
        strokeColor? : any;
        strokeSize? : number;
        fill? : boolean;
        stroke? : boolean;

        shadowBlur? : number;
        shadowColor? : any;
        shadowOffsetX? : number;
        shadowOffsetY? : number;

        horizontalAlignment? : number;
        verticalAlignment? : number;
    }

    export class LabelTTF extends cc.node.Sprite {

        _text : string = null;
        _font : string = "Arial";
        _size : number = 16;
        _flow : boolean = false;
        _flowWidth : number = 1024;
        _fillColor : string = "#fff";
        _strokeColor : string = "#ccc";
        _strokeSize : number = 1;

        _fill : boolean = true;
        _stroke:boolean = false;

        _shadowBlur : number = 0;
        _shadowColor : any = "#ff0";
        _shadowOffsetX : number = 0;
        _shadowOffsetY : number = 0;

        _texture: cc.render.Texture2D= null;

        _horizontalAlignment : HALIGN= HALIGN.LEFT;
        _verticalAlignment : VALIGN= VALIGN.MIDDLE;

        _enabled : boolean = true;

        constructor( _initializer?:LabelTTFInitializer|string,
                        font?:string, fontSize?:number,
                        dimensions?:cc.math.Dimension,
                        halign?:cc.widget.HALIGN, valign?:cc.widget.VALIGN ) {

            super(null);

            var initializer:LabelTTFInitializer;

            if ( typeof _initializer==="string" ) {
                // old calls
                initializer= {
                    text: <string>_initializer,
                    font: typeof font !== "undefined" ? font : this._font,
                    size: typeof fontSize !== "undefined" ? fontSize : this._size
                };

                if ( typeof dimensions!=="undefined" ) {
                    initializer.flowWidth= dimensions.width;
                }

                initializer.horizontalAlignment= typeof halign!=="undefined" ? halign : this._horizontalAlignment;
                initializer.verticalAlignment= typeof valign!=="undefined" ? valign : this._verticalAlignment;

            } else {
                initializer= <LabelTTFInitializer>_initializer;
            }

            if ( initializer ) {
                this.initialize(initializer);

                if (initializer.text) {
                    this.__initLabel();
                }
            }
        }

        initialize( init:LabelTTFInitializer ) : LabelTTF {

            this._text= init.text;
            if ( typeof init.font!=="undefined" ) { this._font= init.font; };
            if ( typeof init.size!=="undefined" ) { this._size= init.size; };

            this._flow= typeof init.flowWidth!=='undefined';
            if (typeof init.flowWidth!=='undefined') { this._flowWidth=init.flowWidth; }

            if (typeof init.fillColor!=='undefined') { this._fillColor= init.fillColor; }
            if (typeof init.strokeColor!=='undefined'){ this._strokeColor= init.strokeColor; }
            if (typeof init.strokeSize!=='undefined' ){ this._strokeSize= init.strokeSize; }

            if (typeof init.fill!=='undefined') { this._fill= init.fill; }
            if (typeof init.stroke!=='undefined') {this._stroke=init.stroke; }

            if (typeof init.shadowBlur!=='undefined') {this._shadowBlur= init.shadowBlur; }
            if (typeof init.shadowColor!=='undefined') {this._shadowColor=init.shadowColor; }
            if (typeof init.shadowOffsetX==='undefined') {this._shadowOffsetX= init.shadowOffsetX; }
            if (typeof init.shadowOffsetY==='undefined') {this._shadowOffsetY=init.shadowOffsetY; }

            if (typeof init.horizontalAlignment!=="undefined") { this._horizontalAlignment= init.horizontalAlignment; }
            if (typeof init.verticalAlignment!=="undefined") { this._verticalAlignment= init.verticalAlignment; }

            this.__initLabel();

            return this;
        }

        setEnabled( b:boolean ) {
            this._enabled= b;
        }

        setText( text:string ) {
            if ( this._text===text ) {
                return;
            }

            this._text= text;
            this.__initLabel();
        }

        setString( text:string ) {
            this.setText(text);
        }

        __initLabel() {

            if ( this._texture ) {
                this._texture.release();
            }

            var canvas= document.createElement("canvas");
            var ctx= canvas.getContext("2d");

            this.__prepareContext(ctx);

            var textSize:cc.math.Dimension= this.__getTextSize( ctx, this._text, this._flowWidth );

            var canvas= this.__drawText( this._text, textSize );

            var textureId= "labelTTF"+__index++;
            this._texture= new cc.render.Texture2D( canvas, textureId );

            this.setSpriteFrame( new cc.node.sprite.SpriteFrame( this._texture ) );
        }

        __prepareContext( ctx:CanvasRenderingContext2D ) {

            ctx.font= ""+this._size+"px "+this._font;
            ctx.textBaseline= "top";

            ctx.fillStyle= this._fillColor;

            if ( this._stroke ) {
                ctx.strokeStyle = this._strokeColor;
                ctx.lineWidth= this._strokeSize;
            }

            if ( this._shadowBlur ) {
                ctx.shadowBlur= this._shadowBlur;
                ctx.shadowColor= this._shadowColor;
                ctx.shadowOffsetX= this._shadowOffsetX;
                ctx.shadowOffsetY= this._shadowOffsetY;
            }

        }

        __drawText( text:string, size:cc.math.Dimension ) {

            var y=0;
            var flowWidth= size.width;

            var offsetX= 0;
            var offsetY= 0;
            if ( this._stroke ) {
                offsetX+= this._strokeSize / 2;
                offsetY+= this._strokeSize / 2;
                size.width+= this._strokeSize;
            }
            if ( this._shadowBlur ) {
                size.width+= this._shadowBlur + this._shadowOffsetX;
                size.height+= this._shadowBlur + this._shadowOffsetY;

                offsetX+= this._shadowBlur / 2 + this._shadowOffsetX;
                offsetY+= this._shadowBlur / 2 + this._shadowOffsetY * (cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM ? -1 : 1);
            }

            var canvas= document.createElement("canvas");
            canvas.width= size.width;
            canvas.height= size.height;
            var ctx= canvas.getContext("2d");
            this.__prepareContext(ctx);

            y= offsetY;

            var lines= text.split("\n");
            for( var l=0; l<lines.length; l++ ) {

                var x:number= offsetX;
                var words= lines[l].split(" ");

                for( var w=0; w<words.length; w++ ) {

                    var word= words[w] + (w<words.length-1 ? " " : "");
                    var wordLength= ctx.measureText(word).width;

                    if ( x+wordLength > flowWidth ) {
                        y+= this._size;
                        x= 0;
                    }

                    if ( this._stroke ) {
                        ctx.strokeText(word,x,y);
                    }
                    if ( this._fill ) {
                        ctx.fillText(word, x, y);
                    }

                    x += wordLength;
                }

                y+= this._size;
            }

            return canvas;
        }

        __getTextSize( ctx:CanvasRenderingContext2D, text:string, flowWidth:number ) : cc.math.Dimension {

            var dim= new cc.math.Dimension();
            flowWidth= this._flowWidth;


            var lines= text.split("\n");
            for( var l=0; l<lines.length; l++ ) {


                var x:number= 0;
                var words= lines[l].split(" ");

                for( var w=0; w<words.length; w++ ) {

                    var word= words[w] + (w<words.length-1 ? " " : "");
                    var wordLength= ctx.measureText(word).width;

                    if ( x+wordLength > flowWidth ) {
                        dim.width= Math.max( dim.width, x );
                        dim.height+= this._size;
                        x= wordLength;
                    } else {
                        x+=wordLength;
                    }
                }

                dim.height+= this._size;
                dim.width= Math.max( dim.width, x );
            }

            if ( this._flow ) {
                dim.width= flowWidth;
            }

            return dim;
        }

        getFont() : string {
            return this._font;
        }

        setFont( font:string ) {
            this._font= font;
            this.__initLabel();
        }

        setFontSize(s:number) {
            this._size= s;
            this.__initLabel();
        }

        getFontSize() : number {
            return this._size;
        }
    }
}
/**
 * License: see license.txt file
 */

module cc.render {


    /**
     * @namespace WebGLState
     * @memberOf cc.render
     *
     * @classdesc
     * This object keeps global webGL state. It has two main purposes.
     *  + Avoid duplicate webgl calls.
     *  + Share internal renderer state with external shaders or renderers so that WebGL state can be consistent when
     *    getting back to the renderer.
     *
     */
    export class WebGLState {

        /**
         * Current program
         * @member cc.render.WebGLState#_currentProgram
         * @type {WebGLProgram}
         */
        _currentProgram : WebGLProgram = null;

        /**
         * Current texture
         * @member cc.render.WebGLState#_currentTexture
         * @type {WebGLTexture}
         */
        _currentTexture : WebGLTexture = null;

        /**
         * blendFunc source blending value.
         * @member cc.render.WebGLState#_blendSource
         * @type {number}
         * @private
         */
        _blendSource : number = -1;

        /**
         * blendFunc destination blending value.
         * @member cc.render.WebGLState#_blendDestination
         * @type {number}
         * @private
         */
        _blendDestination : number = -1;

        /**
         * Object to hold gl flags values, particularly, all calls to gl.enable
         * @member cc.render.WebGLState#_flags
         * @type {{flag:number, enabled:boolean}}
         * @private
         */
        _flags : any = {};

        /**
         * current gl.clearColor value.
         * @member cc.render.WebGLState#_clearColor
         * @type {Array<number>}
         * @private
         */
        _clearColor : number[] = [-1,-1,-1,-1];

        /**
         * current gl.viewport value.
         * @member cc.render.WebGLState#_viewport
         * @type {Array<number>}
         * @private
         */
        _viewport : number[] = [-1,-1,-1,-1];

        /**
         * gl.TEXTURE<XX> values.
         * @member cc.render.WebGLState#_texture
         * @type {{ texture:number, enabled:boolean }}
         * @private
         */
        _texture : any = {};

        /**
         * WebGLUniformLocation dictionary.
         * @member cc.render.WebGLState#_uniformLocation
         * @type {{uniform:WebGLUniformLocation, value:any}}
         * @private
         */
        _uniformLocation : any = {};

        /**
         * vertex attrib array enabled values.
         * @member cc.render.WebGLState#_attribArray
         * @type {Map<number,boolean>}
         * @private
         */
        _attribArray : any = {
            0 : false,
            1 : false,
            2 : false,
            3 : false,
            4 : false,
            5 : false,
            6 : false,
            7 : false,
            8 : false,
            9 : false,
            10: false
        };

        _attribPointers : any = {};

        constructor( public _gl:WebGLRenderingContext) {

            // create TEXTURE<X> entries.
            for( var i=0; i<16; i++ ) {
                this._texture[ _gl["TEXTURE"+i] ]= false;
            }

        }

        useProgram( program:WebGLProgram ) {
            if ( program!==this._currentProgram ) {
                this._currentProgram= program;
                this._gl.useProgram( program );
            }
        }

        /**
         *
         * @param i {number} gl.TEXTURE<X> value.
         */
        activeTexture( i : number ) {
            if ( !this._texture[i] ) {
                this._texture[i]= true;
                this._gl.activeTexture( i );
            }
        }

        bindTexture( type:number, t:WebGLTexture ) {
            if ( t!==this._currentTexture ) {
                this._gl.bindTexture(type, t);
                this._currentTexture= t;
            }
        }

        enable( flag : number ) {

            if ( !this._flags.hasOwnProperty(flag) ) {
                this._flags[flag]= false;
                this._gl.enable( flag );
                return;
            }

            if ( this._flags[flag] ) {
                return;
            }

            this._flags[flag]= true;
            this._gl.enable( flag );
        }

        flagEnabled( flag ) : boolean {
            return this._flags[flag];
        }

        disable( flag : number ) {

            if ( !this._flags.hasOwnProperty(flag) ) {
                this._flags[flag]= false;
                this._gl.disable( flag );
                return;
            }

            if ( !this._flags[flag] ) {
                return;
            }

            this._flags[flag]= false;
            this._gl.disable( flag );
        }

        clear( flags ) {
            this._gl.clear( flags );
        }

        clearColor( r:number, g:number, b:number, a:number ) {
            if (r!==this._clearColor[0] ||
                g!==this._clearColor[1] ||
                b!==this._clearColor[2] ||
                a!==this._clearColor[3] ) {

                this._clearColor[0]=r;
                this._clearColor[1]=g;
                this._clearColor[2]=b;
                this._clearColor[3]=a;

                this._gl.clearColor(r,g,b,a);
            }
        }

        viewport( x:number, y:number, w:number, h:number ) {
            if (x!==this._viewport[0] ||
                y!==this._viewport[1] ||
                w!==this._viewport[2] ||
                h!==this._viewport[3] ) {

                this._viewport[0]= x;
                this._viewport[1]= y;
                this._viewport[2]= w;
                this._viewport[3]= h;

                this._gl.viewport(x,y,w,h);
            }
        }

        blendFunc( blendSource:number, blendDestination:number ) {
            if ( this._blendSource!==blendSource || this._blendDestination!==blendDestination ) {

                this._blendSource= blendSource;
                this._blendDestination= blendDestination;

                this._gl.blendFunc(blendSource, blendDestination);
            }
        }

        __uniform1Scalar( location:any, value:any ) {

            // pending remove hasOwnProperty with prior initialization
            if ( !this._uniformLocation.hasOwnProperty(location._id) ) {
                this._uniformLocation[location._id]= null;
            }

            if ( this._uniformLocation[location._id]!==value ) {
                this._gl.uniform1i( location, value );
                this._uniformLocation[location._id]= value;
            }
        }

        uniform1i( location:any, value:any ) {
            this.__uniform1Scalar( location, value );
        }

        uniform1f( location:any, value:any ) {
            this.__uniform1Scalar( location, value );
        }

        uniformMatrix4fv( location:any, transpose:boolean, value:Float32Array ) {

            // pending remove hasOwnProperty with prior initialization
            if ( !this._uniformLocation.hasOwnProperty(location._id) ) {
                this._uniformLocation[location._id]= [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];
            }

            var v0= this._uniformLocation[location._id];

            if ( v0[0] !==value[0]  || v0[1] !==value[1]  || v0[2] !==value[2]  || v0[3] !==value[3]  ||
                 v0[4] !==value[4]  || v0[5] !==value[5]  || v0[6] !==value[6]  || v0[7] !==value[7]  ||
                 v0[8] !==value[8]  || v0[9] !==value[9]  || v0[10]!==value[10] || v0[11]!==value[11] ||
                 v0[12]!==value[12] || v0[13]!==value[13] || v0[14]!==value[14] || v0[15]!==value[15]    ) {

                this._gl.uniformMatrix4fv(location, transpose, value);
                this._uniformLocation[location._id] = value;
            }
        }

        vertexAttribPointer( locationIndex : number, size : number, type : number, normalized : boolean, stride : number, offset : number ) {
/*
            if (!this._attribPointers.hasOwnProperty(locationIndex)) {
                this._attribPointers[locationIndex]= {
                    size : -1,
                    type : -1,
                    normalized : false,
                    stride : -1,
                    offset : -1
                };
            }

            var v= this._attribPointers[locationIndex];
            if ( v.size!==size || v.type!==type || v.normalized!==normalized || v.stride!==stride || v.offset!==offset) {

                v.size= size;
                v.type= type;
                v.normalized= normalized;
                v.stride= stride;
                v.offset= offset;

            }
*/
            this._gl.vertexAttribPointer(locationIndex, size, type, normalized, stride, offset);

        }

        enableVertexAttribArray( locationIndex:number ) {
            if ( !this._attribArray.hasOwnProperty(locationIndex) ) {
                this._attribArray[locationIndex]= false;
            }

            if ( this._attribArray[locationIndex] ) {
                return;
            }

            this._attribArray[locationIndex]= true;
            this._gl.enableVertexAttribArray(locationIndex);
        }

        disableVertexAttribArray( locationIndex:number ) {
            if ( !this._attribArray.hasOwnProperty(locationIndex) ) {
                this._attribArray[locationIndex]= false;
            }

            if ( !this._attribArray[locationIndex] ) {
                return;
            }

            this._attribArray[locationIndex]= false;
            this._gl.disableVertexAttribArray(locationIndex);
        }

        setTexture( textureIndex:number, textureId:WebGLTexture ) {

            if ( textureId!==this._currentTexture ) {
                this.activeTexture(this._gl.TEXTURE0);
                this.bindTexture(this._gl.TEXTURE_2D, textureId);
                this._currentTexture= textureId;
            }

        }
    }
}
/**
 * License: see license.txt file.
 */


/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="../node/Director.ts"/>
/// <reference path="../action/Action.ts"/>
/// <reference path="../action/MoveAction.ts"/>
/// <reference path="../action/TimeInterpolator.ts"/>

module cc.transition {

    import Node = cc.node.Node;
    import NodeDirtyFlags= cc.node.NodeDirtyFlags;
    import Scene = cc.node.Scene;
    import Director = cc.node.Director;
    import Action = cc.action.Action;
    import MoveAction = cc.action.MoveAction;
    import Interpolator = cc.action.Interpolator;
    import TimeInterpolator = cc.action.TimeInterpolator;

    /**
     * Callback definition for transition end events.
     * @memberOf cc.transition
     * @callback CallbackTransitionEnd
     * @param transition {cc.transition.Transition} Transition triggering end events.
     */
    export interface CallbackTransitionEnd {
        (transition:Transition) : void;
    }

    /**
     * @class cc.transition.Transition
     * @classdesc
     *
     * Transitions are special action groups that move in and out Scenes.
     * <br>
     * As such, only Scenes have Transtions applied, while regulars Nodes have Actions.
     * This is the preferred way for a Director to switch between scenes by calling
     * <code>director.runScene( scene, transition )</code>.
     */
    export class Transition {

        /**
         * Director callback for transition end events.
         * @member cc.transition.Transition#_transitionCallback
         * @type {cc.transition.CallbackTransitionEnd}
         * @private
         */
        _transitionCallback:CallbackTransitionEnd = null;

        /**
         * User defined callback for transition end events.
         * @member cc.transition.Transition#_userTransitionCallback
         * @type {cc.transition.CallbackTransitionEnd}
         * @private
         */
        _userTransitionCallback:CallbackTransitionEnd = null;

        /**
         * Transition duration in milliseconds.
         * @member cc.transition.Transition#_duration
         * @type {number}
         * @private
         */
        _duration:number = 0;

        /**
         * Transition interpolator.
         * <br>
         * {@link cc.action.TimeInterpolator}
         * @member cc.transition.Transition#_interpolator
         * @type {cc.action.TimeInterpolator}
         * @private
         */
        _interpolator:TimeInterpolator = Interpolator.Linear(false, false);

        /**
         * Scene to get in. This is a V3 backwards compatibility need.
         * In v3, Transition extends Scene.
         * In v4, Transition does NOT extend Scene.
         * To keep the director.runAction( Scene|Transition ) method signature, the transition must
         * be built with a target Scene in.
         * @member cc.transition.Transition#_sceneIn
         * @type {cc.node.Scene}
         * @private
         */
        _sceneIn:Scene= null;

        /**
         * Create a new Transition
         * @method cc.transition.Transition#constructor
         * @param duration {number} transition duration in milliseconds.
         */
        constructor(duration:number, scene?:Scene) {
            this._duration = duration;
            this._sceneIn= scene;
        }

        /**
         * Initialize the transition.
         * @method cc.transition.Transition#initialize
         * @param sceneIn {cc.node.Scene} entering scene.
         * @param sceneOut {cc.node.Scene} exiting scene
         * @returns {cc.transition.Transition} the initialized transition
         */
        initialize(sceneIn:Scene, sceneOut:Scene):Transition {
            return this;
        }

        /**
         * Register director callback for transition end events.
         * @method cc.transition.Transition#onDirectorTransitionEnd
         * @param callback {cc.transition.CallbackTransitionEnd}
         * @returns {cc.transition.Transition}
         */
        onDirectorTransitionEnd(callback:CallbackTransitionEnd):Transition {
            this._transitionCallback = callback;
            return this;
        }

        /**
         * Register user callback for transition end events.
         * @method cc.transition.Transition#onTransitionEnd
         * @param callback {cc.transition.CallbackTransitionEnd}
         * @returns {cc.transition.Transition}
         */
        onTransitionEnd(callback:CallbackTransitionEnd):Transition {
            this._userTransitionCallback = callback;
            return this;
        }

        /**
         * Set the transition interpolator.
         * @method cc.transition.Transition#setInterpolator
         * @param i {cc.action.TimeInterpolator}
         * @returns {cc.transition.Transition}
         */
        setInterpolator(i:TimeInterpolator):Transition {
            this._interpolator = i;
            return this;
        }

        /**
         * Prepare the Transition Actions callbacks.
         * In a transition, only the entering scene is mandatory. For example, when the director starts and only one
         * scene slides in.
         * @method cc.transition.Transition#__setupActionCallbacks
         * @param actionIn {cc.node.Scene} enter scene.
         * @param actionOut {cc.node.Scene=} exit scene.
         * @private
         */
        __setupActionCallbacks(actionIn:Action, actionOut?:Action):void {

            actionIn.onStart((action:Action, target:Node) => {
                (<Scene>target).callOnEnter();
            });
            actionIn.onEnd((action:Action, target:Node) => {
                if (this._transitionCallback) {
                    this._transitionCallback(this);
                }
                if (this._userTransitionCallback) {
                    this._userTransitionCallback(this);
                }

                (<Scene>target).callOnEnterTransitionDidFinish();
            });

            if (actionOut) {

                actionOut.onStart((action:Action, target:Node) => {
                    (<Scene>target).callOnExitTransitionDidStart();
                });
                actionOut.onEnd((action:Action, target:Node) => {
                    (<Scene>target).callOnExit();
                    (<Scene>target).__clearFlag(NodeDirtyFlags.VISIBLE)
                });
            }
        }

    }

    /**
     * Enumeration for TransitionMove directions.
     *
     * @tsenum cc.transition.TransitionMoveDirection
     */
    export enum TransitionMoveDirection {
        LEFT = 0,
        RIGHT = 1,
        TOP = 2,
        BOTTOM = 3
    }

    /**
     * @class cc.transition.TransitionFade
     * @classdesc
     */
    export class TransitionFade extends Transition {

        /**
         *
         * @param duration
         */
        constructor(duration:number, scene?:Scene) {
            super(duration, scene);
        }

        initialize(sceneIn:Scene, sceneOut?:Scene):Transition {

            var actionIn:Action = null;
            var actionOut:Action = null;
            var director:Director = null;

            sceneIn.resetScene();
            sceneIn.setAlpha(0);

            actionIn = cc.FadeIn.create(this._duration / 1000);
            if (this._interpolator) {
                actionIn.setInterpolator(this._interpolator);
            }

            director = <Director>sceneIn.getParent();
            director._scenesActionManager.scheduleActionForNode(sceneIn, actionIn);

            if (sceneOut) {
                sceneOut.resetScene();
                actionOut = cc.FadeOut.create(this._duration / 1000);
                director._scenesActionManager.scheduleActionForNode(sceneOut, actionOut);
            }

            this.__setupActionCallbacks(actionIn, actionOut);

            return this;
        }
    }

    /**
     * @class cc.transition.TransitionMove
     * @classdesc
     *
     * Base Transition for Slide Transitions.
     */
    export class TransitionMove extends Transition {

        /**
         * Transition Slide direction.
         * @member cc.transition.TransitionMove#direction
         * @type {cc.transition.TransitionMoveDirection}
         */

        /**
         * @method cc.transition.TransitionMove#constructor
         * @param duration {number} transition duration in milliseconds.
         * @param direction {cc.transition.TransitionMoveDirection}
         * @param scene {cc.node.Scene}
         */
        constructor(duration:number, public direction:TransitionMoveDirection = TransitionMoveDirection.LEFT, scene?:Scene) {
            super(duration, scene);
        }

        /**
         * Initialize the transition.
         * @method cc.transition.TransitionMove#initialize
         * @override
         * @param sceneIn {cc.node.Scene} scene in.
         * @param sceneOut {cc.node.Scene} scene out.
         * @returns {cc.transition.TransitionMove}
         */
        initialize(sceneIn:Scene, sceneOut?:Scene):Transition {

            var actionIn:Action = null;
            var actionOut:Action = null;
            var director:Director = null;

            var _inX = 0;
            var _inY = 0;

            switch (this.direction) {
                case TransitionMoveDirection.LEFT:
                    _inX = -sceneIn._contentSize.width;
                    break;
                case TransitionMoveDirection.RIGHT:
                    _inX = sceneIn._contentSize.width;
                    break;
                case TransitionMoveDirection.TOP:
                    _inY = -sceneIn._contentSize.height;
                    break;
                case TransitionMoveDirection.BOTTOM:
                    _inY = sceneIn._contentSize.height;
                    break;
            }

            sceneIn.resetScene().setPosition(_inX, _inY);

            actionIn = new MoveAction({ from : {x: 0, y: 0}, to: {x: -_inX, y: -_inY}, relative: true}).
                setDuration(this._duration);
            if (this._interpolator) {
                actionIn.setInterpolator(this._interpolator);
            }

            director = <Director>sceneIn._parent;
            director._scenesActionManager.scheduleActionForNode(sceneIn, actionIn);

            if (sceneOut) {
                sceneOut.resetScene();

                actionOut = actionIn.clone();

                director._scenesActionManager.scheduleActionForNode(sceneOut, actionOut);
            }

            this.__setupActionCallbacks(actionIn, actionOut);

            return this;
        }
    }

    /**
     * @class cc.transition.TransitionSlideInL
     * @classdesc
     * A Transition that enters from the left. This is just some sugar to build a TransitionMove.
     */
    export class TransitionSlideInL extends TransitionMove {
        constructor(duration:number, scene?:Scene) {
            super(duration, TransitionMoveDirection.LEFT, scene);
        }
    }

    /**
     * @class cc.transition.TransitionSlideInR
     * @classdesc
     * A Transition that enters from the right. This is just some sugar to build a TransitionMove.
     */
    export class TransitionSlideInR extends TransitionMove {
        constructor(duration:number, scene?:Scene) {
            super(duration, TransitionMoveDirection.RIGHT, scene);
        }
    }

    /**
     * @class cc.transition.TransitionSlideInT
     * @classdesc
     * A Transition that enters from the top. This is just some sugar to build a TransitionMove.
     */
    export class TransitionSlideInT extends TransitionMove {
        constructor(duration:number, scene?:Scene) {
            super(duration, TransitionMoveDirection.TOP, scene);
        }
    }

    /**
     * @class cc.transition.TransitionSlideInB
     * @classdesc
     * A Transition that enters from the bottom. This is just some sugar to build a TransitionMove.
     */
    export class TransitionSlideInB extends TransitionMove {
        constructor(duration:number, scene?:Scene) {
            super(duration, TransitionMoveDirection.BOTTOM, scene);
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../WebGLState.ts"/>

module cc.render.shader {

    "use strict";

    import WebGLState= cc.render.WebGLState;

    /**
     * @class cc.render.shader.UniformInitializer
     * @interface
     * @classdesc
     *
     * Uniform initializer object.
     *
     */
    export interface UniformInitializer {

        /**
         * Uniform type.
         * @member cc.render.shader.UniformInitializer#type
         * @type {string}
         */
        type : string;

        /**
         * Uniform initial value.
         * @member cc.render.shader.UniformInitializer#value
         * @type {any}
         */
        value : any;
    }

    var idGenerator= (function() {
        var index=0;
        return function() {
            return index++;
        }
    })();

    /**
     * @class cc.render.shader.Uniform
     * @classdesc
     *
     * Base class for Shader uniforms.
     *
     */
    export class Uniform {

        /**
         * Previously value set in shader's location.
         * @member cc.render.shader.Uniform#_prevValue
         * @type {any}
         * @private
         */
        _prevValue:any = null;  // previous value set.

        /**
         * Shader program location.
         * @member cc.render.shader.Uniform#_location
         * @type {any}
         * @private
         */
        _location:any = null;  // shader program location

        /**
         * Uniform name
         * @member cc.render.shader.Uniform#_name
         * @type {string}
         */

        /**
         * Uniform type
         * @member cc.render.shader.Uniform#_type
         * @type {string}
         */

        /**
         * Uniform initial value.
         * The value is not set in the shader until <code>setValue</code> is called.
         * @member cc.render.shader.Uniform#_value
         * @type {any}
         */

        /**
         * Create a new Uniform instance.
         * @method cc.render.shader.Uniform#constructor
         * @param _name {string}
         * @param _type {string}
         * @param _value {any}
         */
        constructor(public _name:string, public _type:string, public _value:any) {
        }

        /**
         * Set Uniform shader location.
         * @method cc.render.shader.Uniform#setLocation
         * @param l {any} shader location.
         */
        setLocation(l:any) {
            this._location = l;

            // bugbug dynamic property
            this._location._id= idGenerator();
        }

        /**
         * Set shader location value.
         * @method cc.render.shader.Uniform#setValue
         * @param gl {WebGLState}
         */
        updateValue(gl:WebGLState) {
            if (this._value !== this._prevValue) {
                gl._gl[ "uniform" + this._type ](this._location, this._value);
                this._prevValue = this._value;
            }
        }

        setValue( v : any ) {
            this._value= v;
        }

        /**
         * Create a uniform instance based on its type.
         * @method cc.render.shader.Uniform.createUniform
         * @param name {string} uniform name
         * @param type {string} uniform type
         * @param value {any} uniform value.
         * @returns {cc.render.Uniform} A Uniform instance.
         */
        static createUniform(name:string, type:string, value:any) {
            if (type === "t") {
                return new TextureUniform(name, type, value);
            } else if (type === "m4v") {
                return new MatrixUniform(name, type, value);
            } else {
                return new Uniform(name, type, value);
            }
        }
    }

    /**
     * @class cc.render.shader.TextureUniform
     * @classdesc
     *
     * Create a Texture uniform.
     * Texture value is global for every shader that uses a sampler.
     *
     */
    export class TextureUniform extends Uniform {


        /**
         * Create a TextureUniform instance.
         * @method cc.render.shader.TextureUniform#constructor
         * @param name {string}
         * @param type {string}
         * @param value {any}
         */
        constructor(name:string, type:string, value:any) {
            super(name, type, value);
        }

        /**
         * Set shader location value.
         * The current texture Id is compared with an statically stored texture Id.
         * @member cc.render.shader.TextureUniform#setValue
         * @param gl {WebGLRenderingContext}
         */
        updateValue(gl:WebGLState) {

            if (this._value !== this._prevValue ) {
                gl.uniform1i(this._location, this._value);
                this._prevValue= this._value;
            }
        }

    }

    /**
     * @class cc.render.shader.MatrixUniform
     * @classdesc
     *
     * Create a Matrix uniform.
     *
     */
    export class MatrixUniform extends Uniform {

        _dirty:boolean= true;

        /**
         * @method cc.render.shader.MatrixUniform#constructor
         * @param name {string}
         * @param type {string}
         * @param value {any}
         */
        constructor(name:string, type:string, value:any) {
            super(name, type, value);
        }

        setValue( v:Float32Array ) {
            super.setValue(v);
            this._dirty= true;
        }

        /**
         * Set Shader location value.
         * @method cc.render.shader.MatrixUniform#setValue
         * @param gl {WebGLRenderingContext}
         */
        updateValue(gl:WebGLState) {

            if ( this._dirty ) {

                // PENDING: componentwise matrix comparison
                gl.uniformMatrix4fv(this._location, false, this._value);
                this._prevValue = this._value;

                this._dirty = false;
            }
        }

    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../WebGLState.ts"/>

module cc.render.shader {

    /**
     * @class cc.render.shader.Attribute
     * @classdesc
     *
     * Shader attribute.
     *
     */
    export class Attribute {

        /**
         * Attribute name.
         * @member cc.render.shader.Attribute#_name
         * @type {string}
         */

        /**
         * Attribute location.
         * @member cc.render.shader.Attribute#_location
         * @type {any}
         */

        /**
         * Create a new Attribute instance.
         * @method cc.render.shader.Attribute#constructor
         * @param _name {string}
         * @param _location {any}
         */
        constructor( public _name : string, public _location : any ) {
        }

        /**
         * Enable the shader attribute.
         * @method cc.render.shader.Attribute#enable
         * @param gl {WebGLRenderingContext}
         */
        enable( gl : cc.render.WebGLState) {
            gl.enableVertexAttribArray(this._location);
        }

        /**
         * Disable the shader attribute.
         * @method cc.render.shader.Attribute#disable
         * @param gl {WebGLRenderingContext}
         */
        disable( gl : cc.render.WebGLState ) {
            gl.disableVertexAttribArray(this._location);
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="./Uniform.ts"/>
/// <reference path="./Attribute.ts"/>
/// <reference path="../../math/matrix3.ts"/>
/// <reference path="../WebGLState.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>

module cc.render.shader {

    import Uniform = cc.render.shader.Uniform;
    import UniformInitializer = cc.render.shader.UniformInitializer;
    import Attribute = cc.render.shader.Attribute;
    import WebGLState = cc.render.WebGLState;

    "use strict";

    export interface MapOfUniformInitializer {
        [name: string]: UniformInitializer;
    }

    /**
     * @class cc.render.shader.AbstractShaderInitializer
     * @interface
     * @classdesc
     *
     * Shader initializer object.
     *
     */
    export interface AbstractShaderInitializer {

        /**
         * Vertex shader string definition
         * @member cc.render.shader.AbstractShaderInitializer#vertexShader
         * @type {string|Array<string>}
         */
        vertexShader    : string|string[];

        /**
         * Fragment shader string definition
         * @member cc.render.shader.AbstractShaderInitializer#fragmentShader
         * @type {string|Array<string>}
         */
        fragmentShader  : string|string[];

        /**
         * Map of uniform initializers.
         * @member cc.render.shader.AbstractShaderInitializer#uniforms
         * @type {Map<string,cc.render.shader.UniformInitializer>}
         */
        uniforms?       : MapOfUniformInitializer;

        /**
         * Array of attribute names.
         * @member cc.render.shader.AbstractShaderInitializer#attributes
         * @type {Array<string>}
         */
        attributes?     : Array<any>;

    }

    /**
     * @class cc.render.shader.AbstractShader
     * @classdesc
     *
     * Base class for all 2D rendering shaders.
     *
     */
    export class AbstractShader {

        /**
         * Collection of the shader uniform objects.
         * @member cc.render.shader.AbstractShader#_uniforms
         * @type {Array<cc.render.shader.Uniform>}
         * @private
         */
        _uniforms       : Array<Uniform> = [];

        /**
         * Collection of the shader attribute objects.
         * @member cc.render.shader.AbstractShader#_attributes
         * @type {Array<cc.render.shader.Uniform>}
         * @private
         */
        _attributes     : Attribute[] = [];

        /**
         * Compiled shader program.
         * @member cc.render.shader.AbstractShader#_shaderProgram
         * @type {any}
         * @private
         */
        _shaderProgram  : WebGLProgram = null;

        /**
         * Shader Uniform projection matrix.
         * @member cc.render.shader.AbstractShader#_uniformProjection
         * @type {any}
         * @private
         */
        _uniformProjection: cc.render.shader.Uniform = null;


        /**
         * WebGLState
         * @member cc.render.shader.AbstractShader#_webglState
         * @type {cc.render.WebGLState}
         */

        /**
         * Build a new AbstractShader instance.
         * @method cc.render.shader.AbstractShader#constructor
         * @param _webglState {WebGLState}
         * @param shaderDefinition {cc.render.shader.AbstractShaderInitializer}
         */
        constructor( public _webglState : WebGLState, shaderDefinition : AbstractShaderInitializer ) {
            this.__initializeFromShaderDefinition(shaderDefinition);
        }

        enableAttributes() : AbstractShader {
            for( var i=0; i<this._attributes.length; i++ ) {
                this._attributes[i].enable(this._webglState);
            }

            return this;
        }

        disableAttributes() : AbstractShader {
            for( var i=0; i<this._attributes.length; i++ ) {
                this._attributes[i].disable(this._webglState);
            }

            return this;
        }

        __getShaderDef( def:string|string[] ) : string {

            if ( Object.prototype.toString.call(def)==="[object Array]" ) {
                return (<string[]>def).join('\n');
            }

            return <string>def;
        }

        /**
         * Initialize a shader from a shader initializer.
         * Do not call directly. Ever.
         * @method cc.render.shader.AbstractShader#__initializeFromShaderDefinition
         * @param shaderDef {cc.render.shader.AbstractShaderInitializer}
         * @private
         */
        __initializeFromShaderDefinition(shaderDef : AbstractShaderInitializer) {

            var gl = this._webglState._gl;

            this._shaderProgram = gl.createProgram();
            gl.attachShader(
                this._shaderProgram,
                this.__getShader(gl, "x-shader/x-vertex", this.__getShaderDef(shaderDef.vertexShader) )
            );

            gl.attachShader(
                this._shaderProgram,
                this.__getShader(gl, "x-shader/x-fragment", this.__getShaderDef(shaderDef.fragmentShader) )
            );

            gl.linkProgram(this._shaderProgram);
            if ( gl.getError() ) {
                console.log( gl.getProgramInfoLog(this._shaderProgram) );
            }

            this._webglState.useProgram(this._shaderProgram);

            if ( shaderDef.uniforms ) {
                for( var uniformName in shaderDef.uniforms ) {
                    var uniformDef : UniformInitializer = shaderDef.uniforms[ uniformName ];
                    var type= uniformDef.type;
                    var value=uniformDef.value;

                    var uniform= Uniform.createUniform( uniformName, type, value );
                    uniform.setLocation( gl.getUniformLocation(this._shaderProgram, uniformName ) );

                    if ( typeof value!=="undefined" && value!==null) {
                        uniform.setValue( value );
                        uniform.updateValue( this._webglState );
                    }

                    this._uniforms.push( uniform );
                }
            }

            if ( shaderDef.attributes ) {
                for (var i=0; i< shaderDef.attributes.length; i++ ) {

                    var attribute= new Attribute(
                        shaderDef.attributes[i],
                        gl.getAttribLocation(this._shaderProgram, shaderDef.attributes[i] ) );

                    this._attributes.push( attribute );
                }
            }

        }

        /**
         * Get a shader of given type.
         * Do not call directly.
         * @member cc.render.shader.AbstractShader#__getShader
         * @param gl {WebGLRenderingContext}
         * @param type {string}
         * @param str {string}
         * @returns {any}
         * @private
         */
        __getShader(gl, type, str) {
            var shader : any;
            if (type === "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (type === "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }

            gl.shaderSource(shader, str);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;

        }

        /**
         * Use this program for gpu rendering.
         * @method cc.render.shader.AbstractShader#useProgram
         * @returns {cc.render.shader.AbstractShader}
         */
        useProgram() {
            if ( this._shaderProgram!==this._webglState._currentProgram) {
                this._webglState.useProgram(this._shaderProgram);
                this.enableAttributes();
            }

        }

        notUseProgram() {
            if ( this._shaderProgram===this._webglState._currentProgram) {
                this.disableAttributes();
            }
        }

        /**
         * Flush geometry.
         * Must br overridden.
         * @method cc.render.shader.AbstractShader#flushBuffersWithContent
         * @param rcs {rcs:cc.render.RenderingContextSnapshot}
         */
        flushBuffersWithContent( rcs:cc.render.RenderingContextSnapshot ) {
        }

        __updateUniformValues() {
            for( var i=0;i<this._uniforms.length;i++) {
                this._uniforms[i].updateValue( this._webglState );
            }
        }

        /**
         * Find a uniform by name.
         * @method cc.render.shader.AbstractShader#findUniform
         * @param name {string}
         * @returns {cc.render.shader.Uniform}
         */
        findUniform( name ) : cc.render.shader.Uniform {
            for( var i=0; i< this._uniforms.length; i++ ) {
                if (this._uniforms[i]._name===name ) {
                    return this._uniforms[i];
                }
            }

            return null;
        }

        /**
         * Find an attribute by name.
         * @method cc.render.shader.AbstractShader#findAttribute
         * @param name {string}
         * @returns {cc.render.shader.Attribute}
         */
        findAttribute( name ) {
            for( var i=0; i< this._attributes.length; i++ ) {
                if (this._attributes[i]._name===name ) {
                    return this._attributes[i];
                }
            }

            return null;

        }

        /**
         * Build a shader mat4 from a Matrix3 instance.
         * @method cc.render.shader.AbstractShader#mat4_from_mat3
         * @param mat3 {Float32Array}
         * @param __mat4 {Float32Array}
         * @returns {Float32Array}
         */
        mat4_from_mat3( mat3 : Float32Array, __mat4 : Float32Array ) {

            __mat4[ 0] = mat3[0];
            __mat4[ 4] = mat3[1];
            __mat4[ 1] = mat3[3];
            __mat4[ 5] = mat3[4];
            __mat4[12] = mat3[2];
            __mat4[13] = mat3[5];

            return __mat4;
        }

        useMeshIndex() : boolean {
            return false;
        }
    }

}
/**
 * License: see license.txt file.
 */

/// <reference path="./AbstractShader.ts"/>
/// <reference path="../webGLState.ts"/>
/// <reference path="../../util/util.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>

module cc.render.shader {

    "use strict";

    import AbstractShader = cc.render.shader.AbstractShader;

    /**
     * @class cc.render.shader.SolidColorShader
     * @classdesc
     *
     * This shader fills geometry with a solid color.
     *
     */
    export class SolidColorShader extends AbstractShader {

        /**
         * Spare matrix
         * @member cc.render.shader.SolidColorShader.mat
         * @type {Float32Array}
         */
        static mat : Float32Array = new Float32Array( 16 );

        /**
         * Shader Uniform transformation matrix.
         * @member cc.render.shader.SolidColorShader#_uniformTransform
         * @type {any}
         * @private
         */
        _uniformTransform:any = null;

        /**
         * Shader geometry attribute.
         * @member cc.render.shader.SolidColorShader#_attributePosition
         * @type {any}
         * @private
         */
        _attributePosition:any = null;

        /**
         * Shader texture coords attribute. Not used in this shader.
         * @member cc.render.shader.SolidColorShader#_attributeTexture
         * @type {any}
         * @private
         */
        //_attributeTexture:any = null;

        /**
         * Shader geometry color attribute.
         * @member cc.render.shader.SolidColorShader#_attributeColor
         * @type {any}
         * @private
         */
        _attributeColor:any = null;

        /**
         * Build a new SolidColorShader instance.
         * @method cc.render.shader.SolidColorShader#constructor
         * @param gl {WebGLRenderingContext} gl context
         * @param ortho {Float32Array} projection matrix.
         */
        constructor(gl:cc.render.WebGLState) {
            super(gl, {
                vertexShader: ""+
                    "attribute vec2 aPosition; \n" +
                    "attribute vec4 aColor; \n" +

                    "uniform mat4 uProjection; \n" +
                    "uniform mat4 uTransform; \n" +

                    "varying vec4 vAttrColor; \n" +

                    "void main(void) { \n" +
                    "gl_Position = uProjection * uTransform * vec4( aPosition.x, aPosition.y, 0.0, 1.0 );\n" +
                    "vAttrColor = aColor;\n" +
                    "}\n",

                fragmentShader: "precision mediump float; \n" +
                    "varying vec4 vAttrColor;\n" +

                    "void main(void) { \n" +
                    "  gl_FragColor = vAttrColor; \n" +
                    "}\n",

                uniforms: {
                    "uProjection": {
                        type: "m4v",
                        value: [1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]
                    },
                    "uTransform": {
                        type: "m4v",
                        value: [1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]
                    }
                },

                attributes: [ "aPosition", "aColor" ]

            });

            this._uniformProjection = this.findUniform("uProjection");
            this._uniformTransform = this.findUniform("uTransform");

            this._attributePosition = this.findAttribute("aPosition");
            this._attributeColor = this.findAttribute("aColor");

            SolidColorShader.mat.set([1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]);

        }


        flushBuffersWithContent( rcs:cc.render.RenderingContextSnapshot ) {

            this.__updateUniformValues();

            var gl = this._webglState;

            gl.vertexAttribPointer(this._attributePosition._location, 2, gl._gl.FLOAT, false, 12, 0);
            gl.vertexAttribPointer(this._attributeColor._location, 4, gl._gl.UNSIGNED_BYTE, true,  12, 2 * 4 );
        }

        useMeshIndex() : boolean {
            return true;
        }


    }
}
/**
 * Created by ibon on 11/17/14.
 */

/// <reference path="./AbstractShader.ts"/>
/// <reference path="../WebGLState.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>

module cc.render.shader {

    import AbstractShader = cc.render.shader.AbstractShader;

    /**
     * @class cc.render.shader.TextureShader
     * @extends AbstractShader
     * @classdesc
     * 
     * This shader fills rects with an image. It is expected to be invoked by calls to drawImage.
     * 
     */
    export class TextureShader extends AbstractShader {

        /**
         * Spare matrix
         * @member cc.render.shader.TextureShader.mat
         * @type {Float32Array}
         */
        static mat:Float32Array = new Float32Array(16);

        /**
         * Shader Uniform transformation matrix.
         * @member cc.render.shader.SolidColorShader#_uniformTransform
         * @type {any}
         * @private
         */
        _uniformTransform:any = null;

        /**
         * Shader Uniform for texture.
         * @member cc.render.shader.SolidColorShader#_uniformTextureSampler
         * @type {any}
         * @private
         */
        _uniformTextureSampler : any = null;

        /**
         * Shader geometry attribute.
         * @member cc.render.shader.SolidColorShader#_attributePosition
         * @type {any}
         * @private
         */
        _attributePosition:any = null;

        /**
         * Shader geometry attribute.
         * @member cc.render.shader.SolidColorShader#_attributeTexture
         * @type {any}
         * @private
         */
        _attributeTexture:any = null;

        /**
         * Shader geometry color attribute.
         * @member cc.render.shader.SolidColorShader#_attributeColor
         * @type {any}
         * @private
         */
        _attributeColor:any = null;

        constructor(gl:cc.render.WebGLState) {
            super(gl,
                {
                    vertexShader: "" +
                        "attribute vec2 aPosition; \n" +
                        "attribute vec4 aColor; \n" +
                        "attribute vec2 aTexture; \n" +

                        "uniform mat4 uProjection; \n" +

                        "varying vec2 vTextureCoord; \n" +
                        "varying vec4 vAttrColor; \n" +

                        "void main(void) { \n" +
                        "gl_Position = uProjection * vec4( aPosition.x, aPosition.y, 0.0, 1.0 );\n" +
                        "vTextureCoord = aTexture;\n" +
                        "vAttrColor = aColor;\n" +
                        "}\n",
                    fragmentShader: ""+
                        "precision mediump float; \n" +
                        "varying vec2 vTextureCoord; \n" +
                        "uniform sampler2D uTextureSampler; \n" +
                        "varying vec4 vAttrColor;\n" +

                        "void main(void) { \n" +

                        "  vec4 textureColor= texture2D(uTextureSampler, vec2(vTextureCoord)); \n" +
                        "  gl_FragColor = textureColor * vAttrColor; \n" +

                        "}\n",
                    attributes: [ "aPosition", "aColor", "aTexture" ],
                    uniforms: {
                        "uProjection": {
                            type: "m4v",
                            value: [1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]
                        },
                        "uTextureSampler": {
                            type: "t",
                            value: null
                        }
                    }
                });

            this._uniformTextureSampler = this.findUniform("uTextureSampler");
            this._uniformProjection = this.findUniform("uProjection");

            this._attributePosition = this.findAttribute("aPosition");
            this._attributeColor = this.findAttribute("aColor");
            this._attributeTexture = this.findAttribute("aTexture");

            TextureShader.mat[ 0] = 1.0;
            TextureShader.mat[ 5] = 1.0;
            TextureShader.mat[10] = 1.0;
            TextureShader.mat[15] = 1.0;
            return this;
        }

        flushBuffersWithContent(rcs:cc.render.RenderingContextSnapshot ) {

            this.__updateUniformValues();

            var gl= this._webglState;

            gl.vertexAttribPointer(this._attributePosition._location, 2, gl._gl.FLOAT, false, 5*4, 0);
            gl.vertexAttribPointer(this._attributeColor._location, 4, gl._gl.UNSIGNED_BYTE, true, 5 * 4, 2 * 4 )
            gl.vertexAttribPointer(this._attributeTexture._location, 2, gl._gl.FLOAT, false, 5*4, 3*4 );

        }
    }



    /**
     * @class cc.render.shader.MeshShader
     * @extends AbstractShader
     * @classdesc
     *
     * This shader fills rects with an image. It is expected to be invoked by calls to drawImage.
     *
     */
    export class MeshShader extends AbstractShader {

        /**
         * Spare matrix
         * @member cc.render.shader.TextureShader.mat
         * @type {Float32Array}
         */
        static mat:Float32Array = new Float32Array(16);

        /**
         * Shader Uniform transformation matrix.
         * @member cc.render.shader.MeshShader#_uniformTransform
         * @type {any}
         * @private
         */
        _uniformTransform:any = null;

        /**
         * Shader Uniform for texture.
         * @member cc.render.shader.MeshShader#_uniformTextureSampler
         * @type {any}
         * @private
         */
        _uniformTextureSampler : any = null;

        /**
         * Shader geometry attribute.
         * @member cc.render.shader.MeshShader#_attributePosition
         * @type {any}
         * @private
         */
        _attributePosition:any = null;

        /**
         * Shader geometry attribute.
         * @member cc.render.shader.MeshShader#_attributeTexture
         * @type {any}
         * @private
         */
        _attributeTexture:any = null;

        /**
         * Shader geometry color attribute.
         * @member cc.render.shader.MeshShader#_uniformColor
         * @type {any}
         * @private
         */
        _uniformColor:any = null;

        constructor(gl:cc.render.WebGLState) {
            super(gl,
                {
                    vertexShader: "" +
                        "attribute vec2 aPosition; \n" +
                        "attribute vec2 aTexture; \n" +

                        "uniform mat4 uProjection; \n" +
                        "uniform mat4 uTransform; \n" +

                        "varying vec2 vTextureCoord; \n" +

                        "void main(void) { \n" +
                        "gl_Position = uProjection * uTransform * vec4( aPosition.x, aPosition.y, 0.0, 1.0 );\n" +
                        "vTextureCoord = aTexture;\n" +
                        "}\n",
                    fragmentShader: ""+
                        "precision mediump float; \n" +
                        "varying vec2 vTextureCoord; \n" +
                        "uniform sampler2D uTextureSampler; \n" +
                        "uniform vec4 uColor; \n" +

                        "void main(void) { \n" +

                        "  vec4 textureColor= texture2D(uTextureSampler, vec2(vTextureCoord)); \n" +
                        "  gl_FragColor = textureColor * (uColor/255.0); \n" +

                        "}\n",
                    attributes: [ "aPosition", "aTexture" ],
                    uniforms: {
                        "uProjection": {
                            type: "m4v",
                            value: [1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]
                        },
                        "uTransform": {
                            type: "m4v",
                            value: [1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]
                        },
                        "uTextureSampler": {
                            type: "t",
                            value: null
                        },
                        "uColor" : {
                            type : "4fv",
                            value: [1.0, 1.0, 1.0, 1.0]
                        }
                    }
                });

            this._uniformTextureSampler = this.findUniform("uTextureSampler");
            this._uniformProjection = this.findUniform("uProjection");
            this._uniformTransform = this.findUniform("uTransform");
            this._uniformColor= this.findUniform("uColor");

            this._attributePosition = this.findAttribute("aPosition");
            this._attributeTexture = this.findAttribute("aTexture");

            TextureShader.mat[ 0] = 1.0;
            TextureShader.mat[ 5] = 1.0;
            TextureShader.mat[10] = 1.0;
            TextureShader.mat[15] = 1.0;
            return this;
        }

        flushBuffersWithContent(rcs:cc.render.RenderingContextSnapshot ) {

            this.__updateUniformValues();

            var gl= this._webglState;

            gl.vertexAttribPointer(this._attributePosition._location, 2, gl._gl.FLOAT, false, 4*4, 0);
            gl.vertexAttribPointer(this._attributeTexture._location, 2, gl._gl.FLOAT, false, 4*4, 2*4 );

        }

        useMeshIndex() : boolean {
            return true;
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="./AbstractShader.ts"/>
/// <reference path="../webGLState.ts"/>
/// <reference path="../../util/util.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>

module cc.render.shader {


    function __getPatternFragmentShader() : string[] {
        return  [
            "precision mediump float;",

            "uniform vec4 uPatternImageBounds;",
            "uniform sampler2D uSampler;",

            "varying vec2 v_texCoord;",
            "varying vec4 vColor;",

            "void main() {",
            "    gl_FragColor = texture2D(uSampler, mod(v_texCoord,(uPatternImageBounds.zw-uPatternImageBounds.xy))+ uPatternImageBounds.xy ) * vColor;",
            "}"
        ];
    }

    export class TexturePatternShader extends AbstractShader {

        static mat:Float32Array = new Float32Array(16);

        /**
         * Shader Uniform transformation matrix.
         * @member cc.render.shader.TexturePatternShader#_uniformTransform
         * @type {any}
         * @private
         */
        _uniformTransform: cc.render.shader.Uniform = null;
        _uniformPatternTransform : cc.render.shader.Uniform = null;

        _uniformPatternImageBounds : cc.render.shader.Uniform = null;
        _uniformPatternBounds : cc.render.shader.Uniform = null;

        /**
         * Shader geometry attribute.
         * @member cc.render.shader.TexturePatternShader#_attributePosition
         * @type {any}
         * @private
         */
        _attributePosition:any = null;

        /**
         * Shader geometry color attribute.
         * @member cc.render.shader.TexturePatternShader#_attributeColor
         * @type {any}
         * @private
         */
        _attributeColor:any = null;


        constructor(gl:cc.render.WebGLState) {

            super(gl, {

                    vertexShader: [
                        "precision mediump float;",             // medium precission

                        "attribute vec2 aPosition;",            // position attribute
                        "attribute vec4 aColor;",               // color attribute

                        "uniform vec4 uPatternImageBounds;",    // sprite frame info: (u0,v0), (u1-u1,v1-v0)
                        "uniform vec2 uPatternBounds;",         // pattern screen size
                        "uniform mat4 uProjection;",                 // projection matrix
                        "uniform mat4 uTransform;",             // geometry model view transform
                        "uniform mat4 uPatternTransform;",      // pattern transform (composed of proj+current)

                        "varying vec2 v_texCoord;",
                        "varying vec4 vColor;",

                        "void main(void) {",
                            "vec4 avp= vec4( aPosition, 0, 1);",
                            "gl_Position = uProjection * uTransform * avp;",
                            "v_texCoord = (uPatternTransform * avp).xy / uPatternBounds * (uPatternImageBounds.zw-uPatternImageBounds.xy);",
                            "vColor= aColor;",
                        "}"
                    ],

                    fragmentShader: __getPatternFragmentShader(),

                    uniforms: {
                        "uPatternImageBounds": {
                            type: "4fv",
                            value: [0, 0, 0, 0]
                        },
                        "uPatternBounds": {
                            type: "2fv",
                            value: [0, 0]
                        },
                        "uProjection": {
                            type: "m4v",
                            value: [1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]
                        },
                        "uTransform": {
                            type: "m4v",
                            value: [1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]
                        },
                        "uPatternTransform": {
                            type: "m4v",
                            value: [1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]
                        },
                        "uSampler": {
                            type: "t",
                            value: null
                        }
                    },

                    attributes: ["aPosition", "aColor"]
                });


            this._uniformProjection = this.findUniform("uProjection");
            this._uniformTransform = this.findUniform("uTransform");
            this._uniformPatternTransform= this.findUniform("uTransform");

            this._uniformPatternImageBounds= this.findUniform("uPatternImageBounds");
            this._uniformPatternBounds= this.findUniform("uPatternBounds");

            this._attributePosition = this.findAttribute("aPosition");
            this._attributeColor = this.findAttribute("aColor");

            TexturePatternShader.mat.set([1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]);
        }

        flushBuffersWithContent( rcs:cc.render.RenderingContextSnapshot ) {

            this.__updateUniformValues();

            var gl = this._webglState;

            gl.vertexAttribPointer(this._attributePosition._location, 2, gl._gl.FLOAT, false, 3*4, 0);
            gl.vertexAttribPointer(this._attributeColor._location, 4, gl._gl.FLOAT, false, 3*4, 2*4);

        }
    }

}
/**
 * License: see license.txt file.
 */

/// <reference path="./AbstractShader.ts"/>
/// <reference path="../RenderingContextSnapshot.ts"/>

module cc.render.shader {

    export class FastTextureShader extends AbstractShader {
        /**
         * Spare matrix
         * @member cc.render.shader.TextureShader.mat
         * @type {Float32Array}
         */
        static mat:Float32Array = new Float32Array(16);

        /**
         * Shader Uniform transformation matrix.
         * @member cc.render.shader.SolidColorShader#_uniformTransform
         * @type {any}
         * @private
         */
        _uniformTransform:any = null;

        /**
         * Shader Uniform for texture.
         * @member cc.render.shader.SolidColorShader#_uniformTextureSampler
         * @type {any}
         * @private
         */
        _uniformTextureSampler:any = null;

        /**
         * Shader geometry attribute.
         * @member cc.render.shader.SolidColorShader#_attributePosition
         * @type {any}
         * @private
         */
        _attributePosition:any = null;

        /**
         * Shader geometry attribute.
         * @member cc.render.shader.SolidColorShader#_attributeTexture
         * @type {any}
         * @private
         */
        _attributeTexture:any = null;

        /**
         * Shader geometry color attribute.
         * @member cc.render.shader.SolidColorShader#_attributeColor
         * @type {any}
         * @private
         */
        _attributeColor:any = null;

        _attributeAnchorPosition:any= null;
        _attributeRotation:any= null;
        _attributeScale:any= null;

        constructor(gl:cc.render.WebGLState) {
            super(gl,
                {
                    vertexShader: "" +
                        "precision lowp float; \n" +
                        "attribute vec2 aPosition; \n" +
                        "attribute vec4 aColor; \n" +
                        "attribute vec2 aTexture; \n" +
                        "attribute vec2 aAnchorPosition; \n" +
                        "attribute float aRotation; \n" +
                        "attribute vec2 aScale; \n" +

                        "uniform mat4 uProjection; \n" +

                        "varying vec2 vTextureCoord; \n" +
                        "varying vec4 vAttrColor; \n" +

                        "void main(void) { \n" +
                            "vec2 v;\n"+
                            "vec2 sv = aAnchorPosition * aScale; \n"+
                            "float _rotation= aRotation * 0.017453292519943295;\n" +
                            " v.x = sv.x * cos(_rotation) - sv.y * sin(_rotation); \n"+
                            " v.y = sv.x * sin(_rotation) + sv.y * cos(_rotation); \n"+
                            "gl_Position = uProjection * vec4( v + aPosition, 0.0, 1.0 );\n"+
                            "vTextureCoord = aTexture;\n" +
                            "vAttrColor = aColor;\n" +
                        "}\n",

                    fragmentShader: "" +
                        "precision lowp float; \n" +
                        "varying vec2 vTextureCoord; \n" +
                        "uniform sampler2D uTextureSampler; \n" +
                        "varying vec4 vAttrColor;\n" +

                        "void main(void) { \n" +

                        "  gl_FragColor = texture2D(uTextureSampler,vTextureCoord) * vAttrColor; \n" +

                        "}\n",
                    attributes: ["aPosition", "aColor", "aTexture", "aAnchorPosition", "aRotation", "aScale"],
                    uniforms: {
                        "uProjection": {
                            type: "m4v",
                            value: [1.0,0,0,0, 0,1.0,0,0, 0,0,1.0,0, 0,0,0,1.0]
                        },
                        "uTextureSampler": {
                            type: "t",
                            value: null
                        }
                    }
                });

            this._uniformTextureSampler = this.findUniform("uTextureSampler");
            this._uniformProjection = this.findUniform("uProjection");

            this._attributePosition = this.findAttribute("aPosition");
            this._attributeColor = this.findAttribute("aColor");
            this._attributeTexture = this.findAttribute("aTexture");
            this._attributeAnchorPosition= this.findAttribute("aAnchorPosition");
            this._attributeRotation= this.findAttribute("aRotation");
            this._attributeScale= this.findAttribute("aScale");

            FastTextureShader.mat[0] = 1.0;
            FastTextureShader.mat[5] = 1.0;
            FastTextureShader.mat[10] = 1.0;
            FastTextureShader.mat[15] = 1.0;

            return this;
        }

        flushBuffersWithContent() {

            this.__updateUniformValues();

            var gl = this._webglState;

            gl.vertexAttribPointer(this._attributePosition._location,       2, gl._gl.FLOAT,        false, 10 * 4, 0     );
            gl.vertexAttribPointer(this._attributeColor._location,          4, gl._gl.UNSIGNED_BYTE, true, 10 * 4, 2 * 4 );
            gl.vertexAttribPointer(this._attributeTexture._location,        2, gl._gl.FLOAT,        false, 10 * 4, 3 * 4 );
            gl.vertexAttribPointer(this._attributeAnchorPosition._location, 2, gl._gl.FLOAT,        false, 10 * 4, 5 * 4 );
            gl.vertexAttribPointer(this._attributeRotation._location,       1, gl._gl.FLOAT,        false, 10 * 4, 7 * 4 );
            gl.vertexAttribPointer(this._attributeScale._location,          2, gl._gl.FLOAT,        false, 10 * 4, 8 * 4 );

        }
    }
}
/**
 * Created by ibon on 11/19/14.
 */

module cc.render.shader {

    (function() {
        console.log("Buffers: in bufferData mode with whole buffer.");
    })();

    export class Buffer {

        _buffer : WebGLBuffer = null;
        _prevValue : any = null;
        _usage : number;

        constructor(public _gl : WebGLRenderingContext, public _type : number, initialValue:any, usage:number ) {

            this._usage= usage;

            //this._usage= _gl.STATIC_DRAW;

            this._buffer= _gl.createBuffer();
            if ( initialValue ) {
                this._gl.bindBuffer( _type, this._buffer );
                this._gl.bufferData( _type, initialValue, usage );
            }
        }

        /**
         *
         * @param gl {WebGLRenderingContext}
         * @param v {Float32Array|UInt16Array}
         */
        enableWithValue( v : any ) {

            this._gl.bindBuffer( this._type, this._buffer );
            //if ( this._prevValue!==v ) {
            //    this._gl.bufferData( this._type, v, this._usage );
                this._gl.bufferSubData( this._type, 0, v );
                //this._prevValue= v;
            //}
        }

        forceEnableWithValue( v : any ) {

            this._gl.bindBuffer( this._type, this._buffer );
            //this._gl.bufferData( this._type, v, this._usage );
            this._gl.bufferSubData( this._type, 0, v );
        }

        bind( type ) {
            this._gl.bindBuffer( type, this._buffer);
        }

    }

}
/**
 * License: see license.txt file.
 */


/// <reference path="../math/Dimension.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="./RenderingContext.ts"/>
/// <reference path="./ScaleManager.ts"/>
/// <reference path="./Texture2D.ts"/>
/// <reference path="./DecoratedWebGLRenderingContext.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="../plugin/asset/AssetManager.ts"/>

module cc.render {

    export type RendererResizedCallback= (uw:number, uh:number, puw:number, puh:number, w:number, h:number, sceneHint:cc.render.ScaleContentSceneHint)=>any;

    "use strict";

    export var ORIGIN_BOTTOM = 1;
    export var ORIGIN_TOP = 0;

    /**
     * This flag sets renderer's y axis origin to be on top or bottom (y axis increases up or downwards.
     * <p>
     * Bottom is default's open/webgl while top is canvas' default.
     * <li>The default for CocosJS engine is bottom
     * <li>Setting this flag will affect both renderer types.
     * <li>This flag must be set BEFORE creating a renderer object.
     * <p>
     *     Performance considerations.
     * <p>
     *     While changing this flag for a WebGL renderer has no impact in performance, this is not the case for Canvas.
     *     If (as it is by default) bottom is specified for the renderer origin, there's an important performance penalty.
     *     This is mainly due to the fact that for each node, its coordinate system must be inverted, and thus an extra
     *     call to concatenate the current transformation matrix with the inversion matrix must be performed.
     *     In my MBA (core i7 dual core 2Ghz), with 3000 sprites in canvas the difference can be up to 8 fps. <br>
     *     There could be some solutions to avoid this extra transformation call though:
     *     <li>Invert all your images at compile time. Images are already flipped vertically before loading.
     *     <li>Invert all your images at load time. Extra memory, and extra bootstrapping time.
     *     <li>Change the y axis orientation to cc.render.ORIGIN_BOTTOM, and avoid the extra call. This will work for both canvas and
     *         webgl rendering.
     * <p>
     *     In either case, right now, the system DOES apply the extra transformation, and the performance penalty is
     *     there.
     * <p>
     *     It is also important to note that the local coordinate system y-axis will for each node be positioned as well
     *     either at the top or the bottom of the node itself.
     *
     * @member cc.render.RENDER_ORIGIN
     * @type {number}
     */
    export var RENDER_ORIGIN:number=cc.render.ORIGIN_BOTTOM;

    export function autodetectRenderer( w:number, h:number, elem:string ) : cc.render.Renderer {

        w= w || 800;
        h= h || 600;

        // BORROWED from Mr Doob (mrdoob.com)
        var webgl = ( function () {
            var canvas= document.createElement("canvas");
            try {
                return !! (typeof (<any>window).WebGLRenderingContext!=="undefined") && (
                    canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );
            } catch( e ) {
                return false;
            }
        })();

        if( webgl ) {
            return new cc.render.WebGLRenderer( w, h, <HTMLCanvasElement>document.getElementById(elem) );
        }

        return new cc.render.CanvasRenderer( w, h, <HTMLCanvasElement>document.getElementById(elem) );
    }

    import RenderingContext = cc.render.RenderingContext;
    import DecoratedWebGLRenderingContext = cc.render.DecoratedWebGLRenderingContext;
    import Node= cc.node.Node;
    import Dimension= cc.math.Dimension;
    import Texture2D= cc.render.Texture2D;

    /**
     * @class cc.render.Renderer
     * @classdesc
     *
     * Interface for any renderer.
     * Must be subclassed to build a canvas or gl renderer.
     *
     */
    export class Renderer {

        /**
         * Surface to render to.
         * @member cc.render.Renderer#_surface
         * @type {HTMLCanvasElement}
         * @private
         */
        _surface : HTMLCanvasElement = null;

        /**
         * Rendering context to render on the surface.
         * @member cc.render.Renderer#_renderingContext
         * @type {cc.render.RenderingContext}
         * @private
         */
        _renderingContext : RenderingContext= null;

        _dimension : Dimension = new Dimension();

        _addedToDOM : boolean = false;

        _scaleManager : cc.render.ScaleManager = null;
        _onContentScaled : RendererResizedCallback= null;

        /**
         * When scale content is enabled, this flag makes the canvas object to take over the whole screen and not
         * only the area that honors aspect ratio.
         * @member cc.render.Renderer#_adjustContentToFullScreen
         * @type {boolean}
         * @private
         */
        _adjustContentToFullScreen : boolean = false;

        _preferredUnits : cc.math.Dimension = null;

        _sceneHint : ScaleContentSceneHint = cc.render.ScaleContentSceneHint.CENTER;

        /**
         * Create a new Renderer instance.
         * @param w {width} surface pixels width
         * @param h {height} surface pixels height
         * @param surface {HTMLCanvasElement=} canvas object. @see {cc.render.Renderer#initialize}
         * @member cc.render.Renderer#constructor
         */
        constructor(w : number, h : number, surface? : HTMLCanvasElement) {

            this._surface= typeof surface!=="undefined" ? surface : document.createElement("canvas");
            this._surface.width= typeof w!=="undefined" ? w : 800;
            this._surface.height= typeof h!=="undefined" ? h : 600;

            this._preferredUnits= new Dimension();
            this._preferredUnits.set( w, h );
            this._dimension.set( w, h );

            var me= this;
            this._scaleManager= new cc.render.ScaleManager(this).
                onWindowResized( function(w:number, h:number) {

                    var uw= me._scaleManager._units.width;
                    var uh= me._scaleManager._units.height;

                    if ( me._adjustContentToFullScreen ) {

                        w= window.innerWidth;
                        h= window.innerHeight;
                    }

                    // preferred dimensions
                    me.setScaleContent( uw, uh, w, h );
                });

            this._addedToDOM= surface?true:false;

        }

        __calcPreferredUnits() : cc.math.Dimension {
            var d:cc.math.Dimension= new cc.math.Dimension();

            var units= this.getScaleManager()._units;

            if ( this.getScaleManager()._contentScaled ) {
                var ratio= Math.min( window.innerWidth/units.width, window.innerHeight/units.height );

                d.width= window.innerWidth/ratio;
                d.height= window.innerHeight/ratio;
            } else {
                d.width= units.width;
                d.height= units.height;
            }

            this._preferredUnits.set( d.width, d.height );

            return d;
        }


        adjustContentToFullScreen( hint:cc.render.ScaleContentSceneHint ) : Renderer {
            this._adjustContentToFullScreen= true;
            this._sceneHint= hint;
            return this;
        }

        onContentScaled( callback:RendererResizedCallback ) : Renderer {

            this._onContentScaled= callback;
            return this;
        }

        isAddedToDOM() : boolean {
            return this._addedToDOM;
        }

        addToDOM() {
            if (!this.isAddedToDOM()) {
                document.body.appendChild(this._surface);
                this._addedToDOM = true;
            }
        }

        /**
         * Get the rendering context. @see {cc.render.Renderer#getRenderingContext}
         * @method cc.render.Renderer#getRenderingContext
         * @returns {cc.render.RenderingContext}
         */
        getRenderingContext() : RenderingContext {
            return this._renderingContext;
        }

        /**
         * Render a node. @see {cc.render.Renderer#render}
         * @method cc.render.Renderer#render
         */
        render( node : Node ) {
            node.visit( this._renderingContext );
        }

        /**
         * Flush this renderer (push remaining content to the scene).
         * @method cc.render.Renderer#flush
         */
        flush() : void {
            this._renderingContext.flush();
        }

        getContentSize() : Dimension {
            return this._dimension.clone();
        }

        prepareTexture(texture:Texture2D) : void {

        }

        getScaleContentMatrix() : Float32Array {
            return this._scaleManager.getScaleContentMatrix();
        }

        /**
         * Return the internal scale management object.
         * This object handles all things relative to Renderer surface scale and on-screen positioning, as well as
         * orientation changes and content scale ratio calculations.
         * @method cc.node.Director#getScaleManager
         * @see cc.game.ScaleManager
         * @returns {cc.render.ScaleManager}
         */
        getScaleManager() : cc.render.ScaleManager {
            return this._scaleManager;
        }

        /**
         * Set renderer surface scale strategy.
         * @method cc.node.Director#setScaleStrategy
         * @param ss {cc.render.ScaleManagerStrategy} how renderer surface should me up/down scaled when the window
         *          changes size.
         * @param sp {cc.render.ScalePosition} how to position the renderer surface on the window object.
         */
        setScaleStrategy( ss:cc.render.ScaleManagerStrategy, sp:cc.render.ScalePosition ) {
            this._scaleManager.setScale(ss,sp);
        }

        /**
         * Set internal ratio to adjust screen pixels to game units.
         * A game, usually makes the assumption that one game unit maps directly to one screen pixel.
         * When we want to build better looking games which honor devicePixelRation, retina, etc. we need to undo
         * this direct assumption in favor of other better mechanisms.
         * This method undoes this mapping.
         * For example, my game is 8 by 5 meters and want to see it in a 960x640 pixels screen.
         * The difference between this method and <code>setScaleStrategy</code> is that this one acts in game content,
         * and setScaleStrategy on the renderer generated image.
         * @method cc.node.Director#setScaleContent
         * @see cc.game.ScaleManager
         * @param w {number} game units width
         * @param h {number} game units height
         * @param cw {number=} canvas width
         * @param ch {number=} canvas height
         * @return {number} the scale factor resulting from the map units-pixels.
         */
        setScaleContent( w:number, h:number, cw?:number, ch?:number ) : number {

            if ( typeof cw!=="undefined" && typeof ch!=="undefined" ) {

                // resize canvas size keeping aspect ratio relative to units size.
                if ( cw/ch > w/h ) {
                    cw= w*ch/h + 1;

                } else {
                    ch= cw*h/w + 1;
                }

                cw= Math.ceil(cw);
                ch= Math.ceil(ch);

                if ( this._adjustContentToFullScreen ) {
                    cw= window.innerWidth;
                    ch=window.innerHeight;
                }

                // resize canvas object
                this.__resize( cw>>0, ch>>0 );

            }

            // make calcs for new unit-pixel ratio (w,h)
            this._scaleManager.setScaleContent(w,h);
            // calculate preferred units for the current canvas size
            this.__calcPreferredUnits();

            var ret:number= this._scaleManager.getUnitsFactor();

            if (this._onContentScaled ) {
                this._onContentScaled( w, h, this._preferredUnits.width, this._preferredUnits.height, cw, ch, this._sceneHint);
            }

            return ret;
        }

        /**
         * When <code>setScaleContent</code> has been called this method gives the scale factor for the units-pixel
         * mapping ratio.
         * @method cc.node.Director#getUnitsFactor
         * @returns {number}
         */
        getUnitsFactor() : number {
            return this._scaleManager.getUnitsFactor();
        }

        /**
         * Set renderer surface orientation strategy. If set to landscape or portrait, when the window changes size
         * will notify about valid or wrong orientation.
         * Default orientation is set to BOTH.
         * @method cc.node.Director#setOrientationStrategy
         * @param os {cc.render.OrientationStrategy} desired orientation.
         * @param onOk {cc.render.OrientationCallback}
         * @param onError {cc.render.OrientationCallback}
         */
        setOrientationStrategy( os:cc.render.OrientationStrategy, onOk?:cc.render.OrientationOkCallback, onError?:cc.render.OrientationErrorCallback ) {
            this._scaleManager.forceOrientation(os,onOk,onError);
        }

        /**
         * Get whether the device has fullScreen capabilities
         * @method cc.node.Director#isFullScreenCapable
         * @returns {boolean}
         */
        isFullScreenCapable() : boolean {
            return this._scaleManager.isFullScreenCapable();
        }

        /**
         * Is currently the system in full screen ?
         * @method cc.node.Director#isFullScreen
         * @returns {boolean}
         */
        isFullScreen() : boolean {
            return this._scaleManager.isFullScreen();
        }

        /**
         * Start full screen process. If the system is not full screen capable will silently fail.
         * @method cc.node.Director#startFullScreen
         * @param f {callback=} optional function called when the system enters full screen.
         */
        startFullScreen( f?:()=>any ) {
            this._scaleManager.startFullScreen(f);
        }

        /**
         * End full screen process. If the system is not full screen capable will silently fail.
         * @method cc.node.Director#endFullScreen
         * @param f {callback=} optional function called when the system enters full screen.
         */
        endFullScreen( f?:()=>any ) {
            this._scaleManager.endFullScreen(f);
        }

        forceOrientation( os:OrientationStrategy, onOk?: OrientationOkCallback, onError?: OrientationErrorCallback ) : ScaleManager {
            return this._scaleManager.forceOrientation(os,onOk,onError);
        }

        checkOrientation() {
            return this._scaleManager.checkOrientation();
        }

        __resize( w:number, h:number ) {
            this._surface.width= w;
            this._surface.height= h;
            this._dimension.width= w;
            this._dimension.height= h;
        }

        getType() : number {
            return cc.render.RENDERER_TYPE_CANVAS;
        }
    }

    function dc2d( renderer:Renderer ) : RenderingContext {
        var canvas:HTMLCanvasElement= renderer._surface;
        var c2d:any= canvas.getContext("2d");

        var globalAlpha:number =1;
        var globalCompositeOperation:cc.render.CompositeOperation= cc.render.CompositeOperation.source_over;

        c2d.flush= function() {

        };

        c2d.type= cc.render.RENDERER_TYPE_CANVAS;

        c2d.setStrokeStyleColor= function( color:cc.math.Color ) {
            this.strokeStyle= (<cc.math.Color>color).getFillStyle();
        };

        c2d.setStrokeStyleColorArray= function( colorArray:Float32Array ) {
            this.strokeStyle = new cc.math.Color(colorArray[0], colorArray[1], colorArray[2], colorArray[3]).getFillStyle();
        };

        c2d.setStrokeStylePattern = function( pattern:cc.render.Pattern ) {

        };

        c2d.setFillStyleColor= function( color:cc.math.Color ) {
            this.fillStyle = (<cc.math.Color>color).getFillStyle();
        };

        c2d.setFillStyleColorArray= function( colorArray:Float32Array ) {
            this.fillStyle = new cc.math.Color(colorArray[0], colorArray[1], colorArray[2], colorArray[3]).getFillStyle();
        };

        // BUGBUG canvas can only do fill pattern with whole images.
        c2d.setFillStylePattern = function( pattern:cc.render.Pattern ) {
             var _pattern= this.createPattern( pattern.texture._image, pattern.type );
            this.fillStyle= _pattern;
        };

        c2d.setTintColor= function( color:cc.math.Color ) {
            // useless for canvas.
        };

        c2d.clear= function() {
            this.save();
            this.setTransform(1,0,0,1,0,0);
            this.clearRect(0,0,this.getWidth(), this.getHeight());
            this.restore();
        };

        c2d.getUnitsFactor= function() {
            return renderer.getUnitsFactor();
        };

        c2d.getWidth= function() {
            return this.canvas.width;
        };

        c2d.getHeight= function() {
            return this.canvas.height;
        };

        c2d.setCompositeOperation= function( o:cc.render.CompositeOperation ) {
            if ( o===globalCompositeOperation ) {
                return;
            }
            globalCompositeOperation= o;
            this.globalCompositeOperation= cc.render.CompositeOperationToCanvas[ o ];
        };

        c2d.getCompositeOperation= function( ) : cc.render.CompositeOperation {
            return globalCompositeOperation;
        };

        c2d.setGlobalAlpha= function( alpha:number ) {
            if ( alpha===globalAlpha ) {
                return;
            }

            globalAlpha= alpha;
            this.globalAlpha= alpha;
        };

        c2d.getGlobalAlpha= function() : number {
            return globalAlpha;
        };

        /**
         * this.transform(1,0,0,-1,0,h);
           //this.translate(0, h);
           //this.scale(1, -1);
           this.drawImage(texture._image, sx, sy, sw, sh, dx, 0, dw, dh);
           //this.scale(1, -1);
           //this.translate(0, -h);
           this.transform(1,0,0,-1,0,-h);

         * @param texture
         * @param sx
         * @param sy
         * @param sw
         * @param sh
         * @param dx
         * @param dy
         * @param dw
         * @param dh
         */
        c2d.drawTexture= function(
            texture:cc.render.Texture2D,
            sx:number,  sy:number,  sw?:number, sh?:number,
            dx?:number, dy?:number, dw?:number, dh?:number ) {

            "use strict";

            var h;

            if ( arguments.length===3 ) {
                if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM ) {
                    h= texture._image.height+sy;
                    this.transform(1,0,0,-1,0,h);
                    this.drawImage(texture._image, sx, 0);
                    this.transform(1,0,0,-1,0,h);
                } else {
                    this.drawImage(texture._image, sx, sy);
                }
            } else if ( arguments.length===5 ) {
                if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM ) {
                    this.transform(1,0,0,-1,0,sh+sy);
                    this.drawImage(texture._image, sx, 0, sw, sh);
                    this.transform(1,0,0,-1,0,sh+sy);
                } else {
                    this.drawImage(texture._image, sx, sy, sw, sh);
                }
            } else {
                if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM ) {
                    this.transform(1,0,0,-1,0,dy+dh);
                    this.drawImage(texture._image, sx, sy, sw, sh, dx, 0, dw, dh);
                    this.transform(1,0,0,-1,0,dy+dh);
                } else {

                    this.drawImage(texture._image, sx, sy, sw, sh, dx, dy, dw, dh);
                }
            }
        };

        /**
         * draw a texture, but not preserving transformation homogeneity.
         * For most cases will work, but not for custom drawing nodes.
         * This method is used in Sprite, where you only want to draw the associated SpriteFrame.
         *
         * @param texture
         * @param sx
         * @param sy
         * @param sw
         * @param sh
         * @param dx
         * @param dy
         * @param dw
         * @param dh
         */
        c2d.drawTextureUnsafe= function(
            texture:cc.render.Texture2D,
            sx:number,  sy:number,  sw?:number, sh?:number,
            dx?:number, dy?:number, dw?:number, dh?:number ) {

            "use strict";

            if ( arguments.length===3 ) {
                if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM ) {
                    this.transform(1, 0, 0, -1, 0, texture._image.height);
                }
                this.drawImage(texture._image, sx, sy);
            } else if ( arguments.length===5 ) {
                if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM ) {
                    this.transform(1, 0, 0, -1, 0, sh);
                }
                this.drawImage(texture._image, sx, sy, sw, sh);
            } else {
                if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                    this.transform(1, 0, 0, -1, 0, dh);
                }
                this.drawImage(texture._image, sx, sy, sw, sh, dx, dy, dw, dh);
            }
        };

        c2d.drawMesh= function( geometry:Float32Array, uv:Float32Array, indices:Uint32Array, colorRGBA:number, texture:Texture2D ) {

            var r= (colorRGBA>>24)&0xff;
            var g= (colorRGBA>>16)&0xff;
            var b= (colorRGBA>>8)&0xff;
            var a= colorRGBA&0xff;

            this.strokeStyle= "rgba("+r+","+g+","+b+","+(a/255)+")";

            this.lineWidth= .05;
            for( var i=0; i<indices.length; i+=3 ) {

                var indexVertex0= indices[i+0]*3;
                var indexVertex1= indices[i+1]*3;
                var indexVertex2= indices[i+2]*3;

                this.beginPath();
                this.moveTo( geometry[ indexVertex0 ], geometry[ indexVertex0+1 ] );
                this.lineTo( geometry[ indexVertex1 ], geometry[ indexVertex1+1 ] );
                this.lineTo( geometry[ indexVertex2 ], geometry[ indexVertex2+1 ] );
                this.closePath();
                this.stroke();

            }

        };

        return <RenderingContext>c2d;
    }

    /**
     * @class cc.render.CanvasRenderer
     * @classdesc
     * @extends Renderer
     *
     * Create a Canvas renderer.
     */
    export class CanvasRenderer extends Renderer {

        /**
         * Create a new CanvasRenderer instance
         * @method cc.render.CanvasRenderer#constructor
         * @param w {width} surface pixels width
         * @param h {height} surface pixels height
         * @param surface {HTMLCanvasElement=} canvas object. @see {cc.render.Renderer#initialize}
         */
        constructor(  w : number, h : number, surface? : HTMLCanvasElement ) {
            super( w, h, surface );
            this._renderingContext= dc2d( this );

            cc.plugin.asset.AssetManager.prepareTextures( this );

        }

        /**
         * Get a renderingContext. Has drawing capabilities.
         * @method cc.render.CanvasRenderer#get:renderingContext
         * @returns {RenderingContext}
         */
        get renderingContext() : RenderingContext {
            return this._renderingContext;
        }

        /**
         * Get Canvas context (result from calling <code>canvas.getContext</code>).
         * @method cc.render.CanvasRenderer#get:canvasContext
         * @returns {any}
         */
        get canvasContext() : any {
            return this._renderingContext;
        }


        getCanvasContext() : RenderingContext {
            return this._renderingContext;
        }

        __resize( w:number, h:number ) {
            super.__resize(w,h);
            this._renderingContext= dc2d( this );
        }

        getType() : number {
            return cc.render.RENDERER_TYPE_CANVAS;
        }

    }

    /**
     * @class cc.render.WebGLRenderer
     * @classdesc
     *
     * Create a WebGL Renderer with drawing capabilities like a canvas object.
     */
    export class WebGLRenderer extends Renderer {

        /**
         * The canvas result of calling <code>canvas.getContext("webgl")</code>
         * @member cc.render.WebGLRenderer#_webglState
         * @type {WebGLRenderingContext}
         * @private
         */
        _webglState : WebGLState = null;

        /**
         * Create a new WebGLRenderer instance.
         * @method cc.render.WebGLRenderer#constructor
         * @param w {width} surface pixels width
         * @param h {height} surface pixels height
         * @param surface {HTMLCanvasElement=} canvas object. @see {cc.render.Renderer#initialize}
         */
        constructor( w : number, h : number, surface? : HTMLCanvasElement ) {
            super( w, h, surface );

            var drc : DecoratedWebGLRenderingContext= new cc.render.DecoratedWebGLRenderingContext(this);

            this._webglState= drc._webglState;
            this._renderingContext = drc;


            cc.plugin.asset.AssetManager.prepareTextures( this );

        }

        getCanvasContext() : WebGLState {
            return this._webglState;
        }

        /**
         * Get a renderingContext. Has drawing capabilities like a <code>CanvasRenderingContext2D</code>
         * @method cc.render.WebGLRenderer#get:renderingContext
         * @returns {RenderingContext}
         */
        get renderingContext() : RenderingContext {
            return this._renderingContext;
        }

        /**
         * Get Canvas context (result from calling <code>canvas.getContext</code>). Gets a gl context.
         * @method cc.render.WebGLRenderer#get:canvasContext
         * @returns {WebGLState}
         */
        get canvasContext() : any {
            return this._webglState;
        }

        prepareTexture( texture:cc.render.Texture2D ) : void {
            texture.__setAsGLTexture(this._webglState);
        }

        __resize( w:number, h:number ) {
            super.__resize(w,h);
            this._renderingContext.resize();
            this._webglState= (<DecoratedWebGLRenderingContext>this._renderingContext)._webglState;
        }

        getType() : number {
            return cc.render.RENDERER_TYPE_WEBGL;
        }

    }

    /**
     * @class cc.render.PatchData
     * @interface
     * @classdesc
     *
     * 9Patch scale area definition.
     * The left, right, top, bottom, define the center area.
     * All the others are derived from this. For example, top-left corner (with y growing down) will be:
     *  (0,0)-(left,top)
     */
    export interface PatchData {
        left?:number;
        right?:number;
        top?:number;
        bottom?:number;
    }

    /**
     * @name RendererUtil
     * @memberOf cc.render
     *
     * Various rendering helpers like 9path, etc.
     *
     */
    export var RendererUtil= {

        draw9Patch : function(ctx:RenderingContext,
                                  frameName:string,
                                  x:number, y:number,
                                  w:number, h:number,
                                  patchData? : PatchData
            ) {

            var sf:cc.node.sprite.SpriteFrame = cc.plugin.asset.AssetManager.getSpriteFrame(frameName);
            if (null === sf) {
                return;
            }

            // no patchdata, or destination size just scale the image.
            if (typeof patchData === "undefined") {
                ctx.drawTexture(sf.getTexture(), 0, 0, sf.getWidth(), sf.getHeight(), x, y, w, h);
                return;
            }

            var tx = sf.getX();
            var ty = sf.getY();

            patchData.left = patchData.left || 0;
            patchData.top = patchData.top || 0;
            patchData.right = patchData.right || 0;
            patchData.bottom = patchData.bottom || 0;

            var paddingW = patchData.left + patchData.right;
            var paddingH = patchData.bottom + patchData.top;

            var spriteBottomHeight = patchData.bottom;
            var spriteTopHeight = patchData.top;
            var spriteBottomY = sf.getHeight() - spriteBottomHeight;
            var spriteMiddleHeight = sf.getHeight() - paddingH;
            var spriteMiddleWidth = sf.getWidth() - paddingW;

            var spriteLeftWidth = patchData.left;
            var spriteRightWidth = patchData.right;

            var scaleFactor = ctx.getUnitsFactor();

            var topy = cc.render.RENDER_ORIGIN === cc.render.ORIGIN_TOP ? y :
            y + h - spriteTopHeight / scaleFactor;
            var bottomy = cc.render.RENDER_ORIGIN === cc.render.ORIGIN_TOP ? y + h - spriteBottomHeight / scaleFactor :
                y;
            var middley = cc.render.RENDER_ORIGIN === cc.render.ORIGIN_TOP ? y + spriteTopHeight / scaleFactor :
            y + spriteBottomHeight / scaleFactor;

            if (patchData.left) {

                // top left
                if (patchData.top) {
                    ctx.drawTexture(sf.getTexture(),
                        tx, ty, spriteLeftWidth, spriteTopHeight,
                        x, topy, spriteLeftWidth / scaleFactor, spriteTopHeight / scaleFactor);
                }

                // bottom left
                if (patchData.bottom) {
                    ctx.drawTexture(sf.getTexture(),
                        tx, ty + spriteBottomY, spriteLeftWidth, spriteBottomHeight,
                        x, bottomy, spriteLeftWidth / scaleFactor, spriteBottomHeight / scaleFactor);
                }

                ctx.drawTexture(sf.getTexture(),
                    tx, ty + patchData.top, spriteLeftWidth, spriteMiddleHeight,
                    x, middley, spriteLeftWidth / scaleFactor, h - paddingH / scaleFactor);

            }

            if (patchData.right) {

                // top left
                if (patchData.top) {
                    ctx.drawTexture(sf.getTexture(),
                        tx + sf.getWidth() - patchData.right, ty, spriteRightWidth, spriteTopHeight,
                        x + w - patchData.right / scaleFactor, topy, spriteRightWidth / scaleFactor, spriteTopHeight / scaleFactor);
                }

                // bottom left
                if (patchData.bottom) {
                    ctx.drawTexture(sf.getTexture(),
                        tx + sf.getWidth() - patchData.right, ty + spriteBottomY, spriteRightWidth, spriteBottomHeight,
                        x + w - patchData.right / scaleFactor, bottomy, spriteRightWidth / scaleFactor, spriteBottomHeight / scaleFactor);
                }

                ctx.drawTexture(sf.getTexture(),
                    tx + sf.getWidth() - patchData.right, ty + patchData.top, spriteRightWidth, spriteMiddleHeight,
                    x + w - patchData.right / scaleFactor, middley, spriteRightWidth / scaleFactor, h - paddingH / scaleFactor);

            }


            // top left
            if (patchData.top) {
                ctx.drawTexture(sf.getTexture(),
                    tx + patchData.left, ty, spriteMiddleWidth, spriteTopHeight,
                    x + patchData.left / scaleFactor, topy, w - paddingW / scaleFactor, spriteTopHeight / scaleFactor);
            }

            // bottom left
            if (patchData.bottom) {
                ctx.drawTexture(sf.getTexture(),
                    tx + patchData.left, ty + spriteBottomY, spriteMiddleWidth, spriteBottomHeight,
                    x + patchData.left / scaleFactor, bottomy, w - paddingW / scaleFactor, spriteBottomHeight / scaleFactor);
            }

            ctx.drawTexture(sf.getTexture(),
                tx + patchData.left, ty + patchData.top, spriteMiddleWidth, spriteMiddleHeight,
                x + patchData.left / scaleFactor, middley, w - paddingW / scaleFactor, h - paddingH / scaleFactor);


        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../math/Color.ts"/>
/// <reference path="../render/Texture2D.ts"/>

module cc.render {

    import Color= cc.math.Color;

    "use strict";

    export var RENDERER_TYPE_CANVAS:number = 1;
    export var RENDERER_TYPE_WEBGL:number = 0;

    /**
     * @class cc.render.Pattern
     * @classdesc
     *
     * Pattern fill info.
     *
     */
    export class Pattern {

        _texture: Texture2D= null;
        _type: string= "repeat";

        constructor( texture:cc.render.Texture2D, type:string ) {
            this._texture= texture;
            this._type= type;
        }

        get texture() : Texture2D {
            return this._texture;
        }

        get type() : string {
            return this._type;
        }
    }

    export enum CompositeOperation {
        source_over= 0,
        source_out=1,
        source_in=2,
        source_atop=3,
        destination_over=4,
        destination_in=5,
        destination_out=6,
        destination_atop= 7,
        multiply=8,
        screen=9,
        copy=10,
        lighter=11,
        darker=12,
        xor=13,
        add=14
    }

    export var CanvasToComposite= {
        "source-over": 0,
        "source-out": 1,
        "source-in": 2,
        "source-atop": 3,
        "destination-over": 4,
        "destination-in": 5,
        "destination-out": 6,
        "destination-atop": 7,
        "multiply": 8,
        "screen": 9,
        "copy": 10,
        "lighter": 11,
        "darker": 12,
        "xor": 13,
        "add": 14
    };

    export var CompositeOperationToCanvas= [
        "source-over",
        "source-out",
        "source-in",
        "source-atop",
        "destination-over",
        "destination-in",
        "destination-out",
        "destination-atop",
        "multiply",
        "screen",
        "copy",
        "lighter",
        "darker",
        "xor",
        "lighter"   // should be add, but does not exist.
    ];

    export enum LineCap {
        BUTT, SQUARE, ROUND
    }

    /**
     * @enum
     * 
     */
    export enum LineJoin {
        BEVEL, MITER, ROUND
    }

    /**
     * @class cc.render.RenderingContext
     * @interface
     * @classdesc
     *
     * A RenderingContext is a high level API for paint code execution. Normally, this paint code will be wrapped in a
     * <code>cc.node.Node</code>'s <code>draw</code> method. This allows arbitrary drawing capabilities per node which
     * is a big game changer from previous engine implementations where Node specialization at drawing forced composition
     * for custom draw.
     * <p>
     * While the <code>cc.render.CanvasRenderer</code> will mostly proxy to the under-laying
     * <code>CanvasRenderingContext2D</code>, the <code>cc.render.WebGLRenderer</code> will do extra to achieve
     * to aim at visual consistency with its canvas counterpart. This webgl implementation will allow for:
     *   <li>stroking and filling paths with color, patterns and gradients
     *   <li>use custom shader per quad
     *   <li>image slicing
     *   <li>rendering context save and restore
     *
     * <h4>Path</h4>
     * <p>
     * The rendering context has support for path stroke or fill operations. Internally, these operations are backed by
     * a path implementation <code>cc.math.Path</code>. The path, is composed by a collection of contours (basically
     * each time <code>moveTo</code> is called a new contour is created) and each contour is a collection of
     * <code>cc.math.path.Segment</code> objects. Calls to <code>lineTo</code> or <code>QuadraticCurveTo</code> create
     * segments and contour creation is automatically done.
     * <p>
     * The segment creation operations are incremental. In order to avoid leaking, a call to <code>beginPath</code>
     * must be performed to start with a new fresh path. The rendering context <code>cc.math.Path</code> object is not
     * reset per frame, it is something the developer must do on its own.
     * <p>
     * Each segment operation will automatically be modified by the current transformation matrix.
     * <p>
     * The Path object can manually created and stroked/filled for later fast stroke/fill operations.
     *
     * <h4>Transformation</h4>
     * At any given time, all rendering context operations can be transformed by a cumulative transformation matrix.
     * Calls to <code>translate</code>, <code>rotate</code> and <code>scale</code>, will
     * indistinctly affect path tracing/filling, image drawing, line width, text, pattern and gradient projection space,
     * etc.
     * <p>
     * The tansformation is not reset by the system at any time. It is developers responsibility to either make a call
     * to <code>setTransform(1,0,0,1,0,0)</code> or make appropriate <code>save</code>/<code>restore</code> calls.
     */
    export interface RenderingContext {

        /**
         * Renderer surface (canvas object)
         * @member cc.render.RenderingContext#canvas
         * @type {HTMLCanvasElement}
         */
        canvas : HTMLCanvasElement;

        /**
         * Set draw operations tint color.
         * The tinting only makes sense in a WebGL renderer.
         * @param color {cc.math.Color}
         * @method cc.render.RenderingContext#setTintColor
         */
        setTintColor( color:Color );

        /**
         * Set a global transparency value.
         * @param alpha {number} value between 0 and 1. 0 is full transparent and 1 is full opaque.
         * @method cc.render.RenderingContext#setGlobalAlpha
         */
        setGlobalAlpha( alpha: number );

        /**
         * Get the global transparency value.
         * @method cc.render.RenderingContext#getGlobalAlpha
         * @return number
         */
        getGlobalAlpha( ) : number;

        /**
         * Set rendering context current transformation matrix.
         * Preferred way of setting this will be by calling <code>matrix3.setRenderingContextTransform</code>.
         * @see {cc.math.Matrix3#setRenderingContextTransform}
         * @method cc.render.RenderingContext#setTransform
         * @param a {number}
         * @param b {number}
         * @param c {number}
         * @param d {number}
         * @param tx {number}
         * @param ty {number}
         */
        setTransform( a : number, b: number, c : number, d: number, tx : number, ty : number );

        /**
         * Concatenate the matrix described by a,b,c,d,tx,ty with the current transformation matrix.
         * @param a {number}
         * @param b {number}
         * @param c {number}
         * @param d {number}
         * @param tx {number}
         * @param ty {number}
         */
        transform( a : number, b: number, c : number, d: number, tx : number, ty : number );

        /**
         * Fill a rect with the current fillStyle.
         * @method cc.render.RenderingContext#fillRect
         * @param x {number}
         * @param y {number}
         * @param w {number}
         * @param h {number}
         */
        fillRect( x : number, y :number, w : number, h : number );

        /**
         * Draw an image.
         * This method can be called in 3 different ways:
         *
         * <li>3 parameters</li>
         * This will draw the whole texture at its actual size at the given sx,sy position.
         * <li>5 parameters</li>
         * This will draw the whole texture size at the given sx,sy position but at the size specified by sw,sh.
         * <li>9 parameters</li>
         * This will draw a source rectangle of the texture defined by sx,sy,sw,sh in the destination rectangle defined
         * by dx,dy,dw,dh.
         *
         * <p>
         * This method honors the current transformation matrix and will be safe to perform new drawing operations after
         * calling it.
         *
         * @param texture {cc.render.Texture2D}
         * @param sx {number}
         * @param sy {number}
         * @param sw {number=}
         * @param sh {number=}
         * @param dx {number=}
         * @param dy {number=}
         * @param dw {number=}
         * @param dh {number=}
         *
         * @method cc.render.RenderingContext#drawImage
         */
        drawTexture( texture:Texture2D, sx: number, sy:number, sw?:number, sh?:number, dx?: number, dy?:number, dw?:number, dh?:number  ) : void;

        /**
         * Draw an image.
         * This method can be called in 3 different ways:
         *
         * <li>3 parameters</li>
         * This will draw the whole texture at its actual size at the given sx,sy position.
         * <li>5 parameters</li>
         * This will draw the whole texture size at the given sx,sy position but at the size specified by sw,sh.
         * <li>9 parameters</li>
         * This will draw a source rectangle of the texture defined by sx,sy,sw,sh in the destination rectangle defined
         * by dx,dy,dw,dh.
         *
         * <p>
         * This method <b>does not</b> may leave the current transformation matrix in the wrong state, and you may get
         * not the expected results after calling new drawTexture/drawTextureUnsafe operations.
         * <p>
         * For a webgl renderer, this method is much faster than calling <code>drawTexture</code>. In most cases,
         * like an sprite which just needs to draw a chunk of a texture in a destination rectangle, this method will
         * suffice.
         *
         * @param texture {cc.render.Texture2D}
         * @param sx {number}
         * @param sy {number}
         * @param sw {number=}
         * @param sh {number=}
         * @param dx {number=}
         * @param dy {number=}
         * @param dw {number=}
         * @param dh {number=}
         *
         * @method cc.render.RenderingContext#drawImageUnsafe
         */
        drawTextureUnsafe( texture:Texture2D, sx: number, sy:number, sw?:number, sh?:number, dx?: number, dy?:number, dw?:number, dh?:number  ) : void;

        /**
         * Clear the current renderer surface.
         * @method cc.render.RenderingContext#clear
         */
        clear();

        /**
         * Flush current renderer. This method only makes sense for WebGL, the canvas implementation is empty.
         * A call to this method must be done in a WebGL renderer to have content shown in the canvas.
         * If running inside the engine, this method is called automatically.
         * @method cc.render.RenderingContext#flush
         */
        flush();

        /**
         * Rotate the current rendering context matrix by radians.
         * @method cc.render.RenderingContext#rotate
         * @param angleInRadians {number} radians to rotate
         */
        rotate( angleInRadians : number );

        /**
         * Translate the current rendering context.
         * @method cc.render.RenderingContext#translate
         * @param x {number}
         * @param y {number}
         */
        translate( x:number, y:number );

        /**
         * Scale the current rendering context.
         * @method cc.render.RenderingContext#scale
         * @param x {number}
         * @param y {number}
         */
        scale( x:number, y:number );

        /**
         * Get the rendering area width in pixels.
         * @method cc.render.RenderingContext#getWidth
         */
        getWidth() : number;

        /**
         * Get the rendering area height in pixels.
         * @method cc.render.RenderingContext#getWidth
         */
        getHeight() : number;

        /**
         * Get the renderer type. A value from cc.render.RENDERER_TYPE_CANVAS | cc.render.RENDERER_TYPE_WEBGL
         * @type {number}
         * @member cc.render.RenderingContext#type
         */
        type : number;

        /**
         * Save the current RenderingContext status. It clones the associated <code>cc.render.RenderingContextSnapshot</code>.
         * @method cc.render.RenderingContext#save
         */
        save() : void;

        /**
         * Restore a previously saved RenderingContext status.
         * It clones the associated <code>cc.render.RenderingContextSnapshot</code>.
         * @method cc.render.RenderingContext#restore
         */
        restore() : void;

        /**
         * Stroke (trace contour) of the current rendering context's state path.
         * The path is tracked internally in a <code>cc.math.Path</code> object.
         * The trace of the path contour is modified by:
         *   <li>current transformation matrix
         *   <li>line width
         *   <li>line join
         *   <li>line cap
         *   <li>line join miter limit
         *
         * @method cc.render.RenderingContext#stroke
         */
        stroke();

        /**
         * Fill the current rendering context's state path.
         * The path is tracked internally in a <code>cc.math.Path</code> object.
         * The fill is performed by a basic tessellation process. Self intersecting path contours won't be appropriately
         * displayed.
         * <b>This method may not be consistent between canvas and webgl renderers</b>
         *
         * @method cc.render.RenderingContext#fill
         */
        fill();

        /**
         * The the current rendering context to reset the internal path representation.
         * This method should be called to start a fresh path tracing/filling operation.
         *
         * This operation will be affected by the current transformation matrix.
         *
         * @method cc.render.RenderingContext#beginPath
         */
        beginPath();

        /**
         * Move the path tracer position.
         * @param x {number}
         * @param y {number}
         *
         * @method cc.render.RenderincContext#moveTo
         */
        moveTo(x:number, y:number);

        /**
         * Add a line from the current path position to the desired position.
         * This operation will be affected by the current transformation matrix.
         *
         * @param x {number}
         * @param y {number}
         * @method cc.render.RenderingContext#lineTo
         */
        lineTo(x:number, y:number);

        /**
         * Add a cubic bezier from the current path position defined by the two control points and the final curve point.
         *
         * @param cp0x {number} first control point x position
         * @param cp0y {number} first control point y position
         * @param cp1x {number} second control point x position
         * @param cp1y {number} second control point y position
         * @param p2x {number} second curve point x position
         * @param p2y {number} second curve point y position
         *
         * This operation will be affected by the current transformation matrix.
         *
         * @method cc.render.RenderingContext#bezierCurveTo
         */
        bezierCurveTo( cp0x:number, cp0y:number, cp1x:number, cp1y:number, p2x:number, p2y:number );

        /**
         * Add a quadratic bezier from the current path position defined by one control point and the final curve point.
         *
         * @param cp0x {number} control point x position
         * @param cp0y {number} control point y position
         * @param p2x {number} second curve point x position
         * @param p2y {number} second curve point y position
         *
         * This operation will be affected by the current transformation matrix.
         *
         * @method cc.render.RenderingContext#quadraticCurveTo
         */
        quadraticCurveTo( cp0x:number, cp0y:number, p2x:number, p2y:number );

        /**
         * Create a new rectangular closed contour on the current path.
         * @param x {number}
         * @param y {number}
         * @param width {number}
         * @param height {number}
         *
         * This operation will be affected by the current transformation matrix.
         *
         * @method cc.render.RenderingContext#rect
         */
        rect( x:number, y:number, width:number, height:number );

        /**
         * Add an arc segment to the current path.
         * The arc will be drawn as the least angle difference between startAngle and endAngle. This means that if an arc
         * is defined from 0 to 100*PI radians, the arc will actually be from 0 to 2*PI radians.
         *
         *
         * @param x {number} arc center x position
         * @param y {number} arc center y position
         * @param radius {number} arc radius
         * @param startAngle {number} arc start angle
         * @param endAngle {number} arc end angle
         * @param counterClockWise {boolean} if true the arc will be complimentary arc from the original one.
         *
         * This operation will be affected by the current transformation matrix.
         *
         * @method cc.render.RenderingContext#arc
         */
        arc( x:number, y:number, radius:number, startAngle:number, endAngle:number, counterClockWise:boolean );

        /**
         * Close the current contour on the current path.
         * Successive path operations will create a new contour.
         *
         * This operation will be affected by the current transformation matrix.
         *
         * @method cc.render.RenderingContext#closePath
         */
        closePath();

        /**
         * Set the current path line cap. This call will have effect when a call to <code>stroke</code> is performed.
         * @param cap {cc.render.LineCap}
         *
         * @method cc.render.RenderingContext#setLineCap
         */
        setLineCap( cap:LineCap );

        /**
         * Get the current line cap.
         *
         * @method cc.render.RenderingContext#getLineCap
         * @return cc.render.LineCap
         */
        getLineCap() : LineCap;

        /**
         * Set the current path line join. This call will have effect when a call to <code>stroke</code> is performed.
         * @param join {cc.render.LineJoin}
         *
         * @method cc.render.RenderingContext#setLineJoin
         */
        setLineJoin( join:LineJoin );

        /**
         * Get the current line join.
         *
         * @method cc.render.RenderingContext#getLineJoin
         * @return cc.render.LineJoin
         */
        getLineJoin() : LineJoin;

        /**
         * Set the line width for stroking a path.
         * The lineWidth will be affected by the current transformation matrix.
         *
         * @param w {number} desired line width. 1 by default.
         * @method cc.render.RenderingContext#setLineWidth
         */
        setLineWidth( w:number );

        /**
         * Get the current line width.
         *
         * @method cc.render.RenderingContext#getLineWidth
         * @return number
         */
        getLineWidth() : number;

        /**
         * Set fill operations color.
         *
         * @param color {cc.math.Color}
         * @method cc.render.RenderingContext#setFillStyleColor
         */
        setFillStyleColor( color:Color );

        /**
         * Set fill operations color.
         *
         * @param colorArray {Float32Array}
         * @method cc.render.RenderingContext#setFillStyleColorArray
         */
        setFillStyleColorArray( colorArray:Float32Array );

        /**
         * Set fill operations <code>cc.render.Pattern</code>.
         *
         * @param pattern {cc.render.Pattern}
         * @method cc.render.RenderingContext#setFillStylePattern
         */
        setFillStylePattern( pattern:cc.render.Pattern );

        /**
         * Set stroke operations color.
         *
         * @param color {cc.math.Color}
         * @method cc.render.RenderingContext#setStrokeStyleColor
         */
        setStrokeStyleColor( color:Color );

        /**
         * Set stroke operations color.
         *
         * @param colorArray {Float32Array}
         * @method cc.render.RenderingContext#setStrokeStyleColorArray
         */
        setStrokeStyleColorArray( colorArray:Float32Array );

        /**
         * Set stroke operations <code>cc.render.Pattern</code>.
         *
         * @param pattern {cc.render.Pattern}
         * @method cc.render.RenderingContext#setStrokeStylePattern
         */
        setStrokeStylePattern( pattern:cc.render.Pattern );

        /**
         * Resize the rendering context.
         * This method is internal and must never be called directly.
         *
         * @method cc.render.RenderingContext#resize
         */
        resize();

        /**
         * Get the units/pixels conversion ratio value.
         *
         * @method cc.render.RenderingContext#getUnitsFactor
         */
        getUnitsFactor():number;

        /**
         * Set current composite operation (blending mode).
         *
         * @param o {cc.render.CompositeOperation}
         * @method cc.render.RenderingContext#setCompositeOperation
         */
        setCompositeOperation( o:cc.render.CompositeOperation );

        /**
         * Get current composite operation (blending mode).
         *
         * @method cc.render.RenderingContext#getCompositeOperation
         * @return cc.render.CompositeOperation
         */
        getCompositeOperation() : cc.render.CompositeOperation;

        /**
         * Draw a mesh defined by geometry, texture coordinates and indices.
         * This method is expected to be used only in webgl. Current canvas renderer implementation will draw the mesh
         * itself and not the image.
         *
         * @param geometry {Float32Array} vertices geometry. <b>It expects 3 coords per vertex.</b>
         * @param uv {Float32Array} texture coordinates per vertex. 2 coords per vertex.
         * @param indices {Uint32Array} vertices indices.
         * @param color {number} a 32 bit encoded RGBA value. This will be a tint over the texture.
         * @param texture {cc.render.Texture2D} a texture.
         *
         * @method cc.render.RenderingContext#drawMesh
         */
        drawMesh( geometry:Float32Array, uv:Float32Array, indices:Uint32Array, color:number, texture:Texture2D );
    }

}
/**
 * License: see license.txt file.
 */

/// <reference path="../math/Point.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Path.ts"/>
/// <reference path="../math/path/geometry/StrokeGeometry.ts"/>
/// <reference path="./RenderingContext.ts"/>

module cc.render {

    /**
     * @class cc.render.RenderingContextSnapshot
     * @classdesc
     *
     * This class has all the necessary information for a canvas rendering context.
     * Whenever a call to <code>save</code> or <code>restore</code> is made, a new Object of this type will be
     * created/destroyed.
     * A developer never interacts with this objects directly, but by calling RenderingContext methods.
     * This class is for internal use of RenderingContext implementations (webgl).
     */
    export class RenderingContextSnapshot {

        /**
         * Composite operation.
         * @member cc.render.RenderingContextSnapshot#_globalCompositeOperation
         * @type {string}
         * @private
         */
        _globalCompositeOperation : cc.render.CompositeOperation = cc.render.CompositeOperation.source_over;

        /**
         * Current transformation matrix.
         * @member cc.render.RenderingContextSnapshot#_currentMatrix
         * @type {cc.math.Matrix3}
         * @private
         */
        _currentMatrix : Float32Array = new Float32Array([1.0,0,0, 0,1.0,0, 0,0,1.0]);

        /**
         * Current global alpha value.
         * @member cc.render.RenderingContextSnapshot#_globalAlpha
         * @type {number}
         * @private
         */
        _globalAlpha : number = 1;

        /**
         * Current miter limit.
         * @member cc.render.RenderingContextSnapshot#_miterLimit
         * @type {number}
         * @private
         */
        _miterLimit : number= 10;

        /**
         * Current fill type info. Needed for shader selection.
         * @member cc.render.RenderingContextSnapshot#_currentFillStyleType
         * @type {cc.render.FillStyleType}
         * @private
         */
        _currentFillStyleType : cc.render.FillStyleType= cc.render.FillStyleType.MESHCOLOR;

        /**
         * Current fill style.
         * @member cc.render.RenderingContextSnapshot#_fillStyle
         * @type {any}
         * @private
         */
        _fillStyleColor : Float32Array= new Float32Array([0.0, 0.0, 0.0, 1.0]);

        /**
         * Current pattern info when <code>_currentFillStyleType</code> is
         * <code>cc.render.FillStyleType.PATTERN_REPEAT</code>
         * @type {cc.render.Pattern}
         * @member cc.render.RenderingContextSnapshot#_fillStylePattern
         * @private
         *
         */
        _fillStylePattern : cc.render.Pattern= null;

        /**
         * Current tint color. Only makes sense in webgl renderers.
         * @member cc.render.RenderingContextSnapshot#_tintColor
         * @type {Float32Array}
         * @private
         */
        _tintColor : Float32Array = new Float32Array([0.0, 0.0, 0.0, 1.0]);

        /**
         * Current stroke line width.
         * @member cc.render.RenderingContextSnapshot#_lineWidth
         * @type {number}
         * @private
         */
        _lineWidth : number = 1.0;

        /**
         * Line cap hint for path stroking.
         * @type {cc.render.LineCap.BUTT}
         * @member cc.render.RenderingContextSnapshot#_lineCap
         * @private
         */
        _lineCap : cc.render.LineCap = cc.render.LineCap.BUTT;

        /**
         * Line join hint for path stroking.
         * @type {cc.render.LineCap.BUTT}
         * @member cc.render.RenderingContextSnapshot#_lineJoin
         * @private
         */
        _lineJoin: cc.render.LineJoin= cc.render.LineJoin.MITER;

        /**
         * Current font data.
         * @member cc.render.RenderingContextSnapshot#_fontDefinition
         * @type {string}
         * @private
         */
        _fontDefinition : string = "10px sans-serif";

        /**
         * Current font baseline.
         * @member cc.render.RenderingContextSnapshot#_textBaseline
         * @type {string}
         * @private
         */
        _textBaseline : string = "alphabetic";

        /**
         * Current text align. Valid values are: left, center, right
         * @member cc.render.RenderingContextSnapshot#_textAlign
         * @type {string}
         * @private
         */
        _textAlign : string = "left";

        /**
         * Current path tracing data.
         * @member cc.render.RenderingContextSnapshot#_currentPath
         * @type {any}
         * @private
         */
        _currentPath : any = null;

        /**
         * Current clipping paths stack
         * @member cc.render.RenderingContextSnapshot#_clippingStack
         * @type {Array}
         * @private
         */
        _clippingStack : Array<any> = [];

        /**
         * Build a new RenderingContextSnapshot instance.
         * @method cc.render.RenderingContextSnapshot#constructor
         */
        constructor() {

            this._currentPath= new cc.math.Path();
        }

        /**
         * Clone this snapshot and create a new one.
         * @method cc.render.RenderingContextSnapshot#clone
         * @returns {cc.render.RenderingContextSnapshot}
         */
        clone() : RenderingContextSnapshot {

            var rcs : RenderingContextSnapshot = new RenderingContextSnapshot();

            rcs._globalCompositeOperation = this._globalCompositeOperation;
            rcs._globalAlpha = this._globalAlpha;
            cc.math.Matrix3.copy( rcs._currentMatrix, this._currentMatrix );
            rcs._fillStyleColor= this._fillStyleColor;
            rcs._fillStylePattern= this._fillStylePattern;
            rcs._currentFillStyleType= this._currentFillStyleType;
            rcs._tintColor= this._tintColor;
            rcs._lineWidth= this._lineWidth;
            rcs._miterLimit= this._miterLimit;
            rcs._fontDefinition= this._fontDefinition;
            rcs._textBaseline= this._textBaseline;
            rcs._textAlign= this._textAlign;

            rcs._currentPath = this._currentPath.clone();
            rcs._clippingStack = this._clippingStack;

            return rcs;
        }

        /**
         * begin path in the path tracer.
         * @method cc.render.RenderingContextSnapshot#beginPath
         */
        beginPath() {
            this._currentPath.beginPath();
        }

        /**
         * Close the current contour in the path tracer.
         * A closed contour can't have any other segment added, and successive tracing operations will create a new
         * contour.
         * @method cc.render.RenderingContextSnapshot#closePath
         */
        closePath() {
            this._currentPath.closePath();
        }

        /**
         * Move the current path position based on the current transformation matrix.
         * @param x {number}
         * @param y {number}
         * @method cc.render.RenderingContextSnapshot#moveTo
         */
        moveTo( x:number, y:number ) {
            this._currentPath.moveTo(x,y,this._currentMatrix);
        }

        /**
         * Add a line segment to the current path. Segment info must be transformed by the current transformation matrix.
         * @param x {number}
         * @param y {number}
         * @method cc.render.RenderingContextSnapshot#lineTo
         */
        lineTo( x:number, y:number ) {
            this._currentPath.lineTo(x,y,this._currentMatrix);
        }

        /**
         * Add a bezier segment to the current path. Segment info must be transformed by the current transformation matrix.
         * @param cp0x {number}
         * @param cp0y {number}
         * @param cp1x {number}
         * @param cp1y {number}
         * @param p2x {number}
         * @param p2y {number}
         * @method cc.render.RenderingContextSnapshot#bezierCurveTo
         */
        bezierCurveTo( cp0x:number, cp0y:number, cp1x:number, cp1y:number, p2x:number, p2y:number ) {
            this._currentPath.bezierCurveTo( cp0x, cp0y, cp1x, cp1y, p2x, p2y,this._currentMatrix );
        }

        /**
         * Add a quadratic segment to the current path. Segment info must be transformed by the current transformation matrix.
         * @param cp0x {number}
         * @param cp0y {number}
         * @param p2x {number}
         * @param p2y {number}
         * @method cc.render.RenderingContextSnapshot#quadraticCurveTo
         */
        quadraticCurveTo( cp0x:number, cp0y:number, p2x:number, p2y:number ) {
            this._currentPath.quadraticCurveTo( cp0x, cp0y, p2x, p2y,this._currentMatrix );
        }

        /**
         * Add a rectangle segment to the current path.
         * Segment info must be transformed by the current transformation matrix.
         * @param x {number}
         * @param y {number}
         * @param width {number}
         * @param height {number}
         * @method cc.render.RenderingContextSnapshot#rect
         */
        rect( x:number, y:number, width:number, height:number ) {
            this._currentPath.rect( x, y, width, height, this._currentMatrix );
        }

        /**
         * Add an arc segment to the current path.
         * Segment info must be transformed by the current transformation matrix.
         * @param x {number}
         * @param y {number}
         * @param radius {number}
         * @param startAngle {number}
         * @param endAngle {number}
         * @param counterClockWise {boolean}
         *
         * @method cc.render.RenderingContextSnapshot#arc
         */
        arc( x:number, y:number, radius:number, startAngle:number, endAngle:number, counterClockWise:boolean ) {
            this._currentPath.arc( x, y, radius, startAngle, endAngle, counterClockWise, this._currentMatrix );
        }

        /**
         * Tell the current path to create geometry for its contour stroke.
         * The stroke will different based on the line width, and contour hints line join/cap.
         *
         * You normally don't have to interact with this method.
         *
         * @param lineWidth {number}
         * @param join {cc.render.LineJoin}
         * @param cap {cc.render.LineCap}
         *
         * @method cc.render.RenderingContextSnapshot#setupStroke
         * @returns {Float32Array}
         */
        setupStroke( lineWidth:number, join:cc.render.LineJoin, cap:cc.render.LineCap ) {
            if ( this._currentPath._dirty || this._lineWidth!==lineWidth || this._lineCap!==cap || this._lineJoin!==join ) {

                lineWidth= cc.math.path.getDistanceVector(lineWidth, this._currentMatrix).length();

                this._lineCap= cap;
                this._lineJoin= join;
                this._lineWidth= lineWidth;

                this._currentPath.getStrokeGeometry({
                    width: lineWidth,
                    cap: this._lineCap,
                    join: this._lineJoin,
                    miterLimit: this._miterLimit
                });

            }

            return this._currentPath._strokeGeometry;
        }

        /**
         * Tell the current path to create geometry for filling it.
         *
         * You normally don't have to interact with this method.
         *
         * @method cc.render.RenderingContextSnapshot#setupFill
         * @returns {Float32Array}
         */
        setupFill( ) {
            return this._currentPath.getFillGeometry();
        }

    }

}
/**
 * License: see license.txt file.
 */

/// <reference path="../math/Point.ts"/>
/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="./RenderingContextSnapshot.ts"/>
/// <reference path="./WebGLState.ts"/>
/// <reference path="./shader/AbstractShader.ts"/>
/// <reference path="./shader/Buffer.ts"/>

module cc.render {

    "use strict";

    import Color = cc.math.Color;
    import Point = cc.math.Point;
    import Vector = cc.math.Vector;
    import Matrix3 = cc.math.Matrix3;
    import RenderingContextSnapshot = cc.render.RenderingContextSnapshot;
    import AbstractShader = cc.render.shader.AbstractShader;
    import Buffer = cc.render.shader.Buffer;
    import WebGLState = cc.render.WebGLState;
    import Sprite = cc.node.Sprite;

    var __vv : Point = { x:0, y:0 };
    var __vv0 : Point = { x:0, y:0 };
    var __color : Uint8Array = new Uint8Array([0,0,0,0]);

    /**
     * @class cc.render.GeometryBatcher
     * @classdesc
     *
     * This class handles geometry, batches it into ping-pong'ed buffers and signals when to flush.
     */
    export class GeometryBatcher {

        /**
         * Max bufferable quads.
         * @member cc.render.GeometryBatcher.MAX_QUADS
         * @type {number}
         */
        static MAX_QUADS : number = 16383;

        /**
         * WebGL geometry, color and uv buffer ids.
         * @member cc.render.GeometryBatcher#_glDataBuffers;
         * @type {Array<WebGLBuffer>}
         * @private
         */
        _glDataBuffers : Buffer[] = [];

        /**
         * WebGL indices buffer ids.
         * @member cc.render.GeometryBatcher#_glIndexBuffers;
         * @type {Array<WebGLBuffer>}
         * @private
         */
        _glIndexBuffers : Buffer[] = [];

        /**
         * Currently used gl buffer index.
         * @member cc.render.GeometryBatcher#_glIndexBuffer
         * @type {WebGLBuffer}
         * @private
         */
        _glIndexBuffer : Buffer;

        /**
         * Currently used gl buffer for geometry, color and uv.
         * @member cc.render.GeometryBatcher#_glDataBuffer
         * @type {WebGLBuffer}
         * @private
         */
        _glDataBuffer : Buffer;

        /**
         * Batching buffers index.
         * @member cc.render.GeometryBatcher#_currentBuffersIndex
         * @type {number}
         * @private
         */
        _currentBuffersIndex : number = 0;

        /**
         * Main rendering buffer as buffer array (abstract version).
         * @member cc.render.GeometryBatcher#_dataArrayBuffer
         * @type {ArrayBuffer}
         * @private
         */
        _dataArrayBuffer : ArrayBuffer= null;

        /**
         * Current rendering buffer as Float32 array
         * @member cc.render.GeometryBatcher#_dataBufferFloat
         * @type {Float32Array}
         * @private
         */
        _dataBufferFloat : Float32Array = null;

        /**
         * Current rendering buffer as Uint8 array.
         * @member cc.render.GeometryBatcher#_dataBufferByte
         * @type {Uint8Array}
         * @private
         */
        _dataBufferByte : Uint8Array = null;

        /**
         * Current rendering buffer as Uint32 array.
         * @member cc.render.GeometryBatcher#_dataBufferUint
         * @type {Uint8Array}
         * @private
         */
        _dataBufferUint : Uint32Array = null;

        /**
         * Current Buffer index.
         * @member cc.render.GeometryBatcher#_dataBufferIndex
         * @type {number}
         * @private
         */
        _dataBufferIndex : number = 0;

        /**
         * Current rendering buffer for geometry indices.
         * @member cc.render.GeometryBatcher#_indexBuffer
         * @type {Float32Array}
         * @private
         */
        _indexBuffer : Uint16Array = null;

        /**
         * Current Buffer index.
         * @member cc.render.GeometryBatcher#_indexBufferIndex
         * @type {number}
         * @private
         */
        _indexBufferIndex : number = 0;

        _indexBufferMesh : Uint16Array = null;
        _indexBufferMeshIndex : number = 0;

        _glIndexMeshBuffers : Buffer[] = [];
        _glIndexMeshBuffer : Buffer = null;

        /**
         * The canvas WebGLRenderingContext
         * @member cc.render.GeometryBatcher#_gl
         * @type {WebGLRenderingContext}
         */
        _gl : WebGLRenderingContext= null;

        /**
         * Build a new GeometryBatcher instance. You probably will need one of this.
         * @method cc.render.GeometryBatcher#constructor
         * @param _gl {WebGLRenderingContext}
         */
        constructor( glstate : WebGLState ) {

            this._gl= glstate._gl;

            this._dataArrayBuffer= new ArrayBuffer(GeometryBatcher.MAX_QUADS*40*4);
            this._dataBufferFloat= new Float32Array(this._dataArrayBuffer);    // 40 is fastshader vertex size.
            this._dataBufferByte= new Uint8Array(this._dataArrayBuffer);
            this._dataBufferUint= new Uint32Array(this._dataArrayBuffer);
            this._indexBuffer= new Uint16Array( GeometryBatcher.MAX_QUADS*6 );
            this._indexBufferMesh= new Uint16Array( GeometryBatcher.MAX_QUADS*6 );

            // preset geometry indices.
            var indexBufferIndex= 0;
            var elementIndex= 0;
            var indexBuffer= this._indexBuffer;
            for( var i=0; i<GeometryBatcher.MAX_QUADS; i++ ) {

                indexBuffer[indexBufferIndex] = elementIndex;
                indexBuffer[indexBufferIndex + 1] = elementIndex + 1;
                indexBuffer[indexBufferIndex + 2] = elementIndex + 2;

                indexBuffer[indexBufferIndex + 3] = elementIndex;
                indexBuffer[indexBufferIndex + 4] = elementIndex + 2;
                indexBuffer[indexBufferIndex + 5] = elementIndex + 3;
                indexBufferIndex += 6;
                elementIndex += 4;
            }

            for( var i=0; i<GeometryBatcher.MAX_QUADS*6; i++ ) {
                this._indexBufferMesh[ i ]= i;
            }

            this._glDataBuffers.push( new Buffer( this._gl, this._gl.ARRAY_BUFFER, this._dataBufferFloat, this._gl.DYNAMIC_DRAW ) );
            this._glDataBuffers.push( new Buffer( this._gl, this._gl.ARRAY_BUFFER, this._dataBufferFloat, this._gl.DYNAMIC_DRAW ) );
            this._glDataBuffers.push( new Buffer( this._gl, this._gl.ARRAY_BUFFER, this._dataBufferFloat, this._gl.DYNAMIC_DRAW ) );
            this._glDataBuffers.push( new Buffer( this._gl, this._gl.ARRAY_BUFFER, this._dataBufferFloat, this._gl.DYNAMIC_DRAW ) );

            this._glIndexBuffers.push( new Buffer( this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer, this._gl.STATIC_DRAW ) );
            this._glIndexBuffers.push( new Buffer( this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer, this._gl.STATIC_DRAW ) );
            this._glIndexBuffers.push( new Buffer( this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer, this._gl.STATIC_DRAW ) );
            this._glIndexBuffers.push( new Buffer( this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer, this._gl.STATIC_DRAW ) );

            this._glIndexMeshBuffers.push( new Buffer( this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBufferMesh, this._gl.STATIC_DRAW ) );
            this._glIndexMeshBuffers.push( new Buffer( this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBufferMesh, this._gl.STATIC_DRAW ) );
            this._glIndexMeshBuffers.push( new Buffer( this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBufferMesh, this._gl.STATIC_DRAW ) );
            this._glIndexMeshBuffers.push( new Buffer( this._gl, this._gl.ELEMENT_ARRAY_BUFFER, this._indexBufferMesh, this._gl.STATIC_DRAW ) );

            this._glDataBuffer= this._glDataBuffers[0];
            this._glIndexBuffer= this._glIndexBuffers[0];
            this._glIndexMeshBuffer= this._glIndexMeshBuffers[0];
        }

        /**
         * Batch a rectangle with texture.
         *
         * @method cc.render.GeometryBatcher#batchRectGeometryWithTexture
         * @param vertices {Array<cc.math.Point>}
         * @param u0 {number}
         * @param v0 {number}
         * @param u1 {number}
         * @param v1 {number}
         * @param rcs {cc.render.RenderingContextSnapshot}
         * @returns {boolean}
         */
        batchRectGeometryWithTexture( vertices:Point[], u0:number, v0:number, u1:number, v1:number, rcs:RenderingContextSnapshot ) {
            var cc= this.__uintColor( rcs );

            this.batchVertex( vertices[0], cc, u0,v0 );
            this.batchVertex( vertices[1], cc, u1,v0 );
            this.batchVertex( vertices[2], cc, u1,v1 );
            this.batchVertex( vertices[3], cc, u0,v1 );

            // add two triangles * 3 values each.
            this._indexBufferIndex+=6;

            return this._indexBufferIndex+6 >= this._indexBuffer.length;
        }

        /**
         * Batch a rectangle with texture info and tint color.
         * Tint color will be modified by currently alpha value set.
         * @member cc.render.GeometryBatcher#batchRectWithTexture
         * @param x {number} rectangle position
         * @param y {number}
         * @param w {number} rectangle size
         * @param h {number}
         * @param rcs {RenderingContextSnapshot} current rendering context snapshot info
         * @param u0 {number} texture position
         * @param v0 {number}
         * @param u1 {number} texture size
         * @param v1 {number}
         */
        batchRectWithTexture( x:number, y:number, w:number, h:number, rcs:RenderingContextSnapshot,
                              u0:number, v0:number, u1:number, v1:number ) :boolean {

            var cm : Float32Array= rcs._currentMatrix;
            var cc= this.__uintColor( rcs );

            __vv.x= x;
            __vv.y= y;
            this.batchVertex( Matrix3.transformPoint(cm,__vv), cc, u0,v0 );
            __vv.x= x+w;
            __vv.y= y;
            this.batchVertex( Matrix3.transformPoint(cm,__vv), cc, u1,v0 );
            __vv.x= x+w;
            __vv.y= y+h;
            this.batchVertex( Matrix3.transformPoint(cm,__vv), cc, u1,v1 );
            __vv.x= x;
            __vv.y= y+h;
            this.batchVertex( Matrix3.transformPoint(cm,__vv), cc, u0,v1 );

            // add two triangles * 3 values each.
            this._indexBufferIndex+=6;

            return this._indexBufferIndex+6 >= this._indexBuffer.length;
        }

        /**
         * Batch a rect with the current rendering info. The rect color will be tinted. Resulting transparency value will
         * be modified by currently rendering context alpha value set.
         * @method cc.render.GeometryBatcher#batchRect
         * @param x {number}
         * @param y {number}
         * @param w {number}
         * @param h {number}
         * @param rcs {cc.render.RenderingContextSnapshot} current rendering context snapshot info
         */
        batchRect( x:number, y:number, w:number, h:number, rcs:RenderingContextSnapshot ) : boolean {

            var color:Float32Array= rcs._fillStyleColor;
            var tint:Float32Array= rcs._tintColor;

            var r= ((color[0] * tint[0])*255)|0;
            var g= ((color[1] * tint[1])*255)|0;
            var b= ((color[2] * tint[2])*255)|0;
            var a= ((color[3] * tint[3] * rcs._globalAlpha)*255)|0;
            var cc= (r)|(g<<8)|(b<<16)|(a<<24);

            var cm : Float32Array= rcs._currentMatrix;

            // 0-1-2

            __vv0.x= x;
            __vv0.y= y;
            Matrix3.transformPoint(cm,__vv0);
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv0.x;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv0.y;
            this._dataBufferUint [ this._dataBufferIndex++ ] = cc;

            __vv.x= x+w;
            __vv.y= y;
            Matrix3.transformPoint(cm,__vv);
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv.x;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv.y;
            this._dataBufferUint [ this._dataBufferIndex++ ] = cc;

            __vv.x= x+w;
            __vv.y= y+h;
            Matrix3.transformPoint(cm,__vv);
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv.x;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv.y;
            this._dataBufferUint [ this._dataBufferIndex++ ] = cc;


            // 0-2-3

            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv0.x;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv0.y;
            this._dataBufferUint [ this._dataBufferIndex++ ] = cc;

            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv.x;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv.y;
            this._dataBufferUint [ this._dataBufferIndex++ ] = cc;

            __vv.x= x;
            __vv.y= y+h;
            Matrix3.transformPoint(cm,__vv);
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv.x;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = __vv.y;
            this._dataBufferUint [ this._dataBufferIndex++ ] = cc;

            // add two triangles * 3 values each.
            this._indexBufferMeshIndex+=6;

            return this._indexBufferMeshIndex+6 >= this._indexBuffer.length;
        }

        /**
         * Batch a vertex with color and texture.
         * @method cc.render.GeometryBatcher#batchVertex
         * @param p {Point}
         * @param r {number}
         * @param g {number}
         * @param b {number}
         * @param a {number}
         * @param u {number}
         * @param v {number}
         */
        batchVertex( p:Point, cc:number, u:number, v:number ) : void {
            this._dataBufferFloat[ this._dataBufferIndex++ ] = p.x;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = p.y;
            this._dataBufferUint [ this._dataBufferIndex++ ] = cc;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = u;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = v;
        }

        /**
         * BUGBUG refactor. Move to AbstractShader and reimplement for each shader.
         * Flush currently batched geometry and related info with a given shader program.
         * @method cc.render.GeometryBatcher#flush
         * @param shader {cc.render.shader.AbstractShader} program shader
         * @param rcs {cc.render.RenderingContextSnapshot}
         */
        flush( shader: AbstractShader, rcs:cc.render.RenderingContextSnapshot ) : void {

            var trianglesCount;

            if (shader.useMeshIndex()) {
                trianglesCount = this._indexBufferMeshIndex;
                if (!trianglesCount) {
                    return;
                }
                this._glIndexMeshBuffer.bind(this._gl.ELEMENT_ARRAY_BUFFER);

            } else {
                trianglesCount = this._indexBufferIndex;
                if (!trianglesCount) {
                    return;
                }
                // simply rebind the buffer, not modify its contents.
                this._glIndexBuffer.bind(this._gl.ELEMENT_ARRAY_BUFFER);
            }

            //this._glDataBuffer.forceEnableWithValue(this._dataBufferFloat);
            this._glDataBuffer.forceEnableWithValue(this._dataBufferFloat.subarray(0, this._dataBufferIndex));
            //this._glDataBuffer.enableWithValue(this._dataBufferFloat.subarray(0, this._dataBufferIndex));

            shader.flushBuffersWithContent(rcs);

            this._gl.drawElements(this._gl.TRIANGLES, trianglesCount, this._gl.UNSIGNED_SHORT, 0);
            //this._gl.drawArrays(this._gl.TRIANGLES, 0, trianglesCount);

            // reset buffer data index.
            this._dataBufferIndex = 0;
            this._indexBufferIndex = 0;
            this._indexBufferMeshIndex = 0;

            // ping pong rendering buffer.
            this._currentBuffersIndex = (this._currentBuffersIndex + 1) & 3;
            this._glDataBuffer = this._glDataBuffers[this._currentBuffersIndex];
            this._glIndexBuffer = this._glIndexBuffers[this._currentBuffersIndex];
            this._glIndexMeshBuffer = this._glIndexMeshBuffers[this._currentBuffersIndex];
        }

        /**
         * Get a compact Uint32 representation of a color.
         * The color is calculated as the mix or the rendering context current color multiplied the the rendering context
         * current tint color.
         * @method cc.render.GeometryBatcher#__uintColor
         * @param rcs {cc.render.RenderincContextSnapshot}
         * @returns {number}
         * @private
         */
        __uintColor( rcs:RenderingContextSnapshot ) : number {
            var tint:Float32Array= rcs._tintColor;

            var r= (tint[0]*255)|0;
            var g= (tint[1]*255)|0;
            var b= (tint[2]*255)|0;
            var a= (tint[3] * rcs._globalAlpha*255)|0;

            return (r)|(g<<8)|(b<<16)|(a<<24);
        }

        /**
         * Batch a fast sprite info. Fast sprite objects do all transformation calculations on the GPU, and as such,
         * have some limitations.
         *
         * @method cc.render.GeometryBatcher#batchRectGeometryWithSpriteFast
         *
         * @param sprite {cc.node.Sprite}
         * @param u0 {number}
         * @param v0 {number}
         * @param u1 {number}
         * @param v1 {number}
         * @param rcs {cc.render.RenderingContextSnapshot}
         * @returns {boolean}
         */
        batchRectGeometryWithSpriteFast( sprite:Sprite, u0:number, v0:number, u1:number, v1:number, rcs:RenderingContextSnapshot ) {

            var cc= this.__uintColor( rcs );

            var db= this._dataBufferFloat;
            var dbuint= this._dataBufferUint;
            var dbi=this._dataBufferIndex;

            //var w0 = (sprite._contentSize.width ) * (1-sprite._transformationAnchor.x);
            //var w1 = (sprite._contentSize.width ) * -sprite._transformationAnchor.x;
            //
            //var h1 = sprite._contentSize.height * (1-sprite._transformationAnchor.y);
            //var h0 = sprite._contentSize.height * -sprite._transformationAnchor.y;


            dbuint[dbi+2]= dbuint[dbi+12]= dbuint[dbi+22]= dbuint[dbi+32]= cc;
            db[dbi  ]= db[dbi+10]= db[dbi+20]= db[dbi+30]= sprite.x;
            db[dbi+1]= db[dbi+11]= db[dbi+21]= db[dbi+31]= sprite.y;
            db[dbi+7]= db[dbi+17]= db[dbi+27]= db[dbi+37]= sprite.rotationAngle;
            db[dbi+8]= db[dbi+18]= db[dbi+28]= db[dbi+38]= sprite.scaleX;
            db[dbi+9]= db[dbi+19]= db[dbi+29]= db[dbi+39]= sprite.scaleY;

            var w0 = sprite.width/2.0;
            var w1 = -w0;

            var h1 = sprite.height/2.0;
            var h0 = -h1;

            db[dbi+3]= u0;
            db[dbi+4]= v0;
            db[dbi+5]= w0;
            db[dbi+6]= h0;

            db[dbi+13]= u1;
            db[dbi+14]= v0;
            db[dbi+15]= w1;
            db[dbi+16]= h0;

            db[dbi+23]= u1;
            db[dbi+24]= v1;
            db[dbi+25]= w1;
            db[dbi+26]= h1;

            db[dbi+33]= u0;
            db[dbi+34]= v1;
            db[dbi+35]= w0;
            db[dbi+36]= h1;

            // add two triangles * 3 values each.
            this._indexBufferIndex+=6;
            this._dataBufferIndex+= 40;

            return this._dataBufferIndex+40 >= this._dataBufferFloat.length;
        }

        /**
         * Batch a mesh.
         * A mesh uses a custom shader for meshes. They expect to color-per-vertex info, but a global color for the as
         * a uniform value.
         *
         * @method cc.render.GeometryBatcher#batchMesh
         * @param geometry {Float32Array}
         * @param uv {Float32Array}
         * @param indices {Uint32Array}
         * @param color {number} the result of calling __uintColor
         */
        batchMesh( geometry:Float32Array, uv:Float32Array, indices:Uint32Array, color:number ) {

            for( var i=0; i<indices.length; i+=3 ) {

                var indexVertex0= indices[i+0]*3;
                var indexVertexUV0= indices[i+0]*2;
                this.batchMeshVertex(
                    geometry[ indexVertex0 ], geometry[ indexVertex0+1 ],
                    uv[ indexVertexUV0 ], uv[ indexVertexUV0+1 ] );

                var indexVertex1= indices[i+1]*3;
                var indexVertexUV1= indices[i+1]*2;
                this.batchMeshVertex(
                    geometry[ indexVertex1 ], geometry[ indexVertex1+1 ],
                    uv[ indexVertexUV1 ], uv[ indexVertexUV1+1 ] );

                var indexVertex2= indices[i+2]*3;
                var indexVertexUV2= indices[i+2]*2;
                this.batchMeshVertex(
                    geometry[ indexVertex2 ], geometry[ indexVertex2+1 ],
                    uv[ indexVertexUV2 ], uv[ indexVertexUV2+1 ] );
            }

        }

        /**
         * Batch a vertex for a mesh.
         *
         * @method cc.render.GeometryBatcher#batchMeshVertex
         * @param x {number}
         * @param y {number}
         * @param u {number}
         * @param v {number}
         */
        batchMeshVertex( x:number, y:number, u:number, v:number ) : void {
            this._dataBufferFloat[ this._dataBufferIndex++ ] = x;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = y;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = u;
            this._dataBufferFloat[ this._dataBufferIndex++ ] = v;
            this._indexBufferMeshIndex++;
        }

        /**
         * Batch a path geometry.
         * Requires sequential indices.
         * Geometry already in screen space.
         *
         * @method cc.render.GeometryBatcher#batchPath
         * @param geometry {Float32Array}
         * @param rcs {cc.render.RenderingContextSnapshot}
         */
        batchPath( geometry:Float32Array, rcs:RenderingContextSnapshot ) {

            var color:Float32Array= rcs._fillStyleColor;
            var tint:Float32Array= rcs._tintColor;

            var r= ((color[0] * tint[0])*255)|0;
            var g= ((color[1] * tint[1])*255)|0;
            var b= ((color[2] * tint[2])*255)|0;
            var a= ((color[3] * tint[3] * rcs._globalAlpha)*255)|0;
            var cc= (r)|(g<<8)|(b<<16)|(a<<24);

            for( var i=0; i<geometry.length; i+=2 ) {
                this._dataBufferFloat[ this._dataBufferIndex++ ] = geometry[i];
                this._dataBufferFloat[ this._dataBufferIndex++ ] = geometry[i+1];
                this._dataBufferUint [ this._dataBufferIndex++ ] = cc;
                this._indexBufferMeshIndex++
            }
        }
    }

}
/**
 * License: see license.txt file.
 */


/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Rectangle.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="../node/sprite/SpriteFrame.ts"/>
/// <reference path="./RenderingContext.ts"/>
/// <reference path="./RenderingContextSnapshot.ts"/>
/// <reference path="./WebGLState.ts"/>
/// <reference path="./Texture2D.ts"/>
/// <reference path="./GeometryBatcher.ts"/>
/// <reference path="./RenderUtil.ts"/>
/// <reference path="./shader/AbstractShader.ts"/>
/// <reference path="./shader/SolidColorShader.ts"/>
/// <reference path="./shader/TextureShader.ts"/>
/// <reference path="./shader/FastTextureShader.ts"/>
/// <reference path="./shader/TexturePatternShader.ts"/>
/// <reference path="./shader/Uniform.ts"/>

module cc.render {

    "use strict";

    import Color = cc.math.Color;
    import Rectangle = cc.math.Rectangle;
    import Sprite = cc.node.Sprite;
    import RenderingContext = cc.render.RenderingContext;
    import RenderingContextSnapshot = cc.render.RenderingContextSnapshot;
    import GeometryBatcher = cc.render.GeometryBatcher;
    import AbstractShader = cc.render.shader.AbstractShader;
    import SolidColorShader = cc.render.shader.SolidColorShader;
    import TextureShader = cc.render.shader.TextureShader;
    import TexturePatternShader = cc.render.shader.TexturePatternShader;
    import FastTextureShader = cc.render.shader.FastTextureShader;
    import Matrix3= cc.math.Matrix3;
    import WebGLState= cc.render.WebGLState;
    import SpriteFrame = cc.node.sprite.SpriteFrame;

    /**
     * Decorated WebGL Rendering Context fill style types.
     * @tsenum cc.render.FillStyleType
     */
    export enum FillStyleType {
        MESHCOLOR = 0,
        IMAGE = 1,
        IMAGEFAST = 2,
        PATTERN_REPEAT= 3,
        MESH = 4
    }

    /**
     * Shader types
     * @tsenum cc.render.ShaderType
     */
    export enum ShaderType {
        MESHCOLOR = 0,
        IMAGE = 1,
        IMAGEFAST = 2,
        PATTERN_REPEAT= 3,
        MESH = 4
    }

    /**
     * BIT Flag for WebGL enabled/disabled flags.
     * @tsenum cc.render.WEBGL_FLAGS
     */
    export enum WEBGL_FLAGS {
        BLEND = 1,
        DEPTH_TEST = 2,
        CULL_FACE = 4
    }

    var __mat3 : Float32Array = new Float32Array([1.0,0,0, 0,1.0,0, 0,0,1.0]);
    var __mat4 : Float32Array= new Float32Array( [
        1.0, 0, 0, 0,
        0, 1.0, 0, 0,
        0, 0, 1.0, 0,
        0, 0, 0, 1.0 ] );


    /**
     * @class cc.render.DecoratedWebGLRenderingContext
     * @classdesc
     * @extends RenderingContext
     *
     * This object wraps a 3D canvas context (webgl) and exposes a canvas-like 2d rendering API without sacrificing
     * flexibility to expose the internal gl context for custom drawing on developer side.
     * <p>
     * This object is an implementation of the <code>cc.render.RenderingContext</code> interface, and the documentation
     * associated must be referred there. The rest of the code are just implementation details of the interface.
     *
     * <p>
     * The implementation aims at performance and on-pair visual results with a canvas renderer. To achieve this,
     * as well as highest performance, the implementation:
     *   <li>lazily sets every property.
     *   <li>batches all drawing operations as much as possible.
     *   <li>ping-pongs between buffers
     *   <li>...
     *
     * <br>
     * All this would be transparent for the developer and happen automatically. For example, is a value is set to
     * <code>globalCompositeOperation</code> (set a blend mode), a gl call is not immediately executed, which prevents
     * consecutive calls to <code>globalCompositeOperation</code> to make explicit gl calls. Instead, the gl call
     * is deferred until the moment when some geometry will happen, for example, a fillRect call.
     * <br>
     * This mechanism is set for every potential flushing operation like changing fillStyle, compisite, textures, etc.
     *
     * @see cc.render.RenderingContext
     */
    export class DecoratedWebGLRenderingContext implements RenderingContext {

        /**
         * Enable UNPACK_PREMULTIPLY_ALPHA_WEBGL for textures. False by default.
         * @member cc.render.DecoratedWebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL
         * @type {boolean}
         */
        static UNPACK_PREMULTIPLY_ALPHA_WEBGL : boolean = false;

        /**
         * Enable antialias. False by default
         * @member cc.render.DecoratedWebGLRenderingContext.ANTIALIAS
         * @type {boolean}
         */
        static ANTIALIAS : boolean = false;

        /**
         * Enable context-document alpha blending. False by default.
         * @member cc.render.DecoratedWebGLRenderingContext.CTX_ALPHA
         * @type {boolean}
         */
        static CTX_ALPHA : boolean = false;

        /**
         * Currently set line join stroke hint.
         * @member cc.render.DecoratedRenderingContext#_currentLineJoin
         * @type {cc.render.LineJoin}
         * @private
         */
        _currentLineJoin:cc.render.LineJoin= cc.render.LineJoin.MITER;

        /**
         * Currently set line cap stroke hint.
         * @member cc.render.DecoratedRenderingContext#_currentLineCap
         * @type {cc.render.LineCap}
         * @private
         */
        _currentLineCap:cc.render.LineCap= cc.render.LineCap.BUTT;

        /**
         * Currently set line width stroke hint.
         * @member cc.render.DecoratedRenderingContext#_currentLineWidth
         * @type {number}
         * @private
         */
        _currentLineWidth:number = 1;

        /**
         * Current rendering context data.
         * @member cc.render.DecoratedWebGLRenderingContext#_currentContextSnapshot
         * @type {cc.render.RenderingContextSnapshot}
         * @private
         */
        _currentContextSnapshot : RenderingContextSnapshot = null;

        /**
         * Each call to save will create a new rendering context snapshot that will be tracked here.
         * @member cc.render.DecoratedWebGLRenderingContext#_contextSnapshots
         * @type {Array<cc.render.RenderingContextSnapshot>}
         * @private
         */
        _contextSnapshots : Array<RenderingContextSnapshot> = [];

        /**
         * if _currentFillStyleType===COLORMESH, this is the current color.
         * @member cc.render.DecoratedWebGLRenderingContext#_currentFillStyleColor
         * @type {Float32Array}
         * @private
         */
        _currentFillStyleColor : Float32Array = new Float32Array([0.0,0.0,0.0,1.0]);

        /**
         * if _currentStrokeStyleType===COLORMESH, this is the current color.
         * @member cc.render.DecoratedWebGLRenderingContext#_currentStrokeStyleColor
         * @type {Float32Array}
         * @private
         */
        _currentStrokeStyleColor : Float32Array = new Float32Array([0.0,0.0,0.0,1.0]);

        /**
         * if _currentStrokeStyleType===PATTERN_REPEAT, this is the pattern info.
         * @member cc.render.DecoratedWebGLRenderingContext#_currentFillStylePattern
         * @type {Float32Array}
         * @private
         */
        _currentFillStylePattern : cc.render.Pattern = null;

        /**
         * Current fill style type. The style type reflects what shader is currently set for rendering.
         * @member cc.render.DecoratedWebGLRenderingContext#_currentFillStyleType
         * @type {cc.render.FillStyleType}
         * @private
         */
        _currentFillStyleType : FillStyleType = FillStyleType.MESHCOLOR;

        /**
         * Current tint color. The tint color is multiplied by whatever drawing operation pixel color is currently
         * executed.
         *
         * @member cc.render.DecoratedWebGLRenderingContext#_currentTintColor
         * @type {Float32Array}
         * @private
         */
        _currentTintColor : Float32Array = new Float32Array([1.0,1.0,1.0,1.0]);

        /**
         * Last global composite operation set.
         * @member cc.render.DecoratedWebGLRenderingContext#_currentGlobalCompositeOperation
         * @type {string}
         * @private
         */
        _currentGlobalCompositeOperation : cc.render.CompositeOperation = cc.render.CompositeOperation.source_over;

        /**
         * Internal rendering shaders.
         * @member cc.render.DecoratedWebGLRenderingContext#_shaders
         * @type {Array<cc.render.shader.SolidColorShader>}
         * @private
         */
        _shaders : Array<AbstractShader> = [];

        /**
         * Geometry batcher.
         * @member cc.render.DecoratedWebGLRenderingContext#_batcher
         * @type {cc.render.GeometryBatcher}
         * @private
         */
        _batcher : GeometryBatcher = null;

        /**
         * Internal webgl context wrapping object.
         *
         * @member cc.render.DecoratedWebGLRenderingContext#_webglState
         * @type {cc.render.WebGLState}
         * @private
         */
        _webglState : WebGLState = null;

        /**
         * Rendering surface width.
         *
         * @member cc.render.DecoratedWebGLRenderingContext#_width
         * @type {number}
         * @private
         */
        _width : number = 0;

        /**
         * Rendering surface height.
         *
         * @member cc.render.DecoratedWebGLRenderingContext#_height
         * @type {number}
         * @private
         */
        _height : number = 0;

        /**
         * Renderer instance this gl renderer context belongs to.
         * @type {cc.render.Renderer}
         * @private
         */
        _renderer:Renderer= null;

        /**
         * Rendering surface (canvas object)
         * @member cc.render.DecoratedWebGLRenderingContext#_canvas
         * @type {HTMLCanvasElement}
         * @private
         */
        _canvas:HTMLCanvasElement= null;

        /**
         * Create a new DecoratedWebGLRenderingContext instance.
         * @method cc.render.DecoratedWebGLRenderingContext#constructor
         * @param r {cc.render.Renderer}
         */
        constructor( r:Renderer ) {

            this._renderer= r;
            this._canvas= r._surface;

            this.__initContext();

            this._batcher= new GeometryBatcher( this._webglState );

            this._currentContextSnapshot= new RenderingContextSnapshot();
            this._contextSnapshots.push(this._currentContextSnapshot);

            this.__createRenderingShaders(this._canvas.width, this._canvas.height);

            this.__setGlobalCompositeOperation();
        }

        __initContext() {

            var _canvas= this._canvas;

            function createContext() : WebGLRenderingContext {

                var _gl= null;
                try {
                    var obj = {
                        premultipliedAlpha: DecoratedWebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                        antialias: DecoratedWebGLRenderingContext.ANTIALIAS,
                        alpha: DecoratedWebGLRenderingContext.CTX_ALPHA,
                        stencil: true
                    };

                    _gl = _canvas.getContext("webgl", obj) || _canvas.getContext("experimental-webgl", obj);
                    _gl.pixelStorei(
                        _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                        DecoratedWebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL ? 1 : 0);
                }
                catch (e) {
                    alert("WebGL context error");
                }

                return _gl;
            }

            function initializeContext(webglState : WebGLState) {

                var _gl= webglState._gl;

                // Set clear color to black, fully transparent
                webglState.clearColor(0,0,0,0);
                // Disable depth testing
                webglState.disable(_gl.DEPTH_TEST);
                // Disable back face culling
                webglState.disable(_gl.CULL_FACE);
                // Clear the color as well as the depth buffer.
                webglState.clear(_gl.COLOR_BUFFER_BIT);

                webglState.viewport(0, 0, _canvas.width, _canvas.height);
            }

            this._width= this._canvas.width;
            this._height= this._canvas.height;

            this._webglState = new WebGLState(createContext());

            initializeContext(this._webglState);
        }

        clear() {
            var gl= this._webglState;

            var flags= gl._gl.COLOR_BUFFER_BIT;
            if (gl.flagEnabled( gl._gl.STENCIL_TEST) ) {
                flags |= gl._gl.STENCIL_BUFFER_BIT;
            }
            gl.clear(flags);
        }

        getWidth() : number {
            return this._width;
        }

        getHeight() : number {
            return this._height;
        }

        __createProjection( w:number, h:number ) : Float32Array[] {
            /**
             * Make an orthographics projection matrix.
             * @param left {number}
             * @param right {number}
             * @param bottom {number}
             * @param top {number}
             * @param znear {number}
             * @param zfar {number}
             *
             * @returns {Float32Array}
             */
            function createOrthographicProjectionMatrix(left, right, bottom, top, znear, zfar) {
                var tx = -(right + left) / (right - left);
                var ty = -(top + bottom) / (top - bottom);
                var tz = -(zfar + znear) / (zfar - znear);

                return new Float32Array(
                    [ 2 / (right - left), 0, 0, 0,
                      0, 2 / (top - bottom), 0, 0,
                      0, 0, -2 / (zfar - znear), 0,
                        tx,ty,tz,1 ]

                );
            }

            var opm : Float32Array[]= [];
            opm.push (createOrthographicProjectionMatrix(0, w, h, 0, -1, 1));
            opm.push(createOrthographicProjectionMatrix(0, w, 0, h, -1, 1));

            return opm;
        }

        /**
         * Create internal rendering shaders.
         * Do not call directly.
         * @method cc.render.DecoratedWebGLRenderingContext#__createRenderingShaders
         * @param w {number}
         * @param h {number}
         * @private
         */
        __createRenderingShaders(w:number, h:number) : void {

            /**
             * Never change the order the shaders are pushed.
             * BUGBUG change the _shader array in favor of an associative collection.
             */
            this._shaders.push( new SolidColorShader( this._webglState ) );
            this._shaders.push( new TextureShader( this._webglState ) );
            this._shaders.push( new FastTextureShader( this._webglState ) );
            this._shaders.push( new TexturePatternShader( this._webglState ) );
            this._shaders.push( new cc.render.shader.MeshShader( this._webglState ) );

            this.__setShadersProjection(w,h);

            this._shaders[0].useProgram();
        }

        __setShadersProjection(w:number, h:number) {
            var opms:Float32Array[]= this.__createProjection( w, h );
            var opm= opms[0];
            var opm_inverse= opms[1];

            for( var i=0; i<this._shaders.length; i++ ) {
                if ( i!==2 ) {

                    this._shaders[i]._uniformProjection.setValue(opm);
                } else {

                    /**
                     * FastShader needs different projection matrices because quad coordinates are calculated in the shader,
                     * and not in the client. Thus it is mandatory to send the correct projection matrix based on the
                     * y-axis rendering origin.
                     */
                    this._shaders[2]._uniformProjection.setValue( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_TOP ? opm : opm_inverse );
                }
            }
        }

        /**
         * Get the rendering surface object (canvas).
         * @method cc.render.DecoratedWebGLRenderingContext#get:canvas
         * @returns {HTMLCanvasElement}
         */
        get canvas() {
            return this._canvas;
        }

        /**
         * Set the current rendering tint color. Tint color is an array of 4 components for rgba. Values 0..1
         * @method cc.render.DecoratedWebGLRenderingContext#set:tintColor
         * @param color {cc.math.Color}
         */
        setTintColor( color : Color ) {
            this._currentTintColor= color._color;
        }

        set tintColor( color:Color ) {
            this._currentTintColor= color._color;
        }

        setGlobalAlpha( v : number ) {
            this._currentContextSnapshot._globalAlpha= v;
        }

        getGlobalAlpha() : number {
            return this._currentContextSnapshot._globalAlpha;
        }

        /**
         * Set the current rendering composite operation (blend mode).
         * The value is any of:
         *
         * "source-over", "source-out", "source-in", "source-atop", "destination-over", "destination-in",
         * "destination-out", "destination-atop", "multiply", "screen", "copy", "lighter", "darker", "xor", "add"
         *
         * @method cc.render.DecoratedWebGLRenderingContext#set:globalCompositeOperation
         * @param gco {cc.render.CompositeOperation}
         */
        setCompositeOperation( gco : cc.render.CompositeOperation ) {
            this._currentGlobalCompositeOperation= gco;
        }

        getCompositeOperation() : cc.render.CompositeOperation {
            return this._currentGlobalCompositeOperation;
        }

        /**
         * Internal blending mode set.
         * This function is called not when the blending mode is set, but when an actual geometry operation is about
         * to happen.
         * @method cc.render.DecoratedWebGLRenderingContext#__setGlobalCompositeOperation
         * @private
         */
        __setGlobalCompositeOperation() {

            var gl = this._webglState._gl;

            this._webglState.enable( gl.BLEND );

            switch (this._currentGlobalCompositeOperation) {
                case cc.render.CompositeOperation.source_over:
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                case cc.render.CompositeOperation.source_out:
                    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ZERO);
                    break;
                case cc.render.CompositeOperation.source_in:
                    gl.blendFunc(gl.DST_ALPHA, gl.ZERO);
                    break;
                case cc.render.CompositeOperation.source_atop:
                    gl.blendFunc(gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                case cc.render.CompositeOperation.destination_over:
                    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.DST_ALPHA);
                    break;
                case cc.render.CompositeOperation.destination_in:
                    gl.blendFunc(gl.ZERO, gl.SRC_ALPHA);
                    break;
                case cc.render.CompositeOperation.destination_out:
                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                case cc.render.CompositeOperation.destination_atop:
                    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA);
                    break;
                case cc.render.CompositeOperation.multiply:
                    gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                case cc.render.CompositeOperation.screen:
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
                    break;
                case cc.render.CompositeOperation.copy:
                    gl.blendFunc(gl.ONE, gl.ZERO);
                    break;
                case cc.render.CompositeOperation.lighter:
                    gl.blendFunc(gl.ONE, gl.ONE);
                    break;
                case cc.render.CompositeOperation.darker:
                    gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                case cc.render.CompositeOperation.xor:
                    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                case cc.render.CompositeOperation.add:
                    gl.blendFunc( gl.SRC_ALPHA, gl.DST_ALPHA );
                    break;
                default:
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            }

            this._currentContextSnapshot._globalCompositeOperation= this._currentGlobalCompositeOperation;
        }

        /**
         * Set the current transformation matrix.
         * @method cc.render.DecoratedWebGLRenderingContext#setTransform
         * @param a {number}
         * @param b {number}
         * @param c {number}
         * @param d {number}
         * @param tx {number}
         * @param ty {number}
         */
        setTransform( a : number, b : number, c : number, d : number, tx : number, ty : number ) : void {
            Matrix3.setTransform( this._currentContextSnapshot._currentMatrix, a,b,c,d,tx,ty );
        }

        /**
         * Concatenate current transformation matrix with the given matrix coeficients.
         * @method cc.render.DecoratedWebGLRenderingContext#transform
         * @param a {number}
         * @param b {number}
         * @param c {number}
         * @param d {number}
         * @param tx {number}
         * @param ty {number}
         */
        transform( a : number, b : number, c : number, d : number, tx : number, ty : number ) : void {
            Matrix3.transform( this._currentContextSnapshot._currentMatrix, a,b,c,d,tx,ty );
        }

        /**
         * Fill an area with the current fillStyle.
         * If w or h are <= 0 the call does nothing.
         * @method cc.render.DecoratedWebGLRenderingContext#fillRect
         * @param x {number}
         * @param y {number}
         * @param w {number}
         * @param h {number}
         */
        fillRect( x : number, y : number, w : number, h : number ) : void {

            if (w<=0 || h<=0) {
                return;
            }

            this.__flushFillRectIfNeeded();

            if ( this._batcher.batchRect(x, y, w, h, this._currentContextSnapshot) ) {
                this.flush();
            }
        }

        drawTextureUnsafe( texture:Texture2D, sx: number, sy:number, sw?:number, sh?:number, dx?: number, dy?:number, dw?:number, dh?:number  ) : void {

        }

        drawTexture( texture:Texture2D, sx: number, sy:number, sw?:number, sh?:number, dx?: number, dy?:number, dw?:number, dh?:number  ) : void {

            var ti:Texture2D= texture;
            var textureId : WebGLTexture = ti._glId;

            // no texture info, or invalid gl texture id. do nothing.
            if ( textureId===null ) {
                // BUGBUG refactor this
                cc.Debug.warn(" --- lazy image to texture call.  --- deprecated and dangerous.");
                ti.__setAsGLTexture( this._webglState );
                textureId= ti._glId;
            }

            this.__drawImageFlushIfNeeded( textureId );

            var _sx : number;
            var _sy : number;
            var _sw : number;
            var _sh : number;
            var _dx : number;
            var _dy : number;
            var _dw : number;
            var _dh : number;

            if ( arguments.length>=9 ) {


                if ( ti._invertedY ) {
                    sy = ti._imageHeight - (ti._offsetY + sy) - sh;
                }

                _sy = (sy + ti._offsetY) / ti._textureHeight;
                _sx = (sx + ti._offsetX) / ti._textureWidth;
                _sw = (sx + sw + ti._offsetX) / ti._textureWidth;
                _sh = (sy + sh + ti._offsetY) / ti._textureHeight;

                _dx= dx;
                _dy= dy;
                _dw= dw;
                _dh= dh;

            } else if ( arguments.length>=5 ) {

                _dx = sx;
                _dy = sy;
                _dw = sw;
                _dh = sh;

                _sx = ti._u0;
                _sy = ti._v0;
                _sw = ti._u1;
                _sh = ti._v1;

            } else {
                
                _dx = sx;
                _dy = sy;
                _dw= ti._imageWidth;
                _dh= ti._imageHeight;

                _sx = ti._u0;
                _sy = ti._v0;
                _sw = ti._u1;
                _sh = ti._v1;
            }


            if ( this._batcher.batchRectWithTexture(
                _dx,_dy,_dw,_dh,this._currentContextSnapshot,
                _sx,_sy,_sw,_sh ) ) {

                this.flush();

            }
        }

        batchGeometryWithSprite( sprite:cc.node.Sprite, transposed:boolean ) {

            var frame:SpriteFrame = sprite._spriteFrame;
            var rect:Rectangle= frame._normalizedRect;

            var u0= rect.x;
            var v0= rect.y;
            var u1= rect.x1;
            var v1= rect.y1;

            if ( transposed ) {
                // PENDING implement rotation
            }

            if ( sprite.flippedX ) {
                var itmp:number= u0;
                u0= u1;
                u1= itmp;
            }
            if ( sprite.flippedY ) {
                var itmp:number= v0;
                v0= v1;
                v1= itmp;
            }

            this.__drawImageFlushIfNeeded( frame._texture._glId );

            if (this._batcher.batchRectGeometryWithTexture( sprite._BBVertices, u0,v0,u1,v1, this._currentContextSnapshot )) {
                this.flush();
            }
        }

        batchGeometryWithSpriteFast( sprite:cc.node.Sprite ) {

            var frame:SpriteFrame = sprite._spriteFrame;
            var rect:Rectangle= frame._normalizedRect;

            var u0= rect.x;
            var v0= rect.y;
            var u1= rect.x1;
            var v1= rect.y1;

            if ( sprite.flippedX ) {
                var itmp:number= u0;
                u0= u1;
                u1= itmp;
            }
            if ( sprite.flippedY ) {
                var itmp:number= v0;
                v0= v1;
                v1= itmp;
            }

            this.__drawImageFastFlushIfNeeded( frame._texture._glId );

            if (this._batcher.batchRectGeometryWithSpriteFast( sprite, u0,v0,u1,v1, this._currentContextSnapshot )) {
                this.flush();
            }
        }

        /**
         * Translate the current rendering context transformation matrix.
         * @method cc.render.DecoratedWebGLRenderingContext#translate
         * @param x {number}
         * @param y {number}
         */
        translate( x : number, y : number ) : void {
            Matrix3.setTranslate(__mat3, x, y);
            Matrix3.multiply( this._currentContextSnapshot._currentMatrix, __mat3 );
        }

        /**
         * Rotate the current rendering context transformation matrix.
         * @method cc.render.DecoratedWebGLRenderingContext#rotate
         * @param angle {number} angle in radians.
         */
        rotate( angle : number ) : void {
            Matrix3.setRotate(__mat3, angle);
            Matrix3.multiply( this._currentContextSnapshot._currentMatrix, __mat3 );
        }

        /**
         * Scale the current rendering context transformation matrix.
         * @method cc.render.DecoratedWebGLRenderingContext#scale
         * @param x {number} scale x axis.
         * @param y {number} scale y axis.
         */
        scale( x : number, y : number ) : void {
            Matrix3.setScale(__mat3, x, y);
            Matrix3.multiply( this._currentContextSnapshot._currentMatrix, __mat3 );
        }

        /**
         * Flush the content geometry, color and texture to the screen.
         * @member cc.render.DecoratedWebGLRenderingContext#flush
         */
        flush( ) : void {
            this._batcher.flush( this._shaders[ this._currentContextSnapshot._currentFillStyleType ], this._currentContextSnapshot );
        }

        resize( ) {
            this.__initContext();
            this.__setShadersProjection(this._canvas.width, this._canvas.height);
        }

        getUnitsFactor() : number {
            return this._renderer.getUnitsFactor();
        }

        /**
         * Get RenderingContext type.
         * @member cc.render.DecoratedWebGLRenderingContext#get:type
         * @returns {number} cc.render.RENDERER_TYPE_WEBGL or cc.render.RENDERER_TYPE_CANVAS
         */
        type : number= cc.render.RENDERER_TYPE_WEBGL;

        /**
         * @method cc.render.DecoratedWebGLRenderingContext#__drawImageFlushIfNeeded
         * @param textureId {WebGLTexture}
         * @private
         */
        __drawImageFastFlushIfNeeded( textureId : WebGLTexture ) : void {
            this.__drawImageFlushIfNeededImpl( FillStyleType.IMAGEFAST, this._shaders[ ShaderType.IMAGEFAST ], textureId );
        }

        /**
         * @method cc.render.DecoratedWebGLRenderingContext#__drawImageFlushIfNeeded
         * @param textureId {WebGLTexture}
         * @private
         */
        __drawImageFlushIfNeeded( textureId : WebGLTexture ) : void {
            this.__drawImageFlushIfNeededImpl(FillStyleType.IMAGE, this._shaders[ShaderType.IMAGE], textureId);
        }

        __drawImageFlushIfNeededImpl( fillStyleType : FillStyleType, shader:AbstractShader, textureId:WebGLTexture) {

            if ( this._currentContextSnapshot._currentFillStyleType!==fillStyleType ) {

                this.flush();

                this.__setCurrentFillStyleType( fillStyleType );
                this._currentContextSnapshot._tintColor= this._currentTintColor;

                (<any>shader)._uniformTextureSampler.setValue( 0 );
                this._webglState.setTexture( 0, textureId );

            } else {

                // different textures ? flush.
                if ( this._webglState._currentTexture !== textureId ) {
                    this.flush();
                    (<any>shader)._uniformTextureSampler.setValue( 0 );
                    this._webglState.setTexture( 0, textureId );
                }

                this._currentContextSnapshot._tintColor= this._currentTintColor;

                this.__compositeFlushIfNeeded();

            }
        }

        __flushFillRectIfNeeded() {

            if ( this._currentContextSnapshot._currentFillStyleType!==this._currentFillStyleType ) {
                this.flush();

                this.__setCurrentFillStyleType( this._currentFillStyleType );
            }

            this._currentContextSnapshot._fillStyleColor= this._currentFillStyleColor;
            this._currentContextSnapshot._fillStylePattern= this._currentFillStylePattern;
            this._currentContextSnapshot._tintColor= this._currentTintColor;

        }

        __compositeFlushIfNeeded() {
            if ( this._currentGlobalCompositeOperation!==this._currentContextSnapshot._globalCompositeOperation ) {
                this.flush();
                this.__setGlobalCompositeOperation();
            }
        }

        /**
         * @method cc.render.DecoratedWebGLRenderingContext#__setCurrentFillStyleType
         * @param f {cc.render.FillStyleType}
         * @private
         */
        __setCurrentFillStyleType( f : FillStyleType ) : void {
            this._shaders[ this._currentContextSnapshot._currentFillStyleType ].notUseProgram();
            this._shaders[ f ].useProgram();
            this._currentContextSnapshot._currentFillStyleType= f;
            this._currentFillStyleType= f;
        }

        setFillStyleColor( color:Color ) {
            this._currentFillStyleColor= color._color;
            this._currentFillStyleType= cc.render.FillStyleType.MESHCOLOR;
        }

        setFillStyleColorArray( colorArray:Float32Array ) {
            this._currentFillStyleColor= colorArray;
            this._currentFillStyleType= cc.render.FillStyleType.MESHCOLOR;
        }

        setFillStylePattern( pattern:Pattern ) {
            // BUGBUG change for actual pattern type
            //this._currentFillStyleType= cc.render.FillStyleType.PATTERN_REPEAT;
            //this._currentFillStylePattern= pattern;
        }

        setStrokeStyleColor( color:Color ) {
            this._currentStrokeStyleColor= color._color;
            this._currentFillStyleType= cc.render.FillStyleType.MESHCOLOR;
        }

        setStrokeStyleColorArray( colorArray:Float32Array ) {
            this._currentStrokeStyleColor= colorArray;
            this._currentFillStyleType= cc.render.FillStyleType.MESHCOLOR;
        }

        setStrokeStylePattern( pattern:Pattern ) {
            // BUGBUG change for actual pattern type
            //this._currentStrokeStyleColor= cc.render.FillStyleType.PATTERN_REPEAT;
            //this._currentFillStylePattern= pattern;
        }

        set fillStyle( v:string ) {
            this._currentFillStyleType= cc.render.FillStyleType.MESHCOLOR;
            this._currentFillStyleColor= cc.render.util.parseColor( v );
        }

        set strokeStyle( v:string ) {
            this._currentFillStyleType= cc.render.FillStyleType.MESHCOLOR;
            this._currentStrokeStyleColor= cc.render.util.parseColor( v );
        }

        beginPath() {
            this._currentContextSnapshot.beginPath();
        }

        closePath() {
            this._currentContextSnapshot.closePath();
        }

        stroke() {

            var geometry:Float32Array= this._currentContextSnapshot.setupStroke(
                this._currentLineWidth,
                this._currentLineJoin,
                this._currentLineCap
            );

            this.__checkStrokeFlushConditions();

            this._currentContextSnapshot._fillStyleColor= this._currentStrokeStyleColor;
            this._batcher.batchPath( geometry, this._currentContextSnapshot );
        }

        fill() {

            var geometry:Float32Array= this._currentContextSnapshot.setupFill( );

            this.__checkStrokeFlushConditions();

            this._currentContextSnapshot._fillStyleColor= this._currentFillStyleColor;
            this._batcher.batchPath( geometry, this._currentContextSnapshot );
        }

        __checkStrokeFlushConditions() {

            if ( this._currentContextSnapshot._currentFillStyleType!==FillStyleType.MESHCOLOR ) {
                this.flush();
                this.__setCurrentFillStyleType( FillStyleType.MESHCOLOR );
            }
        }

        set lineWidth( w:number ) {
            this.setLineWidth(w);
        }

        get lineWidth() : number {
            return this._currentLineWidth;
        }

        set lineCap( s:string ) {
            s= s.toLowerCase();

            if ( s==="square" ) {
                this.setLineCap( cc.render.LineCap.SQUARE );
            } else if ( s==="round" ) {
                this.setLineCap( cc.render.LineCap.ROUND );
            } else {
                this.setLineCap( cc.render.LineCap.BUTT );
            }
        }

        get lineCap() : string {
            switch( this._currentLineCap ) {
                case cc.render.LineCap.SQUARE: return "square";
                case cc.render.LineCap.ROUND: return "round";
                default: return "butt";
            }
        }

        set lineJoin( s:string ) {
            s= s.toLowerCase();

            if ( s==="miter" ) {
                this.setLineJoin( cc.render.LineJoin.MITER );
            } else if ( s==="round" ) {
                this.setLineJoin( cc.render.LineJoin.ROUND );
            } else {
                this.setLineJoin( cc.render.LineJoin.BEVEL );
            }
        }

        get lineJoin() : string {
            switch( this._currentLineJoin ) {
                case cc.render.LineJoin.MITER: return "miter";
                case cc.render.LineJoin.ROUND: return "round";
                default: return "bevel";
            }
        }

        setLineWidth( w : number ) {
            this._currentLineWidth= w;
        }

        getLineWidth() : number {
            return this._currentLineWidth;
        }

        setLineCap( cap:cc.render.LineCap ) {
            this._currentLineCap= cap;
        }

        getLineCap() : cc.render.LineCap {
            return this._currentLineCap;
        }

        setLineJoin( join:cc.render.LineJoin ) {
            this._currentLineJoin= join;
        }

        getLineJoin() : cc.render.LineJoin {
            return this._currentLineJoin;
        }

        moveTo(x:number, y:number) {
            this._currentContextSnapshot.moveTo( x, y );
        }

        lineTo(x:number, y:number) {
            this._currentContextSnapshot.lineTo( x, y );
        }

        bezierCurveTo( cp0x:number, cp0y:number, cp1x:number, cp1y:number, p2x:number, p2y:number ) {
            this._currentContextSnapshot.bezierCurveTo( cp0x, cp0y, cp1x, cp1y, p2x, p2y );
        }

        quadraticCurveTo( cp0x:number, cp0y:number, p2x:number, p2y:number ) {
            this._currentContextSnapshot.quadraticCurveTo( cp0x, cp0y, p2x, p2y );
        }

        rect( x:number, y:number, width:number, height:number ) {
            this._currentContextSnapshot.rect( x, y, width, height );
        }

        arc( x:number, y:number, radius:number, startAngle:number, endAngle:number, counterClockWise:boolean ) {
            this._currentContextSnapshot.arc( x, y, radius, startAngle, endAngle, counterClockWise );
        }

        save() {

        }

        restore() {

        }

        drawMesh( geometry:Float32Array, uv:Float32Array, indices:Uint32Array, color:number, texture:Texture2D ) {

            this.__checkMeshFlushConditions( texture._glId, color );
            this._batcher.batchMesh( geometry, uv, indices, color );
            this.flush();
        }

        __checkMeshFlushConditions( textureId:WebGLTexture, color:number ) {

            if ( this._currentContextSnapshot._currentFillStyleType!==FillStyleType.MESH ) {
                this.flush();
                this.__setCurrentFillStyleType( FillStyleType.MESH );
            }

            var shader= this._shaders[ShaderType.MESH];

            shader.mat4_from_mat3( this._currentContextSnapshot._currentMatrix, __mat4 );

            var r= (color>>24)&0xff;
            var g= (color>>16)&0xff;
            var b= (color>>8)&0xff;
            var a= (color)&0xff;

            (<any>shader)._uniformTransform.setValue( __mat4 );
            (<any>shader)._uniformTextureSampler.setValue( 0 );
            (<any>shader)._uniformColor.setValue( [r,g,b,a] );
            this._webglState.setTexture( 0, textureId );

        }
    }
}
/**
 * License: see license.txt file
 */

/// <reference path="../math/Dimension.ts"/>
/// <reference path="../math/Matrix3.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../util/Debug.ts"/>

module cc.render {

    /**
     * Orientation events callback objects.
     * @name OrientationCallback
     * @memberOf cc.render
     * @callback OrientationCallback
     */

    export type WindowResizeCallback= (w:number, h:number) => any;

    export type OrientationErrorCallback= ()=>any;
    export type OrientationOkCallback= ( o:OrientationStrategy )=>any;

    /**
     * Full screen events callback objects.
     * @memberOf cc.render
     * @callback FullScreenCallback
     */
    export type FullScreenCallback= ()=>any;

    /**
     * When setScaleContent is called on a renderer, this hint will tell how to position scenes in director's area.
     * TOP and BOTTOM values are specified regardless of y-axis rendering origin. TOP will always be TOP of the screen.
     * @tsenum cc.render.ScaleContentSceneHint
     */
    export enum ScaleContentSceneHint {
        TOP= 1,
        LEFT=2,

        BOTTOM=4,
        RIGHT=8,

        CENTER=16,
        STRETCH=32
    }

    /**
     * Values for Scale canvas and Scale content.
     * @tsenum cc.render.ScaleManagerStrategy
     */
    export enum ScaleManagerStrategy {

        NONE =          0,
        SCALE_FIT =     1,
        SCALE_ASPECT =  2,
        SCALE_CONTENT=  128
    }

    /**
     * Values for forcing orientation.
     * @tsenum cc.render.OrientationStrategy
     */
    export enum OrientationStrategy {

        BOTH        = 0,
        PORTRAIT    = 1,
        LANDSCAPE   = 2
    }

    /**
     * Values for canvas positioning inside parent node after setting canvas Scale values.
     * @tsenum cc.render.ScalePosition
     */
    export enum ScalePosition {

        NONE    = 0,
        CENTER  = 1,
        LEFT    = 2,
        RIGHT   = 4
    }

    /**
     * @class cc.render.ScaleManager
     * @classdesc
     *
     *
     * The ScaleManager object has different responsibilities that affect the final visual of the built Canvas object.
     * <p>
     * Its main responsibilities are:
     * <ul>
     *     <li>Up/Down scale the canvas object to fit the screen.
     *     <li>Up/Down scale the game content.
     *     <li>Fix the orientation and notify when it changes.
     * </ul>
     * <p>
     * There are important differences between the first and second responsibility, as well as important performance/visual
     * implications.
     *
     * <h3>Up/Down scale the canvas object.</h3>
     * <p>
     *     This feature affects the canvas object, which is scaled using css attributes. This operation affects the final
     *     game's visual quality. For example, if your game uses a 400x300 pixels canvas object, and the window is 1200x900
     *     pixels, the canvas object could be scaled by 3 in each axe, which will lower the visual quality. There are
     *     ways of overcoming this by up/down scaling the game content though.
     * <p>
     *     These scaling operations are sensitive to the DOM node that contains the canvas object though. Internally, this
     *     API call modifies the canvas size with a CSS style.
     * <p>
     *     There are two different modifiers which will tell how to up/down scale the canvas object:
     *
     *     <h4>Scale strategy (How to scale the canvas)</h4>
     *
     *     <ul>NONE</ul>
     *     <p>
     *         This modifier does not change the canvas in any way. It will be presented on screen with the original size
     *     <ul>SCALE_FIT</ul>
     *     <p>
     *         This modifier will stretch the canvas to fit the DOM parent container object. The stretching can be uneven,
     *         breaking the aspect ratio.
     *     <ul>SCALE_ASPECT</ul>
     *     <p>
     *         This modifier will stretch the canvas preserving its aspect ratio. The final scaled Canvas may not take
     *         over the whole parent node's screen area, and some letterboxing effect may occur. This effect makes some
     *         horizontal or vertical lines appear since the canvas can't cover the whole area. You control how these
     *         lines appear with the ScalePosition modifier.
     *
     *     <h4>Scale position (how to position the canvas relative to the parent's client area.</h4>
     *     <ul>NONE</ul>
     *     <p>
     *         Do nothing special. Follow the natural browser rules to position the canvas in the parent. If the
     *         scale strategy is SCALE_ASPECT, the letter-boxing will be on the right/bottom or left/bottom (depending
     *         if the browser writes text left-to-right or right-to-left respectively).
     *     <ul>LEFT</ul>
     *     <p>
     *         Force the canvas position to be left in the parent Node's client area.
     *     <ul>RIGHT</ul>
     *     <p>
     *         Force the canvas position to be right in the parent Node's client area.
     *     <ul>CENTER</ul>
     *     <p>
     *         Force the canvas position to be centered in the parent Node's client area. When the ccale strategy is
     *         SCALE_ASPECT, this is the best option since the letterbox will be evenly distributed to the sides or
     *         top/down of the canvas.
     *
     * <h3>Up/down scale the canvas content, not the canvas itself.</h3>
     * <p>
     *     This feature affects the Canvas content which has a direct impact in better visual quality (if higher resolution
     *     graphics are used) but has an impact in performance as well (bigger graphics, could mean lower performance).
     * <p>
     *     When you want to build a retina enabled game, this is the feature you need to focus on.
     * <p>
     *     Basically, what we want to achieve is to break the bound between pixels and in-game units. This is what happens
     *     with retina displays, which for example, report a 480x320 viewport size, while the actual screen resolution
     *     is 960x640. The system is breaking the bound between points and pixels.
     * <p>
     *     For our games, we may to achieve the same effect, and it is achieved by setting the ratio between pixels and
     *     game units.
     * <p>
     *     A call in the ScaleManager of the form: <code>setScaleContent( unitsWidth:number, unitsHeight:number )</code>
     *     must be done. This will instrument the CocosJS core to break the bound, and start upscaling content.
     *     CocosJS already makes all internal considerations to draw bigger resources in the same screen area resulting
     *     in an upgraded visual experience at no cost.
     * <p>
     *     Internally this API will build a bigger canvas to conform to all the available space, so don't rely on
     *     canvas.width or canvas.height values at all in your game.
     *
     *
     * <h3>Orientation</h3>
     * <p>
     *     This feature affects mobile device or screen orientation. Events for this events can be fired as well if the
     *     browser window aspect ratio changes.
     * <p>
     *     Even though the screen orientation can't yet be locked in HTML5, this API will allow you to manually switch
     *     to a wrong-orientation mode. The default orientation mode is BOTH, so any orientation will be considered valid.
     * <p>
     *     A call to <code>ScaleManager.forceOrientation( orientation:OrientationStrategy, onOk, onError )</code>
     *     must be done to enable orientation control.
     *
     *
     */
    export class ScaleManager {

        /**
         * A DOM Node, and is the reference node to calculate values for ScaleStrategy's canvas
         * positioning. Null means to use the window as reference.
         * @member cc.render.ScaleManager#_referenceParentNode
         * @type {HTMLElement}
         * @private
         */
        _referenceParentNode:HTMLElement= null;

        /**
         * The Scale strategy for up/down scaling the canvas object. Values are from the enum
         * object ScaleManagerStrategy. By default, no scale on the canvas will be applied.
         * @member cc.render.ScaleManager#_scaleStrategy
         * @type {number}
         * @private
         */
        _scaleStrategy:ScaleManagerStrategy = ScaleManagerStrategy.NONE;

        /**
         * The Canvas position after setting a ScaleStrategy value. By default, no Position will be forced since by default,
         * there's no scale to apply. Values are from the enum object ScalePosition.
         * @member cc.render.ScaleManager#_scalePosition
         * @type {number}
         * @private
         */
        _scalePosition:ScalePosition = ScalePosition.NONE;

        /**
         * The preferred Game orientation. By default, both orientations are suitable. The values are from the enum
         * object OrientationStrategy.
         * @member cc.render.ScaleManager#_forceOrientationStrategy
         * @type {number}
         * @private
         */
        _forceOrientationStrategy:OrientationStrategy = OrientationStrategy.BOTH;

        /**
         * Internal boolean that sets current orientation as valid or not depending on the forced orientation strategy.
         * @member cc.render.ScaleManager#_wrongOrientation
         * @type {boolean}
         * @private
         */
        _wrongOrientation:boolean= false;

        /**
         * Callback invoked when the device is or enters in a wrong orientation.
         * @member cc.render.ScaleManager#_onOrientationError
         * @type {cc.render.OrientationCallback}
         * @private
         */
        _onOrientationError: OrientationErrorCallback = null;

        /**
         * Callback invoked when the device is or enters in a valid orientation.
         * @member cc.render.ScaleManager#_onOrientationOk
         * @type {cc.render.OrientationCallback}
         * @private
         */
        _onOrientationOk: OrientationOkCallback = null;

        /**
         * Is the game in fullscreen ?
         * @member cc.render.ScaleManager#_fullScreen
         * @type {boolean}
         * @private
         */
        _fullScreen= false;

        /**
         * Is current browser/device/wrapper full screen capable ?
         * @member cc.render.ScaleManager#_fullScreenCapable
         * @type {boolean}
         * @private
         */
        _fullScreenCapable= false;

        /**
         * Canvas object to apply the Scale strategies to.
         * @member cc.render.ScaleManager#_surface
         * @type {HTMLCanvasElement}
         * @private
         */
        _surface:HTMLCanvasElement= null;

        /**
         * Current browser vendor prefix for orientation and full screen operations.
         * @member cc.render.ScaleManager#_prefix
         * @type {string}
         * @private
         */
        _prefix:string= null;

        /**
         * When resizing the window object, the ScaleManager must wait a few milliseconds to fire its internal
         * orientation, and scale tests. This member is the setTimeout generated id.
         * @member cc.render.ScaleManager#_windowResizeTimer
         * @type {number}
         * @private
         */
        _windowResizeTimer:number= null;

        /**
         * Callback invoked when the system exits full screen.
         * @member cc.render.ScaleManager#_onExitFullScreen
         * @type {cc.render.FullScreenCallback}
         * @private
         */
        _onExitFullScreen: FullScreenCallback = null;

        /**
         * Callback invoked when the system enters full screen.
         * @member cc.render.ScaleManager#_onEnterFullScreen
         * @type {cc.render.FullScreenCallback}
         * @private
         */
        _onEnterFullScreen: FullScreenCallback = null;

        /**
         * Cached vendor-dependent enter fullscreen function name.
         * @member cc.render.ScaleManager#_requestFullScreen
         * @type {string}
         * @private
         */
        _requestFullScreen:string= null;

        /**
         * Cached vendor-dependent exit fullscreen function name.
         * @member cc.render.ScaleManager#_exitFullScreen
         * @type {string}
         * @private
         */
        _exitFullScreen:string= null;

        /**
         * When scale content is enabled, this is the internal matrix to achieve the expected result.
         * @member cc.render.ScaleManager#_unitsMatrix
         * @type {Float32Array}
         * @private
         */
        _unitsMatrix:Float32Array= new Float32Array(9);

        /**
         * User defined game units.
         * @member cc.render.ScaleManager#_units
         * @type {cc.math.Dimension}
         * @private
         */
        _units:cc.math.Dimension;

        /**
         * If scale content is enabled, this is the scale ratio to convert units to pixels.
         * @member cc.render.ScaleManager#_unitsFactor
         * @type {number}
         * @private
         */
        _unitsFactor:number= 1;

        /**
         * Has setContentScale been called ?
         * @member cc.render.ScaleManager#_contentScaled
         * @type {boolean}
         * @private
         */
        _contentScaled:boolean = false;

        // bugbug refactor this.
        _renderer : Renderer = null;

        _onWindowResized : WindowResizeCallback= null;

        /**
         * Create a new ScaleManager object instance.
         * @method cc.render.ScaleManager#constructor
         */
        constructor( renderer:Renderer ) {
            this._renderer= renderer;
            this._units= new cc.math.Dimension();
            cc.math.Matrix3.identity( this._unitsMatrix );
            this._unitsFactor= 1;

            this.__initialize();

            this.setScaleSurface( renderer._surface );

            //this.setScaleContent( renderer._surface.width, renderer._surface.height );
            this.__setScaleContentMatrix();
        }

        /**
         * Initialize the ScaleManager, get method cache names, etc.
         * @method cc.render.ScaleManager#__initialize
         * @private
         */
        __initialize() {

            var prefix= ['','moz','ms','webkit'];
            for( var i=0; i<prefix.length; i++ ) {

                if ( prefix[i]==="moz") {

                    if ( typeof document.body['mozRequestFullScreen']!=="undefined" ) {
                        this._prefix= 'moz';
                        this._requestFullScreen = 'mozRequestFullScreen';
                        this._exitFullScreen = 'mozCancelFullScreen';
                        document.addEventListener(this._prefix + 'fullscreenchange', this.__fullScreenChange.bind(this), false);
                        document.addEventListener(this._prefix + 'fullscreenerror', this.__fullScreenError.bind(this), false);
                    }

                } else {

                    if (document.body[prefix[i] + (prefix[i] === '' ? 'requestFullscreen' : 'RequestFullscreen')]) {
                        this._prefix = prefix[i];

                        this._requestFullScreen = prefix[i] === '' ? 'requestFullscreen' : prefix[i] + 'RequestFullscreen';
                        this._exitFullScreen = prefix[i] === '' ? 'exitFullscreen' : prefix[i] + 'ExitFullscreen';

                        if (prefix[i] === 'ms') {
                            document.addEventListener('MSFullscreenChange', this.__fullScreenChange.bind(this), false);
                            document.addEventListener('MSFullscreenError', this.__fullScreenError.bind(this), false);

                        } else {
                            document.addEventListener(this._prefix + 'fullscreenchange', this.__fullScreenChange.bind(this), false);
                            document.addEventListener(this._prefix + 'fullscreenerror', this.__fullScreenError.bind(this), false);
                        }

                        break;
                    }
                }
            }

            this._fullScreenCapable= null!==this._prefix;

            window.addEventListener( 'resize', this.__windowResized.bind(this), false );
        }

        /**
         * Set the canvas to apply the ScaleStrategy to.
         * @method cc.render.ScaleManager#setScaleSurface
         * @param surface {HTMLCanvasElement}
         */
        setScaleSurface( surface:HTMLCanvasElement ) {
            this._surface= surface;
            this._units.width= surface.width;
            this._units.height=surface.height;

            this.checkOrientation();

            var me = this;
            setTimeout(function () {
                me.__setScaleImpl();
            }, 200);

        }

        /**
         * After setting scale content, this value is the ratio to transform in-game units to pixels.
         * @method cc.render.ScaleManager#getUnitsFactor
         * @returns {number}
         */
        getUnitsFactor() : number {
            return this._unitsFactor;
        }

        /**
         * Enable orientation change detection. If not set, landscape and portrait will be valid orientations.
         * @method cc.render.ScaleManager#forceOrientation
         * @param os {cc.render.OrientationStrategy} enum orientation value
         * @param onOk {cc.render.OrientationOkCallback=} callback invoked when the orientation changes and is valid.
         * @param onError {cc.render.OrientationErrorCallback=} callback invoked when the orientation changes and is NOT valid.
         * @returns {cc.render.ScaleManager}
         */
        forceOrientation( os:OrientationStrategy, onOk?: OrientationOkCallback, onError?: OrientationErrorCallback ) : ScaleManager {
            this._forceOrientationStrategy= os;

            // don't use setters to prevent fire reflow events.
            if (onOk) {
                this._onOrientationOk=onOk;
            }
            if (onError) {
                this._onOrientationError=onError;
            }

            this.checkOrientation();
            return this;
        }

        /**
         * Check whether the orientation is valid, and invoke callbacks accordingly.
         * @method cc.render.ScaleManager#checkOrientation
         * @private
         */
        checkOrientation() {

            var currentOrientation:OrientationStrategy= window.innerWidth>window.innerHeight ?
                OrientationStrategy.LANDSCAPE :
                OrientationStrategy.PORTRAIT;

            if ( this._forceOrientationStrategy===OrientationStrategy.BOTH ) {
                if ( this._onOrientationOk ) {
                    this._onOrientationOk(currentOrientation);
                }
            }

            if ( currentOrientation!==this._forceOrientationStrategy ) {
                this._wrongOrientation = true;
                if ( this._onOrientationError ) {
                    this._onOrientationError();
                }
            } else {
                if ( this._wrongOrientation && this._onOrientationOk ) {
                    if ( this._onOrientationOk ) {
                        this._onOrientationOk(currentOrientation);
                    }
                }
                this._wrongOrientation = false;
            }
        }

        /**
         * Get whether the current orientation is valid compared to the expected orientation.
         * @method cc.render.ScaleManager#isWrongOrientation
         * @returns {boolean}
         */
        isWrongOrientation() : boolean {
            return this._wrongOrientation;
        }

        /**
         * Get whether the system is able to switch to full screen mode.
         * @method cc.render.ScaleManager#isFullScreenCapable
         * @returns {boolean}
         */
        isFullScreenCapable() : boolean {
            return this._fullScreenCapable;
        }

        /**
         * Start full screen process. If success the optional f callback function will be called.
         * @method cc.render.ScaleManager#startFullScreen
         * @param f {cc.render.FullScreenCallback=} callback invoked when successfully switching to full screen.
         */
        startFullScreen( f?:FullScreenCallback ) {
            if ( this._fullScreenCapable ) {
                if ( typeof f!=="undefined" ) {
                    this.onEnterFullScreen(f);
                }
                this._surface[this._requestFullScreen]();
            }
        }

        /**
         * End full screen process. If success the optional f callback function will be called.
         * @method cc.render.ScaleManager#startFullScreen
         * @param f {cc.render.FullScreenCallback=} callback invoked when successfully exiting from full screen.
         */
        endFullScreen( f?:()=>any ) {
            if ( this._fullScreenCapable ) {
                if ( typeof f!=="undefined" ) {
                    this.onExitFullScreen(f);
                }
                document[this._exitFullScreen]();
            }
        }

        /**
         * Get whether the scale manager is currently in full screen mode.
         * @method cc.render.ScaleManager#isFullScreen
         * @returns {boolean}
         */
        isFullScreen() : boolean {
            return this._fullScreen;
        }

        onWindowResized( callback:WindowResizeCallback ) : ScaleManager {
            this._onWindowResized= callback;
            return this;
        }

        /**
         * Internal operation when the window resizes and scale content/scale strategies are set.
         * @method cc.render.ScaleManager#__windowResized
         * @param e {UIEvent}
         * @private
         */
        __windowResized(e:UIEvent) {
            if ( this._windowResizeTimer!==null ) {
                clearTimeout( this._windowResizeTimer );
            }

            var me= this;
            this._windowResizeTimer= setTimeout( function() {
                clearTimeout( me._windowResizeTimer );
                me._windowResizeTimer= null;

                me.checkOrientation();

                if ( me._contentScaled ) {
                    var w, h;
                    if ( this._referenceParentNode ) {
                        w= this._referenceParentNode.width;
                        h= this._referenceParentNode.height;
                    } else {
                        w= window.innerWidth;
                        h= window.innerHeight;
                    }
                    //me._renderer.setScaleContent( me._units.width,  me._units.height, w, h );
                    me._onWindowResized( w, h );
                }

                if ( !this.__wrongOrientation ) {
                    me.__setScaleImpl();
                }
            }, 1000 );
        }

        /**
         * Internal operation when the system switches to full screen.
         * @method cc.render.ScaleManager#__fullScreenChange
         * @param e {UIEvent}
         * @private
         */
        __fullScreenChange(e) {

            if (this._fullScreen) {

                if ( this._onExitFullScreen ) {
                    this._onExitFullScreen();
                }

                this._fullScreen= false;

            } else {


                if ( this._onEnterFullScreen ) {
                    this._onEnterFullScreen();
                }

                this._fullScreen= true;
            }

            var me= this;
            setTimeout( function() {
                me.__setScaleImpl();
            }, 500 );
        }

        /**
         * Register callback to be notified when the system successfully enters full screen mode.
         * @method cc.render.ScaleManager#onEnterFullScreen
         * @param f {cc.render.FullScreenCallback}
         * @returns {cc.render.ScaleManager}
         */
        onEnterFullScreen( f:FullScreenCallback ) : ScaleManager {
            this._onEnterFullScreen= f;
            return this;
        }

        /**
         * Register callback to be notified when the system successfully exits full screen mode.
         * @method cc.render.ScaleManager#onExitFullScreen
         * @param f {cc.render.FullScreenCallback}
         * @returns {cc.render.ScaleManager}
         */
        onExitFullScreen( f:FullScreenCallback ) : ScaleManager {
            this._onExitFullScreen= f;
            return this;
        }

        /**
         * Register callback to be notified when the system successfully changes orientation.
         * @method cc.render.ScaleManager#onOrientationOk
         * @param f {cc.render.OrientationOkCallback}
         * @returns {cc.render.ScaleManager}
         */
        onOrientationOk( f:OrientationOkCallback ) : ScaleManager {
            this._onOrientationOk= f;
            this.checkOrientation();
            return this;
        }

        /**
         * Register callback to be notified when the system unsuccessfully changes orientation.
         * @method cc.render.ScaleManager#onOrientationError
         * @param f {cc.render.OrientationCallback}
         * @returns {cc.render.ScaleManager}
         */
        onOrientationError( f:OrientationErrorCallback ) : ScaleManager {
            this._onOrientationError= f;
            this.checkOrientation();
            return this;
        }

        /**
         * Internal method called at system level when there's no full screen availability.
         * @method cc.render.ScaleManager#__fullScreenError
         * @param e {UIEvent}
         * @private
         */
        __fullScreenError(e) {
            cc.Debug.warn( cc.locale.WARN_FULLSCREEN_ERROR );
        }

        /**
         * When ScaleStrategy is set, this DOM node will be the reference for position calculations.
         * @method cc.render.ScaleManager#setReferenceParentNode
         * @param node {HTMLElement}
         */
        setReferenceParentNode( node:HTMLElement ) {
            this._referenceParentNode= node;
        }

        /**
         * Enable canvas scale capabilities. This will scale the canvas object, not its internal drawing operations.
         * @method cc.render.ScaleManager#setScale
         * @param scale {cc.render.ScaleManagerStrategy} the scale type.
         * @param positionOp {cc.render.ScalePosition=} the positioning when the scale is set.
         * @returns {cc.render.ScaleManager}
         * @see cc.render.ScaleManager#setScaleContent
         */
        setScale( scale:ScaleManagerStrategy, positionOp?:ScalePosition ) : ScaleManager {

            if (this._scaleStrategy === scale) {
                return;
            }

            this._scaleStrategy = scale;
            this._scalePosition = positionOp || ScalePosition.NONE;

            if ( this._surface ) {
                var me = this;
                setTimeout(function () {
                    me.__setScaleImpl();
                }, 200);
            }

            return this;
        }

        /**
         * Enable content scale. Content scale is necessary for retina display honor mechanisms. This method instruments
         * CocosJS core that there's no direct mapping between a pixel and a game unit.
         * @method cc.render.ScaleManager#setScaleContent
         * @param unitsWidth {number}
         * @param unitsHeight {number}
         */
        setScaleContent( unitsWidth:number, unitsHeight:number) : Float32Array {
            this._units.width= unitsWidth;
            this._units.height= unitsHeight;

            this.__setScaleContentMatrix();

            this._contentScaled= true;

            return this._unitsMatrix;
        }

        /**
         * Internal method to calculate the pixel-point mapping operations.
         * @method cc.render.ScaleManager#__setScaleContentMatrix
         * @private
         */
        __setScaleContentMatrix() {

            if (this._surface && this._units.width>0 && this._units.height>0 ) {
                var scale:number = Math.min(
                    this._surface.width / this._units.width,
                    this._surface.height / this._units.height);

                this._unitsFactor= scale;

                cc.math.Matrix3.setScale(this._unitsMatrix, scale, scale);

                if (cc.render.RENDER_ORIGIN === cc.render.ORIGIN_BOTTOM) {
                    // invert viewport
                    var um:Float32Array = this.getScaleContentMatrix();
                    um[1] *= -1;
                    um[4] *= -1;
                    um[5] += this._renderer._dimension.height;

                    //console.log("renderer adjust scale content: \n" + um[0] + "," + um[1] + "," + um[2] + "\n" + um[3] + "," + um[4] + "," + um[5] + "\n" + um[6] + "," + um[7] + "," + um[8]);
                }
            }
        }

        getScaleContentMatrix() : Float32Array {
            return this._unitsMatrix;
        }

        /**
         * Internal method to scale the canvas object using css styles.
         * @method cc.render.ScaleManager#__setScaleImpl
         * @private
         */
        __setScaleImpl() {

            this._surface.style.width= '';
            this._surface.style.height= '';

            var scale = this._scaleStrategy;

            if (scale === ScaleManagerStrategy.NONE) {

                this.__setScaleNone(this._surface);
            } else if (scale === ScaleManagerStrategy.SCALE_FIT) {

                this.__setScaleFit(this._surface);
            } else if (scale === ScaleManagerStrategy.SCALE_ASPECT) {

                this.__setScaleAspect(this._surface);
            }

        }

        /**
         * When setting the scale strategy, this method calculates the necessary styles to position the canvas relative to
         * its parent client area. The calculations will be based on the ScalePosition parameter of setScale method call.
         * @method cc.render.ScaleManager#__setScalePosition
         * @param scaleW {number} canvas scale factor. when setScale is called, the canvas can be scaled with different
         *          values. this is the width scale parameter.
         * @private
         */
        __setScalePosition( scaleW:number ) {

            if (this.isFullScreen()) {
                this._surface.style.margin="0";
                return;
            }

            var pw= 0;

            if (this._referenceParentNode === null) {
                pw = window.innerWidth;
            } else {
                pw = this._referenceParentNode.getBoundingClientRect().width;
            }

            switch( this._scalePosition ) {
                case ScalePosition.LEFT:
                    this._surface.style.margin="0";
                    break;

                case ScalePosition.RIGHT:
                    this._surface.style.marginLeft= ((pw-scaleW*this._surface.width)|0)+'px';
                    break;
                case ScalePosition.CENTER:
                    this._surface.style.marginLeft= (((pw-scaleW*this._surface.width)/2)|0)+'px';
                    break;
            }

            this._surface.style.padding="0";
        }

        /**
         * Set the canvas with no scale.
         * @method cc.render.ScaleManager#__setScaleNone
         * @param surface {HTMLCanvasElement}
         * @private
         */
        __setScaleNone( surface:HTMLCanvasElement ) {

            surface.style.width= surface.width+'px';
            surface.style.height= surface.height+'px';

            this.__setScalePosition(1);
        }

        /**
         * Stretch the canvas with css scale attributes to fit exactly in its parent.
         * This can lead to uneven scaling, because of canvas object stretch operations.
         * @method cc.render.ScaleManager#__setScaleFit
         * @param surface {HTMLCanvasElement}
         * @private
         */
        __setScaleFit( surface:HTMLCanvasElement ) {
            // remove element so that document reflows and can get actual parent size.
            surface.style.display = 'none';

            // scale in parent, but keeping aspect ratio. letterbox  warning!!
            var pw, ph;
            var parentBounds:ClientRect;

            if (this._referenceParentNode === null) {
                pw = window.innerWidth;
                ph = window.innerHeight;

            } else {
                parentBounds = this._referenceParentNode.getBoundingClientRect();

                pw = parentBounds.width;
                ph = parentBounds.height;
            }
            var sw = surface.width;
            var sh = surface.height;

            var factorx = pw / sw;
            var factory = ph / sh;

            surface.style.width = (factorx * sw) + 'px';
            surface.style.height = (factory * sh) + 'px';

            surface.style.display = 'block';

            this.__setScalePosition(factorx);
        }

        /**
         * Scale the canvas keeping aspect ratio to fit in its parent node client area.
         * @param surface {HTMLCanvasElement}
         * @method cc.render.ScaleManager#__setScaleAspect
         * @private
         */
        __setScaleAspect( surface:HTMLCanvasElement ) {
            // remove element so that document reflows and can get actual parent size.
            surface.style.display = 'none';

            // scale in parent, but keeping aspect ratio. letterbox  warning!!
            var pw, ph;
            var parentBounds:ClientRect;

            if (this._referenceParentNode === null) {
                pw = window.innerWidth;
                ph = window.innerHeight;

            } else {
                parentBounds = this._referenceParentNode.getBoundingClientRect();

                pw = parentBounds.width;
                ph = parentBounds.height;
            }
            var sw = surface.width;
            var sh = surface.height;
            var factor = Math.min(pw / sw, ph / sh);

            surface.style.width = (factor * sw) + 'px';
            surface.style.height = (factor * sh) + 'px';

            surface.style.display = 'block';

            this.__setScalePosition(factor);
        }

        /**
         * Get the currently applied canvas scale strategy.
         * @method cc.render.ScaleManager#getScaleStrategy
         * @returns {cc.render.ScaleManagerStrategy}
         */
        getScaleStrategy() : ScaleManagerStrategy {
            return this._scaleStrategy;
        }
    }
}
/**
 * License: see license.txt file.
 */

module cc.render.util {

    export function getAlphaChannel( image:HTMLImageElement|HTMLCanvasElement ) : any[] | Uint8Array {
        return getChannel(image, 3);
    }

    export function getRedChannel( image:HTMLImageElement|HTMLCanvasElement ) : any[] | Uint8Array {
        return getChannel(image, 0);
    }

    export function getGreenChannel( image:HTMLImageElement|HTMLCanvasElement ) : any[] | Uint8Array {
        return getChannel(image, 1);
    }

    export function getBlueChannel( image:HTMLImageElement|HTMLCanvasElement ) : any[] | Uint8Array {
        return getChannel(image, 2);
    }

    export function getChannel( image:HTMLImageElement|HTMLCanvasElement, channel:number ) : any[] | Uint8Array {
        var canvas:HTMLCanvasElement= null;
        var ctx:CanvasRenderingContext2D= null;

        if ( image instanceof HTMLCanvasElement ) {
            canvas= <HTMLCanvasElement>image;
            ctx= canvas.getContext("2d");
        } else {
            var canvas = createCanvas(image.width, image.height);
            ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0);
        }

        var imageData:ImageData= ctx.getImageData(0,0,canvas.width,canvas.height);

        return extractChannel( imageData.data, canvas.width, canvas.height, 3 );
    }

    export function createCanvas( w:number, h:number ) : HTMLCanvasElement {
        var canvas= document.createElement("canvas");
        canvas.width= w;
        canvas.height=h;

        return canvas;
    }

    export function extractChannel( data:number[], width:number, height:number, channel:number ) : any[] | Uint8Array {

        var ret= typeof Uint8Array!=="undefined" ?
                    new Uint8Array( width*height ) :
                    new Array( width*height );

        var pos= 0;
        for( var i=0; i<data.length; i+=4 ) {
            ret[pos++]= data[i+channel];
        }

        return ret;
    }

    export function parseColor( c:string ) : Float32Array {
        return new Float32Array([1,0,0,1]);
    }
}
/**
 * License: see license.txt file
 */

/// <reference path="../../node/sprite/SpriteFrame.ts"/>
/// <reference path="../RenderingContext.ts"/>
/// <reference path="../../math/Rectangle.ts"/>

module cc.render.mesh {


    /**
     * A mesh is a grid composed of geometry and u,v information.
     */
    export class Mesh {

        _originalGeometry:      Float32Array = null;
        _geometry:      Float32Array = null;
        _uv:            Float32Array = null;
        _workuv:        Float32Array = null;
        _indices:       Uint16Array = null;

        _initialized:   boolean = false;
        _rectgl:        cc.math.Rectangle = null;

        Mesh() {

        }

        initialize( pointsWidth:number, pointsHeight:number, width:number, height:number ) {

            var numPointsInMesh:number= pointsWidth*pointsHeight;

            this._geometry= new Float32Array( numPointsInMesh*3 );
            this._originalGeometry= new Float32Array( numPointsInMesh*3 );
            this._uv= new Float32Array( numPointsInMesh*2 );
            this._workuv= new Float32Array( numPointsInMesh*2 );
            this._indices= new Uint16Array( (pointsWidth-1)*(pointsHeight-1)*6 );

            for( var i=0; i<pointsHeight; i++ ) {
                for( var j=0; j< pointsWidth; j++ ) {

                    var pointIndex= j+i*pointsWidth;

                    this._geometry[pointIndex*3  ]= j/(pointsWidth-1) * width;      // x
                    this._geometry[pointIndex*3+1]= i/(pointsHeight-1) * height;    // y
                    this._geometry[pointIndex*3+2]= 0;                              // z
                    this._originalGeometry[ pointIndex*3   ] = this._geometry[ pointIndex * 3   ];
                    this._originalGeometry[ pointIndex*3+1 ] = this._geometry[ pointIndex * 3+1 ];
                    this._originalGeometry[ pointIndex*3+2 ] = this._geometry[ pointIndex * 3+2 ];

                    this._uv[pointIndex*2  ]= j/(pointsWidth-1);                    // normalized u
                    this._uv[pointIndex*2+1]= i/(pointsHeight-1);                   // normalized v

                    this._workuv[pointIndex*2  ]= j/(pointsWidth-1);                // normalized u
                    this._workuv[pointIndex*2+1]= i/(pointsHeight-1);               // normalized v
                }
            }

            var index= 0;
            for( var i=0; i<pointsHeight-1; i++ ) {
                for (var j = 0; j < pointsWidth - 1; j++) {

                    var indexindex= j+i*pointsWidth;

                    this._indices[ index   ]= indexindex;
                    this._indices[ index+1 ]= indexindex+1;
                    this._indices[ index+2 ]= indexindex+pointsWidth;

                    this._indices[ index+3 ]= indexindex+pointsWidth;
                    this._indices[ index+4 ]= indexindex+1;
                    this._indices[ index+5 ]= indexindex+pointsWidth+1;

                    index+=6;
                }
            }

            this._initialized= true;
        }

        draw( ctx:cc.render.RenderingContext, sf:cc.node.sprite.SpriteFrame, color? : number ) {
            if ( !this._initialized ) {
                return;
            }

            color= typeof color==="undefined" ? 0xffffffff : color;

            if ( this._rectgl!==sf._normalizedRect ) {
                this._rectgl= sf._normalizedRect;

                var offx= this._rectgl.x;
                var offy= this._rectgl.y;
                var diffx= this._rectgl.x1-this._rectgl.x;
                var diffy= this._rectgl.y1-this._rectgl.y;

                for( var i=0; i<this._uv.length; i+=2 ) {
                    this._workuv[i]= this._uv[i]*diffx + offx;
                    this._workuv[i]= this._uv[i]*diffy + offy;
                }
            }

            ctx.drawMesh( this._geometry, this._workuv, this._indices, color, sf._texture );
        }

        deform( segment:cc.math.path.Segment ) {

        }
    }

}
/**
 * License: see license.txt file.
 */


module cc {

    //export function extend(derived, base) {
    //    for (var p in base) {
    //        if (base.hasOwnProperty(p)) {
    //            derived[p] = base[p];
    //        }
    //    }
    //
    //    function __() {
    //        this.constructor = derived;
    //    }
    //
    //    __.prototype = base.prototype;
    //    derived.prototype = new __();
    //}

    export module util {
        "use strict";

        /**
         * Create a Float32Array. If it is not possible a plain Array will be created.
         * @method cc.util.FloatArray
         * @param size {number} array size.
         * @param defaultValue {number} default array values.
         * @returns {Float32Array|Array}
         */
        export function FloatArray(size, defaultValue) {
            var a, i;

            defaultValue = defaultValue || 0;

            if (typeof Float32Array !== "undefined") {
                a = new Float32Array(size);
                if (defaultValue) {
                    for (i = 0; i < size; i++) {
                        a[i] = defaultValue;
                    }
                }
            } else {
                a = new Array(size);
                for (i = 0; i < size; i++) {
                    a[i] = defaultValue;
                }

            }

            return a;
        }

        /**
         * Create a UInt16Array. If it is not possible a plain Array will be created.
         * @method cc.util.UInt16Array
         * @param size {number} array size.
         * @param defaultValue {number} default array value.
         * @returns {Uint16Array|Array}
         */
        export function UInt16Array(size, defaultValue) {
            var a, i;

            defaultValue = defaultValue || 0;

            if (typeof Uint16Array !== "undefined") {
                a = new Uint16Array(size);
                if (defaultValue) {
                    for (i = 0; i < size; i++) {
                        a[i] = defaultValue;
                    }
                }
            } else {
                a = new Array(size);
                for (i = 0; i < size; i++) {
                    a[i] = defaultValue;
                }

            }

            return a;
        }

        /**
         * Transform an string with POSIX like regular expressions into javascript regular expressions.
         * @method cc.util.fromPosixRegularExpression
         * @param expr {string}
         * @returns {string} a javascript like valid regular expression string.
         */
        export function fromPosixRegularExpression(expr:string):string {
            expr = expr.replace(/\[\:digit\:\]/g, "\\d");
            expr = expr.replace(/\[\:alpha\:\]/g, "[A-Za-z]");
            expr = expr.replace(/\[\:alnum\:\]/g, "[A-Za-z0-9]");
            expr = expr.replace(/\[\:word\:\]/g, "\\w");

            expr = expr.replace(/\[\:cntrl\:\]/g, "[\\x00-\\x1F\\x7F]");
            expr = expr.replace(/\[\:graph\:\]/g, "[\\x21-\\x7E]");
            expr = expr.replace(/\[\:lower\:\]/g, "[a-z]");
            expr = expr.replace(/\[\:print\:\]/g, "[\\x20-\\x7E]");
            expr = expr.replace(/\[\:punct\:\]/g, "[][!\"#$%&\'()*+,./:;<=>?@\\^_`{|}~-]");
            expr = expr.replace(/\[\:space\:\]/g, "\\s");
            expr = expr.replace(/\[\:upper\:\]/g, "[A-Z]");
            expr = expr.replace(/\[\:xdigit\:\]/g, "[A-Fa-f0-9]");

            return expr;
        }
    }
}
/**
 * License: see license.txt file
 */

/// <reference path="./Loader.ts"/>
/// <reference path="./ResourceLoader.ts"/>

module cc.plugin.loader {



    /**
     * Callback Fired by a Resource to notify about its loader result.
     * Tipically listened by a <code>cc.plugin.loader.Loader</code> object.
     * @memberOf cc.plugin.loader
     * @callback ResourceLoaderResultCallback
     * @param resource {cc.plugin.loader.Resource} loaded resource.
     */
    export interface ResourceLoaderResultCallback {
        (resource:Resource) : void;
    }


    /**
     * @class cc.util.Resource
     * @classdesc
     *
     * <p>
     *     Class for identifying resources at Cocos level.
     *     Resources are shares across all Director instances by storing them in the static AssetManager object.
     *     This class keeps Resource status and its value after loading.
     *     This class is the same for each resource type, but there are specialized Resource loaders depending on the
     *     type, for example loaders for XML, JSON and text are the same one, but convert the content before emitting
     *     it to any observer.
     * <p>
     *     Resources are identified by a string of the form: <valid_url>[@<id>]
     *     If &lt;id&rt; exists, it will be set as Resource's id, otherwise, the &lt;url&gt; will be.
     *     The Resource will dismiss all information (and including) after the ? sign in its loading url.
     *     Resources url are not normalized. That means that urls of the type ../../end/x/../y.png will be untouched.
     * <p>
     *     It is encouraged to define ids for every resouce by using the resource form <url>@<id>.
     *     It could seem handy to have all resources automatically identify themselves by the name part of the url,
     *     but since resources can be downloaded from different sources and id's could clash, the full url will be
     *     used if not id is defined.
     */
    export class Resource {

        /**
         * Resource id.
         * The id is extracted from the url path, and is just the equivalent to the file name.
         * To obtain the id, everything behing an optional question mark is removed.
         * For example, for a resource called /a/b/c/anim.png?stamp=495849809384 the id will be 'anim.png'.
         * @member cc.plugin.loader.Resource#id
         * @type {string}
         */
        id : string = null;

        /**
         * Resource id extension.
         * It is extracted from the id, and is whatever lies behind the last dot character.
         * The extension is used to identify what loader is needed for this king of resource.
         * @member cc.plugin.loader.Resource#extension
         * @type {string}
         */
        extension : string = null;

        /**
         * After the loader ends its work, the resulting object of loading the result is stored in this variable.
         * The value is only valid if the status of the resource is 'loaded'.
         * @memver cc.plugin.loader.Resource#value
         * @type {string}
         */
        value : any = null;

        /**
         * Resource status.
         * Valid status are:
         *   + created: the resource is created and still no load operation has ended for it.
         *   + error: the resource could not be loaded due to an error.
         *   + loaded: the resource has been loaded and is valid to be used.
         * @member cc.plugin.loader.Resource#_status
         * @type {string}
         * @private
         */
        _status : string= "created";

        /**
         * Resource type. Either image, font, atlas, etc.
         * @member cc.plugin.loader.Resource#type
         * @type {string}
         */
        type : string = null;

        /**
         * resource name. the url part after the last slash sigh.
         * @member cc.plugin.loader.Resource#name
         * @type {string}
         */
        name:string= null;

        /**
         * Source url the Resource was loaded from.
         * @member cc.plugin.loader.Resource#url
         * @type {string}
         */
        url : string = null;

        _progress : (p:number) => void = null;

        /**
         * Create a new Resource instance.
         * Resources are automatically built from a list of resource url/uri passed to a
         * <code>cc.plugin.loader.Loader</code> or <code>cc.plugin.loader.ResourceManager</code>.
         * @method cc.plugin.loader.Resource#constructor
         * @param url
         */
        constructor( _url:string ) {

            var url_and_id = _url.split("@");

            var url= url_and_id[0];
            var id= url_and_id.length>1 ? url_and_id[1] : null;

            var path= url.split("/");
            var name= path[ path.length-1 ];
            name= name.split("?")[0];

            var extensionPos:number;
            var extension:string;

            extensionPos= url.lastIndexOf(".");
            extension= null;

            // exists extension
            if ( -1!==extensionPos ) {
                extension= url.substr(extensionPos+1);
            } else {
                extension= "default";
            }

            this.url= url;
            this.extension= extension;
            this.id= id || url;
            this.name= name;

        }

        /**
         * Load a Resource by creating a suitable instance of a ResourceLoader based on the resource extension.
         * The resource exposes its loading results throughout the callback parameters.
         * If there's no loader associated with the resource extension, the error callback is called immediately.
         * @param loaded {cc.plugin.loader.ResourceLoaderResultCallback} callback notification if the resource loaded ok.
         * @param error {cc.plugin.loader.ResourceLoaderResultCallback} callback notification if the resource loaded with error.
         */
        load( loaded:ResourceLoaderResultCallback, error:ResourceLoaderResultCallback ) : void {
            var loaderDescriptor:ResourceLoaderBuilder= cc.plugin.loader.getLoaderByType(this.extension);
            if (loaderDescriptor) {

                this.type= loaderDescriptor.type;

                var loader= loaderDescriptor.loader( this.url );
                loader.load(
                    ( content:any ) => {
                        this.__setValue(content);
                        loaded( this );
                    },
                    () => {
                        this.__setError();
                        error(this);
                    },
                    this._progress );

            } else {
                cc.Debug.warn( cc.locale.WARN_RESOURCE_OF_UNKNOWN_TYPE, this.id );
                error(this);
            }
        }

        /**
         * Helper function.
         * @method cc.plugin.loader.Resource#__setValue
         * @param value {object} result from the loading operation.
         * @private
         */
        __setValue( value:any ) {
            this.value= value;
            this._status= "loaded";
        }

        /**
         * Helper function.
         * @method cc.plugin.loader.Resource#__setError
         * @private
         */
        __setError() {
            this._status="error";
        }

        /**
         * Has this Resource a valid value ?
         * @method cc.plugin.loader.Resource#isValid
         * @returns {boolean}
         */
        isValid() {
            return this._status==='loaded';
        }

        /**
         * Get the resource id.
         * @method cc.plugin.loader.Resource#getId
         * @returns {string}
         */
        getId() : string {
            return this.id;
        }

        setProgress( progress : (p:number)=> void ) {
            this._progress= progress;
        }
    }


}
/**
 * License: see license.txt file
 */

module cc.plugin.loader {

    /**
     * @class ResourceLoaderBuilder
     * @interface
     * @classdesc
     *
     * Type for each ResourceLoader builder descriptor  type.
     * It is composed by a type (image, font, etc.) and a constructor function.
     */
    export interface ResourceLoaderBuilder {
        /**
         * Resource type.
         * @member cc.plugin.loader.ResourceLoaderBuilder#type
         * @type {string}
         */
        type:string;

        /**
         * Constructor function for a given resource type.
         * @param url}
         */
        loader(url:string) : ResourceLoader;
    }

    /**
     * Register a loader type for a given url extension.
     * @member cc.plugin.loader.RegisterLoaderForType
     * @param builder {cc.plugin.loader.ResourceLoader} a loader of this type will be reated for each resource needing it.
     * @param extension {string}
     */
    export function registerLoaderForType( extension:string, builder:ResourceLoaderBuilder ) {
        __resourceLoaderByType[extension]= builder;
    }

    /**
     * Get a loader type for a given url extension.
     * @member cc.plugin.loader.GetLoaderByType
     * @param extension {string}
     * @return {cc.plugin.loader.ResourceLoaderBuilder}
     */
    export function getLoaderByType( extension:string ) : ResourceLoaderBuilder {
        return __resourceLoaderByType[ extension ];
    }

    var __resourceLoaderByType= {
    };

    /**
     * A Resource passed this callback to a ResourceLoader to be notified about the resource being loaded correctly.
     * @callback ResourceLoaderResourceOkCallback
     * @memberOf cc.plugin.loader
     * @param content {object} the result of loading the resource.
     */
    export interface ResourceLoaderResourceOkCallback {
        ( content:any ) : void;
    }

    /**
     * A Resource passed this callback to a ResourceLoader to be notified about the resource being loaded NOT correctly.
     * @callback ResourceLoaderResourceErrorCallback
     * @memberOf cc.plugin.loader
     */
    export interface ResourceLoaderResourceErrorCallback {
        ( ) : void;
    }


    /**
     * @class cc.plugin.loader.ResourceLoader
     * @interface
     * @classdesc
     *
     * All ResourceLoader instances must have a properly signatured load method.
     * A Resource will build a ResourceLoader instance based on its extension, and the pre-registered set of
     * loaders-by-extension available in __resourceLoaderByType
     *
     */
    export interface ResourceLoader {

        /**
         *
         * @param loaded {cc.plugin.loader.ResourceLoaderResourceOkCallback}
         * @param error {cc.plugin.loader.ResourceLoaderResourceErrorCallback}
         */
        load( loaded:ResourceLoaderResourceOkCallback,
              error:ResourceLoaderResourceErrorCallback,
                progress? : (p:number) => void ) : void;
    }

}
/**
 * License: see license.txt file
 */

/// <reference path="./ResourceLoader.ts"/>

module cc.plugin.loader {

    import ResourceLoader= cc.plugin.loader.ResourceLoader;

    /**
     * @class cc.plugin.loader.ResourceLoaderImage
     * @implements cc.plugin.loader.ResourceLoader
     * @classdesc
     *
     * <p>
     *     This object loads images from a url.
     */
    export class ResourceLoaderImage implements ResourceLoader {

        /**
         * Url string where the resource is located.
         * @member cc.plugin.loader.ResourceLoaderImage#_url
         * @type {string}
         * @private
         */
        _url:string= null;

        /**
         * Create a new ResourceLoaderImage instance.
         * @method cc.plugin.loader.ResourceLoaderImage#constructor
         * @param url {string}
         */
        constructor( url:string ) {
            this._url= url;
        }

        /**
         * Load the resource.
         * @param loaded {cc.plugin.loader.ResourceLoaderResourceOkCallback} callback invoked when the resource is successfully loaded.
         * @param error {cc.plugin.loader.ResourceLoaderResourceErrorCallback} callback invoked when the resource is not successfully loaded.
         */
        load( loaded:ResourceLoaderResourceOkCallback, error:ResourceLoaderResourceErrorCallback ) : void {

            var img= new Image();

            img.addEventListener("load", (e) => {
                loaded( e.target );
            }, false);

            img.addEventListener("error", () => {
                error();
            }, false);

            img.src= this._url;
        }
    }

    cc.plugin.loader.registerLoaderForType(
        "png",
        { type: "image", loader: function(url:string) { return new ResourceLoaderImage(url); } }
    );

    cc.plugin.loader.registerLoaderForType(
        "jpg",
        { type: "image", loader: function(url:string) { return new ResourceLoaderImage(url); } }
    );

    cc.plugin.loader.registerLoaderForType(
        "jpeg",
        { type: "image", loader: function(url:string) { return new ResourceLoaderImage(url); } }
    );

}
/**
 * License: see license.txt file
 */

/// <reference path="./ResourceLoader.ts"/>
/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../locale/Locale.ts"/>

module cc.plugin.loader {

    import ResourceLoader= cc.plugin.loader.ResourceLoader;

    /**
     * @class cc.plugin.loader.ResourceLoaderJSON
     * @implements cc.plugin.loader.ResourceLoader
     * @classdesc
     *
     * <p>
     *     This object loads images a JSON object
     */
    export class ResourceLoaderJSON implements ResourceLoader {

        /**
         * Url string where the resource is located.
         * @member cc.plugin.loader.ResourceLoaderJSON#_url
         * @type {string}
         * @private
         */
        _url:string= null;

        /**
         * Use JSON.parse from the loaded value ?
         * @member cc.plugin.loader.ResourceLoaderJSON#_parse
         * @type {boolean}
         * @private
         */
        _parse:boolean=true;

        /**
         * Create a new ResourceLoaderJSON instance.
         * @method cc.plugin.loader.ResourceLoaderJSON#constructor
         * @param url {string}
         */
        constructor( url:string, initializer?:any ) {
            this._url= url;

            if ( typeof initializer!=="undefined" ) {
                this._parse = typeof initializer.parse!=="undefined" ? initializer.parse : true;
            }
        }

        /**
         * Load the resource.
         * @param loaded {cc.plugin.loader.ResourceLoaderResourceOkCallback} callback invoked when the resource is successfully loaded.
         * @param error {cc.plugin.loader.ResourceLoaderResourceErrorCallback} callback invoked when the resource is not successfully loaded.
         */
        load( loaded:ResourceLoaderResourceOkCallback, error:ResourceLoaderResourceErrorCallback, progress?:(p:number) => void ) : void {

            var me = this;

            var req = null;
            if (typeof XMLHttpRequest!=="undefined" && typeof ActiveXObject==="undefined") {
                try {
                    req = new XMLHttpRequest();
                } catch (e) {
                    req = null;
                }
            } else if (typeof ActiveXObject!=="undefined") {
                try {
                    req = new ActiveXObject("Msxml2.XMLHTTP");
                } catch (e) {
                    try {
                        req = new ActiveXObject("Microsoft.XMLHTTP");
                    } catch (e1) {
                        req = null;
                    }
                }
            }

            if (req) {

                req.open("GET", me._url, true);

                if ( progress ) {
                    req.onprogress = function(evt) {
                        if (evt.lengthComputable) {
                            var percentComplete = (evt.loaded / evt.total) * 100;
                            progress( percentComplete );
                        } else {
                            progress( -1 );
                        }
                    };
                }

                req.onload = function (e) {
                    if (req.status != 200) {
                        error();
                        return;
                    }

                    var text = e.currentTarget ? e.currentTarget.responseText : e.target.responseText;
                    if (text!=="") {
                        loaded( me.getValue(text) );
                    }

                };
                req.send();
            }
        }

        getValue( text:string ) {
            return this._parse ? JSON.parse(text) : text;
        }
    }

    /**
     * @class cc.plugin.loader.ResourceLoaderXML
     * @extends ResourceLoaderJSON
     * @classdesc
     *
     * Loads a xml file. Will return a javascript array object parsed form the plist contents.
     * object[0] will be the first plist node, and so on.
     */
    export class ResourceLoaderXML extends ResourceLoaderJSON {

        /**
         * @method cc.plugin.loader.ResourceLoaderXML#constructor
         * @param url
         */
        constructor( url:string ) {
            super(url);
        }

        /**
         * Get the value from the loaded content.
         * It will parse the xml and build a javascript array object.
         * @method cc.plugin.loader.ResourceLoaderXML#getValue
         * @override
         * @param text {string} file contents.
         * @returns {object}
         */
        getValue( text:string ) : any {

            if ( typeof DOMParser!=="undefined" ) {

                var parser:DOMParser= new DOMParser();
                var doc:Document= parser.parseFromString( text, "text/xml" );

                // type Node
                return this.__parseNode( doc.documentElement );

            } else {
                return {};
            }
        }

        /**
         * Parse a XML Document.documentElement.
         * @method cc.plugin.loader.ResourceLoaderXML#__parseNode
         * @param node
         * @returns
         * @private
         */
        __parseNode( node ) {
            var data = null, tagName = node.tagName;

            if(tagName === "plist" ) {
                return this.__parseArray(node);
            } else if(tagName === "dict"){
                return this.__parseDict(node);
            }else if(tagName === "array"){
                return this.__parseArray(node);
            }else if(tagName === "string"){
                if (node.childNodes.length == 1)
                    data = node.firstChild.nodeValue;
                else {
                    //handle Firefox's 4KB nodeValue limit
                    data = "";
                    for (var i = 0; i < node.childNodes.length; i++)
                        data += node.childNodes[i].nodeValue;
                }
            }else if(tagName === "false"){
                return false;
            }else if(tagName === "true"){
                return true;
            }else if(tagName === "real"){
                return parseFloat(node.firstChild.nodeValue);
            }else if(tagName === "integer"){
                return parseInt(node.firstChild.nodeValue, 10);
            }
            return data;
        }

        /**
         * Parse an array Node from a plist.
         * @method cc.plugin.loader.ResourceLoaderXML#__parseArray
         * @param node
         * @returns {Array<object>}
         * @private
         */
        __parseArray(node) {
            var data = [];
            for (var i = 0; i < node.childNodes.length; i++) {
                var child = node.childNodes[i];
                if (child.nodeType !== 1)
                    continue;
                data.push(this.__parseNode(child));
            }
            return data;
        }

        /**
         * Parse a dictionary node form a plist.
         * @method cc.plugin.loader.ResourceLoaderXML#__parseDict
         * @param node
         * @returns {Map<string,object>}
         * @private
         */
        __parseDict(node) {
            var data = {};
            var key = null;
            for (var i = 0; i < node.childNodes.length; i++) {
                var child = node.childNodes[i];
                if (child.nodeType !== 1)
                    continue;

                // Grab the key, next noe should be the value
                if (child.tagName === 'key')
                    key = child.firstChild.nodeValue;
                else
                    data[key] = this.__parseNode(child);                 // Parse the value node
            }
            return data;
        }



    }

    cc.plugin.loader.registerLoaderForType(
        "json",
        { type: "javascript json", loader: function(url:string) { return new ResourceLoaderJSON(url, {parse:true}); } }
    );
    cc.plugin.loader.registerLoaderForType(
        "txt",
        { type: "plain text files", loader: function(url:string) { return new ResourceLoaderJSON(url, {parse:false}); } }
    );
    cc.plugin.loader.registerLoaderForType(
        "fnt",
        { type: "Glypth designer fnt", loader: function(url:string) { return new ResourceLoaderJSON(url, {parse:false}); } }
    );
    cc.plugin.loader.registerLoaderForType(
        "xml",
        { type: "XML file", loader: function(url:string) { return new ResourceLoaderXML(url); } }
    );
    cc.plugin.loader.registerLoaderForType(
        "plist",
        { type: "MAC Plist file", loader: function(url:string) { return new ResourceLoaderXML(url); } }
    );

}
/**
 * License: see license.txt file
 */

/// <reference path="./ResourceLoader.ts"/>
/// <reference path="../../../lib/webaudio/webaudio.d.ts" />


module cc.plugin.loader {

    import ResourceLoader= cc.plugin.loader.ResourceLoader;


    var audioContext:AudioContext= (function() {
            //var ww= <any>window;
            var ctx= typeof AudioContext!=="undefined" ? AudioContext :
                ( typeof webkitAudioContext!=="undefined" ? webkitAudioContext : null );
            return ctx && new ctx();
        })();

    /**
     * @class cc.plugin.loader.ResourceLoaderAudioBuffer
     * @implements cc.plugin.loader.ResourceLoader
     * @classdesc
     *
     * This object loads an audio as an arraybuffer. It must then be turned into an AudioBuffer by dynamically
     * decoding it.
     */
    export class ResourceLoaderAudioBuffer implements ResourceLoader {

        /**
         * Url string where the resource is located.
         * @member cc.plugin.loader.ResourceLoaderAudioBuffer#_url
         * @type {string}
         * @private
         */
        _url:string= null;


        /**
         * Create a new ResourceLoaderAudioBuffer instance.
         * @method cc.plugin.loader.ResourceLoaderAudioBuffer#constructor
         */
        constructor( url:string ) {
            this._url= url;
        }

        /**
         * Load the resource.
         * @param loaded {cc.plugin.loader.ResourceLoaderResourceOkCallback} callback invoked when the resource is successfully loaded.
         * @param error {cc.plugin.loader.ResourceLoaderResourceErrorCallback} callback invoked when the resource is not successfully loaded.
         */
        load( loaded:ResourceLoaderResourceOkCallback, error:ResourceLoaderResourceErrorCallback ) : void {

            var me = this;

            var req = null;
            if (typeof XMLHttpRequest!=="undefined" && typeof ActiveXObject==="undefined") {
                try {
                    req = new XMLHttpRequest();
                } catch (e) {
                    req = null;
                }
            } else if (typeof ActiveXObject!=="undefined") {
                try {
                    req = new ActiveXObject("Msxml2.XMLHTTP");
                } catch (e) {
                    try {
                        req = new ActiveXObject("Microsoft.XMLHTTP");
                    } catch (e1) {
                        req = null;
                    }
                }
            }

            if (req) {

                req.open("GET", me._url, true);
                req.responseType = "arraybuffer";

                req.onload = function() {

                    audioContext.decodeAudioData(
                        req.response,
                        function(buffer) {
                            loaded(buffer);
                        }, function(e) {
                            console.log("decode error ",e);
                            error();
                        });

                };

                req.send();
            }
        }
    }

    cc.plugin.loader.registerLoaderForType(
        "mp3",
        { type: "mp3 audio", loader: function(url:string) { return new ResourceLoaderAudioBuffer(url); } }
    );
    cc.plugin.loader.registerLoaderForType(
        "ogg",
        { type: "ogg audio", loader: function(url:string) { return new ResourceLoaderAudioBuffer(url); } }
    );
    cc.plugin.loader.registerLoaderForType(
        "wav",
        { type: "wav audio", loader: function(url:string) { return new ResourceLoaderAudioBuffer(url); } }
    );


}
/**
 * License: see license.txt file
 */

/// <reference path="../../util/Debug.ts"/>
/// <reference path="../../locale/Locale.ts"/>
/// <reference path="./Resource.ts"/>

module cc.plugin.loader {

    import Resource= cc.plugin.loader.Resource;

    /**
     * Callback definition for Loader ends loading all resources.
     * @memberOf cc.plugin.loader
     * @callback LoaderFinishedCallback
     * @param resources {Array<cc.plugin.loader.Resource>} all resources created in this loader.
     */
    export interface LoaderFinishedCallback {
        ( resources : {[id:string] : any} ) : any;
    }

    /**
     * Callback definition for the event a Loader ends loading one resources.
     * @memberOf cc.plugin.loader
     * @callback LoaderProgressCallback
     * @param resource {cc.plugin.loader.Resource} loaded resource
     * @param index {number} number of loaded resources so far.
     * @param size {number} total number of resources.
     * @param errored {boolean} true if the resource had an error while loading, false otherwise.
     */
    export interface LoaderProgressCallback {
        (resource:Resource, index:number, size:number, errored:boolean) : void;
    }

    /**
     * Callback definition for the event a Loader gets error loading a resources.
     * @memberOf cc.plugin.loader
     * @callback LoaderErrorCallback
     * @param resource {string} resource error.
     */
    export interface LoaderErrorCallback {
        (resource:Resource) : void;
    }


    /**
     * @class cc.plugin.loader.LoaderInitializer
     * @interface
     * @classdesc
     *
     * This object is the Loader initializer object.
     *
     */
    export interface LoaderInitializer {

        /**
         * Optional common prefix to add to every resource uri before loading.
         * @member cc.plugin.loader.LoaderInitializer#prefix
         * @type {string=}
         */
        prefix? : string;

        /**
         * Optional resource list.
         * @member cc.plugin.loader.LoaderInitializer#resources
         * @type {Array<string>=}
         */
        resources? : string[];
    }

    /**
     * @class cc.plugin.loader.Loader
     * @classdesc
     *
     * <p>
     *     A loader object has the responsibility of loading different types of files and notify success or error
     *     of loading operations.
     * <p>
     *     It has the ability to register new types of loader for different extension files.
     *     The Loader loads data synchronous or asynchronously.
     *     Notifies for each resource in the list about success or error on loading.
     * <p>
     *     The Loader keeps track of loaded content, and notifies callback functions for each resource
     *     loaded, and another callback when it is done with all resources.
     *     When all resources all loaded, local references to these resources are cleared to avoid memory leaks.
     *     Also all resources are instrumented to remove unnecessary information such as loading/error callbacks, etc.
     * <p>
     *     To avoid repetition in resources urls, a common 'prefix' can be specified which will be prepended to every
     *     resource before loading.
     */
    export class Loader {

        /**
         * Common uri prefix to add to all resources before loading.
         * The prefix is added to resources that
         *   * don't start with a protocol prefix (http, https, etc.)
         *   * don't start with a slash '/'
         * This way, you could mix prefixed and non-prefixed resources.
         * <p>
         * The prefix is added as is, is not normalized, or modified in any way.
         * <p>
         * The prefix saves time and typing, so that instead of setting something like:
         *
         * <code>
         * {
         *    resources : [
         *      "/folder/folder2/img1.png",
         *      "/folder/folder2/img2.png",
         *      ...
         *    ]
         * }
         * </code>
         *
         * you could instead do:
         *
         * <code>
         * {
         *   prefix : "/folder/folder2/",
         *   resources : [ "img1.png", "img2.png" ]
         * }
         * </code>
         *
         * @member cc.plugin.loader.Loader#_prefix
         * @type {string}
         * @private
         */
        _prefix : string= null;

        /**
         * Resources list.
         * @member cc.plugin.loader.Loader#_resources
         * @type {Array<string>}
         * @private
         */
        _resources : Resource[]= [];

        /**
         * Current
         * @type {number}
         * @private
         */
        _currentLoadedResourcesCount= 0;

        constructor(loaderData?:LoaderInitializer) {
            if ( loaderData ) {

                // if there's a prefix, set it.
                if (typeof loaderData.prefix!=="undefined") {
                    this._prefix= loaderData.prefix;
                }

                // if there are resources to load, register them.
                if (typeof loaderData.resources!=="undefined") {
                    this.addResources( loaderData.resources );
                }
            }
        }

        /**
         * Prepend the _prefix to the string s if needed.
         * <p>
         * Won't be added for:
         *   * strings starting with /
         *   * strings starting with protocol http,https or ftp
         *
         * @method cc.plugin.loader.Loader#__addPrefixIfNeeded
         * @param s {string} string to add prefix to.
         * @returns {string}
         * @private
         */
        __addPrefixIfNeeded( s:string ) {

            // there's no prefix, nothing to prepend.
            if (!this._prefix) {
                return s;
            }

            // remove trailing spaces.
            s= s.trim();

            // resouce starts with /, an absolute uri, don't add prefix.
            if ( s.charAt(0)==='/' ) {
                return s;
            }

            // is a protocol url, don't add prefix.
            if ( s.indexOf("http")===0 || s.indexOf("https")===0 || s.indexOf("ftp")===0 ) {
                return s;
            }

            return this._prefix + s;
        }

        /**
         * Add one resource to the load queue.
         * @method cc.plugin.loader.Loader#addResource
         * @param url {string}
         */
        addResource( url:string ) : Loader {

            url= this.__addPrefixIfNeeded(url);

            var resource= new Resource(url);
            this._resources.push( resource );

            return this;
        }

        /**
         * Add a collection of resources to the load queue.
         * @method cc.plugin.loader.Loader#addResources
         * @param resources {Array<string>}
         */
        addResources( resources:string[] ) : Loader {
            for( var i=0; i<resources.length; i++) {
                this.addResource( resources[i] );
            }
            return this;
        }

        setProgressLoadForResource( id:string, progress: (percentage:number) => void ) {
            for( var i=0; i<this._resources.length; i++ ) {
                if ( this._resources[i].id===id ) {
                    this._resources[i].setProgress( progress );
                }
            }
        }

        /**
         * Start loading all resources in this loader.
         * @param onEnd {cc.plugin.loader.LoaderFinishedCallback} callback invoked when all asset are loaded. If no resources
         *  are registered, this callback will be immediately invoked.
         * @param onProgress {cc.plugin.loader.LoaderProgressCallback} invoked for each successfully loaded resource.
         * @param onError {cc.plugin.loader.LoaderErrorCallback} invoked for each not sucessfully loaded resource.
         */
        startLoading( onEnd:LoaderFinishedCallback, onProgress?:LoaderProgressCallback, onError?:LoaderErrorCallback ) : Loader {

            if ( this._resources.length===0 ) {
                onEnd({});
                return;
            }

            for( var i=0; i<this._resources.length; i++ ) {
                this._resources[i].load(
                    (resource:Resource) => {    // loaded

                        this._currentLoadedResourcesCount++;
                        if ( onProgress ) {
                            onProgress(resource, this._currentLoadedResourcesCount, this._resources.length, true);
                        }
                        if ( this._currentLoadedResourcesCount===this._resources.length ) {

                            // create resources object. Has index with resources, and associate values by id.
                            var notify:any= {};
                            for( var i=0; i<this._resources.length; i++ ) {
                                //notify[i]= this._resources[i];
                                notify[ this._resources[i].getId() ]= this._resources[i].value;
                            }
                            //notify.length= this._resources.length;

                            onEnd( notify );

                            // remove all local references for resources. Avoid leaks.
                            this._resources= null;
                            this._currentLoadedResourcesCount= 0;
                        }
                    },
                    (resource:Resource) => {    // error

                        this._currentLoadedResourcesCount++;
                        if ( onProgress ) {
                            onProgress(resource, this._currentLoadedResourcesCount, this._resources.length, false);
                        }
                        if ( onError ) {
                            onError(resource);
                        }
                    }
                );
            }

            return this;
        }

    }

}
/**
 * License: see license.txt file.
 */

/// <reference path="../../math/Dimension.ts"/>
/// <reference path="../../node/sprite/SpriteFrame.ts"/>
/// <reference path="../../render/Texture2D"/>
/// <reference path="../../render/RenderingContext"/>
/// <reference path="../asset/AssetManager.ts"/>

module cc.plugin.texture {

    "use strict";

    import Dimension= cc.math.Dimension;

    var getTexturePageIndex= function() {
        var index=0;
        return function() {
            return index++;
        }
    }();

    /**
     * @class cc.plugin.texture.PackInfo
     * @interface
     * @classdesc
     *
     * Object to configure texture packer result.
     * It defines the size of the resulting images, optional margin between adjacent images and what the sorting
     * strategy will be.
     * The sorting is important because may impact considerably in the final result. Conceptually, since bigger
     * images take more space, it is important to first pack them. But, this sprite packer is simple, and despite
     * it gives very good results, it needs some info form you. On average, a sortBy strategy of perimeter gives
     * better results than based on area. Perimeter will be the default value.
     * You can choose from 'perimeter', 'area', 'width' and 'height'.
     *
     */
    export interface PackInfo {

        /**
         * Show debug borders ? Will spoil the generated SpriteFrames but will allow you to see each created node.
         * @member cc.plugin.texture.PackInfo#debug
         * @type {number}
         */
        debug?:boolean;

        /**
         * Texture packer's pages width
         * @member cc.plugin.texture.PackInfo#width
         * @type {number}
         */
        width: number;

        /**
         * Texture packer's pages height
         * @member cc.plugin.texture.PackInfo#height
         * @type {number}
         */
        height: number;

        /**
         * Value from ['perimeter', 'area', 'width', 'height'].
         * Before building the pages the items to pack will be sorted with an internal stock function.
         * 'perimeter' is generally the preferred method and on average gives the best packing results.
         * If not set 'perimeter' will be used.
         * @member cc.plugin.texture.PackInfo#sortBy
         * @type {string=}
         */
        sortBy?: string;

        /**
         * A number defining the margin around packed items. If set will override all other margin-xx values.
         * @member cc.plugin.texture.PackInfo#margin
         * @type {number=}
         */
        margin?: number;

        /**
         * Margin left of packed items.
         * @member cc.plugin.texture.PackInfo#margin-left
         * @type {number=}
         */
        'margin-left'?: number;

        /**
         * Margin top of packed items.
         * @member cc.plugin.texture.PackInfo#margin-top
         * @type {number=}
         */
        'margin-top'?: number;

        /**
         * Margin right of packed items.
         * @member cc.plugin.texture.PackInfo#margin-right
         * @type {number=}
         */
        'margin-right'?: number;

        /**
         * Margin bottom of packed items.
         * @member cc.plugin.texture.PackInfo#margin-bottom
         * @type {number=}
         */
        'margin-bottom'?: number;

    }

    var SortStrategies= {

        __compare: function( v0:number, v1:number) {
            if ( v0<v1 ) {
                return 1;
            } else if ( v0>v1 ) {
                return -1;
            }
            return 0;
        },

        perimeter: function(i0:TexturePackerItem, i1:TexturePackerItem) {
            var w0= i0.getWidth();
            var h0= i0.getHeight();
            var w1= i1.getWidth();
            var h1= i1.getHeight();

            return SortStrategies.__compare(w0+w0+h0+h0, w1+w1+h1+h1);
        },

        area: function(i0:TexturePackerItem, i1:TexturePackerItem) {
            var w0= i0.getWidth();
            var h0= i0.getHeight();
            var w1= i1.getWidth();
            var h1= i1.getHeight();

            return SortStrategies.__compare(w0*h0, w1*h1);
        },

        width: function(i0:TexturePackerItem, i1:TexturePackerItem) {
            return SortStrategies.__compare(i0.getWidth(), i1.getHeight());
        },

        height: function(i0:TexturePackerItem, i1:TexturePackerItem) {
            return SortStrategies.__compare(i0.getWidth(), i1.getHeight());
        }

    };

    /**
     * @class cc.plugin.texture.TexturePackerNode
     * @classdesc
     *
     * This Object is a helper for a TexturePackerPage object. It represents a region on a packed image.
     * This object is a actually a binary tree.
     * It will either hold an Image, or two descendant nodes.
     *
     */
    export class TexturePackerNode {

        /**
         * x position in page.
         * @member cc.plugin.texture.TexturePackerNode#_x
         * @type {number}
         * @private
         */
        _x: number= 0;

        /**
         * y position in page.
         * @member cc.plugin.texture.TexturePackerNode#_y
         * @type {number}
         * @private
         */
        _y: number= 0;

        /**
         * node width in page.
         * @member cc.plugin.texture.TexturePackerNode#_width
         * @type {number}
         * @private
         */
        _width: number= 0;

        /**
         * node height in page.
         * @member cc.plugin.texture.TexturePackerNode#_height
         * @type {number}
         * @private
         */
        _height:number= 0;

        /**
         * Left child node.
         * @member cc.plugin.texture.TexturePackerNode#_left
         * @type {cc.plugin.texture.TexturePackerNode}
         * @private
         */
        _left: TexturePackerNode= null;

        /**
         * right child node.
         * @member cc.plugin.texture.TexturePackerNode#_right
         * @type {cc.plugin.texture.TexturePackerNode}
         * @private
         */
        _right:TexturePackerNode= null;

        /**
         * Item this node contains. The item is a pair of Image/Canvas and an id.
         * @member cc.plugin.texture.TexturePackerNode#_item
         * @type {{any,string}
         * @private
         */
        _item:TexturePackerItem= null;

        /**
         * Create anew TexturePackerNode object instance.
         * @method cc.plugin.texture.TexturePackerNode#constructor
         */
        constructor() {
        }

        /**
         * Insert a Node in this node with the given size.
         * The function will recursively traverse in-order the node to find the most suitable place to insert.
         * It will eventually create child nodes as needed.
         *
         * @param w {number}
         * @param h {height}
         * @param margin {Array<number>=} an array describing a margin around the node. array index are: left, top, right, bottom
         * @returns {cc.plugin.texture.TexturePackerNode}
         */
        insert( w:number, h:number, margin:number[] ) : TexturePackerNode {

            var marginw= margin[0]+margin[2];
            var marginh= margin[1]+margin[3];

            if ( this._left ) {
                var node:TexturePackerNode= this._left.insert( w, h, margin );
                return null===node ?
                    this._right.insert(w,h, margin) :
                    node;
            } else {

                // node has been assigned ? no further search
                if ( this._item!==null) {
                    return null;
                }

                // does not fit here
                if ( this._width<w || this._height<h ) {
                    // return signal to try in another node
                    return null;
                } else if ( this._width===w && this._height===h ) {
                    // perfect match. return this, w/o further dividing
                    return this;
                } else {

                    // create descendants
                    this._left= new TexturePackerNode();
                    this._right= new TexturePackerNode();

                    // when substracting the desired area, it is wider than taller ?
                    // create children maximizing available area.
                    if ( this._width-w >= this._height-h ) {

                        // divide vertically

                        this._left._x= this._x;
                        this._left._y= this._y;
                        this._left._width= w;
                        this._left._height= this._height;

                        //this._right._x= this._x + w;
                        this._right._x= this._x + w + marginw;
                        this._right._y= this._y;
                        //this._right._width= this._width - w;
                        this._right._width= this._width - w - marginw;
                        this._right._height= this._height;
                    } else {

                        // divide horizontally

                        this._left._x= this._x;
                        this._left._y= this._y;
                        this._left._width= this._width;
                        this._left._height= h;

                        this._right._x= this._x;
                        //this._right._y= this._y + h;
                        this._right._y= this._y + h + marginh;
                        this._right._width= this._width;
                        //this._right._height= this._height - h;
                        this._right._height= this._height - h - marginh;
                    }

                    return this._left.insert( w, h, margin );
                }

            }
        }

        /**
         * Paint this node and all its descendants.
         * @method cc.plugin.texture.TexturePackerNode#paint
         * @param ctx {CanvasRenderingContext2D}
         * @param margin {Array<number>=} an array describing a margin around the node. array index are: left, top, right, bottom
         * @param debug {boolean} draw debug info: a red crossed-rect for empty nodes, and a white rect around packed
         * images.
         */
        paint( ctx:CanvasRenderingContext2D, margin:number[], debug:boolean ) {

            if ( debug) {
                // DEBUG rects.

                if ( this._item ) {
                    ctx.strokeStyle = "#fff";
                    ctx.strokeRect(this._x + .5, this._y + .5, this._width - 1, this._height - 1);
                } else if ( !this._left ) {
                    ctx.strokeStyle = "#f00";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this._x + .5, this._y + .5, this._width - 1, this._height - 1);
                    ctx.beginPath();
                    ctx.moveTo(this._x + .5, this._y + .5);
                    ctx.lineTo( this._x+this._width - .5, this._y+this._height - .5);
                    ctx.moveTo(this._x + this._width - .5, this._y + .5);
                    ctx.lineTo( this._x + .5, this._y + this._height - .5);
                    ctx.stroke();
                }
                //ctx.strokeStyle="#0f0";
                //ctx.lineWidth= margin[0];
                //ctx.st rokeRect( this._x+margin[0], this._y+margin[1], this._width-margin[0]-margin[2], this._height-margin[1]-margin[3] );
            }

            if ( this._item ) {
                this._item.draw( ctx, this._x, this._y );
            }

            if ( this._left ) {
                this._left.paint(ctx, margin, debug);
            }
            if ( this._right ) {
                this._right.paint(ctx, margin, debug);
            }
        }

        /**
         * Create and add to the AssetManager a SpriteFrame for each node in the tree that has an associated image.
         * The SpriteFrames will be created using the SpriteFrame that corresponds to the textureId parameter.
         * @method cc.plugin.texture.TexturePackerNode#createFrames
         * @param textureId {string}
         */
        createFrames( textureId:string ) {
            if ( this._item ) {
                cc.plugin.asset.AssetManager.addSpriteFrame(
                    cc.plugin.asset.AssetManager.getSpriteFrame(textureId).createSubSpriteFrame(
                    this._x, this._y,
                    this._width, this._height,
                    this._item.getId()
                ));
            }

            if ( this._left ) {
                this._left.createFrames(textureId);
            }
            if ( this._right ) {
                this._right.createFrames(textureId);
            }
        }
    }

    /**
     * @class cc.plugin.texture.TexturePackerPage
     * @classdesc
     *
     * This object creates an on-the-fly Image atlas with the Images that best fit in it.
     * Internally keeps a Tree of Nodes to maintain the Atlas image representation.
     * When requested, it will create a canvas object with all the images drawn in it in a non-overlapping manner.
     * Images can (and should) have a margin around them of at least 1 pixel.
     *
     */
    export class TexturePackerPage {

        /**
         * Canvas with packer images.
         * @member cc.plugin.texture.TexturePackerPage#_canvas
         * @type {null}
         * @private
         */
        _canvas:HTMLCanvasElement= null;

        /**
         * Canvas rendering context.
         * @member cc.plugin.texture.TexturePackerPage#_ctx
         * @type {CanvasRenderingContext2D}
         * @private
         */
        _ctx:CanvasRenderingContext2D= null;

        /**
         * Page width.
         * @member cc.plugin.texture.TexturePackerPage#_width
         * @type {number}
         * @private
         */
        _width:number;

        /**
         * Page height.
         * @member cc.plugin.texture.TexturePackerPage#_height
         * @type {number}
         * @private
         */
        _height:number;

        /**
         * Page id.
         * When assets are created, the page texture will be added to the SpriteFrame assets map with this id.
         * @member cc.plugin.texture.TexturePackerPage#_id
         * @type {string}
         * @private
         */
        _id:string;

        /**
         * This tree keeps the regions for each image.
         * @member {cc.plugin.texture.TexturePackerPage#_root}
         * @type {cc.plugin.texture.TexturePackerNode}
         * @private
         */
        _root:TexturePackerNode= null;

        /**
         * Create a new TexturePackerPage object instance.
         * @method {cc.plugin.texture.TexturePackerPage#constructor}
         * @param id {string}
         * @param w {number}
         * @param h {number}
         */
        constructor( id:string, w:number, h:number ) {
            this._id= id;
            this._width= w;
            this._height= h;

            this._root= new TexturePackerNode();
            this._root._width= w;
            this._root._height= h;
        }

        /**
         * Insert an image in the best place for it in the node's tree.
         * @method {cc.plugin.texture.TexturePackerPage#insertImage}
         * @param item {{any,string}} a pair of image/canvas and an id
         * @param margin {Array<number>=} an array describing a margin around the node. array index are: left, top, right, bottom
         * @returns {cc.plugin.texture.TexturePackerNode}
         */
        insertImage( item:TexturePackerItem, margin:number[] ) : TexturePackerNode {
            var node= this._root.insert( item.getWidth(), item.getHeight(), margin );
            if (null!==node) {
                node._item= item;
            }

            return node;
        }

        /**
         * Create page's assets and adds them to the AssetManager.
         * @method cc.plugin.texture.TexturePackerPage#createAssets
         */
        createAssets( margin:number[], debug:boolean ) {

            // create a canvas.
            this._canvas= document.createElement("canvas");
            this._canvas.width= this._width;
            this._canvas.height= this._height;
            this._ctx= this._canvas.getContext("2d");

            // draw nodes.
            this._root.paint( this._ctx, margin, debug );

            // create texture
            cc.plugin.asset.AssetManager.addImage( this._canvas, this._id );

            // add all SpriteFrames
            this._root.createFrames( this._id );
        }
    }

    /**
     * Internal object to keep a pair of Image and Id.
     */
    export interface TexturePackerItem {

        getId() : string;
        getWidth() : number;
        getHeight() : number;
        fits( w:number, h:number ) : boolean;
        draw( ctx:CanvasRenderingContext2D, x:number, y:number);
    }

    class TexturePackerItemImage implements TexturePackerItem {

        constructor( public image:any, public id:string ) {
        }

        getId() : string {
            return this.id;
        }

        getWidth() {
            return this.image.width;
        }

        getHeight() {
            return this.image.height;
        }

        fits( w:number, h:number ) : boolean {
            return this.image.width<=w && this.image.height<=h;
        }

        draw( ctx:CanvasRenderingContext2D, x:number, y:number ) {
            ctx.drawImage( this.image, x, y );
        }
    }

    class TexturePackerItemSpriteFrame implements TexturePackerItem {

        constructor( public frame:cc.node.sprite.SpriteFrame, public id:string ) {
        }

        getId() : string {
            return this.id;
        }

        getWidth() {
            return this.frame.getWidth();
        }

        getHeight() {
            return this.frame.getHeight();
        }

        fits( w:number, h:number ) : boolean {
            return this.frame.getWidth()<=w && this.frame.getHeight()<=h;
        }

        draw( ctx:CanvasRenderingContext2D, x:number, y:number ) {

            ctx.save();

            var w= this.frame.getWidth();
            var h= this.frame.getHeight();
            var rect= this.frame._rect;

            if (this.frame._rotated) {
                ctx.translate(w / 2, h / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.translate(-w / 2, -h / 2);
            }

            //if ( cc.render.RENDER_ORIGIN==="" )
            ctx.drawImage(
                this.frame._texture._image,
                rect.x, rect.y, rect.w, rect.h,
                x, y, w, h);

            ctx.restore();
        }
    }

    /**
     * @class cc.plugin.texture.TexturePacker
     * @classdesc
     *
     * This class is a very simple yet effective TexturePacker. It will create images of a user-defined size
     * and pack images in them.
     *
     * The process is:
     * <li>Add images to the packer. Each image must have an id associated.
     * <li>call pack. This will create page object and the tree of nodes with image references.
     * <li>call createAssets, that creates the Page Images and packs the supplied images on them. It also creates
     *   necessary SpriteFrames and Texture objects.
     *
     * This packer is not expected to be used with dynamic textures, adding and removing textures on-the-fly.
     *
     * Images that don't fit in the specified texture page size will be silently discarded.
     *
     */
    export class TexturePacker {

        /**
         * An array of pair Image,id with images to pack.
         * @member cc.plugin.texture.TexturePacker#_images
         * @type {Array<{any,string}>}
         * @private
         */
        _images:TexturePackerItem[] = [];

        /**
         * An array of generated texture page object.
         * @member cc.plugin.texture.TexturePacker#_pages
         * @type {Array<cc.plugin.texture.TexturePackerPage>}
         * @private
         */
        _pages: TexturePackerPage[] = [];

        _margin: number[]= [0,0,0,0];

        _debug: boolean= false;

        /**
         * Create a new TexturePacker object instance.
         * @method cc.plugin.texture.TexturePacker#constructor
         */
        constructor() {

        }

        /**
         * Add an image with associated id to pack.
         * @method cc.plugin.texture.TexturePacker#addImage
         * @param image {HTMLImageElement|HTMLCanvasElement}
         * @param id {string}
         */
        addImage( image:any, id?:string ) {
            this._images.push( new TexturePackerItemImage( image, id ? id : image.src ) );
        }

        addSpriteFrame( spriteFrame:cc.node.sprite.SpriteFrame ) {
            this._images.push( new TexturePackerItemSpriteFrame( spriteFrame, spriteFrame._name ) );
        }

        addSpriteFrames( spriteFrames:cc.node.sprite.SpriteFrame[] ) {
            for( var i=0; i<spriteFrames.length; i++ ) {
                this.addSpriteFrame( spriteFrames[i] );
            }
        }

        addPListAtlas( image:any, atlasInfo:any ) {
            var main= new cc.node.sprite.SpriteFrame( new cc.render.Texture2D(image, "") );
            var sf:cc.node.sprite.SpriteFrame[]= main.createSpriteFramesFromPLIST(atlasInfo);
            this.addSpriteFrames(sf);
        }

        addJSONAtlas( image:any, atlasInfo:any ) {
            var main= new cc.node.sprite.SpriteFrame( new cc.render.Texture2D(image, "") );
            var sf:cc.node.sprite.SpriteFrame[]= main.createSpriteFramesFromJSON(atlasInfo);
            this.addSpriteFrames(sf);
        }

        /**
         * Pack images.
         * This method ONLY creates the internal TexturePackerPage nodes, not the images.
         * Images will be packed in pages of the specified size.
         * @method cc.plugin.texture.TexturePacker#pack
         * @param pack {cc.plugin.texture.PackInfo} texture packer packing info.
         */
        pack( pack:PackInfo  ) {

            var w= pack.width || 2048;
            var h= pack.height || 2048;
            var sortStrategy= pack.sortBy;
            var margin_v= pack.margin || 0;

            // left top right bottom
            var margin= [ margin_v, margin_v, margin_v, margin_v ];
            if ( pack['margin-left'] ) {
                margin[0]= pack['margin-left'];
            }
            if ( pack['margin-top'] ) {
                margin[1]= pack['margin-top'];
            }
            if ( pack['margin-right'] ) {
                margin[2]= pack['margin-right'];
            }
            if ( pack['margin-bottom'] ) {
                margin[3]= pack['margin-bottom'];
            }

            this._debug= typeof pack.debug!=="undefined" ? pack.debug : false;

            this._margin= margin;
            this._pages= [];

            if ( sortStrategy ) {
                var ss= SortStrategies[sortStrategy] || SortStrategies['perimeter'];
                this._images.sort( ss );
            }

            this._pages.push( new TexturePackerPage( "texturepage"+getTexturePageIndex(), w,h ) );

            for( var i=0; i<this._images.length; i++ ) {
                if ( this._images[i].fits(w,h) ) {

                    var node:TexturePackerNode = null;
                    for( var j=0; j<this._pages.length; j++ ) {
                        node= this._pages[j].insertImage( this._images[i], margin );
                        if (node!==null) {
                            break;
                        }
                    }

                    // not a valid insertion node in the currently created pages.
                    // create a new one (the image fits in page dimensions after all)
                    if ( null===node ) {
                        var newPage:TexturePackerPage= new TexturePackerPage( "texturepage"+getTexturePageIndex(),w,h );
                        this._pages.push( newPage );
                        newPage.insertImage(this._images[i], margin);
                    }
                }
            }
        }

        /**
         * Builds page images and the associated SpriteFrame and Texture2D objects.
         * Will also add the assets to the AssetManager.
         * Added images will register a SpriteFrame identified by the supplied id or the image.src if it was not set.
         * Added sprite frames will register a SpriteFrame identified by its id.
         * Created Texture pages will register a SpriteFrame identified as texturepage<i>, where i is the sequence
         * of the created page.
         * This TexturePage index grows with every created frame, so don't always expect to habe texturepage0 as the
         * first created page.
         * @method cc.plugin.texture.TexturePacker#createAssets
         */
        createAssets() {
            for( var i=0; i<this._pages.length; i++ ) {
                this._pages[i].createAssets( this._margin, this._debug );
            }
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../asset/AssetManager.ts"/>
/// <reference path="../../node/sprite/SpriteFrame.ts"/>
/// <reference path="../../render/RenderingContext.ts"/>
/// <reference path="../../render/Texture2D.ts"/>
/// <reference path="../../widget/Label.ts"/>
/// <reference path="./SpriteFontHelper.ts"/>

module cc.plugin.font {

    import SpriteFrame= cc.node.sprite.SpriteFrame;

    /**
     * @class cc.plugin.font.SystemFontInitializer
     * @classdesc
     * @interface
     *
     * This interface represents the needed information to build a SpriteFont from a system font.
     * A new canvas with the specified characters will be generated and will also create a Texture2D and the necessary
     * SpriteFrames for the characters.
     *
     */
    export interface SystemFontInitializer {

        /**
         * Font size. This will be the px size of the valid canvas string font representation.
         * @member cc.plugin.font.SystemFontInitializer#size
         * @type {number}
         */
        size: number;

        /**
         * Font name. This will be the font name of the valid canvas string font representation.
         * @member cc.plugin.font.SystemFontInitializer#fontface
         * @type {string}
         */
        fontface: string;

        /**
         * The font will have the following characters.
         * @member cc.plugin.font.SystemFontInitializer#characters
         * @type {string}
         */
        characters:string;

        /**
         * The font style. a combination of bold+italic
         * @member cc.plugin.font.SystemFontInitializer#style
         * @type {string=}
         */
        style?: string;

        /**
         * Whether the font will be filled. If not set defaults to false.
         * @member cc.plugin.font.SystemFontInitializer#fill
         * @type {boolean=}
         */
        fill?: boolean;

        /**
         * Whether the font will be stroked
         * @member cc.plugin.font.SystemFontInitializer#stroke
         * @type {boolean=}
         */
        stroke?: boolean;

        /**
         * If the font is stroked, this is the size of the stroke. If not set will default to 1.
         * @member cc.plugin.font.SystemFontInitializer#strokeSize
         * @type {number=}
         */
        strokeSize?:number;

        /**
         * If the font is filled, this is a valid canvas fillStyle. If not set defaults to "#000".
         * @member cc.plugin.font.SystemFontInitializer#fillStyle
         * @type {any=}
         */
        fillStyle?:any;

        /**
         * If the font is stroked, this is a valid canvas strokeStyle. If not set defaults to "#000".
         * @member cc.plugin.font.SystemFontInitializer#fillStyle
         * @type {any=}
         */
        strokeStyle?:any;

        /**
         * A padding between characters and font texture lines.
         * In canvas, there's no kerning information, and some characters may not honor the maxAscend value.
         * If after building the font a characters shows pixels from other surrounding characters, increment the
         * padding.
         * Each font will have its own needs.
         * @member cc.plugin.font.SystemFontInitializer#padding
         * @type {number=}
         */
        padding?:number;
    }

    /**
     * @class cc.plugin.font.SpriteFontChar
     * @classdesc
     *
     * For a SpriteFont, this class represents a TextureFont character.
     * It contains information about its size and kerning.
     *
     */
    export class SpriteFontChar {

        /**
         * This numerical id is the charCode of a font character.
         * @member cc.plugin.font.SpriteFontChar#_id
         * @type {number}
         * @private
         */
        _id:number= null;

        /**
         * A SpriteFrame representing character texture information.
         * @member cc.plugin.font.SpriteFontChar#_frame
         * @type {cc.node.sprite.SpriteFrame}
         * @private
         */
        _frame:SpriteFrame= null;

        /**
         * Pixels to advance the cursor after typing this character.
         * @member cc.plugin.font.SpriteFontChar#_xadvance
         * @type {number}
         * @private
         */
        _xadvance:number= 0;

        /**
         * Horizontal offset to draw the character.
         * @member cc.plugin.font.SpriteFontChar#_xoffset
         * @type {number}
         * @private
         */
        _xoffset:number= 0;

        /**
         * Vertical offset to draw the character. this offset will make the character lie on the baseline.
         * @member cc.plugin.font.SpriteFontChar#_yoffset
         * @type {number}
         * @private
         */
        _yoffset:number= 0;

        /**
         * Kerning info.
         * @member cc.plugin.font.SpriteFontChar#_kerningInfo
         * @type {Map<string,number>}
         * @private
         */
        _kerningInfo:{ [char:string]: number; }= {};

        /**
         * Reference to the SpriteFont object this char belongs to.
         * @member cc.plugin.font.SpriteFontChar#_font
         * @type {cc.node.sprite.SpriteFont}
         * @private
         */
        _font:SpriteFont=null;

        /**
         * Create a new SpritFontChar object instance.
         * @method cc.plugin.font.SpriteFontChar#constructor
         */
        constructor( ) {
        }

        /**
         * Get the char width.
         * @member cc.plugin.font.SpriteFontChar#get:width
         * @returns {number}
         */
        get width() : number {
            return this._frame._rect.w;
        }

        /**
         * Set the char SpriteFont reference.
         * @member cc.plugin.font.SpriteFontChar#setFont
         * @param f {cc.plugin.font.SpriteFont}
         */
        setFont( f:SpriteFont ) {
            this._font= f;
        }

        /**
         * Set the char SpriteFrame.
         * @member cc.plugin.font.SpriteFontChar#setFrame
         * @param spriteFrame {cc.node.sprite.SpriteFrame}
         */
        setFrame( spriteFrame:SpriteFrame ) {
            this._frame= spriteFrame;
        }

        /**
         * Add kerning info for a given char.
         * @member cc.plugin.font.SpriteFontChar#addKerning
         * @param char {string} a single character string.
         * @param v {number} kerning value for the char parameter
         */
        addKerning( char:string, v:number ) {
            this._kerningInfo[char]= v;
        }

        /**
         * Draw a SpritFont character.
         * @member cc.plugin.font.SpriteFontChar#draw
         * @param ctx {cc.render.RenderingContext}
         * @param x {number}
         * @param y {number}
         * @param nextChar {string} next drawing character. needed for kerning adjustment.
         */
        draw( ctx:cc.render.RenderingContext, x:number, y:number, nextChar:string ) {

            if ( null===this._frame || this._frame._rect.isEmpty() ) {
                return;
            }

            if ( nextChar!==null ) {
                var _kerning= this._kerningInfo[ nextChar ];
                if ( _kerning ) {
                    x+= _kerning;
                }
            }

            var rect= this._frame._rect;

            var _y;
            if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_TOP ) {
                _y= y + this._yoffset;
            } else {
                _y = y + this._font._height - (rect.h+this._yoffset);
            }

            ctx.drawTexture(
                this._frame.getTexture(),
                rect.x, rect.y, rect.w, rect.h,
                x + this._xoffset, _y, rect.w, rect.h);
        }

        /**
         * Create a SpriteFontChar from a SpriteFrame and some data definition.
         * @member cc.plugin.font.SpriteFontChar.createFrom
         * @param frame {cc.node.sprite.SpriteFrame} a sprite frame the character will be mapped to.
         * @param data {object} SpriteFontChar definition.
         * @returns {cc.plugin.font.SpriteFontChar}
         */
        static createFrom( frame:SpriteFrame, data:any ) : SpriteFontChar {

            var sfc= new SpriteFontChar();
            sfc._frame= frame.createSubSpriteFrame( data.x-2, data.y, data.width, data.height, data.id );
            if ( null===sfc._frame ) {
                cc.Debug.info( cc.locale.ERR_FONT_GLYPTH_NOT_IN_FRAME, data.id );
            }
            sfc._xadvance= data.xadvance||0;
            sfc._xoffset= data.xoffset||0;
            sfc._yoffset= data.yoffset||0;
            sfc._id= data.id;

            return sfc;
        }
    }

    /**
     * @class cc.plugin.font.SpriteFont
     * @classdesc
     *
     * A sprite font is a fast drawing type of font that for webgl autobatches with very good performance results.
     * This kind of fonts are backed by a texture, where the characters are already drawn. The font basically blits
     * characters to the screen.
     *
     * Currently, a SpriteFont can be created:
     * <li>From a glyph designer output file
     * <li>A FNT output file, like the ones coming from https://www.glyphite.com
     * <li>From Texture packer JSON output
     * 
     * Fonts can be cached in the AssetManager.
     *
     * BUGBUG: fonts are slow. remove all split calls in favor or faster methods.
     */
    export class SpriteFont {

        /**
         * A font name of choice. This name will be used as the key for the SpriteFont cache.
         * @member cc.plugin.font.SpriteFont#_fontName
         * @type {string}
         * @private
         */
        _fontName:string= null;

        /**
         * Whether the font is valid for draw.
         * @member cc.plugin.font.SpriteFont#_valid
         * @type {boolean}
         * @private
         */
        _valid:boolean= false;

        /**
         * Collection of objects representing font characters.
         * @member cc.plugin.font.SpriteFont#_chars
         * @type {Map<string,SpriteFontChar>}
         * @private
         */
        _chars: { [char:string]: SpriteFontChar }= {};

        /**
         * Font height. The height is the height of every font character. Height is the result of ascent+descent.
         * @member cc.plugin.font.SpriteFont#_height
         * @type {number}
         * @private
         */
        _height:number=0;

        /**
         * Font baseline, corresponding to the alphabetic baseline.
         * @member cc.plugin.font.SpriteFont#_baseline
         * @type {number}
         * @private
         */
        _baseline:number=0;

        /**
         * Font ascent. Height of char area corresponding to the content above the baseline.
         * @member cc.plugin.font.SpriteFont#_descent
         * @type {number}
         * @private
         */
        _descent:number=0;

        /**
         * Font descent. Height of the char area correspoingind to the content below the baseline.
         * @member cc.plugin.font.SpriteFont#_ascent
         * @type {number}
         * @private
         */
        _ascent:number=0;

        /**
         * Create a new SpriteFont object instance.
         * @method cc.plugin.font.SpriteFont#constructor
         * @param name
         */
        constructor( name:string ) {
            this._fontName= name;
        }

        /**
         * Whether the font is valid.
         * @method cc.plugin.font.SpriteFont#isValid
         * @returns {boolean}
         */
        isValid() : boolean {
            return this._valid;
        }

        /**
         * Insert a SpriteFontChar in the font definition.
         * @method cc.plugin.font.SpriteFont#__addChar
         * @param obj {cc.plugin.font.SpriteFontChar}
         * @private
         */
        __addChar( obj:SpriteFontChar ) {
            obj.setFont( this );
            this._chars[String.fromCharCode(obj._id)]= obj;
        }

        /**
         * Create a font font a FNT file.
         * @method cc.plugin.font.SpriteFont#setAsGlypthDesigner
         * @param spriteFrameId {string} The name of a SpriteFrame in the AssetManager cache. The font characters
         *  will be mapped on the SpriteFrame represented by the id.
         * @param fontDef {string} a .fnt file contents.
         * @returns {cc.plugin.font.SpriteFont}
         */
        setAsFnt( spriteFrameId:string, fontDef:string ) :SpriteFont {
            return this.setAsGlypthDesigner( spriteFrameId, fontDef );
        }

        /**
         * Build the font from a glyph designer output file.
         * @method cc.plugin.font.SpriteFont#setAsGlypthDesigner
         * @param spriteFrameId {string} The name of a SpriteFrame in the AssetManager cache. The font characters 
         *  will be mapped on the SpriteFrame represented by the id.
         * @param fontDef {string} a glyph designed file contents.
         * @returns {cc.plugin.font.SpriteFont}
         */
        setAsGlypthDesigner( spriteFrameId:string, fontDef:string ) :SpriteFont {

            var f:SpriteFrame= cc.plugin.asset.AssetManager.getSpriteFrame(spriteFrameId);

            // remove tabs for spaces.
            var text= fontDef.split("\n");

            // iterate lines.
            for (var i = 0; i < text.length; i++) {

                text[i]= text[i].replace(/\t/gi," ");

                // parse a char
                if (0 === text[i].indexOf("char ")) {

                    var str = text[i].substring(5);
                    var pairs = str.split(' ');
                    var props= {};

                    for ( var j = 0; j < pairs.length; j++) {
                        var pair = pairs[j];

                        // skip empty split pairs which are just ""
                        if ( pair!=="" ) {
                            var pairData = pair.trim().split("=");

                            if (pairData[0] !== "page" && pairData[0] !== "chnl" && pairData[0] !== "letter") {
                                var property = pairData[0];
                                var value = pairData[1];
                                props[property] = parseFloat(value);
                            }
                        }
                    }

                    this.__addChar( SpriteFontChar.createFrom( f, props ) );

                } else if ( 0=== text[i].indexOf("kerning ") ) {

                    // parse kerning info.

                    var str= text[i].substring(8);
                    var pairs= str.trim().split(' ');
                    for( var j=0; j< pairs.length; j++ ) {
                        var first=  pairs[0].split('=')[1];
                        var second= pairs[1].split('=')[1];
                        var amount= pairs[2].split('=')[1];

                        var char= this._chars[ String.fromCharCode(parseInt(first)) ];
                        if ( char ) {
                            char.addKerning( String.fromCharCode(parseInt(second)), parseInt(amount) );
                        }
                    }
                } else if ( 0=== text[i].indexOf("common")) {

                    // parse font definition info

                    var str= text[i].substring(7);
                    var pairs= str.trim().split(' ');
                    for( var j=0; j< pairs.length; j++ ) {
                        var vv= pairs[j].split("=");
                        var key= vv[0];
                        value= vv[1];

                        if ( key==="lineHeight" ) {
                            this._height= parseFloat(value);
                        } else if ( key==="base" ) {
                            this._baseline= parseFloat(value);
                            this._descent= this._height-this._baseline;
                        }
                    }
                } else if ( 0=== text[i].indexOf("info")) {

                }
            }

            this._valid= true;

            return this;
        }

        /**
         * Build the font from a systm font object initializer.
         * @method cc.plugin.font.SpriteFont#setAsSystemFont
         * @param fontDef {cc.plugin.font.SystemFontInitializer} font definition
         * @returns {cc.plugin.font.SpriteFont}
         */
        setAsSystemFont( fontDef:SystemFontInitializer ) : SpriteFont {

            if ( typeof fontDef.fontface==="undefined" ) {
                fontDef.fontface="arial";
            }
            if ( typeof fontDef.size==="undefined") {
                fontDef.size= 20;
            }

            fontDef.padding= fontDef.padding||2;
            fontDef.strokeSize=fontDef.strokeSize||1;
            fontDef.strokeStyle= fontDef.strokeStyle || "#000";
            fontDef.fillStyle= fontDef.fillStyle || "#000";

            // create a canvas object
            var canvas:HTMLCanvasElement= document.createElement("canvas");
            var ctx= canvas.getContext("2d");

            var font=  "" + fontDef.size + "px " + fontDef.fontface + (fontDef.style? " "+fontDef.style : "");
            ctx.font= font;
            ctx.strokeStyle= fontDef.strokeStyle;
            ctx.fillStyle=fontDef.fillStyle;
            ctx.lineWidth=fontDef.strokeSize;

            var mt:cc.plugin.font.FontMetrics= cc.plugin.font.getFontMetrics(ctx, font);

            this._height= mt.height + fontDef.padding;
            this._baseline= this._height;

            var mwidth= ctx.measureText(fontDef.characters).width;  //  measured width
            var w= (Math.min(mwidth,1024)|0)+1;
            var h= (2+((mwidth/1024)|0))*this._height;

            canvas.width= w;
            canvas.height= h;
            ctx= canvas.getContext("2d");

            ctx.font= font;

            ctx.textBaseline= "alphabetic";
            ctx.textAlign= "center";

            ctx.strokeStyle= fontDef.strokeStyle;
            ctx.fillStyle=fontDef.fillStyle;
            ctx.lineWidth=fontDef.strokeSize;

            var x=0;
            var y= mt.ascent;

            var chars = {};

            for( var i=0; i<fontDef.characters.length; i++ ) {
                var str= fontDef.characters.substr(i,1);
                var strw= 1+(ctx.measureText( str ).width|0);

                if ( x+strw+fontDef.padding >= w ) {
                    x=0;
                    y+= this._height;
                }

                if ( fontDef.stroke ) {
                    ctx.strokeText( str, x+strw/2, y );
                }
                if ( fontDef.fill ) {
                    ctx.fillText( str, x+strw/2, y );
                }

                chars[ str ]= {
                    x: x + fontDef.padding/2,
                    y: y - mt.ascent ,
                    width: strw+ fontDef.strokeSize/2,
                    height: this._height,
                    id : str.charCodeAt(0),
                    xadvance : strw
                };

                x+=strw+fontDef.padding;
            }

            cc.plugin.asset.AssetManager.addImage( canvas, this._fontName );

            for( var char in chars ) {
                this.__addChar( SpriteFontChar.createFrom( cc.plugin.asset.AssetManager.getSpriteFrame(this._fontName), chars[char] ) );
            }

            this._valid= true;

            return this;
        }

        /**
         * Draw text with the font.
         * Characters not present in the font will be skipped, as if they were not in the string.
         * The string can be multiline, and text is splitted in lines with \n character.
         * The split operation is slow and GC prone, so better call drawTextArray.
         * @method cc.plugin.font.SpriteFont#drawText
         * @param ctx {cc.render.RenderingContext}
         * @param text {string}
         * @param x {number}
         * @param y {number}
         */
        drawText( ctx:cc.render.RenderingContext, text:string, x:number, y:number ) {

            var lines = text.split('\n');
            this.drawTextArray( ctx, lines, x, y );
        }

        /**
         * Draw an array of strings. Each string will be considered one line of text.
         * This method will be called by drawText. Prefer this method to avoid creating intermediate strings
         * per frame compared to drawText.
         * @param ctx {cc.render.RenderingContext}
         * @param lines {string[]}
         * @param x {number}
         * @param y {number}
         */
        drawTextArray( ctx:cc.render.RenderingContext, lines:string[], x:number, y:number ) {

            var h= this._height;

            if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM) {
                y += (lines.length - 1) * this._height;
                h= -h;
            }

            for(var n = 0; n < lines.length; n++) {
                this.drawTextLine( ctx, lines[n], x, y );
                y += h;
            }
        }

        /**
         * This method is like drawText but does not take into account line breaks.
         * It will therefore draw all text in one single line.
         * This method is called by drawTextArray. Prefer this method if the text has one single line of text.
         * @param ctx {cc.render.RenderingContext}
         * @param text {string}
         * @param x {number}
         * @param y {number}
         */
        drawTextLine( ctx:cc.render.RenderingContext, text:string, x:number, y:number ) {

            for (var i = 0; i < text.length; i++) {

                var char = this._chars[text.charAt(i)];
                if (char) {
                    // draw char
                    char.draw(ctx, x, y, i<text.length-1 ? text.charAt(i + 1) : null );
                    x += char._xadvance;
                }
            }
        }

        /**
         * Draw a text with the current font that will fit in a given rectangle.
         * The text will flow with the given rectangle width.
         * The text will be horizontal and vertically aligned in the rect based on the valign/halign hints.
         * The text can have multiple lines separated by \n characters.
         * @param ctx {cc.render.RenderingContext} multi renderer rendering context.
         * @param text {string} text to fit in the rectangle.
         * @param x {number} x position of the rect to fit the text in.
         * @param y {number} y position of the rect to fit the text in.
         * @param width {number} width of the rect to fit the text in.
         * @param height {number} height of the rect to fit the text in.
         * @param valign {cc.widget.VALIGN} vertical alignment hint
         * @param halign {cc.widget.HALIGN} horizontal alignment hint
         */
        drawTextInRect( ctx:cc.render.RenderingContext, text:string, x:number, y:number, width:number, height:number, halign:number, valign:number ) {

            var textSize= this.getTextSize( text, width );

            var lines = text.split('\n');

            var textHeight= textSize.height;
            var yoffset= 0;

            // make top be always up regardless how y-axis grows.
            if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM) {
                if ( valign===cc.widget.VALIGN.BOTTOM ) {
                    valign= cc.widget.VALIGN.TOP;
                } else if ( valign===cc.widget.VALIGN.TOP ) {
                    valign= cc.widget.VALIGN.BOTTOM;
                }
            }

            switch( valign ) {
                case cc.widget.VALIGN.MIDDLE:
                    yoffset= (height-textHeight)/2;
                    break;
                case cc.widget.VALIGN.BOTTOM:
                    yoffset= height-textHeight-1;
            }

            if ( cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM) {
                yoffset += (lines.length - 1) * this._height;
            }

            var xx= x;

            for(var n = 0; n < lines.length; n++) {

                var xoffset=0;
                var lineWidth= this.getStringWidth( lines[n] );
                switch( halign ) {
                    case cc.widget.HALIGN.CENTER:
                        //xoffset= (width-lineWidth)/2;
                        break;
                    case cc.widget.HALIGN.RIGHT:
                        //xoffset= width-lineWidth-1;
                }

                var words= lines[n].split(" ");

                for (var i = 0; i < words.length; i++) {

                    var word= words[i];
                    if ( i<words.length-1 ) {
                        word += " ";
                    }

                    var wordWidth= this.getStringWidth( word );
                    if ( x+wordWidth>width ) {
                        y += this._height * (cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM ? -1 : 1);
                        x= 0;
                    }

                    for( var j=0; j<word.length; j++ ) {
                        var char = this._chars[ word[j] ];
                        if (char) {
                            // draw char
                            char.draw(ctx, x + xoffset, y + yoffset, lines[n].charAt(i + 1));
                            x += char._xadvance;
                        }
                    }
                }

                y += this._height * (cc.render.RENDER_ORIGIN===cc.render.ORIGIN_BOTTOM ? -1 : 1);
                x = xx;

            }
        }

        /**
         * Get a text dimension by this font.
         * @method cc.plugin.font.SpriteFont#textSize
         * @param text {string}
         * @param flowWidth {number=}
         * @returns {cc.math.Dimension}
         */
        getTextSize( text:string, flowWidth?:number ) : cc.math.Dimension {

            var width=0;
            var height=0;

            if (!flowWidth) {

                var lines = text.split('\n');
                for (var n = 0; n < lines.length; n++) {

                    var w = this.getStringWidth(lines[n]);
                    if (w > width) {
                        width = w;
                    }
                    height += this._height;
                }

                return new cc.math.Dimension(width, height);
            } else {

                return this.getTextSizeFlow( text, flowWidth );
            }
        }

        getTextSizeFlow( text:string, flowWidth:number ) : cc.math.Dimension {
            var lines= text.split("\n");
            var ret= new cc.math.Dimension();
            for( var i=0; i<lines.length; i++) {
                var d= this.getLineSizeFlow( lines[i], flowWidth );

                if ( d.width>ret.width ) {
                    ret.width= d.width;
                }

                ret.height+= d.height;
            }

            return ret;
        }

        getLineSizeFlow( text:string, flowWidth:number ) : cc.math.Dimension {

            var maxWidth=0;
            var w=0;
            var h= this._height;

            var words= text.split(" ");
            for (var i = 0; i < words.length; i++) {

                var word= words[i];
                if ( i<words.length-1 ) {
                    word += " ";
                }

                var wordWidth=this.getStringWidth(word);

                // wrap line
                if ( w+wordWidth > flowWidth ) {
                    h+= this._height;
                    if ( w>maxWidth ) {
                        maxWidth=w;
                    }
                    w=wordWidth;
                } else {
                    w+= wordWidth;
                }
            }

            if ( w>maxWidth ) {
                maxWidth=w;
            }

            return new cc.math.Dimension( maxWidth, h );
        }

        /**
         * Get a string width based on the font char definition.
         * If the string contains an unknown character to the font, that character will be skipped and add 0 to the
         * string width.
         * @param text {string}
         * @returns {number} string width based on the current font.
         */
        getStringWidth( text:string ) : number {

            var w= 0;
            for (var i = 0; i < text.length; i++) {
                var char = this._chars[text.charAt(i)];
                if (char) {
                    w += char._xadvance;
                }
            }

            return w;
        }

    }
}
/**
 * License: see license.txt file
 */

module cc.plugin.font {

    /**
     * @class cc.plugin.font.FontMetrics
     * @classdesc
     *
     * This class represents Font metrics information.
     * It is needed for building on-the-fly system SpriteFont objects.
     *
     */
    export class FontMetrics {

        /**
         * Text height.
         * @member cc.plugin.font.FontMetrics#height
         * @type {number}
         */
        height: number;

        /**
         * Text ascent.
         * @member cc.plugin.font.FontMetrics#ascent
         * @type {number}
         */
        ascent: number;

        /**
         * Text descent.
         * @member cc.plugin.font.FontMetrics#descent
         * @type {number}
         */
        descent:number;

        /**
         * Build a new FontMetrics object instance.
         * @method cc.plugin.font.FontMetrics#constructor
         */
        constructor( h?:number, as?:number, des?:number ) {
            this.height= h;
            this.ascent= as;
            this.descent= des;
        }
    }

    /**
     * Get a FontMetrics object. The system will try to guess the most accurate FontMetrics object based on system
     * capabilities:
     *
     * <li>First, try to get metrics info from the CanvasRenderingContext2D TextMetrics object.
     * <li>If not available, will try to execute a voodoo function to measure size using DOM and CSS.
     * <li>If not, will guess from the font size. most inaccurate, and buggy.
     *
     * @name getFontMetrics
     * @memberOf cc.plugin.font
     *
     * @param ctx {CanvasRenderingContext2D}
     * @param font {string} valid canvas font representation.
     */
    export function getFontMetrics(ctx:CanvasRenderingContext2D, font:string) : FontMetrics {

        var prevFont= ctx.font;
        ctx.font= font;
        var fm:TextMetrics= ctx.measureText("WHGg");
        var ffm= <any>fm;
        if ( typeof ffm.actualBoundingBoxDescent!=="undefined" ) {

            var ret= new FontMetrics();
            ret.height= ffm.actualBoundingBoxAscent + ffm.actualBoundingBoxDescent;
            ret.ascent= ffm.actualBoundingBoxAscent;
            ret.descent= ffm.actualBoundingBoxDescent;

            ctx.font= prevFont;
            return ret;
        }

        try {
            ret = getFontMetricsCSS(font);
            return ret;
        } catch (e) {
        }

        return getFontMetricsNoCSS(font);
    }

    function getFontMetricsNoCSS(font) {

        var re = /(\d+(\.\d+)?)p[x|t]\s*/i;
        var res = re.exec(font);

        var height:number;

        if (!res) {
            height = 32;
        } else {
            // yes, no need to split the px|t, parsefloat is good enough !!
            height = parseFloat(res[1]);
        }

        var ascent = height - 1;
        var h = (height + height * 0.25) | 0;
        return new FontMetrics( h, ascent, h - ascent );

    }

    /**
     * Totally ripped from:
     *
     * jQuery (offset function)
     * Daniel Earwicker: http://stackoverflow.com/questions/1134586/how-can-you-find-the-height-of-text-on-an-html-canvas
     *
     * @param font
     * @return {*}
     */
    function getFontMetricsCSS(font) {

        function offset(elem) {

            var box, docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft, top, left;
            var doc = elem && elem.ownerDocument;
            docElem = doc.documentElement;

            box = elem.getBoundingClientRect();

            body = document.body;
            win = doc.nodeType === 9 ? doc.defaultView || doc.parentWindow : false;

            clientTop = docElem.clientTop || body.clientTop || 0;
            clientLeft = docElem.clientLeft || body.clientLeft || 0;
            scrollTop = win.pageYOffset || docElem.scrollTop;
            scrollLeft = win.pageXOffset || docElem.scrollLeft;
            top = box.top + scrollTop - clientTop;
            left = box.left + scrollLeft - clientLeft;

            return { top:top, left:left };
        }

        try {
            var text = document.createElement("span");
            text.style.font = font;
            text.innerHTML = "g";

            var block = document.createElement("div");
            block.style.display = "inline-block";
            block.style.width = "1px";
            block.style.height = "0px";

            var div = document.createElement("div");
            div.appendChild(text);
            div.appendChild(block);


            var body = document.body;
            body.appendChild(div);

            try {

                var result = new FontMetrics( );

                block.style.verticalAlign = 'baseline';
                result.ascent = offset(block).top - offset(text).top;

                block.style.verticalAlign = 'bottom';
                result.height = offset(block).top - offset(text).top;

                result.ascent = Math.ceil(result.ascent);
                result.height = Math.ceil(result.height);

                result.descent = result.height - result.ascent;

                return result;

            } finally {
                body.removeChild(div);
            }
        } catch (e) {
            return null;
        }
    }

}
/**
 * License: see license.txt file
 */

/// <reference path="../../../lib/webaudio/webaudio.d.ts" />

/// <reference path="../../math/Rectangle.ts"/>
/// <reference path="../../node/sprite/SpriteFrame.ts"/>
/// <reference path="../../node/sprite/Animation.ts"/>
/// <reference path="../../render/Texture2D.ts"/>
/// <reference path="../../render/Renderer.ts"/>
/// <reference path="../../plugin/font/SpriteFont.ts"/>
/// <reference path="../loader/Loader.ts"/>
/// <reference path="../loader/Resource.ts"/>

module cc.plugin.asset {

    import Loader= cc.plugin.loader.Loader;
    import Resource= cc.plugin.loader.Resource;
    import Texture2D= cc.render.Texture2D;
    import SpriteFrame= cc.node.sprite.SpriteFrame;
    import Animation= cc.node.sprite.Animation;
    import SpriteFont= cc.plugin.font.SpriteFont;
    import SystemFontInitializer= cc.plugin.font.SystemFontInitializer;

    /**
     * Stores all image resources.
     * @type {Map<string,cc.render.Texture2D>}
     * @private
     */
    var _textures: { [id:string]:Texture2D; }= {};

    /**
     * Stores all SpriteFrame resources. Loaded Atlases will also add SpriteFrames based on their internal definitions.
     * @type {Map<string,cc.node.sprite.SpriteFrame>}
     * @private
     */
    var _frames: { [id:string]:SpriteFrame; }= {};

    /**
     * Stores Animation objects
     * @type {Map<string,cc.node.sprite.Animation>}
     * @private
     */
    var _animations:{ [id:string]:Animation; }= {};

    /**
     * Stores SpriteFont objects
     * @type {Map<string,cc.plugin.font.SpriteFont>}
     * @private
     */
    var _spriteFonts:{ [id:string]:SpriteFont; }= {};

    var _audioBuffers: {[id:string]:AudioBuffer; }= {};

    export interface ResourcesMap {
        [id:string] : any;
    }

    /**
     * @class cc.plugin.asset.AssetManager
     * @classdesc
     *
     * A AssetManager manager keeps references of in-game resources. The difference with a plain resource is that a
     * resource manages load-and-set operations, but an asset han have some postprocessing, like creating an atlas
     * from an image, etc.
     * This object is the only globally available object and thus, can be shared across different Director objects.
     * The idea is to have a centralized resource mechanism where sounds, sprites, atlases, fonts, etc. can be directly
     * accessed. The resource manager will just store, contents, not handle or load it in anyway.
     * <p>
     *     The AssetManager can be the listener or any Loader objects, thus receiving the independent resources,
     *     and then grouping them in different stores.
     * <p>
     *     The method load, creates a Loader object and registers itself as observer of the loading events.
     */
    export class AssetManager {

        /**
         * For backwards compatibility
         * Map of string,Resource
         */
        static _resources: {[id:string]:any} = {};

        static mergeResources( res:{[id:string]:any} ) {
            for( var i in res ) {
                cc.plugin.asset.AssetManager._resources[i]= res[i];
            }
        }

        /**
         * Load a resource set.
         * Internally, it builds a <code>cc.plugin.loader.Loader</code> object and starts the loading process.
         * @method cc.plugin.loader.AssetManager.load
         * @param data {cc.plugin.loader.LoaderInitializer} resources descriptor.
         * @param onEnd {cc.plugin.loader.LoaderFinishedCallback} callback invoked when all resources end loading.
         *          either the resources loaded ok or wrong, this method will be called.
         * @param onProgress {cc.plugin.loader.LoaderProgressCallback=} callback invoked for each loaded resource
         *          regardless of its loading result.
         * @param onError {cc.plugin.loader.LoaderErrorCallback=} callback invoked for each resource loaded with error.
         */
        static load( data:cc.plugin.loader.LoaderInitializer,
                     onEnd?:cc.plugin.loader.LoaderFinishedCallback,
                     onProgress?:cc.plugin.loader.LoaderProgressCallback,
                     onError?:cc.plugin.loader.LoaderErrorCallback ) {

            new Loader(data).startLoading(

                function end(resources:ResourcesMap) {
                    if (onEnd) {
                        onEnd(resources);
                    }

                },
                function progress( resource:Resource, index:number, total:number, errored:boolean ) {
                    //AssetManager.addResource( resource );
                    if (onProgress) {
                        onProgress( resource, index, total, errored );
                    }
                },
                function error( resource:Resource ) {
                    if (onError) {
                        onError(resource);
                    }
                }
            );
        }

        /**
         * Setup textures for a given renderer. Concretelly, if the renderer is webgl, textures are turned into webgl
         * textures.
         * @method cc.plugin.asset.AssetManager.prepareTextures
         * @param renderer {cc.render.Renderer}
         */
        static prepareTextures( renderer:cc.render.Renderer ) {
            for( var texture in _textures ) {
                if ( _textures.hasOwnProperty(texture) ) {
                    renderer.prepareTexture(_textures[texture]);
                }
            }
        }

        /**
         * Add an Image to the Manager resources.
         * The image will be stored as a cc.render.Texture2D object.
         * A SpriteFrame with the given id and representing the whole image will be added too.
         * @method cc.plugin.asset.AssetManager.addImage
         * @param img {HTMLImageElement|HTMLCanvasElement}
         * @param id {string} The texture and the SpriteFrame representing the texture will have this id.
         */
        static addImage( img:HTMLImageElement|HTMLCanvasElement, id:string ) : cc.render.Texture2D {
            var texture:Texture2D= new cc.render.Texture2D(img, id);
           _textures[ id ]= texture;
           _frames[ id ]= new cc.node.sprite.SpriteFrame( texture );

            return texture;
        }

        /**
         * Add a cc.plugin.loader.Resource instance.
         * Currently only works for images.
         * @method cc.plugin.asset.AssetManager.addResource
         * @param resource {cc.plugin.loader.Resource}
         */
        static addResource( resource:Resource ) {
            if ( resource.isValid() ) {

                switch( resource.type ) {
                    case "image":   // resource loaded as image.
                        AssetManager.addImage( resource.value, resource.id );
                        break;
                    //default:        // resource loaded as WTF ??
                    //    cc.Debug.warn( cc.locale.WARN_RESOURCE_OF_UNKNOWN_TYPE, resource.id );
                }

            }
        }

        /**
         * Add a SpriteFrame to the cache.
         * @method cc.plugin.asset.AssetManager.addSpriteFrame
         * @param frame {cc.node.sprite.SpriteFrame}
         */
        static addSpriteFrame( frame:SpriteFrame ) {
            _frames[ frame._name ]= frame;
        }

        /**
         * Get an SpriteFrame by id.
         * @method cc.plugin.asset.AssetManager.getSpriteFrame
         * @param id {string}
         * @returns {cc.node.sprite.SpriteFrame}
         */
        static getSpriteFrame( id:string ) : SpriteFrame {
            var ret= _frames[id];
            return ret ? ret : null;
        }

        /**
         * Add an array of SpriteFrames to the cache.
         * @method cc.plugin.asset.AssetManager.addSpriteFrames
         * @param frames {Array<cc.node.sprite.SpriteFrame>}
         */
        static addSpriteFrames( frames:SpriteFrame[] ) {
            for( var i=0; i<frames.length; i++ ) {
                this.addSpriteFrame( frames[i] );
            }
        }

        /**
         * Get an array of sprite frames identified by an array of SpriteFrame ids.
         * If any of the ids does not match a SpriteFrame object, a warning will be printed in the console,
         * but nothing will happen.
         * @method cc.plugin.asset.AssetManager.getSpriteFrames
         * @param ids {Array<string>}
         * @returns {Array<cc.node.sprite.SpriteFrame>}
         */
        static getSpriteFrames( ids:string[] ) : SpriteFrame[] {
            var ret:SpriteFrame[]= [];

            for( var i=0; i<ids.length; i++ ) {
                var sf:SpriteFrame= AssetManager.getSpriteFrame( ids[i] );
                if ( sf ) {
                    ret.push( sf );
                } else {
                    cc.Debug.warn( cc.locale.ASSETMANAGER_WARN_SPRITEFRAME_NOT_FOUND, "getSpriteFrames", ids[i] );
                }
            }

            return ret;
        }

        /**
         * Add a Texture2D to the cache.
         * @method cc.plugin.asset.AssetManager.addTexture
         * @param texture {cc.render.Texture2D}
         */
        static addTexture( texture:Texture2D ) {
            _textures[ texture._name ]= texture;
        }

        /**
         * Get a Texture2D object by string id.
         * @param name {string}
         * @returns {cc.render.Texture2D}
         */
        static getTexture( name:string ) : Texture2D {
            var ret= _textures[name];
            return ret ? ret : null;
        }

        static addAnimation( animation:cc.node.sprite.Animation, name:string ) {
            _animations[ name ]= animation;
        }

        /**
         * Create and store an animation build of the frames identified by the frames array.
         * If there's a prefix set, the frames is assumed to be an array of number, to build the SpriteFrame names:
         *  prefix+frames[0], prefix+frames[1], ..., etc.
         * If no prefix, the frames array is assumed to be the sting identifiers of the frames composing the animation.
         * @param animationName {string}
         * @param frames {Array<number|string>}
         * @param prefix {string=}
         */
        static addAnimationForFrames( animationId:string, frames:Array<number>|string[], prefix?:string ) : Animation {

            var animation= new cc.node.sprite.Animation();
            for( var i=0; i<frames.length; i++ ) {
                var frameName : string= prefix ? prefix+frames[i] : <string>frames[i];
                var spriteFrame= _frames[ frameName ];
                if ( spriteFrame ) {
                    animation.addFrame( spriteFrame );
                }
            }

            _animations[animationId]= animation;

            return animation;
        }

        /**
         * Get an animation by id.
         * @param animationId {string}
         * @returns {cc.node.sprite.Animation}
         */
        static getAnimationById( animationId:string ) : cc.node.sprite.Animation {
            var anim:Animation = _animations[animationId];
            if ( anim ) {
                return anim.clone();
            }

            return null;
        }

        /**
         * Create SpriteFrames for all the elements in the JSON object.
         * The new SpriteFrame objects will be mapped inside the SpriteFrame identified by the spriteFrameId parameter.
         * @method cc.plugin.asset.AssetManager.addSpriteFramesFromFrameWithJSON
         * @param spriteFrameId {string} a SpriteFrame in the cache.
         * @param json {any}
         * @param prefix {string=} an optional prefix to prepend to all sprite frame names.
         */
        static addSpriteFramesFromFrameWithJSON( spriteFrameId:string, json:any, prefix?:string ) {
            var spriteFrame:SpriteFrame = AssetManager.getSpriteFrame(spriteFrameId);
            if ( spriteFrame ) {
                var frames:SpriteFrame[]= spriteFrame.createSpriteFramesFromJSON(json);
                if ( prefix ) {
                    for( var i=0; i<frames.length; i++ ) {
                        frames[i]._name = prefix + frames[i]._name;
                    }
                }
                AssetManager.addSpriteFrames( frames );
            }
        }

        /**
         * Create a grid of sub SpriteFrames from a given SpriteFrame.
         * @method cc.plugin.asset.AssetManager.addGridSpriteFramesFromFrame
         * @param spriteFrameId {string} a SpriteFrame id from the cache
         * @param rows {number} number or rows of the grid
         * @param cols {number} number or columns of the grid
         */
        static addGridSpriteFramesFromFrame( spriteFrameId:string, rows:number, cols:number ) {

            var spriteFrame:SpriteFrame = AssetManager.getSpriteFrame(spriteFrameId);
            if ( spriteFrame ) {
                var frames:SpriteFrame[]= spriteFrame.createSubSpriteFrames( rows, cols );
                AssetManager.addSpriteFrames( frames );
            }
        }

        /**
         * Create a SpriteFont from the definition of a Glypth Designer file.
         * The font will be stored in the fonts cache.
         * @methoc cc.plugin.asset.AssetManager.createSpriteFontFromGlypthDesigner
         * @param fontName {string} name for storing the font.
         * @param spriteFrameId {string} a SpriteFrame from the cache. The glypths will be mapped in this SpriteFrame.
         * @param glypthDesignerInfo {string} the contents of a Glypth Designer file.
         */
        static createSpriteFontFromGlypthDesigner( fontName:string, spriteFrameId:string, glypthDesignerInfo:string ) {
            var font = new cc.plugin.font.SpriteFont(fontName).
                setAsGlypthDesigner(spriteFrameId, glypthDesignerInfo);
            if (font.isValid()) {
                _spriteFonts[fontName] = font;
            }
        }

        /**
         * Get a SpriteFont from the cache.
         * @methoc cc.plugin.asset.AssetManager.getSpriteFont
         * @param fontName {string} the id of a SpriteFont in the cache.
         * @returns {cc.plugin.font.SpriteFont}
         */
        static getSpriteFont( fontName:string ) : cc.plugin.font.SpriteFont {
            var ret= _spriteFonts[ fontName ];
            return ret ? ret : null;
        }

        /**
         * Create a SpriteFont for a System Font.
         * @param fontName {string} the name to store the font in the cache.
         * @param systemFont {cc.plugin.font.SystemFontInitializer} font definition object.
         */
        static createSystemSpriteFont( fontName:string, systemFont:SystemFontInitializer ) {
            var font= new cc.plugin.font.SpriteFont( fontName ).
                setAsSystemFont( systemFont );
            if (font.isValid()) {
                _spriteFonts[fontName] = font;
            }
        }

        static addSpriteFramesFromFrameWithPLIST( spriteFrameId:string, plist:any ) {
            var spriteFrame:SpriteFrame = AssetManager.getSpriteFrame(spriteFrameId);
            if ( spriteFrame ) {
                var frames:SpriteFrame[]= spriteFrame.createSpriteFramesFromPLIST( plist );
                AssetManager.addSpriteFrames( frames );
            }
        }

        static getAudioBuffer( id:string ) {
            var ret= _audioBuffers[id];
            return ret ? ret : null;
        }

        static addAudioBuffer( buffer:AudioBuffer, id:string ) {
            _audioBuffers[id]= buffer;
        }
    }
}
/**
 *
 */

/// <reference path="../../../lib/webaudio/webaudio.d.ts"/>

module cc.plugin.audio {

    /**
     * @name AudioCallback
     * @memberOf cc.plugin.audio
     * @callback cc.plugin.audio.AudioCallback
     * @param audio {cc.plugin.audio.AudioEffect} the audio object that fired the callback.
     */
    export type AudioCallback= (audio:AudioEffect)=>any;

    var audioContext:AudioContext= (function() {
            var ctx= typeof AudioContext!=="undefined" ? AudioContext :
                ( typeof webkitAudioContext!=="undefined" ? webkitAudioContext : null );
            return ctx && new ctx();
        })();

    var codecs:any= null;

    (function() {

        function check(str):boolean {
            return str!=='' && str!=="no";
        }

        var audio = new Audio();
        codecs = {
            mp3: check(audio.canPlayType('audio/mpeg;')),
            ogg: check(audio.canPlayType('audio/ogg; codecs="vorbis"')),
            wav: check(audio.canPlayType('audio/wav; codecs="1"')),
            aac: check(audio.canPlayType('audio/aac;')),
            m4a: check(audio.canPlayType('audio/x-m4a;')) || check(audio.canPlayType('audio/m4a;')) || check(audio.canPlayType('audio/aac;')),
            mp4: check(audio.canPlayType('audio/x-mp4;')) || check(audio.canPlayType('audio/mp4;')) || check(audio.canPlayType('audio/aac;')),
            weba:check(audio.canPlayType('audio/webm; codecs="vorbis"'))
        };
    })();

    /**
     * @tsenum cc.plugin.audio.AudioEffectStatus
     */
    export enum AudioEffectStatus {
        NONE= 0,
        PLAY= 1,
        PAUSE=2,
        STOP= 3,
        END=  4,
        LOADED= 5
    }

    /**
     * @class cc.plugin.audio.AudioFilterInitializer
     * @interface
     */
    export interface AudioFilterInitializer {

        /**
         * A value form: lowpass, highpass, bandpass, lowshelf, highself, peaking, notch, allpass
         * @member cc.plugin.audio.AudioFilterInitializer#type
         * @type {string}
         */
        type : string;

        /**
         * Frequency parameter
         * @member cc.plugin.audio.AudioFilterInitializer#frequency
         * @type {number}
         */
        frequency? : number;

        /**
         * gain parameter
         * @member cc.plugin.audio.AudioFilterInitializer#gain
         * @type {number}
         */
        gain? : number;

        /**
         * Q parameter
         * @member cc.plugin.audio.AudioFilterInitializer#gain
         * @type {number}
         */
        Q? : number
    }

    /**
     * @class cc.plugin.audio.AudioEffect
     * @classdesc
     *
     * This object represents a WebAudio enabled Object. It can:
     *
     * <ul>
     *  <li>play, pause, resume, stop and loop.
     *  <li>define an AudioSprite (a region over a given audio).
     *  <li>Apply BiquadFilters to output.
     *  <li>Apply Convolution (needs external audio buffers).
     *  <li>Expose full lifecycle: start, stop, repeat, pause and resume.
     *  <li>Manage volume.
     *  <li>Be independently muted.
     *  <li>Play with delay time, so that you can schedule sounds on the future.
     *  <li>Seek audio.
     *  <li>On-the-fly change of properties such as volume, filter, convolver, loop, etc.
     * </ul>
     *
     * This audio object is connected to a master volume.
     */
    export class AudioEffect {

        /**
         * An string id.
         * @member cc.plugin.audio.AudioEffect#_id
         * @type {string}
         * @private
         */
        _id:string= null;

        /**
         *
         * @member cc.plugin.audio.AudioEffect#_isWebAudio
         * @type {boolean}
         * @private
         */
        _isWebAudio:boolean= false;

        /**
         * Internal audio object status.
         * @member cc.plugin.audio.AudioEffect#_status
         * @type {cc.plugin.audio.AudioEffectStatus}
         * @private
         */
        _status:AudioEffectStatus= AudioEffectStatus.NONE;

        /**
         * Is this object muted ?
         * @member cc.plugin.audio.AudioEffect#_muted
         * @type {boolean}
         * @private
         */
        _muted:boolean= false;

        /**
         * The audio volume. Volume ranges from 0 to 1.
         * @member cc.plugin.audio.AudioEffect#_volume
         * @type {boolean}
         * @private
         */
        _volume= 1;

        /**
         * The original audio buffer duration.
         * this value opposes to _duration which is the current Audio object duration.
         * @member cc.plugin.audio.AudioEffect#_bufferDuration
         * @type {number}
         * @private
         */
        _bufferDuration : number= 0;

        /**
         * Current Audio object duration. If the audio is a sprite, the value will be different from _bufferDuration
         * @member cc.plugin.audio.AudioEffect#_bufferDuration
         * @type {number}
         * @private
         */
        _duration:number = 0;

        /**
         * The audio source node.
         * @member cc.plugin.audio.AudioEffect#_source
         * @type {AudioBufferSourceNode}
         * @private
         */
        _source: AudioBufferSourceNode= null;

        /**
         * The audio contents.
         * @member cc.plugin.audio.AudioEffect#_buffer
         * @type {AudioBuffer}
         * @private
         */
        _buffer: AudioBuffer= null;

        /**
         * Relative to duration time when the audio was paused. Never use directly
         * @member cc.plugin.audio.AudioEffect#_pauseTime
         * @type {number}
         * @private
         */
        _pauseTime:number= 0;

        /**
         * The audioContext time when play was called.
         * @member cc.plugin.audio.AudioEffect#_startPlaybackTime
         * @type {number}
         * @private
         */
        _startPlaybackTime:number= 0;

        /**
         * If play is called with delay, this is the delay time before play the sound.
         * @member cc.plugin.audio.AudioEffect#_delayTime
         * @type {number}
         * @private
         */
        _delayTime:number= 0;

        /**
         * Master volume node to which the audio volume will be connected.
         * @member cc.plugin.audio.AudioEffect#_masterGain
         * @type {number}
         * @private
         */
        _masterGain:GainNode= null;

        /**
         * The audio volume node.
         * @member cc.plugin.audio.AudioEffect#_gain
         * @type {number}
         * @private
         */
        _gain:GainNode= null;

        /**
         * Whether the audio is a sprite audio. A sprite audio is just a region from another audio object.
         * @member cc.plugin.audio.AudioEffect#_isSprite
         * @type {boolean}
         * @private
         */
        _isSprite:boolean= false;

        /**
         * If the audio is a Sprite audio, relative time offset where the sprite starts.
         * @member cc.plugin.audio.AudioEffect#_spriteStartTime
         * @type {boolean}
         * @private
         */
        _spriteStartTime:number= 0;

        /**
         * Loop the audio ?.
         * @member cc.plugin.audio.AudioEffect#_loop
         * @type {boolean}
         * @private
         */
        _loop:boolean= false;

        /**
         * Internal loop timer.
         * @member cc.plugin.audio.AudioEffect#_endTimerId
         * @type {number}
         * @private
         */
        _endTimerId:number= null;

        /**
         * Audio end callback.
         * @member cc.plugin.audio.AudioEffect#_onEnd
         * @type {cc.plugin.audio.AudioCallback}
         * @private
         */
        _onEnd:AudioCallback= null;

        /**
         * Audio resume callback.
         * @member cc.plugin.audio.AudioEffect#_onResume
         * @type {cc.plugin.audio.AudioCallback}
         * @private
         */
        _onResume:AudioCallback= null;

        /**
         * Audio pause callback.
         * @member cc.plugin.audio.AudioEffect#_onPause
         * @type {cc.plugin.audio.AudioCallback}
         * @private
         */
        _onPause:AudioCallback= null;

        /**
         * Audio stop callback.
         * @member cc.plugin.audio.AudioEffect#_onStop
         * @type {cc.plugin.audio.AudioCallback}
         * @private
         */
        _onStop:AudioCallback= null;

        /**
         * Audio start callback.
         * @member cc.plugin.audio.AudioEffect#_onStart
         * @type {cc.plugin.audio.AudioCallback}
         * @private
         */
        _onStart:AudioCallback= null;

        /**
         * Audio repeat callback.
         * @member cc.plugin.audio.AudioEffect#_onRepeat
         * @type {cc.plugin.audio.AudioCallback}
         * @private
         */
        _onRepeat:AudioCallback= null;

        /**
         * Internal BiquadFilter node for sound filtering.
         * @member cc.plugin.audio.AudioEffect#_filter
         * @type {object}
         * @private
         */
        _filter:BiquadFilterNode= null;

        /**
         * Is filtering enabled ?
         * @member cc.plugin.audio.AudioEffect#_filterEnabled
         * @type {boolean}
         * @private
         */
        _filterEnabled:boolean= false;

        /**
         * Internal convolver node for sound convolution.
         * @member cc.plugin.audio.AudioEffect#_convolver
         * @type {object}
         * @private
         */
        _convolver:ConvolverNode = null;

        /**
         * Is convolution enabled ?
         * @member cc.plugin.audio.AudioEffect#_convolverEnabled
         * @type {boolean}
         * @private
         */
        _convolverEnabled:boolean= false;

        _playbackRate:number = 1;

        /**
         * @method cc.plugin.audio.AudioEffect#constructor
         * @param buffer {object} Audio buffer object.
         * @param masterGain {object} a GainNode which will act as system volume.
         */
        constructor( masterGain:GainNode, buffer?:AudioBuffer ) {

            this._isWebAudio= true;

            if ( buffer ) {
                this.setBuffer( buffer );
            }

            this._gain= (typeof audioContext.createGain==="undefined") ?
                (<any>audioContext).createGainNode() :
                audioContext.createGain();

            this._gain.connect( masterGain );
            this._masterGain= masterGain;

            this._filter= cc.plugin.audio.AudioManager.getContext().createBiquadFilter();
            this._convolver= cc.plugin.audio.AudioManager.getContext().createConvolver();
        }

        setId( s:string ) : AudioEffect {
            this._id= s;
            return this;
        }

        getId() : string {
            return this._id;
        }

        setBuffer( buffer:AudioBuffer ) {
            this._bufferDuration= buffer.duration;
            this._duration= buffer.duration;
            this._buffer= buffer;
        }

        /**
         * Make the audio loop or not. This can be changed at any given time.
         * @method cc.plugin.audio.AudioEffect#loop
         * @param enable {boolean} enable loop or not.
         * @returns {cc.plugin.audio.AudioEffect}
         */
        loop( enable:boolean ) : AudioEffect {
            this._loop= enable;
            return this;
        }

        /**
         * Get whether the sound is looping.
         * @method cc.plugin.audio.AudioEffect#isLoop
         * @returns {boolean}
         */
        isLoop() : boolean {
            return this._loop;
        }

        /**
         * Get the audio volume
         * @method cc.plugin.audio.AudioEffect#getVolume
         * @returns {number}
         */
        getVolume() : number {
            return this._gain.gain.value;
        }

        /**
         * Set the audio volume.
         * @method cc.plugin.audio.AudioEffect#setVolume
         * @param v {number} a number ranging from 0 (no sound) to 1 (full sound)
         */
        setVolume( v:number ) {
            this._volume= v;
            if (!this._muted) {
                this._gain.gain.value= v;
            }
        }

        /**
         * Set this audio as sprite.
         * Sprites must not be changed while playing. Should be set before.
         * The default sprite will be from starting of sound to its length;
         * If setSprite is called with enable=false, it will set the audio as non sprite, but the information of
         * sprite's start and duration can still be set. If not specified, these values will be kept 'as is'.
         * @method cc.plugin.audio.AudioEffect#setSprite
         * @param enable {boolean} enable this audio as sprite.
         * @param start {number} time offset to play the sound
         * @param duration {number} the audio will play from start to start+duration
         */
        setSprite( enable:boolean, start?:number, duration?:number ) : AudioEffect {
            this._isSprite = enable;

            if (typeof start !== "undefined") {
                this._spriteStartTime = start;
                this._duration = duration;
            }

            if (this._source) {
                this.__setSpriteData();
            }

            return this;
        }

        /**
         * Configure internal audio sprite data.
         * @method cc.plugin.audio.AudioEffect#__setSpriteData
         * @private
         */
        __setSpriteData() {

            if ( this._isSprite ) {
                if ( this._isWebAudio ) {
                    this._source.loopStart = this._spriteStartTime;
                    this._source.loopEnd = Math.min( this._duration, this._spriteStartTime + this._duration );
                }
            } else {
                if ( this._isWebAudio ) {
                    this._duration= this._bufferDuration;
                    this._source.loopStart= 0;
                    this._source.loopEnd= this._duration;
                }
            }

        }

        setPlaybackRate( rate:number ) {
            this._playbackRate= rate;

            if ( this._source ) {
                var wasPlaying= this.isPlaying();
                if (wasPlaying) {
                    this.pause();
                }
                this._source.playbackRate.value = rate;
                if (wasPlaying) {
                    this.resume();
                }
            }
        }

        /**
         * Get audio duration. If the audio loops, getDuration will be Number.MAX_VALUE, and the buffer or sprite duration
         * otherwise plus the delay otherwise.
         * @method cc.plugin.audio.AudioEffect#getDuration
         * @returns {number}
         */
        getDuration() {
            return this._loop ? Number.MAX_VALUE : this._delayTime + this._duration;
        }

        /**
         * Create the audio source and some internal piping.
         * @method cc.plugin.audio.AudioEffect#__createSource
         * @private
         */
        __createSource() {

            this._source= audioContext.createBufferSource();
            this._source.buffer= this._buffer;

            this.__connectNodes();

            this.loop( this._loop );
            this.__setSpriteData();

            this._delayTime=0;
            this._startPlaybackTime= 0;
            if ( !this._muted ) {
                this._gain.gain.value = this._volume;
            }
            this._status= AudioEffectStatus.NONE;
        }

        /**
         * Do the internal volume, source, filter, convolver wiring.
         * @method cc.plugin.audio.AudioEffect#__connectNodes
         * @private
         */
        __connectNodes() {

            var chain:AudioNode[]= [];

            chain.push( this._source );
            if ( this._filterEnabled ) {
                chain.push( this._filter );
            }
            if ( this._convolverEnabled ) {
                chain.push( this._convolver );
            }
            chain.push( this._gain );

            for( var i=0; i<chain.length-1; i++ ) {
                chain[i].connect( chain[i+1] );
            }

        }

        /**
         * Set a filter for the effect.
         * @method cc.plugin.audio.AudioEffect#setFilter
         * @param f {cc.plugin.audio.AudioFilterInitializer} filter info.
         */
        setFilter( f:AudioFilterInitializer ) {

            var wasFilterEnabled= this._filterEnabled;

            this._filterEnabled= f!==null;

            if ( f ) {
                var type= f.type.toLowerCase();
                this._filter.type= type;

                for( var pr in f ) {
                    if ( pr!=="type" && f.hasOwnProperty(pr) ) {
                        this._filter[ pr ].value= f[pr];
                    }
                }
            }

            if ( this._status===AudioEffectStatus.PLAY ) {

                // only if there's no filter now or was not before, do the audio filter wiring.
                if ( !wasFilterEnabled || !this._filterEnabled ) {
                    this.__pausePlay();
                }
            }
        }

        /**
         * Internal method to pause and play the audio. Between pause and play, will do some wiring of the internal nodes.
         * @method cc.plugin.audio.AudioEffect#__pausePlay
         * @private
         */
        __pausePlay() {
            var ct = this.getCurrentTime();
            this.stop();
            this.setCurrentTime(ct);
            this.__connectNodes();
            this.play();
        }

        /**
         * Play the audio. Alternatively, the play can be deferred by passing a delay parameter.
         * @method cc.plugin.audio.AudioEffect#play
         * @param delay {number} milliseconds to defer audio play.
         * @returns {cc.plugin.audio.AudioEffect}
         */
        play( delay?:number ) : AudioEffect {

            delay= delay || 0;

            var startTime= 0;
            var waspaused= false;

            if ( this._status=== AudioEffectStatus.PLAY ) {
                this.stop();
            } else if ( this._status===AudioEffectStatus.PAUSE ) {
                startTime= this._pauseTime;
                waspaused= true;
            }

            this.__createSource();
            this._status= AudioEffectStatus.PLAY;

            this._startPlaybackTime= audioContext.currentTime;
            this._delayTime= delay;

            this._source.playbackRate.value= this._playbackRate;

            if ( this._isSprite ) {
                if ( this._isWebAudio ) {
                    if (typeof this._source.start === 'undefined') {
                        (<any>this._source).noteGrainOn( delay, this._spriteStartTime+startTime, this.getRemainingTime());
                    } else {
                        this._source.start(delay, this._spriteStartTime+startTime, this.getRemainingTime());
                    }
                }
            } else {
                if ( this._isWebAudio ) {
                    this._source.start(delay, startTime);

                }
            }

            //if ( !this._loop ) {
                this.__cancelEndTimer();
                this.__startEndTimer();
            //}

            if ( waspaused ) {
                if ( this._onResume ) {
                    this._onResume(this);
                }
            } else {
                if ( this._onStart ) {
                    this._onStart(this);
                }
            }

            return this;
        }

        /**
         * Is the audio playing ?
         * @method cc.plugin.audio.AudioEffect#isPlaying
         * @returns {boolean}
         */
        isPlaying() : boolean {
            return this._status===cc.plugin.audio.AudioEffectStatus.PLAY;
        }

        /**
         * Convolve the audio.
         * @method cc.plugin.audio.AudioEffect#convolve
         * @param _buffer {string|object} if string, it will look up an AudioObject in the AssetManager as convolution
         *    parameter. If not, a convolution audio buffer is expected.
         */
        convolve( _buffer:string|AudioBuffer ) {

            var buffer:AudioBuffer = null;

            if ( typeof _buffer!=="undefined") {
                if ( typeof _buffer==='string' ) {
                    buffer= cc.plugin.asset.AssetManager.getAudioBuffer( _buffer );
                }
            }

            if ( null===buffer ) {
                this._convolver.buffer= null;
                this._convolverEnabled= false;
            } else {
                this._convolverEnabled= true;
                this._convolver.buffer =  buffer;
            }

            if ( this.isPlaying() ) {
                this.__pausePlay();
            }
        }

        /**
         * Get current audio time. If playing or paused, will give the actual audio time and zero otherwise.
         * @method cc.plugin.audio.AudioEffect#getCurrentTime
         */
        getCurrentTime() {
            return this._status===AudioEffectStatus.PLAY || this._status===AudioEffectStatus.PAUSE ?
                ((audioContext.currentTime - this._startPlaybackTime + this._spriteStartTime)%this._duration) - this._delayTime + this._pauseTime:
                0;
        }

        /**
         * Set current audio time. The time will be modulo the duration.
         * @method cc.plugin.audio.AudioEffect#setCurrentTime
         * @param time {number} expected audio seek position.
         */
        setCurrentTime( time:number ) {

            var wasPlaying:boolean= this._status===AudioEffectStatus.PLAY;
            this.stop();
            this._pauseTime= time%this._duration + this._spriteStartTime;
            // hack to restart from pause position.
            this._status= AudioEffectStatus.PAUSE;
            if ( wasPlaying) {
                this.play();
            }
        }

        /**
         * If the audio is playing or paused get remaining play time, zero otherwise.
         * @method cc.plugin.audio.AudioEffect#getRemainingTime
         */
        getRemainingTime() {
            // sometimes, an few milliseconds negative time could happen when you mess around a lot with pause/resume
            return this._status===AudioEffectStatus.PLAY || this._status===AudioEffectStatus.PAUSE ?
                Math.max(0,this._duration - this.getCurrentTime() ) :
                0;
        }

        /**
         * Internal method that cancels the end play timer.
         * @method cc.plugin.audio.AudioEffect#__cancelEndTimer
         */
        __cancelEndTimer() {
            if ( this._endTimerId ) {
                clearTimeout( this._endTimerId );
                this._endTimerId= null;
            }
        }

        /**
         * Internal method that starts the end play timer.
         * @method cc.plugin.audio.AudioEffect#__startEndTimer
         */
        __startEndTimer() {

            if ( this._endTimerId ) {
                return;
            }

            var timeleft= this.getRemainingTime() / this._playbackRate;
            var me= this;

            this._endTimerId= setTimeout( function() {
                me._endTimerId= null;
                me._pauseTime= 0;
                me._status= AudioEffectStatus.END;
                if ( me._loop ) {
                    if (me._onRepeat) {
                        me._onRepeat(me);
                    }
                    me.play(0);
                } else {
                    if (me._onEnd) {
                        me._onEnd(me);
                    }
                }
            }, timeleft * 1000 );

        }

        /**
         * Internal method that performs the common stop audio part.
         * @method cc.plugin.audio.AudioEffect#__pause_stop_common
         */
        __pause_stop_common() {

            if (typeof this._source.stop === 'undefined') {
                (<any>this._source).noteOff(0);
            } else {
                this._source.stop(0);
            }
            this.__cancelEndTimer();
        }

        /**
         * Stop the audio
         * @method cc.plugin.audio.AudioEffect#stop
         */
        stop() : AudioEffect {

            if ( this._source ) {
                this.__pause_stop_common();
            }

            this._pauseTime= 0;
            this._status= AudioEffectStatus.STOP;

            if ( this._onStop ) {
                this._onStop(this);
            }

            return this;
        }

        /**
         * Pause the audio
         * @method cc.plugin.audio.AudioEffect#pause
         */
        pause() :AudioEffect {
            if ( this._status!==AudioEffectStatus.PLAY ) {
                return;
            }

            var pt=this.getCurrentTime();

            this.__pause_stop_common();

            var ct= audioContext.currentTime;
            this._pauseTime= pt;
//console.log("pause at "+this._pauseTime);
            this._startPlaybackTime= ct;
            this._status= AudioEffectStatus.PAUSE;

            if ( this._onPause ) {
                this._onPause(this);
            }

            return this;
        }

        /**
         * Resume the audio
         * @method cc.plugin.audio.AudioEffect#resume
         */
        resume():AudioEffect {

            if ( this._status!==AudioEffectStatus.PAUSE ) {
                return;
            }
            return this.play();
        }

        /**
         * Set audio on end callback
         * @method cc.plugin.audio.AudioEffect#onEnd
         * @param c {cc.plugin.audio.AudioCallback}
         */
        onEnd( c:AudioCallback ) : AudioEffect {
            this._onEnd= c;
            return this;
        }

        /**
         * Set audio on repeat callback.
         * Effects repeat when looping.
         * @method cc.plugin.audio.AudioEffect#onRepeat
         * @param c {cc.plugin.audio.AudioCallback}
         */
        onRepeat( c:AudioCallback ) : AudioEffect {
            this._onRepeat= c;
            return this;
        }

        /**
         * Set audio on pause callback
         * @method cc.plugin.audio.AudioEffect#onPause
         * @param c {cc.plugin.audio.AudioCallback}
         */
        onPause( c:AudioCallback ) : AudioEffect {
            this._onPause= c;
            return this;
        }

        /**
         * Set audio on resume callback
         * @method cc.plugin.audio.AudioEffect#onResume
         * @param c {cc.plugin.audio.AudioCallback}
         */
        onResume( c:AudioCallback ) : AudioEffect {
            this._onResume= c;
            return this;
        }

        /**
         * Set audio on stop callback
         * @method cc.plugin.audio.AudioEffect#onStop
         * @param c {cc.plugin.audio.AudioCallback}
         */
        onStop( c:AudioCallback ) : AudioEffect {
            this._onStop= c;
            return this;
        }

        /**
         * Set audio on start callback
         * @method cc.plugin.audio.AudioEffect#onStart
         * @param c {cc.plugin.audio.AudioCallback}
         */
        onStart( c:AudioCallback ) : AudioEffect {
            this._onStart= c;
            return this;
        }

        /**
         * Mute the audio.
         * @method cc.plugin.audio.AudioEffect#mute
         */
        mute():AudioEffect {
            if ( this._isWebAudio ) {
                this._gain.gain.value= 0;
            }
            this._muted= true;
            return this;
        }

        /**
         * Unmute the audio.
         * @method cc.plugin.audio.AudioEffect#unmute
         */
        unmute():AudioEffect {

            if ( this._isWebAudio ) {
                this._gain.gain.value= this._volume;
            }
            this._muted= false;
            return this;
        }
    }

    export class SimpleAudioEffect {

        _audio: HTMLAudioElement= null;
        _loaded:boolean= false;
        _status:AudioEffectStatus= AudioEffectStatus.NONE;
        _url:string= null;
        _pauseTime:number=0;
        _volume:number=1;
        _masterVolume:number=1;
        _loop:boolean;

        constructor() {

            this._audio= document.createElement('audio');
            this._audio.preload= "auto";
            this._audio.autoplay= false;

        }

        setUrl( url:string, autoplay?:boolean ) {

            if ( url===this._url ) {
                return;
            }

            var me= this;
            this._url= url;
            this._loaded= false;
            this._audio.addEventListener( "canplaythrough", function(e) {

                e.srcElement.removeEventListener("canplaythrough",this);
                me._loaded= true;
                me._status= AudioEffectStatus.LOADED;
                if ( autoplay ) {
                    me.play();
                }

            }, false );

            this._audio.src= url;
        }

        setMasterVolume( v:number ) {
            this._masterVolume= v;
        }

        setVolume( v:number ) {
            this._volume= v;
            this._audio.volume= v*this._masterVolume;
        }

        loop( v:boolean ) {
            this._loop= true;
            this.play();
        }

        play() {
            if ( this._status!==AudioEffectStatus.NONE ) {
                this._status=AudioEffectStatus.PLAY;
                this._audio.currentTime=0;
                this._audio.loop= this._loop;
                this._audio.play();
            }
        }

        pause() {

            if ( this._status!==AudioEffectStatus.NONE ) {
                this._status=AudioEffectStatus.PAUSE;
                this._pauseTime= this._audio.currentTime;
                this._audio.pause();
            }
        }

        resume() {

            if ( this._status!==AudioEffectStatus.NONE ) {
                this._status=AudioEffectStatus.PLAY;
                this._audio.currentTime= this._pauseTime;
                this._audio.play();
                this._pauseTime=0;
            }
        }

        stop() {
            this._status=AudioEffectStatus.STOP;
            this._pauseTime=0;
            this._audio.pause();
        }
    }

    export interface AudioManagerInitializer {

        numChannels? : number;

    }

    /**
     * @class cc.plugin.audio.AudioManager
     * @classdesc
     *
     * This object represents a sound manager.
     * The sound manager does several things:
     *
     * <li>keep an internal AudioEffect object pool. These elements are AudioBuffer decoded objects or Audio tags,
     *     depending on the AudioManager implementation.
     * <li>Has 3 gain nodes: music, effects, and a general one connected to the two previous ones.
     * <li>Plays background music using an Audio tag. You definitely don't want to have a 10 minutes song decoded
     *     into memory.
     *
     * There's only one music node and up to MAX_AUDIO_EFFECTS (16) for a total of 17 concurrent sounds.
     * The AudioManager objects manages lifecycle of the sounds. That means that an effect can be requested for play,
     * but not stop pause or resume. For such fine control, call <code>createAudio</code> method to get an
     * <code>AudioEffect</code> object which has much more advanced capabilities.
     */
    export class AudioManager {

        _context : AudioContext= null;

        _effects:AudioEffect[];

        /**
         * Master volume.
         * @type {number}
         * @private
         */
        _volume: number = 1;
        _masterGain:GainNode= null;

        _soundPool : AudioEffect[] = [];
        _playingPool : AudioEffect[] = [];

        _music : SimpleAudioEffect = null;

        constructor( ami?:AudioManagerInitializer ) {

            if ( audioContext ) {
                this._masterGain= audioContext.createGain();
                this._masterGain.connect( audioContext.destination );
            }

            this._music= new SimpleAudioEffect();

            ami= ami || {};
            ami.numChannels= ami.numChannels || 16;

            for( var i=0; i<ami.numChannels; i++ ) {
                var ae:AudioEffect= new AudioEffect( this._masterGain );
                this._soundPool.push( ae );

                ae.onEnd( (ae:AudioEffect)=> {
                    this.__recycle( ae );
                });

                ae.onStop( (ae:AudioEffect)=> {
                    this.__recycle( ae );
                });
            }
        }

        __recycle( ae:AudioEffect ) {
            var index= this._playingPool.indexOf(ae);
            if ( -1!==index ) {
                this._playingPool.splice(index,1);
                this._soundPool.push(ae);
            } else {
                console.log("recycle sound for not found element.");
            }
        }

        createAudio( id:string ) : AudioEffect {
            return new AudioEffect( this._masterGain,  cc.plugin.asset.AssetManager.getAudioBuffer(id) );
        }

        setVolume( v:number ) {
            this._volume= v;
            this._masterGain.gain.value= v;
            this._music.setMasterVolume(v);
        }

        setMusicVolume( v:number ) {
            this._music.setVolume( v );
        }

        /**
         * Play a loaded AudioBuffer.
         * This method plays a fully system-controlled sound. There's no user-side control.
         * To have a client side controlled audio effect object, call <code>createAudio</code>.
         * @param id {string|AudioBuffer} a string id in the asset manager.
         * @param volume {number=} the volume for this effect. if not set, full volume will be used.
         */
        playEffect( id:string|AudioBuffer, volume?:number ) {
            if ( this._soundPool.length===0 ) {
                cc.Debug.warn( cc.locale.ERR_SOUND_POOL_EMPTY );
            }

            var ab:AudioBuffer= null;
            if ( typeof id==='string' ) {
                ab= cc.plugin.asset.AssetManager.getAudioBuffer(id);
            } else {
                ab= <AudioBuffer>id;
            }

            if (null!==ab) {
                var ae:AudioEffect = this._soundPool.pop();
                ae.setVolume( volume || 1 );
                ae.setBuffer( ab );
                ae.play();

                this._playingPool.push( ae );
            }
        }

        pauseEffects() {
            for( var i=0; i<this._playingPool.length; i++ ) {
                this._playingPool[i].pause();
            }
        }

        resumeEffects() {
            for( var i=0; i<this._playingPool.length; i++ ) {
                this._playingPool[i].resume();
            }
        }

        stopEffects() {
            for( var i=0; i<this._playingPool.length; i++ ) {
                this._playingPool[i].stop();
            }
        }

        setMusic( url:string, autoplay?:boolean ) {
            this._music.loop(true);
            this._music.setUrl(url, autoplay);
        }

        playMusic() {
            this._music.loop(true);
            this._music.play();
        }

        pauseMusic() {
            this._music.pause();
        }

        resumeMusic() {
            this._music.resume()
        }

        stopMusic() {
            this._music.stop();
        }

      //
      //  enableiOSAudio() {
      //    var me = this;
      //
      //    if (audioContext && (me._iOSEnabled || !/iPhone|iPad|iPod/i.test(navigator.userAgent))) {
      //      return;
      //    }
      //
      //    me._iOSEnabled = false;
      //
      //    // call this method on touch start to create and play a buffer,
      //    // then check if the audio actually played to determine if
      //    // audio has now been unlocked on iOS
      //    var unlock = function() {
      //      // create an empty buffer
      //      var buffer = ctx.createBuffer(1, 1, 22050);
      //      var source = ctx.createBufferSource();
      //      source.buffer = buffer;
      //      source.connect(ctx.destination);
      //
      //      // play the empty buffer
      //      if (typeof source.start === 'undefined') {
      //        source.noteOn(0);
      //      } else {
      //        source.start(0);
      //      }
      //
      //      // setup a timeout to check that we are unlocked on the next event loop
      //      setTimeout(function() {
      //        if ((source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE)) {
      //          // update the unlocked state and prevent this check from happening again
      //          me._iOSEnabled = true;
      //          me.iOSAutoEnable = false;
      //
      //          // remove the touch start listener
      //          window.removeEventListener('touchstart', unlock, false);
      //        }
      //      }, 0);
      //    };
      //
      //    // setup a touch start listener to attempt an unlock in
      //    window.addEventListener('touchstart', unlock, false);
      //
      //    return me;
      //  }
      //}

        static canPlay(codec:string):boolean {
            return codecs[codec];
        }

        static getContext():AudioContext {
            return audioContext;
        }

        static isWebAudioEnabled():boolean {
            return audioContext!==null;
        }
    }

}
/**
 * License: see license.txt file.
 */

/// <reference path="../../math/Rectangle.ts"/>
/// <reference path="../../math/Dimension.ts"/>

module cc.plugin.layout {

    export type UnitValue= number|string;

    /**
     * @interface cc.plugin.layout.BaseLayoutInitializer
     * @classdesc
     *
     * Initializer object for a common layout.
     *
     */
    export interface BaseLayoutInitializer {

        /**
         * type of the layout, currently: 'element', 'border', 'grid'
         * @member cc.plugin.layout.BaseLayoutInitializer#type
         * @type {string}
         */
        type :              string;

        /**
         * Layout element name
         * @member cc.plugin.layout.BaseLayoutInitializer#name
         * @type {string=}
         */
        name? :             string;

        /**
         * Preferred width. Has Unit notation, so values like '10px' or '20%' are valid.
         * @member cc.plugin.layout.BaseLayoutInitializer#preferredWidth
         * @type {string=}
         */
        preferredWidth? :   string;

        /**
         * Preferred height. Has Unit notation, so values like '10px' or '20%' are valid.
         * @member cc.plugin.layout.BaseLayoutInitializer#preferredHeight
         * @type {string=}
         */
        preferredHeight? :  string;

        /**
         * Element insets.
         * An array of four strings representing insets for: left, top, right, bottom respectively.
         * Unit notation.
         * @member cc.plugin.layout.BaseLayoutInitializer#insets
         * @type {Array<string>=}
         */
        insets? :           string[];

        /**
         * Element gap.
         * An array of two strings representing element separation for horizontal and vertical respectively.
         * Unit notation.
         * @member cc.plugin.layout.BaseLayoutInitializer#gap
         * @type {Array<string>=}
         */
        gap? :              string[];

        /**
         * Array of other layout initializer objects.
         * @member cc.plugin.layout.BaseLayoutInitializer#elements
         * @type {Array<cc.plugin.layout.BaseLayoutInitializer>} any layout initializer.
         */
        elements? :         BaseLayoutInitializer[];
    }

    /**
     * @interface GridLayoutInitializer
     * @extends BaseLayoutInitializer
     * @classdesc
     *
     * Initializer object for a grid layout
     *
     */
    export interface GridLayoutInitializer extends BaseLayoutInitializer {

        /**
         * Set the grid to grow in columns every number of rows.
         * @member cc.plugin.layout.GridLayoutInitializer#rows
         * @type {number=}
         */
        rows? :     number;

        /**
         * Set the grid to grow in rows every number of columns.
         * @member cc.plugin.layout.GridLayoutInitializer#columns
         * @type {number=}
         */
        columns? :  number;
    }

    /**
     * @interface BorderLayoutInitializer
     * @extends BaseLayoutInitializer
     * @classdesc
     *
     * Initializer for a border layout
     */
    export interface BorderLayoutInitializer extends BaseLayoutInitializer {

        /**
         * Left element initializer.
         * @member cc.plugin.layout.BorderLayoutInitializer#left
         * @type {cc.plugin.layout.BaseLayoutInitializer=}
         */
        left? :     BaseLayoutInitializer;

        /**
         * Right element initializer.
         * @member cc.plugin.layout.BorderLayoutInitializer#right
         * @type {cc.plugin.layout.BaseLayoutInitializer=}
         */
        right? :    BaseLayoutInitializer;

        /**
         * Top element initializer.
         * @member cc.plugin.layout.BorderLayoutInitializer#top
         * @type {cc.plugin.layout.BaseLayoutInitializer=}
         */
        top? :      BaseLayoutInitializer;

        /**
         * Bottom element initializer.
         * @member cc.plugin.layout.BorderLayoutInitializer#bottom
         * @type {cc.plugin.layout.BaseLayoutInitializer=}
         */
        bottom? :   BaseLayoutInitializer;

        /**
         * Center element initializer.
         * @member cc.plugin.layout.BorderLayoutInitializer#center
         * @type {cc.plugin.layout.BaseLayoutInitializer=}
         */
        center? :   BaseLayoutInitializer;
    }

    /**
     * @class cc.plugin.layout.Unit
     * @classdesc
     *
     * This class encapsulates a value in a given unit.
     * Currently, it could be a number, or a percentage value.
     * If the value is a percentage, a call to <code>getValue</code> needs a reference value.
     */
    export class Unit {

        /**
         * Unit value.
         * @member cc.plugin.layout.Unit#_orgValue
         * @type {number}
         * @private
         */
        _orgValue:number= 0;

        /**
         * Unit type. Either px, %, or nothing.
         * @member cc.plugin.layout.Unit#_orgType
         * @type {string}
         * @private
         */
        _orgType:string= "";

        /**
         * Create a new Unit object instance.
         * @method cc.plugin.layout.Unit#constructor
         * @param original {string=} Unit value. if not set, the unit it set to 0.
         */
        constructor( original?:string ) {

            if ( typeof original!=='undefined' ) {
                this.setValue(original);
            }
        }

        /**
         * Set the unit value. For example '2%', '100px', '100'
         * @method cc.plugin.layout.Unit#setValue
         * @param original {string}
         */
        setValue( original:UnitValue ) {
            var exp:RegExp= new RegExp("\\d+\\.?\\d*(.*)","gi");
            var m= exp.exec(""+original);
            if ( m ) {
                this._orgType=m[1];
                this._orgValue=parseInt(m[0]);
            }
        }

        /**
         * Get the unit value.
         * If the unit type is percentage, and no reference value is supplied, zero will be returned as value.
         * @method cc.plugin.layout.Unit#getValue
         * @param ref {number=} percentage reference value.
         * @returns {number}
         */
        getValue( ref?:number ) {

            switch( this._orgType ) {
                case "":
                    return this._orgValue;
                case "px":
                    return this._orgValue;
                case "%":
                    return typeof ref!=="undefined" ? this._orgValue/100*ref : 0;
            }
        }
    }

    /**
     * @class cc.plugin.layout.Insets
     * @classdesc
     *
     * This class describes a layout element internal padding.
     * It is descibed as independent inset values for top, bottom, left and right.
     * These values are Unit objects, so can be described as percentage values. The relative values are relative to
     * the Layout element assigned dimension, so its calculation is deferred to the proper layout stage.
     */
    export class Insets {

        /**
         * Layout element left inset Unit.
         * @member cc.plugin.layout.Insets#left
         * @type {cc.plugin.layout.Unit}
         */
        left: Unit= new Unit();

        /**
         * Layout element top inset Unit.
         * @member cc.plugin.layout.Insets#top
         * @type {cc.plugin.layout.Unit}
         */
        top: Unit= new Unit();

        /**
         * Layout element right inset Unit.
         * @member cc.plugin.layout.Insets#right
         * @type {cc.plugin.layout.Unit}
         */
        right: Unit= new Unit();

        /**
         * Layout element bottom inset Unit.
         * @member cc.plugin.layout.Insets#bottom
         * @type {cc.plugin.layout.Unit}
         */
        bottom: Unit= new Unit();
    }

    /**
     * @class cc.plugin.layout.Gap
     * @classdesc
     *
     * This object describes the separation values between two adjacent layout elements.
     * For example, for a grid, describes the Units to separate the grid elements.
     */
    export class Gap {

        /**
         * Horizontal gap Unit.
         * @member cc.plugin.layout.Gap#horizontal
         * @type {cc.plugin.layout.Unit}
         */
        horizontal: Unit= new Unit();

        /**
         * Vertical gap Unit.
         * @member cc.plugin.layout.Gap#vertical
         * @type {cc.plugin.layout.Unit}
         */
        vertical: Unit= new Unit();
    }

    /**
     * @class cc.plugin.layout.Layout
     * @classdesc
     *
     * This object is the base for all other layout objects.
     * The layout will assign bounds (position and size) for all the layout elements it contains.
     * Layouts will apply different space partitioning rules to conform elements to available space.
     * Layout elements can be nested. for example, a grid cell can contain another grid of elements.
     * <p>
     * Each layout element will have its bounds modified by an <code>Insets</code> object which will reduce the
     * available element bounds.
     * Some layout types, like <code>GridLayout</code> or <code>BorderLayout</code> will be able to apply a gap
     * to separate the contained elements.
     * <p>
     * A layout element can define a preferred size (either in units or percentage) to layout with. This value is
     * needed for layout types that don't impose a size constraint. For example, a GridLayout will set each element's
     * bounds with a fixed rule, that is, dividing the space evenly. But others, like a BorderLayout won't, so you
     * must hint how much space each element is expected to take.
     * <p>
     *     Layouts are defined declaratively and a Node or any other object, does not need to know anything about
     *     the layout itself.
     * <p>
     * The BaseLayout object assumes no children when laying out. Other extending objects will modify this behavior.
     */
    export class BaseLayout {

        /**
         * Resulting bounds after applying the layout rules.
         * @member cc.plugin.layout.BaseLayout#_bounds
         * @type {cc.math.Rectangle}
         * @private
         */
        _bounds:cc.math.Rectangle= null;

        /**
         * The layout insets. Insets will reduce the bounds area by setting a padding for the element.
         * @member cc.plugin.layout.BaseLayout#_insets
         * @type {cc.plugin.layout.Insets}
         * @private
         */
        _insets : Insets = null;

        /**
         * Separation between each layout elements. Not all layout will use this value.
         * @member cc.plugin.layout.BaseLayout#_gap
         * @type {cc.plugin.layout.Gap}
         * @private
         */
        _gap : Gap = null;

        /**
         * Array of elements to lay out. Since layouts are nestable, children are layout instances as well.
         * @member cc.plugin.layout.BaseLayout#_children
         * @type {Array<cc.plugin.layout.BaseLayout>}
         * @private
         */
        _children : BaseLayout[]= [];

        /**
         * Layout preferred width Unit hint.
         * @member cc.plugin.layout.BaseLayout#_preferredWidth
         * @type {cc.plugin.layout.Unit}
         * @private
         */
        _preferredWidth : Unit= null;

        /**
         * Layout preferred height Unit hint.
         * @member cc.plugin.layout.BaseLayout#_preferredHeight
         * @type {cc.plugin.layout.Unit}
         * @private
         */
        _preferredHeight: Unit= null;

        /**
         * Optional layout identifier.
         * This is useful so that a node tag or name can be matched against this layout element.
         * @member cc.plugin.layout.BaseLayout#_name
         * @type {string}
         * @private
         */
        _name: string= '';

        _parent: BaseLayout = null;

        /**
         * Create a new BaseLayout object instance.
         * Do not create directly, only by subclasses.
         * @method cc.plugin.layout.BaseLayout#constructor
         */
        constructor() {
            this._bounds= new cc.math.Rectangle();
            this._insets= new Insets();
            this._gap= new Gap();
            this._preferredWidth= new Unit();
            this._preferredHeight= new Unit();
        }

        /**
         * Parse a layout initializer object to get a layout element object.
         * @param layout {string|cc.plugin.layout.BaseLayoutInitializer} a layout initializer object, or a string.
         *   If a string is set, a BaseLayout object will be used.
         */
        static parse( layout:string|BaseLayoutInitializer ) : BaseLayout {

            if (typeof layout==="string") {
                return new BaseLayout().parse({
                    type: 'element',
                    name: <string>layout
                });
            } else if (layout.type === "element") {
                return new BaseLayout().parse(layout);
            } else if (layout.type === "border") {
                return new BorderLayout().parse(layout);
            } else if (layout.type === "layer") {
                return new LayerLayout().parse(layout);
            } else if (layout.type === "grid") {
                return new GridLayout().parse(layout);
            } else {
                console.log("unknown layout type: "+layout.type);
            }
        }

        /**
         * Helper method to visually see the layout result.
         * @method cc.plugin.layout.BaseLayout#paint
         * @param ctx {CanvasRenderingContext2D}
         */
        paint( ctx:CanvasRenderingContext2D ) {
            //ctx.setTransform(1,0,0,1,0,0);
            ctx.strokeRect( this._bounds.x, this._bounds.y, this._bounds.w, this._bounds.h );
            for( var i=0; i<this._children.length; i++ ) {
                this._children[i].paint(ctx);
            }
        }

        /**
         * Set the layout bounds.
         * @method cc.plugin.layout.BaseLayout#setBounds
         * @param x {number}
         * @param y {number}
         * @param w {number}
         * @param h {number}
         */
        setBounds( x:number, y:number, w:number, h:number ) {
            this._bounds.set(x,y,w,h);
        }

        /**
         * Set the layout size.
         * @method cc.plugin.layout.BaseLayout#setSize
         * @param w {number}
         * @param h {number}
         */
        setSize( w:number, h:number ) {
            this._bounds.w= w;
            this._bounds.h=h;
        }

        /**
         * Set the layout preferred size Unit hints.
         * @param w {number|string}
         * @param h {number|string}
         */
        setPreferredSize( w:UnitValue, h:UnitValue ) {
            this._preferredWidth.setValue( w );
            this._preferredHeight.setValue( h );
        }

        /**
         * Get the element preferredSize.
         * The size units are evaluated, so if they are percentage, the value is recalculated now again.
         * @method cc.plugin.layout.BaseLayout#getPreferredSize
         * @returns {cc.math.Dimension}
         */
        getPreferredSize() : cc.math.Dimension {
            return new cc.math.Dimension(
                    this._preferredWidth.getValue( this._parent ? this._parent._bounds.w : this._bounds.w ),
                    this._preferredHeight.getValue( this._parent ? this._parent._bounds.h : this._bounds.h ) );
        }

        /**
         * Recursively evaluate the layout elements and get the resulting preferred size.
         * This does not take into account the size constraints, will get the desired size.
         * In this object, the implementation returns the result of the preferredSize Unit hints + Insets.
         * @method cc.plugin.layout.BaseLayout#getPreferredLayoutSize
         * @returns {cc.math.Dimension}
         */
        getPreferredLayoutSize() : cc.math.Dimension {
            var ps= this.getPreferredSize();
            this.adjustWithInsets(ps);

            return ps;
        }

        /**
         * Evaluate the layout with the current size constraints. The root layout element bounds will be used
         * as size constraint.
         * @method cc.plugin.layout.BaseLayout#doLayout
         */
        doLayout() {

            var d= new cc.math.Dimension();
            this.adjustWithInsets(d);
            this._bounds.w-= d.width;
            this._bounds.h-= d.height;
            this._bounds.x+= d.width/2;
            this._bounds.y+= d.height/2;
        }

        /**
         * Set size constraints and evaluate the layout.
         * The result will be all layout elements have assigned a bounds.
         * @method cc.plugin.layout.BaseLayout#layout
         * @param x {number}
         * @param y {number}
         * @param w {number}
         * @param h {number}
         */
        layout( x:number, y:number, w:number, h:number ) {
            this.setBounds(x,y,w,h);
            this.getPreferredLayoutSize();
            this.doLayout();
        }

        /**
         * Parse a layout definition object.
         * This will get all the common layout properties: insets, gap, preferred size and elements.
         * @method cc.plugin.layout.BaseLayout#parse
         * @param layoutInfo {cc.plugin.layout.BaseLayoutInitializer}
         * @returns {cc.plugin.layout.BaseLayout}
         */
        parse( layoutInfo:BaseLayoutInitializer ) : BaseLayout {

            if ( typeof layoutInfo.insets!=='undefined' ) {

                var arr:UnitValue[]= <UnitValue[]>layoutInfo.insets;
                if ( arr.length!==4 ) {
                    console.log("wrong defined insets: "+arr);
                }

                this._insets.left.setValue(layoutInfo.insets[0]);
                this._insets.right.setValue(layoutInfo.insets[2]);
                this._insets.top.setValue(layoutInfo.insets[1]);
                this._insets.bottom.setValue(layoutInfo.insets[3]);
            }

            if ( typeof layoutInfo.gap!=='undefined' ) {

                var arr:UnitValue[]= <UnitValue[]>layoutInfo.gap;
                if ( arr.length!==2 ) {
                    console.log("wrong defined gap: "+arr);
                }

                this._gap.horizontal.setValue(layoutInfo.gap[0]);
                this._gap.vertical.setValue(layoutInfo.gap[1]);
            }

            if ( typeof layoutInfo.preferredWidth!=='undefined' ) {
                this._preferredWidth.setValue(layoutInfo.preferredWidth);
            }
            if ( typeof layoutInfo.preferredHeight!=='undefined' ) {
                this._preferredHeight.setValue(layoutInfo.preferredHeight);
            }

            if ( typeof layoutInfo.name!=='undefined' ) {
                this._name= layoutInfo.name;
            }

            if ( typeof layoutInfo.elements!=='undefined' ) {
                if ( Object.prototype.toString.call( layoutInfo.elements ) === '[object Array]' ) {
                    this.parseElements(layoutInfo.elements);
                } else {
                    console.log("Layout elememts block is not array.");
                }
            }
            return this;
        }

        /**
         * Parse the elements block from the layout initializer object.
         * @method cc.plugin.layout.BaseLayout#parseElements
         * @param children {Array<object>}
         */
        parseElements( children:Array<any> ) {

            var me= this;

            function addElement( s:string|BaseLayoutInitializer, parent:BaseLayout ) {

                var elem:BaseLayout = cc.plugin.layout.BaseLayout.parse(s);
                if (elem) {
                    elem._parent= parent;
                    me._children.push(elem);
                } else {

                }

            }

            for( var i=0; i<children.length; i++ ) {

                if ( typeof children[i]==='string' ) {

                    var elem:string= <string>children[i];

                    // is elem of the form text[...] ?
                    if ( elem.indexOf('[')!==-1 && elem.indexOf(']')!==-1 ) {
                        var exp= new RegExp("(.*)\\[(.*)\\]","gi");
                        var m= exp.exec( elem );
                        var prefix:string= m[1];
                        var pattern:string[]= m[2].split('-');

                        if ( pattern.length===2 ) {

                            var from:number= parseInt( pattern[0] );
                            var to:number= parseInt( pattern[1] );

                            while( from <= to ) {
                                addElement( prefix+from, this );
                                from++;
                            }

                        } else {
                            /// wrong pattern ?!?!?!?!?
                            console.log("wrong pattern for element by name: "+elem );
                            addElement( elem, this );
                        }
                    } else {
                        // not name pattern.
                        addElement( elem, this );
                    }

                } else {

                    addElement( children[i], this );
                }
            }
        }

        /**
         * Add an element layout to this layout object.
         * @param e {cc.plugin.layout.BaseLayout}
         * @param constraint {string=} a constraint to add an element. For example, BorderLayout requires a position hint
         *      to add an element.
         */
        addElement( e:BaseLayout, constraint?:string ) {
            this._children.push(e);
        }

        /**
         * Helper method to add the Inset object value to a Dimension.
         * @method cc.plugin.layout.BaseLayout#adjustWithInsets
         * @param d
         */
        adjustWithInsets( d:cc.math.Dimension ) {
            d.width+= this._insets.left.getValue( this._bounds.w ) + this._insets.right.getValue( this._bounds.w );
            d.height+= this._insets.top.getValue( this._bounds.h ) + this._insets.bottom.getValue( this._bounds.h );
        }

        /**
         * Recursively traverse the layout elements and, if a layout element has name, find a node with that name
         * and then set the found node's position to the layout calculated position. If resize is set to true,
         * the found node's content size will be set to the layout calculated size.
         * The node is searched in the _node parameter or any of its children.
         * @param _node {cc.node.Node} the node to traverse to find a node with a layout name
         * @param resize {boolean} change de node size to that of the calculated layout ?
         */
        applyToNode( _node:cc.node.Node, resize:boolean ) {

            if (!_node ) {
                return;
            }

            if ( this._name!=="" ) {
                _node.enumerateChildren(this._name, ( node:cc.node.Node ) => {
                    node.setPosition( this._bounds.x, this._bounds.y );
                    if ( resize ) {
                        node.setContentSize( this._bounds.w, this._bounds.h );
                    }
                });
            }

            for( var i=0; i<this._children.length; i++ ) {
                this._children[i].applyToNode( _node, resize );
            }
        }
    }

    /**
     * @class cc.plugin.layout.BorderLayout
     * @extends cc.plugin.layout.BaseLayout
     * @classdesc
     *
     * A BorderLayout object divides the available space in up to 5 different regions as follows:
     * <pre>
     *
     *     +----------------------------+
     *     |            TOP             |
     *     +------+-------------+-------+
     *     | LEFT |             | RIGHT |
     *     |      |             |       |
     *     |      |             |       |
     *     |      |   CENTER    |       |
     *     |      |             |       |
     *     |      |             |       |
     *     |      |             |       |
     *     +------+-------------+-------+
     *     |           BOTTOM           |
     *     +----------------------------+
     * </pre>
     *
     * <p>
     *     Since all bounds are dynamically calculated, elements added to a BorderLayout (at any nesting level) must
     *     have preferred size hints.
     * <p>
     *     The gap values will be empty filler values between every elements. Horizontal between left-center center-right
     *     and vertical betweeen top and bottom and all the others.
     * <p>
     *     All Elements are optional to define.
     * <p>
     *     The center element will get the remaining space after laying out all the other elements.
     *     The left, right and center elements will get the remaining height after evaluating top and then
     *     bottom elements.
     * <p>
     *     top, left, right, bottom and center can be, at the same time, other layouts.
     *
     */
    export class BorderLayout extends BaseLayout {

        /**
         * Left layout element.
         * @member cc.plugin.layout.BorderLayout#_left
         * @type {cc.plugin.layout.BaseLayout}
         * @private
         */
        _left:BaseLayout =    null;

        /**
         * Right layout element.
         * @member cc.plugin.layout.BorderLayout#_right
         * @type {cc.plugin.layout.BaseLayout}
         * @private
         */
        _right:BaseLayout =   null;

        /**
         * Top layout element.
         * @member cc.plugin.layout.BorderLayout#_top
         * @type {cc.plugin.layout.BaseLayout}
         * @private
         */
        _top:BaseLayout =     null;

        /**
         * Bottom layout element.
         * @member cc.plugin.layout.BorderLayout#_bottom
         * @type {cc.plugin.layout.BaseLayout}
         * @private
         */
        _bottom:BaseLayout =  null;

        /**
         * Center layout element.
         * @member cc.plugin.layout.BorderLayout#_center
         * @type {cc.plugin.layout.BaseLayout}
         * @private
         */
        _center:BaseLayout =  null;

        /**
         * Build a new BorderLayout object instance
         * @method cc.plugin.layout.BorderLayout#constructor
         */
        constructor() {
            super();
        }

        /**
         * Get the preferred layout size after recursively applying the layout. The size will be the preferred size,
         * not the actual size.
         * @method cc.plugin.layout.BorderLayout#getPreferredLayoutSize
         * @returns {cc.math.Dimension}
         */
        getPreferredLayoutSize() : cc.math.Dimension {

            var ret:cc.math.Dimension= new cc.math.Dimension();

            var d:cc.math.Dimension;

            if ( this._left ) {
                d= this._left.getPreferredLayoutSize();
                ret.width+= d.width + this._gap.horizontal.getValue( this._bounds.w );
                ret.height= Math.max( d.height, ret.height );
            }

            if ( this._right ) {
                d= this._right.getPreferredLayoutSize();
                ret.width+= d.width + this._gap.horizontal.getValue( this._bounds.w );
                ret.height= Math.max( d.height, ret.height );
            }

            if ( this._center ) {
                d= this._center.getPreferredLayoutSize();
                ret.width+= d.width;
                ret.height= Math.max( d.height, ret.height );
            }

            if ( this._top ) {
                d= this._top.getPreferredLayoutSize();
                ret.height+= d.height + this._gap.vertical.getValue( this._bounds.h );
                ret.width= Math.max( ret.width, d.width );
            }

            if ( this._bottom ) {
                d= this._bottom.getPreferredLayoutSize();
                ret.height+= d.height + this._gap.vertical.getValue( this._bounds.h );
                ret.width= Math.max( ret.width, d.width );
            }

            this.adjustWithInsets( d );

            var pd= this.getPreferredSize();
            d.width= Math.max( d.width, pd.width );
            d.height= Math.max( d.width, pd.height );

            return d;
        }

        /**
         * Set the left layout element.
         * @method cc.plugin.layout.BorderLayout#left
         * @param e {cc.plugin.layout.BaseLayout}
         * @returns {cc.plugin.layout.BorderLayout}
         */
        left( e:BaseLayout ) : BorderLayout {
            this._children.push(e);
            this._left= e;
            this._left._parent= this;
            return this;
        }

        /**
         * Set the right layout element.
         * @method cc.plugin.layout.BorderLayout#right
         * @param e {cc.plugin.layout.BaseLayout}
         * @returns {cc.plugin.layout.BorderLayout}
         */
        right( e:BaseLayout ) : BorderLayout {
            this._children.push(e);
            this._right= e;
            this._right._parent= this;
            return this;
        }

        /**
         * Set the top layout element.
         * @method cc.plugin.layout.BorderLayout#top
         * @param e {cc.plugin.layout.BaseLayout}
         * @returns {cc.plugin.layout.BorderLayout}
         */
        top( e:BaseLayout ) : BorderLayout {
            this._children.push(e);
            this._top= e;
            this._top._parent= this;
            return this;
        }

        /**
         * Set the bottom layout element.
         * @method cc.plugin.layout.BorderLayout#bottom
         * @param e {cc.plugin.layout.BaseLayout}
         * @returns {cc.plugin.layout.BorderLayout}
         */
        bottom( e:BaseLayout ) : BorderLayout {
            this._children.push(e);
            this._bottom= e;
            this._bottom._parent= this;
            return this;
        }

        /**
         * Set the center layout element.
         * @method cc.plugin.layout.BorderLayout#center
         * @param e {cc.plugin.layout.BaseLayout}
         * @returns {cc.plugin.layout.BorderLayout}
         */
        center( e:BaseLayout ) : BorderLayout {
            this._children.push(e);
            this._center= e;
            this._center._parent= this;
            return this;
        }

        /**
         * Parse the BorderLayout.
         * @method cc.plugin.layout.BorderLayout#parse
         * @param layoutInfo {cc.plugin.layout.BorderLayoutInitializer}
         * @returns {cc.plugin.layout.BorderLayout}
         */
        parse( layoutInfo:BorderLayoutInitializer ) : BorderLayout {

            super.parse(layoutInfo);

            if ( typeof layoutInfo.left!=="undefined" ) {
                this.left( cc.plugin.layout.BaseLayout.parse( layoutInfo.left ) );
            }
            if ( typeof layoutInfo.right!=="undefined" ) {
                this.right( cc.plugin.layout.BaseLayout.parse( layoutInfo.right ) );
            }
            if ( typeof layoutInfo.bottom!=="undefined" ) {
                this.bottom( cc.plugin.layout.BaseLayout.parse( layoutInfo.bottom ) );
            }
            if ( typeof layoutInfo.top!=="undefined" ) {
                this.top( cc.plugin.layout.BaseLayout.parse( layoutInfo.top ) );
            }
            if ( typeof layoutInfo.center!=="undefined" ) {
                this.center( cc.plugin.layout.BaseLayout.parse( layoutInfo.center ) );
            }

            return this;
        }

        /**
         * Add an element to the layout. Since this layout only allows for 5 specific elements, an adding constraint
         * must be used.
         * @method cc.plugin.layout.BorderLayout#addElement
         * @param e {cc.plugin.layout.BaseLayout}
         * @param constraint {string} must exist. a value from 'top','bottom','left','right' or 'center'.
         */
        addElement( e:BaseLayout, constraint?:string ) {
            if ( typeof this[constraint]!=='undefined' ) {
                this[constraint](e);
            } else {
                console.log("wrong border layout constraint.");
            }
        }

        /**
         * Do the actual lay out process. Elements will fit into the previously set element bounds.
         * @method cc.plugin.layout.BorderLayout#doLayout
         */
        doLayout() {

            var left= this._bounds.x + this._insets.left.getValue( this._bounds.w );
            var top= this._bounds.y + this._insets.top.getValue( this._bounds.h );
            var right= this._bounds.x1 - this._insets.right.getValue( this._bounds.w );
            var bottom= this._bounds.y1 - this._insets.bottom.getValue( this._bounds.h );

            var d:cc.math.Dimension;

            if ( this._top ) {
                this._top.setSize(right - left, this._top._bounds.h);
                d = this._top.getPreferredLayoutSize();
                this._top._bounds.set( left, top, right-left, d.height );
                this._top.doLayout();
                top+= d.height + this._gap.vertical.getValue( this._bounds.h );
            }
            if ( this._bottom ) {
                this._bottom.setSize(right - left, this._bottom._bounds.h);
                d = this._bottom.getPreferredLayoutSize();
                d.height= Math.min( d.height, bottom-top );
                this._bottom._bounds.set(left, bottom - d.height, right-left, d.height);
                this._bottom.doLayout( );
                bottom-= d.height + this._gap.vertical.getValue( this._bounds.h );
            }
            if ( this._right ) {
                this._right.setSize(this._right._bounds.w, bottom - top);
                d = this._right.getPreferredLayoutSize();
                this._right._bounds.set(right - d.width, top, d.width, bottom-top);
                this._right.doLayout( );
                right-= d.width + this._gap.horizontal.getValue( this._bounds.w );
            }
            if ( this._left ) {
                this._left.setSize(this._left._bounds.w, bottom - top);
                d = this._left.getPreferredLayoutSize();
                d.width= Math.min( d.width, right-left );
                this._left._bounds.set(left, top, d.width, bottom-top );
                this._left.doLayout();
                left+= d.width + this._gap.horizontal.getValue( this._bounds.w );
            }
            if ( this._center ) {
                this._center._bounds.set(left, top, right-left, bottom-top);
                this._center.doLayout( );
            }

        }
    }

    /**
     * @class cc.plugin.layout.GridLayout
     * @extends cc.plugin.layout.BaseLayout
     * @classdesc
     *
     * A grid layout lays elements out either in rows or columns. If rows are specified, the lay out will keep the fixed
     * number of rows and grow on the number of columns or vice versa, like as follows:
     *
     * <pre>
     *
     *     3 rows                        3 columns
     *
     *     +------------+-----...        +----------+----------+----------+
     *     |  row1      |                |   col1   |   col2   |   col3   |
     *     +------------+-----...        +----------+----------+----------+
     *     |  row2      |                |          |          |          |
     *     +------------+-----...        .          .          .          .
     *     |  row3      |                .          .          .          .
     *     +------------+-----...
     * </pre>
     *
     */
    export class GridLayout extends BaseLayout {

        /**
         * Lay out in rows or columns.
         * @member cc.plugin.layout.GridLayout#_layoutRows
         * @type {boolean}
         * @private
         */
        _layoutRows:boolean= false;

        /**
         * Elements to layout before adding a row or column.
         * @member cc.plugin.layout.GridLayout#_numElements
         * @type {number}
         * @private
         */
        _numElements:number= 0;

        /**
         * Calculated number of rows for the current added elements.
         * @member cc.plugin.layout.GridLayout#_rows
         * @type {number}
         * @private
         */
        _rows:number= 0;

        /**
         * Calculated number of columns for the current added elements.
         * @member cc.plugin.layout.GridLayout#_columns
         * @type {number}
         * @private
         */
        _columns:number= 0;

        /**
         * Create a new GridLayout object instance.
         * @method cc.plugin.layout.GridLayout#constructor
         */
        constructor() {
            super();
        }

        /**
         * Parse the grid info.
         * @method cc.plugin.layout.GridLayout#parse
         * @param layoutInfo {cc.plugin.layout.GridLayoutInitializer}
         * @returns {cc.plugin.layout.GridLayout}
         */
        parse( layoutInfo:GridLayoutInitializer ) : GridLayout {
            super.parse(layoutInfo);

            if ( typeof layoutInfo.rows!=='undefined' ) {
                this._layoutRows= true;
                this._numElements= <number>layoutInfo.rows;
            }

            if ( typeof layoutInfo.columns!=='undefined' ) {
                this._layoutRows= false;
                this._numElements= <number>layoutInfo.columns;
            }

            if ( !this._numElements ) {
console.log("bug bug grid info wrong defined.");
            }

            return this;
        }

        /**
         * Get the preferred layout elements size. The preferred size will be the adjusted to the biggest element's
         * preferred size, adding the gap for each of the layout elements.
         * Finally, the insets will be added to the size.
         * @method cc.plugin.layout.GridLayout#getPreferredLayoutSize
         * @returns {cc.math.Dimension}
         */
        getPreferredLayoutSize() : cc.math.Dimension {

            var rows=0;
            var columns=0;

            var ret= new cc.math.Dimension();

            if ( this._layoutRows ) {
                rows= this._numElements;
                columns= ((rows + this._children.length - 1)/rows)>>0;

            } else {
                columns= this._numElements;
                rows= ((columns + this._children.length - 1)/columns)>>0;
            }

            for( var i=0; i<this._children.length; i++ ) {

                var d= this._children[i].getPreferredLayoutSize();
                if ( d.width > ret.width ) {
                    ret.width= d.width;
                }
                if ( d.height > ret.height ) {
                    ret.height= d.height;
                }
            }



            this.adjustWithInsets(d);

            d.width+=  columns * ret.width  + (columns - 1) * this._gap.horizontal.getValue( this._bounds.w );
            d.height+= rows    * ret.height + (rows - 1)    * this._gap.vertical.getValue(   this._bounds.h );

            var pd= this.getPreferredSize();
            d.width= Math.max( d.width, pd.width );
            d.height= Math.max( d.height, pd.height );


            this._rows= rows;
            this._columns= columns;

            return d;
        }

        /**
         * Do the actual elements lay out. The size of each element will be constrained to the element's bound.
         * @method cc.plugin.layout.GridLayout#doLayout
         */
        doLayout() {


            if (!this._children.length) {
                return;
            }

            var rows, columns;

            if ( this._layoutRows ) {
                rows= this._numElements;
                columns= ((rows + this._children.length - 1)/rows)>>0;

            } else {
                columns= this._numElements;
                rows= ((columns + this._children.length - 1)/columns)>>0;
            }

            this._rows= rows;
            this._columns= columns;

            var nrows = this._rows;
            var ncols = this._columns;

            var totalGapsWidth = (ncols - 1) * this._gap.horizontal.getValue( this._bounds.w );
            var widthWOInsets = this._bounds.w - (this._insets.left.getValue( this._bounds.w ) + this._insets.right.getValue( this._bounds.w ) );
            var widthOnComponent = ((widthWOInsets - totalGapsWidth) / ncols);  // floor
            var extraWidthAvailable = ((widthWOInsets - (widthOnComponent * ncols + totalGapsWidth)) / 2); // floor

            var totalGapsHeight = (nrows - 1) * this._gap.vertical.getValue( this._bounds.h );
            var heightWOInsets = this._bounds.h - (this._insets.top.getValue( this._bounds.h ) + this._insets.bottom.getValue(this._bounds.h));
            var heightOnComponent = ((heightWOInsets - totalGapsHeight) / nrows); // floor
            var extraHeightAvailable = ((heightWOInsets - (heightOnComponent * nrows + totalGapsHeight)) / 2); // floor

            for (var c = 0, x = this._insets.left.getValue( this._bounds.w ) + extraWidthAvailable;
                 c < ncols;
                 c++, x += widthOnComponent + this._gap.horizontal.getValue( this._bounds.w ) ) {

                for (var r = 0, y = this._insets.top.getValue( this._bounds.h ) + extraHeightAvailable;
                     r < nrows;
                     r++, y += heightOnComponent + this._gap.vertical.getValue( this._bounds.h ) ) {

                    var i = r * ncols + c;
                    if (i < this._children.length) {
                        var child = this._children[i];
                        if (null !== child) {
                            child.setBounds(this._bounds.x + x, this._bounds.y + y, widthOnComponent, heightOnComponent);
                            child.doLayout( );
                        }
                    }
                }
            }

        }
    }

    /**
     * @class cc.plugin.layout.LayerLayout
     * @extends cc.plugin.layout.BaseLayout
     * @classdesc
     *
     * A LayerLayout stacks elements one on top of the other making their bounds the same.
     * The layout does not work on z-index, simply makes them to take over the same area.
     *
     */
    export class LayerLayout extends BaseLayout {

        /**
         * Build a new LayerLayout
         * @method cc.plugin.layout.LayerLayout#constructor
         */
        constructor() {
            super();
        }

        /**
         * @method cc.plugin.layout.LayerLayout#getPreferredLayoutSize
         * @returns {cc.math.Dimension}
         */
        getPreferredLayoutSize() : cc.math.Dimension {
            var d= new cc.math.Dimension();

            d.set( this._preferredWidth.getValue( this._bounds.w ), this._preferredHeight.getValue( this._bounds.h ) );
            this.adjustWithInsets( d );

            var pd= this.getPreferredSize();
            d.width= Math.max( d.width, pd.width );
            d.height= Math.max( d.width, pd.height );

            return d;
        }

        /**
         * @method cc.plugin.layout.LayerLayout#doLayout
         */
        doLayout() {

            var x= this._bounds.x + this._insets.left.getValue( this._bounds.w );
            var y= this._bounds.y + this._insets.top.getValue( this._bounds.h );
            var w= this._bounds.w - this._insets.left.getValue( this._bounds.w ) - this._insets.right.getValue( this._bounds.w );
            var h= this._bounds.h -this._insets.top.getValue( this._bounds.h ) - this._insets.bottom.getValue( this._bounds.h );

            for( var i=0; i<this._children.length; i++ ) {
                this._children[i].setBounds( x,y,w,h );
                this._children[i].doLayout( );
            }
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../node/Node.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="../locale/Locale.ts"/>
/// <reference path="../util/Debug.ts"/>
/// <reference path="./KeyboardInputManager.ts"/>
/// <reference path="./MouseInputManager.ts"/>

module cc.input {

    import Node= cc.node.Node;
    import KeyboardInputManager= cc.input.KeyboardInputManager;

    /**
     * @class cc.input.InputManagerEvent
     * @classdesc
     *
     * This is the base type for all CocosJS input events.
     */
    export class InputManagerEvent {

        /**
         * Target is the object for which the event happened.
         * For example, for MouseInputManagerEvents, _target is the node in which the event happened.
         * @member cc.input.InputManagerEvent#_target
         * @type {Object}
         * @private
         */
        _target : any = null;

        /**
         * Input event type.
         * Identifies the emitted event type for each addEventListener event call.
         * @member cc.input.InputManagerEvent#_type
         * @type {string}
         * @private
         */
        _type : string = null;

        /**
         * Build a new InputManagerEvent object.
         * Does nothing.
         * @method cc.input.InputManagerEvent#constructor
         */
        constructor() {
        }

        /**
         * Get this event's target. The target can be any type.
         * @method cc.input.InputManagerEvent#get:target
         * @returns {any}
         */
        get target() : any {
            return this._target;
        }

        /**
         * Get the event target.
         * @method cc.input.InputManagerEvent#getCurrentTarget
         * @returns {cc.node.Node}
         */
        getCurrentTarget() : cc.node.Node {
            return this._target;
        }

        /**
         * Get this event's type.
         * @method cc.input.InputManagerEvent#get:type
         * @returns {string}
         */
        get type() : string {
            return this._type;
        }

        /**
         * Must override and honor.
         * @method cc.input.InputManagerEvent#initializeEventForTarget
         * @param target {Object} a target object.
         * @param type {string} an event type.
         *
         */
        initializeEventForTarget( target:any, type:string ) {
            this._target= target;
            this._type= type;
        }
    }

    /**
     * @class cc.input.InputManager
     * @classdesc
     *
     * General input manager object.
     *
     */
    export class InputManager {

        _keyboardManager: KeyboardInputManager = null;

        constructor() {

            this._keyboardManager= new cc.input.KeyboardInputManager();
        }

        enable( element:HTMLCanvasElement) : InputManager {
            this._keyboardManager.enable();
            cc.input.MouseInputManager.enable(element);
            return this;
        }

        disable() : InputManager {
            this._keyboardManager.disable();
            cc.input.MouseInputManager.disable();
            return this;
        }

        addEventListener(event, callback, params) {
            if (event==="keydown") {
                this._keyboardManager.onDown(params, callback)
            } else if (event==="keyup") {
                this._keyboardManager.onUp(params, callback)
            }
        }

        registerCursor( kd:cc.input.CursorInitializer, callback:(key:string, down:boolean)=>any ) : number {
            return this._keyboardManager.registerCursor( kd, callback );
        }

        unregisterCursor( id:number ) {
            this._keyboardManager.unregisterCursor(id);
        }
    }

    /**
     * @class cc.input.PriorityInputNode
     * @classdesc
     *
     * This class encapsulated a descriptor for priority input routing. Basically keeps track of a target Node and
     * a priority value.
     * These descriptors are sorted in priority value, meaning lower values will be evaluated for input first.
     */
    export class PriorityInputNode {

        /**
         * Input target.
         * @member cc.input.PriorityInputNode#node
         * @type {cc.node.Node}
         */

        /**
         * Priority value.
         * @member cc.input.PriorityInputNode#priority
         * @type {number}
         */

        /**
         * @method cc.input.PriorityInputNode#constructor
         * @param node {cc.node.Node}
         * @param priority {number}
         */
        constructor( public node:Node, public priority:number ) {

        }
    }

    /**
     *
     * @class cc.input.SceneGraphInputTreeNode
     * @classdesc
     *
     * Input is routed in two different ways:
     *  + prioritized: where elements are sorted in priority order.
     *  + scene graph: where elements are sorted in scene-graph order, that is, in a parent/child order.
     *
     * Some Input managers will keep a root node of this type, which has inserting/removing capabilities and keeps
     * nodes in SceneGraph order.
     *
     * Preferred way of input routing should be prioritized.
     * SceneGraph, for a large number of nodes, sounds reasonably to maintain an smaller subset of the scene graph
     * to try routing input to. For smaller amounts, sounds like not a good idea to keep a copy, and have to notify
     * each manager about scene-graph mutation operations to rebuild the nodes tree.
     *
     * The input system will traverse this tree in pre-order to test for input.
     *
     * This class will only be used for point-like input systems like mouse or touch.
     */
    export class SceneGraphInputTreeNode {

        /**
         * Target Node.
         * @member cc.input.SceneGraphInputTreeNode#node
         * @type {cc.node.Node}
         */
        node:Node=null;

        /**
         * This node's Scene-Graph priority children nodes.
         * @member cc.input.SceneGraphInputTreeNode#children
         * @type {cc.input.SceneGraphInputTreeNode}
         */
        children:SceneGraphInputTreeNode[]=null;

        /**
         * Is this node enabled ? if not, it won't be tested for input.
         * @member cc.input.SceneGraphInputTreeNode#enabled
         * @type {boolean}
         */
        enabled:boolean=false;

        /**
         * Create a new Scene-Graph priority node/tree.
         * @method cc.input.SceneGraphInputTreeNode#constructor
         * @param node {cc.node.Node=}
         */
        constructor( node?:Node ) {
            this.children= [];
            if (typeof node!=="undefined" ) {
                this.node= node;
            }
        }

        /**
         * Insert a Path of nodes.
         * A path of nodes is an array of a Node, and all its ancestors.
         * These path will be added to the tree, creating nodes for missing nodes, and modifying existing ones for input
         * route enable as needed.
         * If the path does not have as top most ancestor the tree's root node, nothing will be added, and an error
         * will be sent to the console.
         * @method cc.input.SceneGraphInputTreeNode#insert
         * @param path {Array<cc.node.Node>}
         */
        insert( path:Node[] ) : SceneGraphInputTreeNode {
            var lastNode= path[ path.length - 1 ];
            if ( lastNode===this.node ) {
                return this.__insertImpl( this, path );
            } else {
                cc.Debug.warn(cc.locale.INPUT_WARN_WRONG_ROOT_NODE);
            }

            return null;
        }

        /**
         * Node path insertion implementation.
         * @method cc.input.SceneGraphInputTreeNode#__insertImpl
         * @param inputNode {cc.input.SceneGraphInputTreeNode} a tree node.
         * @param path {Array<cc.node.Node>} node path.
         * @returns {cc.input.SceneGraphInputTreeNode}
         * @private
         */
        __insertImpl( inputNode:SceneGraphInputTreeNode, path:Node[] ) : SceneGraphInputTreeNode {

            var pathNode= path.pop();

            // adding input to the inputNode.
            if ( pathNode!==inputNode.node ) {
                // the node is not of this input tree node.
                // add it as children, and go on.
                inputNode= inputNode.addChildInputNode( pathNode );
            }

            if ( path.length===0 ) {
                inputNode.enabled = true;
            } else {
                return this.__insertImpl( inputNode, path );
            }

            return inputNode;
        }

        /**
         * Add a node as a Scene-Graph priority tree node's child.
         * @method cc.input.SceneGraphInputTreeNode#addChildInputNode
         * @param node {cc.node.Node}
         * @returns {*}
         */
        addChildInputNode( node:Node ) : SceneGraphInputTreeNode {

            // make sure the node does not already exist wrapped into a SceneGraphInputTreeNode
            for( var i=0; i<this.children.length; i++ ) {
                if ( this.children[i].node===node ) {
                    return this.children[i];
                }
            }

            // the node is not as children

            var newInputNode= new SceneGraphInputTreeNode(node);

            this.children.push( newInputNode );
            this.children.sort( function( sn0:SceneGraphInputTreeNode, sn1:SceneGraphInputTreeNode ) : number {

                // nodes for input are sorted inversely, input goes to the top most.

                var n0:Node= sn0.node;
                var n1:Node= sn1.node;

                if ( n0._localZOrder < n1._localZOrder ) {
                    return 1;
                }

                if (n0._localZOrder > n1._localZOrder) {
                    return -1;
                }

                return n0._orderOfArrival < n1._orderOfArrival ? 1 : -1;

            });

            return newInputNode;
        }

        /**
         * Flatten this tree and get an array of pre-order sorted nodes.
         * @method cc.input.SceneGraphInputTreeNode#flatten
         * @returns {Array<cc.node.Node>}
         */
        flatten() : Node[] {
            var ret: Node[]= [];
            this.__flattenImpl( this, ret );

            return ret;
        }

        /**
         * Tree flatten operation implementation.
         * @method cc.input.SceneGraphInputTreeNode#__flattenImpl
         * @param inputNode {cc.input.SceneGraphInputTreeNode} a tree node.
         * @param nodes {Array<cc.node.Node>} an array to push the sorted nodes.
         * @private
         */
        __flattenImpl( inputNode: SceneGraphInputTreeNode, nodes:Node[] ) {

            var i;

            for( i=0;i<inputNode.children.length; i++ ) {
                this.__flattenImpl( inputNode.children[i], nodes );
            }

            // all enabled nodes, must be added to the list of enabled elements.
            if ( inputNode.enabled ) {
                nodes.push( inputNode.node );
            }
        }

        /**
         * For an screen position, get the first node that is at that position and has input enabled.
         * This will be the target of the pointer input operation.
         * @method cc.input.SceneGraphInputTreeNode#findNodeAtScreenPoint
         * @param e {cc.input.MouseInputManager}
         * @returns {cc.node.Node}
         */
        findNodeAtScreenPoint( p:cc.math.Vector, callback?:(node:Node)=>boolean ) : Node {
            var node= this.__findNodeAtScreenPoint( this, p, callback );
            if (!node && callback) {
                callback(null);
            }

            return node;
        }

        /**
         * findNodeAtScreenPoint's implementation
         * @method cc.input.SceneGraphInputTreeNode#__findNodeAtScreenPoint
         * @param inputNode {cc.input.SceneGraphInputTreeNode}
         * @param e {cc.input.MouseInputManager}
         * @returns {cc.node.Node}
         * @private
         */
        __findNodeAtScreenPoint( inputNode:SceneGraphInputTreeNode, p:cc.math.Vector, callback?:(node:Node)=>boolean ) : Node {

            var i;

            var pp= new cc.math.Vector();
            pp.set( p.x, p.y );

            for( i=0;i<inputNode.children.length; i++ ) {
                var node:Node= this.__findNodeAtScreenPoint( inputNode.children[i], p, callback );
                if ( node ) {
                    return node;
                }
            }

            // all enabled nodes, must be added to the list of enabled elements.
            if ( inputNode.enabled ) {
                var node:Node= inputNode.node;
                p.set( pp.x, pp.y );
                if ( node.isScreenPointInNode(p) ) {
                    //return node;
                    if ( callback ) {
                        if (!callback(node) ) {
                            return node;
                        }
                        p.set( pp.x, pp.y );
                    } else {
                        return node;
                    }
                }
            }

            p.set( pp.x, pp.y );
            return null;
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="InputManager.ts"/>

module cc.input {

    import Vector= cc.math.Vector;
    import Point= cc.math.Point;
    import Scene= cc.node.Scene;
    import Node= cc.node.Node;

    import SceneGraphInputTreeNode= cc.input.SceneGraphInputTreeNode;
    import PriorityInputNode= cc.input.PriorityInputNode;
    import InputManagerEvent= cc.input.InputManagerEvent;

    var __p0:Vector= new Vector();

    /**
     * DOM target element. Tipically a Canvas object.
     * Director will call this method when the renderer is set.
     * @type {HTMLElement}
     * @private
     */
    var _target : HTMLCanvasElement = null;

    /**
     * Current event screen-space point.
     * @type {cc.math.Vector}
     * @private
     */
    var _screenPoint : Vector = new Vector();

    /**
     * Previous event screen-space point. When a drag event is detected, the event emitted will contain current and
     * previous screen coordinated which will allow for a proper dragging calculation w/o the client need to store
     * previous coords.
     * @type {cc.math.Vector}
     * @private
     */
    var _prevScreenPoint : Vector = new Vector();

    /**
     * Mouse event in _target space. For a node this will have the _screenPoint transformed to node's local coordinate
     * system (regardless of the compound affine transform it has).
     * @type {cc.math.Vector}
     * @private
     */
    var _targetPoint : Vector = new Vector();

    /**
     * This is director's current scene.
     * It is needed since each scene will have two lists for input: priority and scene-graph order.
     * @type {cc.node.Scene}
     * @private
     */
    var _scene : Scene = null;

    /**
     * Flag indicating whether the mouse/touch is pressed when moving. This allows to differentiate between move and drag.
     * @type {boolean}
     * @private
     */
    var _isMouseDown:boolean= false;

    /**
     * Is dragging internal flag.
     * @type {boolean}
     * @private
     */
    var _isDragging:boolean= false;

    var _isDraggingInCapture:boolean= false;

    /**
     * When the mouse/pointer is down, a target Node is identified as event target.
     * This variable holds a Node reference as capturing Node.
     * @type {cc.node.Node}
     * @private
     */
    var _currentCaptureNode:Node= null;

    /**
     * Internal flag that identifies an IOS user agent.
      * @type {Navigator|string[]}
     */
    var isIOS= navigator && navigator.userAgent.match(/iOS/);


    /**
     * Create a MouseInputManagerEvent.
     * This event contains:
     *   + target for the event. A Node.
     *   + type of event (mouseover, mouseout, mousedown, mouseup, mousemove, mousedrag, mouseclick, doubleclick)
     *   + screen point (canvas space) where the event originated.
     *   + previous screen point (canvas space) where the event originated in the previous event.
     *   + local node point (node space) where the event originated in the previous event.
     *
     * WARNING: all properties of this event must be copied. Don't rely on the point values unless you make a copy
     * of them.
     * WARNING: don't change any of the event properties in the callback functions it is passed to.
     *
     * @param e {MouseEvent} original DOM event
     * @param event {string} the type of event that will be emitted.
     * @param node {cc.node.Node} a target node.
     *
     * @returns {MouseInputManagerEvent}
     */
    function createEvent( e:MouseEvent, event:string, node:Node ) : MouseInputManagerEvent {

        var mie:MouseInputManagerEvent= new MouseInputManagerEvent(e);

        getTargetSpacePoint( __p0, e );

        // original canvas-space position
        mie.setScreenPoint( __p0.x, __p0.y );

        if (null===_prevScreenPoint) {
            _prevScreenPoint= new Vector( __p0.x, __p0.y );
        }

        mie.localPoint.x= mie.screenPoint.x;
        mie.localPoint.y= mie.screenPoint.y;

        mie.prevScreenPoint.x= _prevScreenPoint.x;
        mie.prevScreenPoint.y= _prevScreenPoint.y;

        mie.initializeEventForTarget( node, event );

        return mie;
    }

    function routeEvent( p:Vector, callback?:(node:Node)=>boolean ) : Node {
        if ( _scene) {
            return _scene.findNodeAtScreenPoint( p, callback );
        }

        return null;
    }

    /**
     * Mouse down handler.
     * @param e {MouseEvent}
     */
    function mouseDown(e:MouseEvent) {
        e.preventDefault();
        if (e.stopPropagation) {e.stopPropagation()}

        if (!_scene) { return; }

        __inputDown(createEvent(e, "mousedown", _currentCaptureNode), "mousedown");
    }

    function __inputDown( ee:MouseInputManagerEvent, event ) {
        _isMouseDown = true;

        ee._localPoint.set( ee._screenPoint.x, ee._screenPoint.y );
        routeEvent( ee._localPoint , function(node:Node) : boolean {

            var ret= false;

            if ( node ) {
                ee._type = event;
                ee._target = node;
                ret= node.notifyEvent(ee);
            }

            if (_currentCaptureNode !== node && !ret ) {

                if ( _currentCaptureNode ) {
                    ee._type = event === "mousedown" ? "mouseout" : "touchend";
                    ee._target = _currentCaptureNode;
                    _currentCaptureNode.notifyEvent(ee);
                }
            }

            if (!ret) {
                _currentCaptureNode = node;
            }

            _prevScreenPoint.set(ee.screenPoint.x, ee.screenPoint.y);

            return ret;
        } );
    }

    /**
     * Mouse up handler
     * @param e {MouseEvent}
     */
    function mouseUp(e) {
        e.preventDefault();
        if (e.stopPropagation) {e.stopPropagation()}

        if (!_scene) { return; }

        __inputUp(createEvent(e, "mouseup", _currentCaptureNode), "mouseup");
    }

    function __inputUp( ee:MouseInputManagerEvent, event ) {

        ee._localPoint.set( ee._screenPoint.x, ee._screenPoint.y );
        var node= routeEvent( ee._localPoint );

            var ret= false;

            if (_currentCaptureNode) {
                // up in a different node
                if (_currentCaptureNode !== node) {
                    // send out to the previous one.
                    ee._type = event === "mouseup" ? "mouseout" : "touchend";
                    ee._target = _currentCaptureNode;
                    ee.localPoint.x = ee.screenPoint.x;
                    ee.localPoint.y = ee.screenPoint.y;
                    _currentCaptureNode.isScreenPointInNode(ee.localPoint);
                    _currentCaptureNode.notifyEvent(ee);

                    // eat the out.
                } else {
                    // up in the same captured node

                    // notify mouse up
                    _currentCaptureNode.notifyEvent(ee);

                    // and if not dragging, mouse click
                    if (!_isDragging && event === "mouseup") {
                        ee._type = "mouseclick";
                        ee._target = _currentCaptureNode;
                        _currentCaptureNode.notifyEvent(ee);
                    }
                }
            }

            _currentCaptureNode = null;
            _isMouseDown = false;
            _isDragging = false;
            _isDraggingInCapture = false;

            _prevScreenPoint = null;

    }

    /**
     * Mouse move handler
     * @param e {MouseEvent}
     * @param _event {string} mouseout/mouseover are treated as mouseMove. If set, this variable forces the event type.
     */
    function mouseMove(e, _event?) {
        e.preventDefault();
        if (e.stopPropagation) {e.stopPropagation()}

        if (!_scene) { return; }

        var event = _event ? _event : (_isMouseDown ? "mousedrag" : "mousemove");
        __inputMove(createEvent(e, event, _currentCaptureNode), event);
    }

    function __inputMove( ee:MouseInputManagerEvent, event:string ) {

        if (_isMouseDown) {
            _isDragging = true;
            _isDraggingInCapture = true;
        }

        // drag is sent to the captured node.
        if (!_isDragging) {


            ee._localPoint.set( ee._screenPoint.x, ee._screenPoint.y );
            routeEvent( ee._localPoint, function(node:Node) : boolean {

                var ret= false;

                if ( node ) {
                    ee._type= event;
                    ee._target = node;
                    ret= node.notifyEvent( ee );
                }

                if (node !== _currentCaptureNode && !ret) {
                    // if there's a previous capture node notify mouse-out on it.
                    if (_currentCaptureNode) {
                        ee._type = event === "mousedrag" || event === "mousemove" ? "mouseout" : "touchout";
                        ee._target= _currentCaptureNode;
                        _currentCaptureNode.notifyEvent(ee);
                    }

                    if ( node ) {
                        ee._type= event === "mousedrag" || event === "mousemove" ? "mouseover" : "touchover";
                        ee._target = node;
                        ret= node.notifyEvent( ee );
                    }
                }

                if (!ret) {
                    _currentCaptureNode = node;
                }

                _prevScreenPoint.set( ee.screenPoint.x, ee.screenPoint.y );

                return ret;
            });

        } else {
            // dragging


            // dragging outside the capture node ??
            //routeEvent( ee.screenPoint, function(node:Node) : boolean {

            ee._localPoint.set( ee._screenPoint.x, ee._screenPoint.y );
            var node= routeEvent( ee._localPoint );

                var ret= false;

                if (node !== _currentCaptureNode) {
                    if (_currentCaptureNode) {
                        ee._type = ee._type = event === "mousedrag" || event === "mousemove" ? "mouseout" : "touchout";
                        ee.localPoint.x = ee.screenPoint.x;
                        ee.localPoint.y = ee.screenPoint.y;
                        _currentCaptureNode.getScreenPointInLocalSpace(ee.localPoint);
                        _currentCaptureNode.notifyEvent(ee);
                        _isDraggingInCapture = false;
                    }
                } else {
                    if (!_isDraggingInCapture) {
                        _isDraggingInCapture = true;
                        ee._type = ee._type = event === "mousedrag" || event === "mousemove" ? "mouseover" : "touchover";
                        _currentCaptureNode.notifyEvent(ee);
                    }
                }

                // notify mouse-over to the new capture node
                if (_currentCaptureNode !== null) {
                    ee._type= event;
                    ee._target= _currentCaptureNode;
                    //ret= _currentCaptureNode.notifyEvent( ee );
                    ret= _currentCaptureNode.notifyEvent( ee );
                }

                _prevScreenPoint.set( ee.screenPoint.x, ee.screenPoint.y );

                //return ret;

            //});
        }

    }

    /**
     * double click handler.
     * @param e {MouseEvent}
     */
    function doubleClick(e) {
        e.preventDefault();
        if (e.stopPropagation) {e.stopPropagation()}

        if (!_scene) { return; }

        var ee= createEvent(e, "doubleclick", _currentCaptureNode);
        if (_currentCaptureNode) {
            _currentCaptureNode.notifyEvent( ee);
        } else {
            ee._localPoint.set( ee._screenPoint.x, ee._screenPoint.y );
            routeEvent( ee._localPoint, function(node:Node) : boolean {

                var ret= false;
                if (_currentCaptureNode) {
                    ret= _currentCaptureNode.notifyEvent(ee);
                }

                return ret;
            });
        }

        _prevScreenPoint= null;
    }

    /**
     * Mouse over handler.
     * @param e {MouseEvent}
     */
    function mouseOver(e) {
        e.preventDefault();
        if (e.stopPropagation) {e.stopPropagation()}

        if (!_scene) { return; }

        mouseMove(e, "mouseoever");
    }

    /**
     * Mouse out handler
     * @param e {MouseEvent}
     */
    function mouseOut(e) {
        e.preventDefault();
        if (e.stopPropagation) {e.stopPropagation()}

        if (!_scene) { return; }

        mouseMove(e,"mouseout");

    }

    function touchStart(e) {
        e.preventDefault();
        if (e.stopPropagation) {e.stopPropagation()}

        if (!_scene) { return; }

        __inputDown( createEvent(e.targetTouches[0],"touchstart",_currentCaptureNode), "touchstart" );
    }

    function touchEnd(e) {
        e.preventDefault();
        if (e.stopPropagation) {e.stopPropagation()}

        if (!_scene) { return; }

        __inputUp( createEvent(e.changedTouches[0],"touchend",_currentCaptureNode), "touchend" );

    }

    function touchMove(e) {
        e.preventDefault();
        if (e.stopPropagation) {e.stopPropagation()}

        if (!_scene) { return; }

        __inputMove( createEvent(e.targetTouches[0],"touchmove",_currentCaptureNode), "touchmove" );
    }

    function __accumulateOffset(node:HTMLElement, parentProperty:string, property:string) {

        var left = property + 'Left';
        var top = property + 'Top';
        var x = 0, y = 0, style;

        while (isIOS && node && node.style) {
            if (node.currentStyle) {
                style = node.currentStyle.position;
            } else {
                style = (node.ownerDocument.defaultView || node.ownerDocument.parentWindow).getComputedStyle(node, null);
                style = style ? style.getPropertyValue('position') : null;
            }

            if (!/^(fixed)$/.test(style)) {
                x += node[left];
                y += node[top];
                node = node[parentProperty];
            } else {
                break;
            }
        }

        return {
            x: x,
            y: y,
            style: style
        };
    }

    /**
     * Get a DOM node offset based on its position attribute.
     * @param node {HTMLElement}
     * @returns {cc.math.Point}
     * @private
     */
    function __getOffset(node:HTMLElement) {

        var res = __accumulateOffset(node, 'offsetParent', 'offset');
        if (res.style === 'fixed') {
            var res2 = __accumulateOffset(node, node.parentNode ? 'parentNode' : 'parentElement', 'scroll');
            return {
                x: res.x + res2.x,
                y: res.y + res2.y
            };
        }

        return {
            x: res.x,
            y: res.y
        };
    }

    /**
     * This function tansforms a window-space input coordinate event into a _target-space coordinate.
     * Modern browsers have a getBoundingClientRect for this purpose, but older don't so a more complex mechanism for
     * finding out the coordinate is deployed.
     * This includes logic based on the position style of the canvas, screen scroll, etc., and some other perks.
     *
     * It surely does not cover corner or weird cases !!!.
     *
     * It also stores the _screenPoint value.
     *
     * @param point {cc.math.Point} an output point.
     * @param e {MouseEvent}
     */
    function getTargetSpacePoint(point, e) {

        _screenPoint.x = e.clientX;
        _screenPoint.y = e.clientY;

        var posx = 0;
        var posy = 0;

        if ( (<any>navigator).isCocoonJS) {
            posx = e.pageX;
            posy = e.pageY;
        } else if (typeof e.offsetX !== "undefined" || typeof e.layerX !== "undefined" || typeof e.clientX !== "undefined") {
            var bcr = _target.getBoundingClientRect();

            posx = e.clientX; // || e.offsetX || e.layerX;
            posy = e.clientY; // || e.offsetY || e.layerY;

            posx = (posx - bcr.left) * (_target.width / bcr.width);
            posy = (posy - bcr.top) * (_target.height / bcr.height);

        } else {

            /**
             * older browsers.
             * survival model. try to find things on your own by traversing upwards the DOM tree.
             */
            if (!e) e = window.event;

            if (e.pageX || e.pageY) {
                posx = e.pageX;
                posy = e.pageY;
            }
            else if (e.clientX || e.clientY) {
                posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            }

            var offset = __getOffset(this.canvas);

            posx -= offset.x;
            posy -= offset.y;
        }

        _targetPoint.set(posx, posy);
        point.set(posx, posy);

    }

    /**
     * @class cc.input.MouseInputManagerEvent
     * @extends cc.input.InputManagerEvent
     * @classdesc
     *
     * This class represents information for a Mouse-level event and translated into CocosJS needed information.
     *
     */
    export class MouseInputManagerEvent extends InputManagerEvent {

        /**
         * Original DOM level event that triggered this MouseInputManagerEvent
         * @member cc.input.MouseInputManagerEvent#_originalDOMEvent
         * @type {MouseEvent}
         * @private
         */
        _originalDOMEvent : MouseEvent= null;

        /**
         * position in canvas space.
         * @member cc.input.MouseInputManagerEvent#_screenPoint
         * @type {cc.math.Vector}
         * @private
         */
        _screenPoint:Vector= null;

        /**
         * Target Node local coordinate.
         * @member cc.input.MouseInputManagerEvent#_screenPoint
         * @type {cc.math.Vector}
         * @private
         */
        _localPoint:Vector= null;

        /**
         * For a dragging operation, position in canvas space of the previous event.
         * @member cc.input.MouseInputManagerEvent#_screenPoint
         * @type {cc.math.Vector}
         * @private
         */
        _prevScreenPoint:Vector= null;

        /**
         * Create a new MouseInputManagerEvent instance.
         * @method cc.input.MouseInputManagerEvent#constructor
         * @param e {MouseEvent} DOM level original event.
         */
        constructor(e:MouseEvent) {
            super();
            this._originalDOMEvent= e;
            this._screenPoint= new Vector();
            this._localPoint= new Vector();
            this._prevScreenPoint= new Vector();
        }

        getDelta() : cc.math.Point {
            return {
                x: this._screenPoint.x - this._prevScreenPoint.x,
                y: this._screenPoint.y - this._prevScreenPoint.y
            }
        }

        /**
         * Set this event's screen point.
         * @method cc.input.MouseInputManagerEvent#setScreenPoint
         * @param x {number}
         * @param y {number}
         */
        setScreenPoint( x:number, y:number ) {
            this._screenPoint.set(x,y);
        }

        /**
         * Initialize the event for type and target.
         * @method cc.input.MouseInputManagerEvent#initializeEventForTarget
         * @param target {cc.node.Node}
         * @param event {string}
         */
        initializeEventForTarget( target:Node, event:string ) {
            super.initializeEventForTarget(target, event);

            this._localPoint.set(this._screenPoint.x, this._screenPoint.y);
        }

        /**
         * Get target Node's local coordinate where the event originated.
         * @method cc.input.MouseInputManagerEvent#get:localPoint
         * @returns {cc.math.Vector}
         */
        get localPoint() : Vector {
            return this._localPoint;
        }

        /**
         * Get target screen coordinate where the previous event originated.
         * @method cc.input.MouseInputManagerEvent#get:prevScreenPoint
         * @returns {cc.math.Vector}
         */
        get prevScreenPoint() : Vector {
            return this._prevScreenPoint;
        }

        /**
         * Get target screen coordinate where the event originated.
         * @method cc.input.MouseInputManagerEvent#get:screenPoint
         * @returns {cc.math.Vector}
         */
        get screenPoint() : Vector {
            return this._screenPoint;
        }
    }

    function hasTouch() {
        return (('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (navigator.msMaxTouchPoints > 0));
    }


    /**
     * @class cc.input.MouseInputManager
     * @classdesc
     *
     * This object is CocosJS system general mouse/touch input manager.
     * Mouse events are registered at window level. This will prevent from stop receiving input events if the mouse/touch
     * gets out of the canvas area, but on the other hand, it will impose a more complicated local canvas coordinate
     * matching for older browsers.
     *
     * It is a non-instantiable object, and a call to enable/disable, like to any other system-wide input event must
     * be performed before receiving input events.
     *
     * Touch events are mapped as follows:
     *
     *  <li>touch start -> mousedown
     *  <li>touch end   -> mouseup
     *  <li>touch move  -> mousedrag
     *
     * There's no need to register specific listeners for the touch events. If a corresponding mouse event is registered
     * it will be notified on these instead.
     *
     */
    export class MouseInputManager {

        /**
         * Set the scene to route input events to.
         * This happens automatically at director level whenever a call to runAction happens.
         * @method cc.input.MouseInputManager.enableInputForScene
         * @param scene {cc.node.Scene}
         */
        static enableInputForScene( scene:Scene ) {
            _scene= scene;

        }

        static disableInputForScene( ) {
            _scene= null;

        }

        /**
         * Enable the input for mouse and touch.
         * @method cc.input.MouseInputManager.enable
         * @param target {HTMLCanvasElement} canvas target.
         */
        static enable(target:HTMLCanvasElement) {
            if ( _target!==null ) {
                this.disable();
            }
            _target= target;


            if ( hasTouch() ) {
                target.addEventListener("touchstart", touchStart, false);
                target.addEventListener("touchmove", touchMove, false);
                target.addEventListener("touchend", touchEnd, false);
            } else {

                window.addEventListener('mouseup',  mouseUp,    false);
                window.addEventListener('mousedown',mouseDown,  false);
                window.addEventListener('mouseover',mouseOver,  false);
                window.addEventListener('mouseout', mouseOut,   false);
                window.addEventListener('mousemove',mouseMove,  false);
                window.addEventListener('dblclick', doubleClick,false);
            }
        }

        /**
         * Disable the input for mouse and touch.
         * @method cc.input.MouseInputManager.disable
         */
        static disable() {

            if ( _target!==null ) {

                if ( hasTouch() ) {
                    _target.removeEventListener("touchstart", touchStart, false);
                    _target.removeEventListener("touchmove", touchMove, false);
                    _target.removeEventListener("touchend", touchEnd, false);
                } else {

                    window.removeEventListener('mouseup',  mouseUp,     false);
                    window.removeEventListener('mousedown',mouseDown,   false);
                    window.removeEventListener('mouseover',mouseOver,   false);
                    window.removeEventListener('mouseout', mouseOut,    false);
                    window.removeEventListener('mousemove',mouseMove,   false);
                    window.removeEventListener('dblclick', doubleClick, false);
                }

                _target= null;
            }
        }
    }

}
/**
 * Created by ibon on 1/6/15.
 */

/// <reference path="./InputManager.ts"/>

module cc.input {


    /**
     * Keys names and ascii chars.
     * From Impact Game Engine.
     * @name KEYS
     * @memberOf cc.input
     * @type {Map<string,number>}
     */
    export var KEYS = {

        enter: 13,
        backspace: 8,
        tab: 9,
        shift: 16,
        ctrl: 17,
        alt: 18,
        pause: 19,
        capslock: 20,
        escape: 27,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        insert: 45,
        "delete": 46,
        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        command: 91,
        meta: 91,
        select: 93,
        rcommand: 93,
        numpad0: 96,
        numpad1: 97,
        numpad2: 98,
        numpad3: 99,
        numpad4: 100,
        numpad5: 101,
        numpad6: 102,
        numpad7: 103,
        numpad8: 104,
        numpad9: 105,
        multiply: 106,
        add: 107,
        subtract: 109,
        decimalpoint: 110,
        divide: 111,
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123,
        numlock: 144,
        scrolllock: 145,
        semicolon: 186,
        equalsign: 187,
        comma: 188,
        dash: 189,
        period: 190,
        forwardslash: 191,
        graveaccent: 192,
        openbracket: 219,
        backslash: 220,
        closebracket: 221,
        singlequote: 222,
        commandright: 224
    };
    
    /**
     * Build a keyboard modifiers object.
     * Modifers have some numerical members corresponding to the key codes for command, commandright, shift, alt and control.
     * 
     * @returns {object}
     */
    function buildKeyModifiers() : any {

        var modifiers:any= {};
        modifiers[ KEYS.command ]= false;
        modifiers[ KEYS.commandright ]= false;
        modifiers[ KEYS.ctrl    ]= false;
        modifiers[ KEYS.shift   ]= false;
        modifiers[ KEYS.alt     ]= false;

        return modifiers;
    }


    /**
     * @class cc.input.KeyInfo
     * @classdesc 
     * 
     * Describes a key and its modifiers.
     * For example: command+a, shift+alt+g
     * A Key, is parsed from a string, amd must be defined in this order: modifiers+key.
     * It won't recognize something like: a+shift whili it will recognized shift+a
     * KeyInfo objects keep internal state for parsing result validity.
     * 
     * Objects of this type are internal to the keyboard manager.
     */
    export class KeyInfo {

        /**
         * Key Code.
         * @member cc.input.KeyInfo#key
         * @type {number}
         */
        key:number = null;
        
        /**
         * Modifiers Object.
         * @member cc.input.KeyInfo#modifiers
         * @type {object}
         */
        modifiers:any = null;
        
        /**
         * Key has been parsed correctly ?
         * @member cc.input.KeyInfo#isValid
         * @type {boolean}
         */
        isValid:boolean= true;

        /**
         * Build a new KeyInfo instance from a string key representation.
         * @method cc.input.KeyInfo#constructor
         * @param keyDef {string}
         */
        constructor( keyDef:string ) {

            this.modifiers= buildKeyModifiers();
            
            var keys= keyDef.split("+");

            // 0 to length-1 are supposed to be the modifers.
            for( var i=0; i<keys.length-1; i++ ) {
                if ( this.modifiers.hasOwnProperty( cc.input.KEYS[ keys[i] ] ) ) {
                    this.modifiers[ cc.input.KEYS[ keys[i] ] ]= true;
                } else {
                    this.isValid= false;
                    console.log("wrong key modifier: '"+keys[i]+"' in key definition: "+keyDef);
                }
            }

            var key= keys[ keys.length-1 ];
            if ( KEYS.hasOwnProperty(key) ) {
                this.key= KEYS[key];
            } else {
                this.isValid= false;
                console.log("wrong key '"+key+"' in key definition: "+keyDef);
            }
        }

        /**
         * Test whether this KeyInfo matches a keyCode and some modifiers.
         * @method cc.input.KeyInfo#matches
         * @param key {number} key code.
         * @param modifiers {object}
         * @returns {boolean}
         */
        matches( key:number, modifiers:any ) {
            return this.key===key &&
                    modifiers.ctrl===           this.modifiers.ctrl &&
                    modifiers.alt===            this.modifiers.alt &&
                    modifiers.shift===          this.modifiers.shift &&
                    modifiers.command===        this.modifiers.command &&
                    modifiers.commandright===   this.modifiers.commandright;
        }
    }

    /**
     * @class cc.input.KeyActionInfo
     * @classdesc
     * 
     * A KeyActionInfo is responsible for defining a key sequence, composed by a collection of KeyInfo objects.
     * It will also be responsible for identifying whether the sequence has been types correctly, and of notifying any
     * sequence listeners registered for it.
     * 
     * A sample KeyActionInfo could be for example the konami code:
     * "up up down dow left right left right b a", "a b c", or a simple "a". The callback associated with the sequence
     * will be fired when all the keys are pressed in order.
     * 
     * An action info will be fired on key down or up, depending on the construction parameter.
     * For multi-key actions, the callback will be fired on key down or up of the last sequence key.
     * The sequence will be invalidated if the wrong key for the current sequence position is typed, or it more than
     * KeyActionInfo._typeTime is exceeded.
     */
    export class KeyActionInfo {

        /**
         * The registered keys of the sequence action.
         * @member cc.input.KeyActionInfo#_keys
         * @type {Array<cc.input.KeyInfo>} 
         * @private
         */
        _keys : KeyInfo[] = [];

        /**
         * Action for which the ket sequence action was registered. Either 'down' or 'up'.
         * @member cc.input.KeyActionInfo#_action
         * @type {string}
         * @private
         */
        _action : string = null;

        /**
         * Callback to fire when the sequence is complete.
         * @member cc.input.KeyActionInfo#_callback
         * @type {Function}
         * @private
         */
        _callback : Function = null;

        /**
         * Current sequence expected key.
         * @member cc.input.KeyActionInfo#_currentKeyInfoIndex
         * @type {number}
         * @private
         */
        _currentKeyInfoIndex= -1;

        /**
         * Time at which the last valid action sequence key was typed.
         * @member cc.input.KeyActionInfo#_time
         * @type {number}
         * @private
         */
        _time:number= -1;

        /**
         * A index-sequence generated id. It is valid for unregistering key sequences from the keyboard manager.
         * @member cc.input.KeyActionInfo#_id
         * @type {number}
         * @private
         */
        _id:number=KeyboardIdGenerator();

        /**
         * If more than this milliseconds elapse between two valid sequence action keys, the sequence will be aborted.
         * @member cc.input.KeyActionInfo#_typeTime
         * @type {number}
         * @private
         */
        _typeTime:number = 1000;
        
        /**
         * Create a new KeyActionInfo sequence object.
         * @method cc.input.KeyActionInfo#constructor
         * @param keys {string} a string with the sequence keys definition.
         * @param action {string} down or up. If keys is a sequence of keys, the sequence will be fired on up or down
         *                        of the last sequence key.
         * @param callback {function} a parameterless callback function.
         */
        constructor( keys:string, action:string, callback:Function ) {
            this._action= action;
            this._callback= callback;

            this.__parseKeys( keys );
        }

        /**
         * Get the sequence id.
         * @method cc.input.KeyActionInfo#getId
         * @returns {number}
         */
        getId():number {
            return this._id;
        }

        /**
         * Build KeyInfo objects from a keys definition string.
         * @method cc.input.KeyActionInfo#__parseKeys
         * @param keys {string} a string with keys (combinations) names. for example: "command+b", "alt+shift+f1 a b c"
         * @private
         */
        __parseKeys( keys:string ) {

            var keyDefs= keys.split(" ");
            for( var i=0; i<keyDefs.length; i++ ) {
                var keyDef:KeyInfo = new KeyInfo( keyDefs[i] );
                if ( keyDef.isValid ) {
                    this._keys.push( keyDef );
                }
            }
        }

        /**
         * Signal a key down event has been generated at keyboard manager level
         * @method cc.intpu.KeyInfoAction#down
         * @param modifiers {object} modifiers object
         * @param key {number} key code
         * @param time {number} time at which the event key was produced.
         */
        down(modifiers:any, key:number, time:number) {
            if ( this._action==="down" ) {
                this.__checkKey(key,modifiers,time);
            }
        }

        /**
         * Signal a key up event has been generated at keyboard manager level
         * @method cc.intpu.KeyInfoAction#up
         * @param modifiers {object} modifiers object
         * @param key {number} key code
         * @param time {number} time at which the event key was produced.
         */
        up(modifiers:any, key:number, time:number) {

            if ( this._action==="up" ) {
                this.__checkKey(key,modifiers,time);
            }
        }

        /**
         * Check whether the key code fulfills the key sequence in time.
         * The sequence will be reset if the wrong expected key is pressed or too much time elapse between two valid
         * sequence keys.
         * @param key {number} key code
         * @param modifiers {object} modifiers object
         * @param time {number} time at which the event key was produced.
         * @private
         */
        __checkKey( key:number, modifiers:any, time:number ) {

            // too much time for sequence
            if ( time-this._time > this._typeTime ) {
                // restart
                this._currentKeyInfoIndex= -1;
            }

            if ( this._currentKeyInfoIndex===-1 ) {
                this._currentKeyInfoIndex=0;
                this._time= time;
            }

            if ( this._keys[this._currentKeyInfoIndex].matches(key, modifiers) ) {
                // right key + modifiers
                this._currentKeyInfoIndex++;
                this._time= time;

                if ( this._currentKeyInfoIndex===this._keys.length ) {
                    // sequence ok
                    this._callback();
                    this._currentKeyInfoIndex= -1;
                }

            } else {
                // wrong key, restart
                this._currentKeyInfoIndex=-1;
            }

        }

        /**
         * Change the valid waiting time between two valid sequence keys.
         * The function won't check whether the number is valid or too low.
         * @method cc.input.KeyInfoAction#setSequenceTypeMaxTime
         * @param m {number}
         */
        setSequenceTypeMaxTime( m : number ) : KeyActionInfo {
            this._typeTime= m;
            return this;
        }
    }

    /**
     * @class cc.input.CursorInitializer
     * @interface
     * @classdesc
     * 
     * Cursor initializer. the up, down, left and right members represent a valid key enumeration.
     * Each of the keys in the sequence will be added as valid key sequences for each cursor event.
     * For example, if "w up" is specified for up, the Cursor will fire a callback for each of the keys 'w' and 'up'.
     */
    export interface CursorInitializer {

        /**
         * @member cc.input.CursorInitializer#up
         */
        up:string;

        /**
         * @member cc.input.CursorInitializer#down
         */
        down:string;

        /**
         * @member cc.input.CursorInitializer#left
         */
        left:string;
        /**
         * @member cc.input.CursorInitializer#right
         */
        right:string;
    }

    var KeyboardIdGenerator = function() {

        var index= 0;

        return function() {
            return index++;
        }

    }();

    /**
     * @class cc.input.KeyboardCursor
     * @classdesc
     *
     * This class represents a cursor composed of the 4 cursor events up, down, left and right.
     * For each of the events, a valid key enumeration can be defined.
     * For example, if "w up" is specified for up, the Cursor will fire a callback for each of the keys 'w' and 'up'.
     * This class makes all the necessary wiring between the cursor keys and KeyInfoAction objects.
     */
    export class KeyboardCursor {

        /**
         * Cursor up flag.
         * @member cc.input.KeyboardCursor#_upPressed
         * @type {boolean}
         * @private
         */
        _upPressed:boolean=     false;

        /**
         * Cursor down flag.
         * @member cc.input.KeyboardCursor#_downPressed
         * @type {boolean}
         * @private
         */
        _downPressed:boolean=   false;

        /**
         * Cursor left flag.
         * @member cc.input.KeyboardCursor#_leftPressed
         * @type {boolean}
         * @private
         */
        _leftPressed:boolean=   false;

        /**
         * Cursor right flag.
         * @member cc.input.KeyboardCursor#_rightPressed
         * @type {boolean}
         * @private
         */
        _rightPressed:boolean=  false;

        /**
         * Array for KeyActionInfo generated objects to keep track of the cursor.
         * @member cc.input.KeyboardCursor#_actionInfoIds
         * @type {Array<number>}
         * @private
         */
        _actionInfoIds:number[]= [];

        /**
         * For each cursor key press/release, this callback function will be called.
         * The key parameter of the callback will contain the cursor event names: up,down,left,right, and not the key name
         * that triggered the action. Thus, a generic cursor handle function could be used instead on having to taylor
         * a function for each cursor type.
         * @member cc.input.KeyboardCursor#_callback
         * @type {function(string,boolean)}
         * @private
         */
        _callback: ( key:string, down:boolean, keyCode:number ) => any;

        /**
         * Internal cursor id. Necessary for unregistering a cursor.
         * @member cc.input.KeyboardCursor#_id
         * @type {number}
         * @private
         */
        _id: number= KeyboardIdGenerator();

        /**
         * Create a new KeyboardCursor object instance.
         * @method cc.input.KeyboardCursor#constructor
         * @param kim {cc.input.KeyboardInputManager}
         * @param cd {cc.input.CursorInitializer}
         * @param callback {function(string,boolean)}
         */
        constructor( kim:KeyboardInputManager, cd:CursorInitializer, callback:(key:string, down:boolean)=>any ) {

            var me= this;
            
            this._callback= callback;
            
            this.__registerKeys(
                kim,
                cd.up,
                function() {
                    me._upPressed= true;
                    me.__onKeyChange("up", me._upPressed);
                }, 
                function() {
                    me._upPressed= false;
                    me.__onKeyChange("up", me._upPressed);
                }
            );
            
            this.__registerKeys(
                kim,
                cd.down,
                function() {
                    me._downPressed= true;
                    me.__onKeyChange("down", me._downPressed);
                }, 
                function() {
                    me._downPressed= false;
                    me.__onKeyChange("down", me._downPressed);
                }
            );

            this.__registerKeys(
                kim,
                cd.left,
                function() {
                    me._leftPressed= true;
                    me.__onKeyChange("left", me._leftPressed);
                }, 
                function() {
                    me._leftPressed= false;
                    me.__onKeyChange("left", me._leftPressed);
                }
            );

            this.__registerKeys(
                kim,
                cd.right,
                function() {
                    me._rightPressed= true;
                    me.__onKeyChange("right", me._rightPressed);
                }, 
                function() {
                    me._rightPressed= false;
                    me.__onKeyChange("right", me._rightPressed);
                }
            );

        }

        /**
         * Notify a cursor key status change.
         * @method cc.input.KeyboardCursor#__onKeyChange
         * @param key {string} the cursor event type.
         * @param pressed {boolean} true the key is pressed, false is released.
         * @private
         */
        __onKeyChange( key:string, pressed:boolean ) {
            this._callback( key, pressed, KEYS[key] );
        }

        /**
         * Register a KeyActionInfo for each key defined in the cursor event key description.
         * For example if "up w" is supplied, it will generate sequences for 'up' and 'w' respectively.
         * @param kim {cc.input.KeyboardInputManager}
         * @param keysdesc {string} keys descripion
         * @param callbackdown {function}
         * @param callbackup {function}
         * @private
         */
        __registerKeys( kim:KeyboardInputManager, keysdesc:string, callbackdown:()=>any, callbackup:()=>any ) {
            var keys= keysdesc.split(" ");
            for( var i=0; i<keys.length; i++ ) {
                this._actionInfoIds.push( kim.onDown( keys[i], callbackdown ) );
                this._actionInfoIds.push( kim.onUp( keys[i], callbackup ) );
            }
        }

        /**
         * Get the cursor id.
         * @method cc.input.KeyboardCursor#getId
         * @returns {number}
         */
        getId() {
            return this._id;
        }

        /**
         * Unregisted all key sequences from the cursor.
         * This method is internally used by the KeyboardInputManager
         * @method cc.input.KeyboardCursor#unregisted
         * @param kim {cc.action.KeyboardInputManager}
         */
        unregister( kim:KeyboardInputManager ) {
            for( var i=0; i<this._actionInfoIds.length; i++ ) {
                kim.removeActionInfo( this._actionInfoIds[i] );
            }
        }

        /**
         * Get cursor's event up status flag.
         * @method cc.input.KeyboardCursor#get:up
         * @returns {boolean} true is pressed.
         */
        get up() :boolean {
            return this._upPressed;
        }

        /**
         * Get cursor's event down status flag.
         * @method cc.input.KeyboardCursor#get:down
         * @returns {boolean} true is pressed.
         */
        get down() :boolean {
            return this._downPressed;
        }

        /**
         * Get cursor's event left status flag.
         * @method cc.input.KeyboardCursor#get:left
         * @returns {boolean} true is pressed.
         */
        get left() :boolean {
            return this._leftPressed;
        }

        /**
         * Get cursor's event right status flag.
         * @method cc.input.KeyboardCursor#get:right
         * @returns {boolean} true is pressed.
         */
        get right() :boolean {
            return this._rightPressed;
        }

    }

    /**
     * @class cc.input.KeyboardInputManager
     * @classdesc
     *
     * This object is the general keyboard input manager.
     * It must be instantiated.
     *
     */
    export class KeyboardInputManager {

        /**
         * Registered key sequences.
         * @member cc.input.KeyboardInputManager#_keyActionInfos
         * @type {Array<cc.input.KeyActionInfo>}
         * @private
         */
        _keyActionInfos : KeyActionInfo[];

        /**
         * Whether the keyboard handler is enabled.
         * @member cc.input.KeyboardInputManager#_enabled
         * @type {boolean}
         * @private
         */
        _enabled:boolean= false;

        /**
         * Global keyboard modifiers.
         * @member cc.input.KeyboardInputManager#_modifiers
         * @type {object}
         * @private
         */
        _modifiers: any = null;

        /**
         * Registered KeyboardCursor objects.
         * @member cc.input.KeyboardInputManager#_cursors
         * @type {Map<string,KeyboardCursor>}
         * @private
         */
        _cursors: any = {};

        /**
         * Internally bound function for down events.
         * Do not use or modify.
         * @member cc.input.KeyboardInputManager#_onDown
         * @type {function(KeyboardEvent)}
         * @private
         */
        _onDown : (e:KeyboardEvent) => any = null;

        /**
         * Internally bound function for up events.
         * Do not use or modify.
         * @member cc.input.KeyboardInputManager#_onUp
         * @type {function(KeyboardEvent)}
         * @private
         */
        _onUp : (e:KeyboardEvent) => any = null;

        /**
         * Create a new KeyboardInputManager instance.
         * @method cc.input.KeyboardInputManager#constructor
         */
        constructor() {
            this._keyActionInfos= [];
            this._onDown= this.__onDown.bind(this);
            this._onUp= this.__onUp.bind(this);
            this._modifiers= buildKeyModifiers();
        }

        __onDown( e:KeyboardEvent ) {

            var key:number= e.which ? e.which : e.keyCode;
            var time:number=new Date().getTime();

            if ( !this.__setModifiers( key, true ) ) {
                for( var i=0;i<this._keyActionInfos.length;i++ ) {
                    this._keyActionInfos[i].down( this._modifiers, key, time )
                }
            }
        }

        __onUp( e:KeyboardEvent ) {

            var key:number= e.which ? e.which : e.keyCode;
            var time:number=new Date().getTime();

            if ( !this.__setModifiers( key, false ) ) {
                for( var i=0;i<this._keyActionInfos.length;i++ ) {
                    this._keyActionInfos[i].up( this._modifiers, key, time )
                }
            }
        }

        __setModifiers( key:number, down:boolean ) {
            if ( this._modifiers.hasOwnProperty(key) ) {
                this._modifiers[key]= down;
                return true;
            }

            return false;
        }

        /**
         * Register and Enable the keyboard manager.
         * @method cc.input.KeyboardInputManager#enable
         */
        enable() {
            if ( !this._enabled ) {
                window.addEventListener("keydown", this._onDown, false);
                window.addEventListener("keyup", this._onUp, false);
                this._enabled= true;
            }
        }

        /**
         * Disable the keyboard manager and remove keyboard listeners.
         * @method cc.input.KeyboardInputManager#enable
         */
        disable() {
            if ( this._enabled ) {
                window.removeEventListener("keydown", this._onDown, false);
                window.removeEventListener("keyup", this._onUp, false);
                this._enabled= false;
            }
        }

        /**
         * Add a callback for a key sequence. Fired on 'down' of the last sequence key.
         * @method cc.input.KeyboardInputManager#onDown
         * @param keys {string}
         * @param callback {function()}
         * @returns {number}
         */
        onDown( keys:string, callback:()=>any ) : number {
            var kai:KeyActionInfo= new KeyActionInfo(keys, "down", callback);
            this._keyActionInfos.push( kai );
            return kai.getId();
        }

        /**
         * Add a callback for a key sequence. Fired on 'up' of the last sequence key.
         * @method cc.input.KeyboardInputManager#onUp
         * @param keys {string}
         * @param callback {function()}
         * @returns {number}
         */
        onUp( keys:string, callback:()=>any ) : number {
            var kai:KeyActionInfo= new KeyActionInfo(keys, "up", callback);
            this._keyActionInfos.push( kai );
            return kai.getId();
        }

        /**
         * Register a cursor object with the cursor keys defined in the initializer.
         * @method cc.input.KeyboardInputManager#registerCursor
         * @param cd {cc.input.CursorInitializer}
         * @param callback {function({string},{boolean}) a callback function invoked with the cursor event name and
         *        status of the cursor key.
         * @returns {number}
         */
        registerCursor( cd:CursorInitializer, callback:(key:string,down:boolean)=>any ) : number {
            var kc= new KeyboardCursor( this, cd, callback );
            this._cursors[ kc.getId() ]= kc;
            return kc.getId();
        }

        /**
         * Unregister a KeyboardCursor object.
         * @method cc.input.KeyboardInputManager#unregisterCursor
         * @param id {number}
         */
        unregisterCursor( id:number ) {

            if ( this._cursors.hasOwnProperty(id) ) {
                this._cursors[id].unregister(this);
                this._cursors[id]= null;
            }
        }

        /**
         * Remove a key sequence from the keyboard manager.
         * @method cc.input.KeyboardInputManager#removeActionInfo
         * @param id {number}
         */
        removeActionInfo( id : number ) {
            for( var i=0; i<this._keyActionInfos.length; i++ ) {
                if ( this._keyActionInfos[i].getId()===id ) {
                    this._keyActionInfos.splice(i,1);
                    return;
                }
            }
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="../node/Director.ts"/>

/// <reference path="../render/ScaleManager.ts"/>
/// <reference path="../plugin/asset/AssetManager.ts"/>
/// <reference path="../plugin/loader/Loader.ts"/>
/// <reference path="../plugin/loader/Resource.ts"/>

module cc.game {

    import Resource= cc.plugin.loader.Resource;
    import ResourcesMap= cc.plugin.asset.ResourcesMap;

    /**
     * @class cc.game.ResolutionInitializer
     * @interface
     * @classdesc
     *
     * ScaleManager resolution, orientation and units initialization info.
     */
    export interface ResolutionInitializer {


        width: number;
        height: number;

        unitsWidth?: number;
        unitsHeight?: number;

        canvasElement?: string;
        scaleStrategy?: string;
        canvasPosition?: string;
        orientation?: string;

        renderer?:string;
    }

    /**
     * @class cc.game.Game
     * @classdesc
     *
     * Helper object to glue all CocosJS components together.
     * The game object builds a default Director, is able to define orientation, scale and content scale, load assets
     * and preload them into the asset manager, etc. etc.
     *
     */
    export class Game {

        _director:cc.node.Director;
        _renderer:cc.render.Renderer;

        constructor() {

            this._director= new cc.node.Director();
        }

        setDesignResolutionSize( ri: ResolutionInitializer ) : cc.game.Game {

            if ( typeof ri==="undefined" ) {
                ri = {
                    width: 800,
                    height: 600
                };
            }
            if ( typeof ri.canvasPosition==="undefined") {
                ri.canvasPosition="center";
            }
            if ( typeof ri.scaleStrategy==="undefined") {
                ri.scaleStrategy="scale_aspect";
            }
            if ( typeof ri.orientation==="undefined") {
                ri.orientation="both";
            }

            var renderer;
            if ( typeof ri.renderer==="string" ) {
                if ( ri.renderer==="canvas" ) {
                    renderer= new cc.render.CanvasRenderer( ri.width, ri.height, <HTMLCanvasElement>document.getElementById(ri.canvasElement) );
                } else if ( ri.renderer==="webgl" ) {
                    renderer= new cc.render.WebGLRenderer( ri.width, ri.height, <HTMLCanvasElement>document.getElementById(ri.canvasElement) );
                } else {
                    // autodetect
                    renderer= cc.render.autodetectRenderer( ri.width, ri.height, ri.canvasElement );
                }
            }

            this._director.setRenderer( renderer );
            this._renderer= renderer;

            ri.scaleStrategy= ri.scaleStrategy.toUpperCase();
            ri.canvasPosition= ri.canvasPosition.toUpperCase();
            ri.orientation= ri.orientation.toUpperCase();

            var st:cc.render.ScaleManagerStrategy= cc.render.ScaleManagerStrategy[ ri.scaleStrategy ] ||
                cc.render.ScaleManagerStrategy.SCALE_FIT;
            var sp:cc.render.ScalePosition= cc.render.ScalePosition[ ri.canvasPosition ] ||
                cc.render.ScalePosition.CENTER;
            var co:cc.render.OrientationStrategy= cc.render.OrientationStrategy[ ri.orientation ] ||
                cc.render.OrientationStrategy.BOTH;

            this._renderer.setScaleStrategy( st, sp );
            this._renderer.setOrientationStrategy( co );

            return this;
        }

        load(   assets:string[],
                _onLoad: (game:cc.game.Game)=>any,
                _onProgress: (resource:Resource, index:number, size:number, errored:boolean)=>any,
                _onError: (resource:Resource)=>any ) {

            var me=this;

            cc.plugin.asset.AssetManager.load(
                {
                    resources:assets
                },
                function onLoad( resources: ResourcesMap ) {

                    if ( cc.__BACKWARDS_COMPATIBILITY__ ) {
                        cc.plugin.asset.AssetManager.mergeResources( resources )
                    }

                    _onLoad( me );
                },
                function onProgress(resource:Resource, index:number, size:number, errored:boolean) {
                    if (typeof _onProgress!=="undefined" ) {
                        _onProgress(resource,index,size,errored);
                    }
                },
                function onError(resource:Resource) {
                    if( typeof _onError!=="undefined" ) {
                        _onError( resource );
                    }
                }
            );

        }

        runScene( scene:cc.node.Scene ) {
            this._director.runScene( scene );
        }


        /**
         * Return the internal scale management object.
         * This object handles all things relative to Renderer surface scale and on-screen positioning, as well as
         * orientation changes and content scale ratio calculations.
         * @method cc.node.Director#getScaleManager
         * @see cc.game.ScaleManager
         * @returns {cc.game.ScaleManager}
         */
        getScaleManager() : cc.render.ScaleManager {
            return this._renderer.getScaleManager();
        }

        /**
         * Set renderer surface scale strategy.
         * @method cc.node.Director#setScaleStrategy
         * @param ss {cc.render.ScaleManagerStrategy} how renderer surface should me up/down scaled when the window
         *          changes size.
         * @param sp {cc.render.ScalePosition} how to position the renderer surface on the window object.
         */
        setScaleStrategy( ss:cc.render.ScaleManagerStrategy, sp:cc.render.ScalePosition ) {
            this._renderer.setScaleStrategy(ss,sp);
        }

        /**
         * Set internal ratio to adjust screen pixels to game units.
         * A game, usually makes the assumption that one game unit maps directly to one screen pixel.
         * When we want to build better looking games which honor devicePixelRation, retina, etc. we need to undo
         * this direct assumption in favor of other better mechanisms.
         * This method undoes this mapping.
         * For example, my game is 8 by 5 meters and want to see it in a 960x640 pixels screen.
         * The difference between this method and <code>setScaleStrategy</code> is that this one acts in game content,
         * and setScaleStrategy on the renderer generated image.
         * @method cc.node.Director#setScaleContent
         * @see cc.game.ScaleManager
         * @param w {number} game units width
         * @param h {number} game units height
         * @param cw {number=} canvas width
         * @param ch {number=} canvas height
         * @return {number} the scale factor resulting from the map units-pixels.
         */
        setScaleContent( w:number, h:number, cw?:number, ch?:number ) : number {
            this._renderer.setScaleContent(w,h,cw,ch);
            return this._renderer.getUnitsFactor();
        }

        /**
         * When <code>setScaleContent</code> has been called this method gives the scale factor for the units-pixel
         * mapping ratio.
         * @method cc.node.Director#getUnitsFactor
         * @returns {number}
         */
        getUnitsFactor() : number {
            return this._renderer.getUnitsFactor();
        }

        /**
         * Set renderer surface orientation strategy. If set to landscape or portrait, when the window changes size
         * will notify about valid or wrong orientation.
         * Default orientation is set to BOTH.
         * @method cc.node.Director#setOrientationStrategy
         * @param os {cc.render.OrientationStrategy} desired orientation.
         * @param onOk {cc.render.OrientationCallback}
         * @param onError {cc.render.OrientationCallback}
         */
        setOrientationStrategy( os:cc.render.OrientationStrategy, onOk?:cc.render.OrientationOkCallback, onError?:cc.render.OrientationErrorCallback ) {
            this._renderer.forceOrientation(os,onOk,onError);
        }

        /**
         * Get whether the device has fullScreen capabilities
         * @method cc.node.Director#isFullScreenCapable
         * @returns {boolean}
         */
        isFullScreenCapable() : boolean {
            return this._renderer.isFullScreenCapable();
        }

        /**
         * Is currently the system in full screen ?
         * @method cc.node.Director#isFullScreen
         * @returns {boolean}
         */
        isFullScreen() : boolean {
            return this._renderer.isFullScreen();
        }

        /**
         * Start full screen process. If the system is not full screen capable will silently fail.
         * @method cc.node.Director#startFullScreen
         * @param f {callback=} optional function called when the system enters full screen.
         */
        startFullScreen( f?:()=>any ) {
            this._renderer.startFullScreen(f);
        }

        /**
         * End full screen process. If the system is not full screen capable will silently fail.
         * @method cc.node.Director#endFullScreen
         * @param f {callback=} optional function called when the system enters full screen.
         */
        endFullScreen( f?:()=>any ) {
            this._renderer.endFullScreen(f);
        }
    }
}
/**
 * License: see license.txt file.
 */


/// <reference path="../math/Point.ts"/>
/// <reference path="../math/path/Segment.ts"/>
/// <reference path="../math/path/SegmentBezier.ts"/>
/// <reference path="../math/Path.ts"/>
/// <reference path="../node/Node.ts"/>
/// <reference path="../node/sprite/Animation.ts"/>
/// <reference path="../action/Action.ts"/>
/// <reference path="../action/MoveAction.ts"/>
/// <reference path="../action/RotateAction.ts"/>
/// <reference path="../action/ScaleAction.ts"/>
/// <reference path="../action/PropertyAction.ts"/>
/// <reference path="../action/SequenceAction.ts"/>
/// <reference path="../action/TintAction.ts"/>
/// <reference path="../action/AlphaAction.ts"/>
/// <reference path="../action/AnimateAction.ts"/>
/// <reference path="../action/PathAction.ts"/>
/// <reference path="../action/JumpAction.ts"/>
/// <reference path="../action/TimeInterpolator.ts"/>

module cc {
    "use strict";

    export var __BACKWARDS_COMPATIBILITY__ = true;

    import Vector = cc.math.Vector;
    import Point = cc.math.Point;

    import Node= cc.node.Node;
    import NodeDirtyFlags= cc.node.NodeDirtyFlags;
    import Action = cc.action.Action;
    import MoveAction = cc.action.MoveAction;
    import RotateAction = cc.action.RotateAction;
    import PropertyAction = cc.action.PropertyAction;
    import SequenceAction = cc.action.SequenceAction;
    import TintAction = cc.action.TintAction;
    import AlphaAction = cc.action.AlphaAction;
    import ScaleAction = cc.action.ScaleAction;
    import AnimateAction = cc.action.AnimateAction;
    import PathAction = cc.action.PathAction;
    import JumpAction = cc.action.JumpAction;
    import SegmentBezier = cc.math.path.SegmentBezier;
    import Path = cc.math.Path;

    import TimeInterpolator = cc.action.TimeInterpolator;
    import Interpolator = cc.action.Interpolator;

    import Animation= cc.node.sprite.Animation;

    /**
     * Create a Animate like <code>AnimateAction</code> action.
     * @method cc.animate
     * @param animation {cc.node.sprite.Animation}
     * @returns {Action}
     */
    export function animate( animation : Animation ) : Action {
        return new AnimateAction( animation );
    }

    export function callFunc( fn:any, _this?:any, data? : any ) : Action {
        return new Action().
            onEnd( function( action:Action, target:Node ) : void {
                if ( typeof _this!=="undefined" ) {
                    fn.call( _this, target, data );
                } else {
                    fn( target, data );
                }
            } );
    }

    export function show( ) : Action {
        return new Action().
            onEnd( function( action:Action, target:Node ) : void {
                target.setVisible( !action._reversed );
            });
    }

    export function toggleVisibility( ) : Action {
        return new Action().
            onEnd( function( action:Action, target:Node ) : void {
                target.setVisible( !target.__isFlagSet(NodeDirtyFlags.VISIBLE) );
            });
    }

    export function hide( ) : Action {
        return new Action().
            onEnd( function( action:Action, target:Node ) : void {
                target.setVisible( action._reversed );
            });
    }

    export function place( v:Point ) : Action {
        return new Action().
            onEnd( function( action:Action, target:Node ) : void {
                target.setPosition(v.x,v.y);
            });
    }

    export function blink( timeInSecs:number, blinks:number ) {

        var originalVisibility:boolean= true;

        var action:Action= new Action().
            timeInfo(0,timeInSecs).
            onStart( function(action:Action, node:Node) {
                originalVisibility= node.__isFlagSet(NodeDirtyFlags.VISIBLE);
            }).
            onEnd( function(action:Action, node:Node) {
                node.setVisible(originalVisibility);
            });

        action.update= function(delta:number, node:Node) : any {
            delta%= 1/blinks;
            node.setVisible( delta>=1/blinks/2 );
        };

        return action;
    }

    export function jumpTo( timeInSecs:number, pos:Point, amplitude:number, jumps:number=1 ) {
        return __jump( timeInSecs, pos, amplitude, jumps, false );
    }

    export function jumpBy( timeInSecs:number, pos:Point, amplitude:number, jumps:number=1 ) {
        return __jump( timeInSecs, pos, amplitude, jumps, true );
    }

    function __jump( timeInSecs:number, pos:Point, amplitude:number, jumps:number, relative:boolean ) {
        return new JumpAction({
            type: "JumpAction",
            position : pos,
            jumps : jumps,
            amplitude : amplitude,
            relative : relative
        }).timeInfo( 0,timeInSecs );
    }

    function __catmull(timeInSecs:number, p:Array<Point>, tension:number, relative:boolean, closed:boolean):Action {

        var segment:Path = new Path().catmullRomTo(p, closed, tension);

        return new PathAction({type:"PathAction", segment: segment}).
            setRelative(relative).
            timeInfo(0, timeInSecs );

    }

    export function cardinalSplineTo(timeInSecs:number, p:Array<Point>, tension:number, closed:boolean = false):Action {
        return __catmull(timeInSecs, p, tension, false, closed);
    }

    export function cardinalSplineBy(timeInSecs:number, p:Array<Point>, tension:number, closed:boolean = false):Action {
        return __catmull(timeInSecs, p, tension, true, closed);
    }

    export function catmullRomTo(timeInSecs:number, p:Array<Point>, closed:boolean = false):Action {
        return __catmull(timeInSecs, p, 0, false, closed);
    }

    export function catmullRomBy(timeInSecs:number, p:Array<Point>, closed:boolean = false):Action {
        return __catmull(timeInSecs, p, 0, true, closed);
    }

    function __bezier( timeInSecs : number, p : Array<Point>, relative : boolean ) : Action {
        return new PathAction({
            type : "PathAction",
            segment : new SegmentBezier({
                    p0 : { x:0, y:0 },
                    p1 : p[0],
                    p2 : p[1],
                    p3 : p[2]
                })
            }).
            setRelative( relative ).
            timeInfo( 0, timeInSecs );

    }

    export function bezierTo( timeInSecs : number, p : Array<Point> ) : Action {
        return __bezier( timeInSecs, p, false );
    }

    export function bezierBy( timeInSecs : number, p : Array<Point> ) : Action {
        return __bezier( timeInSecs, p, true );
    }

    function __move( timeInSecs : number, p : Point, relative : boolean ) : Action {
        return new MoveAction().
            to(p).
            setRelative( relative ).
            timeInfo( 0, timeInSecs );
    }

    /**
     * Create a moveTo like <code>MoveAction</code> action.
     * @method cc.moveTo
     * @param timeInSecs {number}
     * @param p {cc.math.Point}
     * @returns {Action}
     */
    export function moveTo( timeInSecs : number, p : Point ) : Action {
        return __move( timeInSecs, p, false );
    }

    /**
     * Create a moveBy like <code>MoveAction</code> action.
     * @method cc.moveBy
     * @param timeInSecs {number}
     * @param p {cc.math.Point}
     * @returns {Action}
     */
    export function moveBy( timeInSecs : number, p : Point ) : Action {
        return __move( timeInSecs, p, true );
    }

    function __scale( timeInSecs : number, x : number, y : number, relative : boolean ) : Action {
        return new ScaleAction().
            to( { x: x, y : y } ).
            setRelative( relative ).
            timeInfo( 0, timeInSecs );
    }

    /**
     * Create a scaleTo like <code>ScaleAction</code> action.
     * @method cc.scaleTo
     * @param timeInSecs {number}
     * @param x {number}
     * @param y {number}
     * @returns {Action}
     */
    export function scaleTo( timeInSecs : number, x : number, y? : number ) : Action {
        return __scale( timeInSecs, x, typeof y==="undefined" ? x : y, false);
    }

    /**
     * Create a scaleBy like <code>ScaleAction</code> action.
     * @method cc.scaleBy
     * @param timeInSecs {number}
     * @param x {number}
     * @param y {number}
     * @returns {Action}
     */
    export function scaleBy( timeInSecs : number, x : number, y? : number ) : Action {
        return __scale( timeInSecs, x, typeof y==="undefined" ? x : y, true);
    }

    function __rotate( timeInSecs : number, a : number, relative : boolean ) : Action {
        return new RotateAction().
            to( a ).
            setRelative( relative ).
            timeInfo( 0, timeInSecs );
    }

    /**
     * Create a rotateTo like <code>RotateAction</code> action.
     * @method cc.rotateTo
     * @param timeInSecs {number}
     * @param a {number}
     * @returns {Action}
     */
    export function rotateTo( timeInSecs : number, a : number ) : Action {
        return __rotate( timeInSecs, a, false);
    }

    /**
     * Create a rotateBy like <code>RotateAction</code> action.
     * @method cc.rotateBy
     * @param timeInSecs {number}
     * @param a {number}
     * @returns {Action}
     */
    export function rotateBy( timeInSecs : number, a : number ) : Action {
        return __rotate( timeInSecs, a, true);
    }

    /**
     * Create a fadeIn like <code>AlphaAction</code> action.
     * @method cc.fadeIn
     * @param timeInSecs {number}
     * @returns {cc.action.Action}
     */
    export function fadeIn( timeInSecs : number ) : Action {
        return new AlphaAction().
            from(0).
            to( 1 ).
            timeInfo( 0, timeInSecs );
    }

    /**
     * Create a fadeIn like <code>AlphaAction</code> action.
     * @method cc.fadeOut
     * @param timeInSecs {number}
     * @returns {cc.action.Action}
     */
    export function fadeOut( timeInSecs : number ) : Action {
        return new AlphaAction().
            from(1).
            to( 0 ).
            timeInfo( 0, timeInSecs );
    }

    function __fade( timeInSecs : number, a : number, relative : boolean ) : Action {
        return new AlphaAction().
            to( a/255 ).
            setRelative( relative ).
            timeInfo( 0, timeInSecs );
    }

    /**
     * Create a fadeTo like <code>AlphaAction</code> action.
     * @method cc.fadeTo
     * @param timeInSecs {number}
     * @param a {number}
     * @returns {Action}
     */
    export function fadeTo( timeInSecs : number, a : number ) : Action {
        return __fade( timeInSecs, a, false);
    }

    /**
     * Create a fadeBy like <code>AlphaAction</code> action.
     * @method cc.fadeBy
     * @param timeInSecs {number}
     * @param a {number}
     * @returns {Action}
     */
    export function fadeBy( timeInSecs : number, a : number ) : Action {
        return __fade( timeInSecs, a, true);
    }

    function __tint( timeInSecs : number, r : number, g : number, b : number, relative : boolean ) : Action {
        return new TintAction().
            to( { r: r/255, g : g/255, b: b/255 } ).
            setRelative( relative ).
            timeInfo( 0, timeInSecs );
    }

    /**
     * Create a tintTo like <code>TintAction</code> action.
     * @method cc.tintTo
     * @param timeInSecs {number}
     * @param r {number}
     * @param g {number}
     * @param b {number}
     * @returns {Action}
     */
    export function tintTo( timeInSecs : number, r : number, g : number, b : number ) : Action {
        return __tint( timeInSecs, r, g, b, false);
    }

    /**
     * Create a tintBy like <code>TintAction</code> action.
     * @method cc.tintBy
     * @param timeInSecs {number}
     * @param r {number}
     * @param g {number}
     * @param b {number}
     * @returns {Action}
     */
    export function tintBy( timeInSecs : number, r : number, g : number, b : number ) : Action {
        return __tint( timeInSecs, r, g, b, true);
    }

    /**
     * Reverses the target action
     * @method cc.reverseTime
     * @param action {cc.action.Action}
     * @returns {cc.reverseTime}
     */
    export function reverseTime( action : Action ) : Action {
        action.setReversedTime( !action.isReversedTime() );
        return this;
    }

    /**
     * Make an action repeat a number of times.
     * @method cc.repeat
     * @param action {cc.action.Action}
     * @param times {number}
     * @returns {Action}
     */
    export function repeat( action : Action, times : number ) : Action {
        if ( times<1 ) {
            times=1;
        }
        action.setRepeatTimes( times );
        return action;
    }

    /**
     * Make an action repeat forever.
     * @method cc.repeatForever
     * @param action {cc.action.Action}
     * @returns {Action}
     */
    export function repeatForever( action : Action ) : Action {
        action.setRepeatForever();
        return action;
    }

    /**
     * Create an action that waits the given time.
     * @method cc.delayTime
     * @param delayInSecs {number}
     * @returns {cc.action.Action}
     */
    export function delayTime( delayInSecs : number ) : Action {
        return new PropertyAction().
            from({}).
            to({}).
            timeInfo(0,delayInSecs);
    }

    export function __sequence( sequential : boolean, actions : Array<Action> ) : SequenceAction {

        var seq= new SequenceAction( {sequential : sequential} );

        if (!actions.length) {
            return null;
        }

        for( var i=0; i<actions.length; i++ ) {
            seq.addAction( actions[i] );
        }

        return seq;
    }

    /**
     * Set an action speed.
     * @method cc.speed
     * @param action {cc.action.Action}
     * @param speed {number} speed 1 is the default speed. speed 2 will make the action to take twice the time.
     * @returns {Action}
     */
    export function speed( action : Action, speed : number) : Action {
        action.setSpeed( speed );
        return action;
    }

    /**
     * Create a Sequence of Actions.
     * Actions can be other Sequences or Spawns.
     * @method cc.sequence
     * @param actions {Array<cc.action.Action>}
     * @returns {SequenceAction}
     */
    export function sequence( ...actions : Array<Action> ) : SequenceAction {
        return __sequence( true, actions );
    }

    /**
     * Create a Spawn of Actions.
     * Actions can be other Sequences or Spawns.
     * @methos cc.spawn
     * @param actions {Array<cc.action.Action>}
     * @returns {SequenceAction}
     */
    export function spawn( ...actions : Array<Action> ) : SequenceAction {
        return __sequence( false, actions );
    }


    /**
     * Apply easing to an action time.
     * @method cc.easing
     * @param action {cc.action.Action}
     * @param interpolator {cc.action.TimeInterpolator}
     * @returns {Action}
     */
    export function easing( action : Action, interpolator : TimeInterpolator ) : Action {
        return action.easing(interpolator);
    }

    function __interpolator( interpolator:TimeInterpolator, action?:Action ) : any {
        return typeof action!=="undefined" ?
            easing( action, interpolator ) :
            interpolator;
    }

    /**
     * Apply BackIn easing to an action
     * @method cc.easeBackIn
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeBackIn( action?:Action ) : any {
        return __interpolator( Interpolator.EaseBackIn(false,false), action );
    }

    /**
     * Apply easeBackOut easing to an action.
     * @method cc.easeBackOut
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeBackOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseBackOut(false,false), action);
    }

    /**
     * Apply easeBackInOut easing to an action.
     * @method cc.easeBackInOut
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeBackInOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseBackInOut(false,false), action );
    }

    /**
     * Apply BounceIn easing to an action
     * @method cc.easeBounceIn
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeBounceIn( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseBounceIn(false,false), action );
    }

    /**
     * Apply easeBounceOut easing to an action.
     * @method cc.easeBounceOut
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeBounceOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseBounceOut(false,false), action );
    }

    /**
     * Apply easeBounceInOut easing to an action.
     * @method cc.easeBounceInOut
     * @param action {cc.action.Action=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeBounceInOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseBounceInOut(false,false), action );
    }

    /**
     * Apply elasticlIn easing to an action
     * @method cc.easeElasticIn
     * @param action {cc.action.Action|number=}
     * @param period {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeElasticIn( action?:any, period?:number ) : Action {

        var int:TimeInterpolator= Interpolator.EaseElasticIn(
            ( typeof action==="undefined" ) ? <number>action : period,
            false,false);

        return __interpolator( int, action );
    }

    /**
     * Apply elasticOut easing to an action.
     * @method cc.easeElasticOut
     * @param action {cc.action.Action|number=}
     * @param period {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeElasticOut( action:any, period?:number ) : Action {
        var int:TimeInterpolator= Interpolator.EaseElasticOut(
            ( typeof action==="undefined" ) ? <number>action : period,
            false,false);

        return __interpolator( int, action );
    }

    /**
     * Apply elasticInOut easing to an action.
     * @method cc.easeElasticInOut
     * @param action {cc.action.Action|number}
     * @param period {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeElasticInOut( action:any, period?:number ) : Action {
        var int:TimeInterpolator= Interpolator.EaseElasticInOut(
            ( typeof action==="undefined" ) ? <number>action : period,
            false,false);

        return __interpolator( int, action );
    }

    /**
     * Apply exponentialIn easing to an action. Exponent 2.
     * @method cc.easeIn
     * @param action {cc.action.Action|number}
     * @param exponent {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeIn( action:any, exponent:number ) : Action {
        var int:TimeInterpolator= Interpolator.EaseIn(
            ( typeof action==="undefined" ) ? <number>action : exponent,
            false,false);

        return __interpolator( int, action );
    }

    /**
     * Apply exponentialIn easing to an action. Exponent 2.
     * @method cc.easeOut
     * @param action {cc.action.Action}
     * @param exponent {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeOut( action:any, exponent?:number ) : Action {
        var int:TimeInterpolator= Interpolator.EaseOut(
            ( typeof action==="undefined" ) ? <number>action : exponent,
            false,false);

        return __interpolator( int, action );
    }

    /**
     * Apply exponentialInOut easing to an action. Exponent 2.
     * @method cc.easeInOut
     * @param action {cc.action.Action}
     * @param exponent {number=}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeInOut( action:any, exponent?:number ) : Action {
        var int:TimeInterpolator= Interpolator.EaseInOut(
            ( typeof action==="undefined" ) ? <number>action : exponent,
            false,false);

        return __interpolator( int, action );
    }

    /**
     * Apply exponentialIn easing to an action. Exponent 2.
     * @method cc.easeExponentialIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeExponentialIn( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseExponentialIn(false,false), action );

    }

    /**
     * Apply exponentialOut easing to an action. Exponent 2.
     * @method cc.easeExponentialOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeExponentialOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseExponentialOut(false,false), action );
    }

    /**
     * Apply exponentialInOut easing to an action. Exponent 2.
     * @method cc.easeExponentialInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeExponentialInOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseExponentialInOut(false,false), action );
    }

    /**
     * Apply sineIn easing to an action. Exponent 2.
     * @method cc.easeSineIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeSineIn( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseSineIn(false,false), action );
    }

    /**
     * Apply sineOut easing to an action. Exponent 2.
     * @method cc.easeSineOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeSineOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseSineOut(false,false), action );
    }

    /**
     * Apply sineInOut easing to an action. Exponent 2.
     * @method cc.easeSineInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeSineInOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseSineInOut(false,false), action );
    }

    /**
     * Apply exponentialIn easing to an action. Exponent 2.
     * @method cc.easeQuadraticActionIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeQuadraticActionIn( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseIn(2,false,false), action );
    }

    /**
     * Apply exponentialOut easing to an action. Exponent 2.
     * @method cc.easeQuadraticActionOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeQuadraticActionOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseOut(2,false,false), action );
    }

    /**
     * Apply exponentialInOut easing to an action. Exponent 2.
     * @method cc.easeQuadraticActionInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeQuadraticActionInOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseInOut(2,false,false), action );
    }

    /**
     * Apply exponentialIn easing to an action. Exponent 3.
     * @method cc.easeCubicActionIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeCubicActionIn( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseIn(3,false,false), action );
    }

    /**
     * Apply exponentialOut easing to an action. Exponent 3.
     * @method cc.easeCubicActionOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeCubicActionOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseOut(3,false,false), action );
    }

    /**
     * Apply exponentialInOut easing to an action. Exponent 3.
     * @method cc.easeCubicActionInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeCubicActionInOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseInOut(3,false,false), action );
    }

    /**
     * Apply exponentialIn easing to an action. Exponent 4.
     * @method cc.easeQuarticlActionIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeQuarticlActionIn( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseIn(4,false,false), action );
    }

    /**
     * Apply exponentialOut easing to an action. Exponent 4.
     * @method cc.easeQuarticActionOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeQuarticActionOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseOut(4,false,false), action );
    }

    /**
     * Apply exponentialInOut easing to an action. Exponent 4.
     * @method cc.easeQuarticActionInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeQuarticActionInOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseInOut(4,false,false), action );
    }

    /**
     * Apply exponentialIn easing to an action. Exponent 5.
     * @method cc.easeQuinticlActionIn
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeQuinticActionIn( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseIn(5,false,false), action );
    }

    /**
     * Apply exponentialOut easing to an action. Exponent 5.
     * @method cc.easeQuinticlActionOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeQuinticActionOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseOut(5,false,false), action );
    }

    /**
     * Apply exponentialInOut easing to an action. Exponent 5.
     * @method cc.easeQuinticlActionInOut
     * @param action {cc.action.Action}
     * @returns {cc.action.Action|cc.action.Interpolator}
     */
    export function easeQuinticActionInOut( action?:Action ) : Action {
        return __interpolator( Interpolator.EaseInOut(5,false,false), action );
    }

}

/**
 * License: see license.txt file.
 */


/// <reference path="./Action.ts"/>

/*
 * Cocos2D HTML5 Version 2 backwards compatibility actions.
 * These symbols are optional to be used in V4 API.
 */
module cc {

    "use strict";

    export module EaseBackIn {
        export var create = cc.easeBackIn;
    }

    export module EaseBackOut {
        export var create = cc.easeBackOut;
    }

    export module EaseBackInOut {
        export var create = cc.easeBackInOut;
    }

    export module EaseBounceIn {
        export var create = cc.easeBounceIn;
    }

    export module EaseBounceOut {
        export var create = cc.easeBounceOut;
    }

    export module EaseBounceInOut {
        export var create = cc.easeBounceInOut;
    }

    export module EaseElasticIn {
        export var create = cc.easeElasticIn;
    }

    export module EaseElasticOut {
        export var create = cc.easeElasticOut;
    }

    export module EaseElasticInOut {
        export var create = cc.easeElasticInOut;
    }

    export module EaseSineIn {
        export var create = cc.easeSineIn;
    }

    export module EaseSineOut {
        export var create = cc.easeSineOut;
    }

    export module EaseSineInOut {
        export var create = cc.easeSineInOut;
    }

    export module CatmullRomTo {
        export var create = cc.catmullRomTo;
    }

    export module CatmullRomBy {
        export var create = cc.catmullRomBy;
    }

    export module CardinalSplineTo {
        export var create = cc.cardinalSplineTo;
    }

    export module CardinalSplineBy {
        export var create = cc.cardinalSplineBy;
    }

    export module BezierTo {
        export var create = cc.bezierTo;
    }

    export module BezierBy {
        export var create = cc.bezierBy;
    }

    export module MoveTo {
        export var create = cc.moveTo;
    }

    export module MoveBy {
        export var create = cc.moveBy;
    }

    export module ScaleTo {
        export var create = cc.scaleTo;
    }

    export module ScaleBy {
        export var create = cc.scaleBy;
    }

    export module RotateTo {
        export var create = cc.rotateTo;
    }

    export module RotateBy {
        export var create = cc.rotateBy;
    }

    export module FadeIn {
        export var create = cc.fadeIn;
    }

    export module FadeOut {
        export var create = cc.fadeOut;
    }

    export module FadeTo {
        export var create = cc.fadeTo;
    }

    export module FadeBy {
        export var create = cc.fadeBy;
    }

    export module TintTo {
        export var create = cc.tintTo;
    }

    export module TintBy {
        export var create = cc.tintBy;
    }

    export module ReverseTime {
        export var create = cc.reverseTime;
    }

    export module Repeat {
        export var create = cc.repeat;
    }

    export module RepeatForever {
        export var create = cc.repeatForever;
    }

    export module DelayTime {
        export var create = cc.delayTime;
    }

    export module Speed {
        export var create = cc.speed;
    }

    export module Sequence {
        export var create = cc.sequence;
    }

    export module Spawn {
        export var create = cc.spawn;
    }

    export module Easing {
        export var create = cc.easing;
    }

    export module EaseIn {
        export var create = cc.easeIn;
    }

    export module EaseOut {
        export var create = cc.easeOut;
    }

    export module EaseInOut {
        export var create = cc.easeInOut;
    }

    export module EaseExponentialIn {
        export var create = cc.easeExponentialIn;
    }

    export module EaseExponentialOut {
        export var create = cc.easeExponentialOut;
    }

    export module EaseExponentialInOut {
        export var create = cc.easeExponentialInOut;
    }

    export module EaseQuadraticActionIn {
        export var create = cc.easeQuadraticActionIn;
    }

    export module EaseQuadraticActionOut {
        export var create = cc.easeQuadraticActionOut;
    }

    export module EaseQuadraticActionInOut {
        export var create = cc.easeQuadraticActionInOut;
    }

    export module EaseCubicActionIn {
        export var create = cc.easeCubicActionIn;
    }

    export module EaseCubicActionOut {
        export var create = cc.easeCubicActionOut;
    }

    export module EaseCubicInOut {
        export var create = cc.easeCubicActionInOut;
    }

    export module EaseQuarticActionIn {
        export var create = cc.easeQuarticlActionIn;
    }

    export module EaseQuarticActionOut {
        export var create = cc.easeQuarticActionOut;
    }

    export module EaseQuarticActionInOut {
        export var create = cc.easeQuarticActionInOut;
    }

    export module EaseQuinticActionIn {
        export var create = cc.easeQuinticActionIn;
    }

    export module EaseQuinticActionOut {
        export var create = cc.easeQuinticActionOut;
    }

    export module EaseQuinticActionInOut {
        export var create = cc.easeQuinticActionInOut;
    }

    export module CallFunc {
        export var create = cc.callFunc;
    }

    export module Animate {
        export var create = cc.animate;
    }

    export module Show {
        export var create = cc.show;
    }

    export module Hide {
        export var create = cc.hide;
    }

    export module Place {
        export var create = cc.place;
    }

    export module ToggleVisibility {
        export var create = cc.toggleVisibility;
    }

    export module JumpTo {
        export var create = cc.jumpTo;
    }

    export module JumpBy {
        export var create = cc.jumpBy;
    }

    export module Blink {
        export var create = cc.blink;
    }
}
/**
 * License: see license.txt file
 */

/// <reference path="../math/Color.ts"/>
/// <reference path="../math/Point.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="../node/Director.ts"/>
/// <reference path="../node/sprite/Animation.ts"/>
/// <reference path="../util/Class.ts"/>
/// <reference path="../plugin/audio/AudioManager.ts"/>

module cc {

    import Color= cc.math.Color;
    import RGBAColor= cc.math.RGBAColor;
    import Point= cc.math.Point;
    import Vector= cc.math.Vector;

    export function rect( x:number, y:number, w:number, h:number ) : cc.math.Rectangle {
        return new cc.math.Rectangle(x,y,w,h);
    }

    /**
     * Create a new Point/Vector object.
     * @param x {number}
     * @param y {number}
     * @returns {cc.math.Vector}
     * @deprecated call <code>new cc.math.Vector(x,y);</code>
     * @see {cc.math.Vector}
     */
    export function p( x:number, y:number ) {
        return new Vector( x, y );
    }

    export function size(w:number, h:number) {
        return new cc.math.Dimension(w,h);
    }

    /**
     * create a new Color full opaque.
     * @param r {number}
     * @param g {number}
     * @param b {number}
     * @returns {cc.math.Color}
     * @deprecated call <code>new cc.math.Color(r,g,b,a?);</code>
     * @see {cc.math.Color}
     */
    export function c3b( r:number, g:number, b:number ) {
        return new cc.math.Color( r/255, g/255, b/255 );
    }

    /**
     * create a new Color with RGBA
     * @param r {number}
     * @param g {number}
     * @param b {number}
     * @param a {number}
     * @returns {cc.math.Color}
     * @deprecated call <code>new cc.math.Color(r,g,b,a);</code>
     * @see {cc.math.Color}
     */
    export function c4b( r:number, g:number, b:number, a:number ) {
        return new cc.math.Color( r/255, g/255, b/255, a/255 );
    }

    /**
     *
     * @param r {number|string|{r:number,g:number,b:number,a:number=}}
     * @param g {number} 0..255
     * @param b {number} 0..255
     * @param a {number=} 0..255
     * @returns {*}
     */
    export function color(r:any, g:number, b:number, a?:number) {
        if ( typeof r === 'undefined') {
            return Color.BLACK;
        }
        if (typeof r==='string') {
            return Color.fromStringToColor(<string>r);
        }
        if (typeof r==='object') {
            return Color.createFromRGBA(<RGBAColor>r);
        }

        if (typeof a==="undefined") {
            a= 255;
        }
        return new Color( r/255,g/255,b/255,a/255 );
    }

    /**
     * @name Director
     * @memberOf cc
     * @deprecated
     */
    export module Director {

        var directorInstance : cc.node.Director = null;

        /**
         * Get always the same director instance.
         * @method cc.Director.getInstance
         * @returns {cc.node.Director}
         */
        export function getInstance() {

            if ( directorInstance===null ) {
                directorInstance= new cc.node.Director();
            }

            return directorInstance;
        }
    }

    export var director:cc.node.Director= null;

    export function scene() {
        return new cc.node.Scene( );
    }
    export var Scene= cc.node.Scene;

    export function animation() {
        return new cc.node.sprite.Animation();
    }

    export function sprite(p) {
        return new cc.node.Sprite(p);
    }
    export var Sprite= cc.node.Sprite;
    export var SpriteBatchNode= cc.node.SpriteBatchNode;

    export function layer() {
        return new cc.node.Node( );
    }
    export var Layer= cc.node.Node;

    export var Node= cc.node.Node;

    export var LabelBMFont= cc.widget.Label;
    export var LabelTTF= cc.widget.LabelTTF;

    export function Animation( frames:cc.node.sprite.SpriteFrame[], duration:number ) {
        var animation= new cc.node.sprite.Animation();
        animation.addFrames( frames );
        animation.setDelayPerUnit( duration );
        return animation;
    }

    (<any>Animation).create = cc.animation;

    export var TransitionSlideInL = function( time_in_secs:number, scene?:cc.node.Scene ) {
        return new cc.transition.TransitionSlideInL( time_in_secs*1000, scene );
    };

    export var TransitionSlideInR = function( time_in_secs:number, scene?:cc.node.Scene ) {
        return new cc.transition.TransitionSlideInR( time_in_secs*1000, scene );
    };

    export var TransitionSlideInT = function( time_in_secs:number, scene?:cc.node.Scene ) {
        return new cc.transition.TransitionSlideInT( time_in_secs*1000, scene );
    };

    export var TransitionSlideInB  = function( time_in_secs:number, scene?:cc.node.Scene ) {
        return new cc.transition.TransitionSlideInB( time_in_secs*1000, scene );
    };

    export var TransitionFade = function( time_in_secs:number, scene?:cc.node.Scene ) {
        return new cc.transition.TransitionFade( time_in_secs*1000, scene );
    };

    export var TEXT_ALIGNMENT_LEFT= 0;
    export var TEXT_ALIGNMENT_CENTER= 1;
    export var TEXT_ALIGNMENT_RIGHT= 2;

    export var VERTICAL_TEXT_ALIGNMENT_TOP = 0;
    export var VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
    export var VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;

    export var pAdd= cc.math.Vector.add;

    export function clampf(value, min_inclusive, max_inclusive) {
        if (min_inclusive > max_inclusive) {
            var temp = min_inclusive;
            min_inclusive = max_inclusive;
            max_inclusive = temp;
        }
        return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
    }

    export function pClamp(p, min_inclusive, max_inclusive) {
        return cc.p(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y));
    }

    export var audioEngine= (function() {

        var ae:cc.plugin.audio.AudioManager= new cc.plugin.audio.AudioManager();

        return {
            playMusic : function( url ) {
                ae.setMusic(url, true);
            },
            stopMusic : function() {
                ae.stopMusic();
            },
            stopAllEffects : function() {
                ae.stopEffects();
            },
            playEffect : function(name) {

                var r= cc.plugin.asset.AssetManager._resources[name];
                if ( r ) {
                    ae.playEffect(r);
                }
            },
            setMusicVolume : function( vol ) {
                ae.setMusicVolume(vol);
            }
        }

    }) ();

    export function rectIntersectsRect( r0:cc.math.Rectangle, r1:cc.math.Rectangle ) {
        return r0.intersectsWith(r1);
    }

    export var KEY= cc.input.KEYS;

    // blending constants. Use node.setCompositeOperation instead.
    export var ONE = 1;
    export var ZERO = 0;
    export var SRC_ALPHA = 0x0302;
    export var SRC_ALPHA_SATURATE = 0x308;
    export var SRC_COLOR = 0x300;
    export var DST_ALPHA = 0x304;
    export var DST_COLOR = 0x306;
    export var ONE_MINUS_SRC_ALPHA = 0x0303;
    export var ONE_MINUS_SRC_COLOR = 0x301;
    export var ONE_MINUS_DST_ALPHA = 0x305;
    export var ONE_MINUS_DST_COLOR = 0x0307;
    export var ONE_MINUS_CONSTANT_ALPHA	= 0x8004;
    export var ONE_MINUS_CONSTANT_COLOR	= 0x8002;

}

/// <reference path="./AssetManager.ts"/>
/// <reference path="../loader/Resource.ts"/>
/// <reference path="../asset/AssetManager.ts"/>

module cc {

    import Resource= cc.plugin.loader.Resource;

    var path = {

        join: function () {
            var l = arguments.length;
            var result = "";
            for (var i = 0; i < l; i++) {
                result = (result + (result == "" ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
            }
            return result;
        },

        extname: function (pathStr) {
            var temp = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(pathStr);
            return temp ? temp[1] : null;
        },

        mainFileName: function (fileName) {
            if (fileName) {
                var idx = fileName.lastIndexOf(".");
                if (idx !== -1)
                    return fileName.substring(0, idx);
            }
            return fileName;
        },

        basename: function (pathStr, extname) {
            var index = pathStr.indexOf("?");
            if (index > 0) pathStr = pathStr.substring(0, index);
            var reg = /(\/|\\\\)([^(\/|\\\\)]+)$/g;
            var result = reg.exec(pathStr.replace(/(\/|\\\\)$/, ""));
            if (!result) return null;
            var baseName = result[2];
            if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() == extname.toLowerCase())
                return baseName.substring(0, baseName.length - extname.length);
            return baseName;
        },

        dirname: function (pathStr) {
            return pathStr.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, '$2');
        },

        changeExtname: function (pathStr, extname) {
            extname = extname || "";
            var index = pathStr.indexOf("?");
            var tempStr = "";
            if (index > 0) {
                tempStr = pathStr.substring(index);
                pathStr = pathStr.substring(0, index);
            }
            index = pathStr.lastIndexOf(".");
            if (index < 0) return pathStr + extname + tempStr;
            return pathStr.substring(0, index) + extname + tempStr;
        },

        changeBasename: function (pathStr, basename, isSameExt) {
            if (basename.indexOf(".") == 0) return this.changeExtname(pathStr, basename);
            var index = pathStr.indexOf("?");
            var tempStr = "";
            var ext = isSameExt ? this.extname(pathStr) : "";
            if (index > 0) {
                tempStr = pathStr.substring(index);
                pathStr = pathStr.substring(0, index);
            }
            index = pathStr.lastIndexOf("/");
            index = index <= 0 ? 0 : index + 1;
            return pathStr.substring(0, index) + basename + ext + tempStr;
        }
    };


    function getResource( id:string ) : any {
        var res:cc.plugin.asset.ResourcesMap= cc.plugin.asset.AssetManager._resources;
        return res[id];
    }

    export class spriteFrameCache {

        static addSpriteFrames( plist_url_file ) {

            var plist= getResource( plist_url_file );
            var imageName= plist[0].metadata.realTextureFileName;

            var imageResFile:string= path.changeBasename(plist_url_file, imageName || ".png", false);

            var resource= cc.plugin.asset.AssetManager._resources[ imageResFile ];

            cc.plugin.asset.AssetManager.addImage( resource, imageResFile );
            cc.director._renderer.prepareTexture( cc.plugin.asset.AssetManager.getTexture(imageResFile) );
            cc.plugin.asset.AssetManager.addSpriteFramesFromFrameWithPLIST( imageResFile, plist );
        }

        static getSpriteFrame( name:string ) {
            return cc.plugin.asset.AssetManager.getSpriteFrame( name );
        }
    }

    export class textureCache {

        static addImage( name:string ) : cc.render.Texture2D {

            var image= getResource( name );

            var texture:cc.render.Texture2D= cc.plugin.asset.AssetManager.addImage( image, name );
            cc.director._renderer.prepareTexture( texture );

            return texture;
        }
    }

    export class animationCache {
        static addAnimation( animation:cc.node.sprite.Animation, name:string ) {
            cc.plugin.asset.AssetManager.addAnimation( animation, name );
        }

        static getAnimation( name:string ) : cc.node.sprite.Animation {
            return cc.plugin.asset.AssetManager.getAnimationById( name );
        }
    }
}
/**
 * License: see license.txt file.
 */

/// <reference path="../node/Node.ts"/>
/// <reference path="../node/Sprite.ts"/>
/// <reference path="../node/FastSprite.ts"/>
/// <reference path="../node/Scene.ts"/>
/// <reference path="../action/Action.ts"/>

module cc {

    var initializing:boolean= false;

    // The base Class implementation (does nothing)
    var _Class:any= function() {
    };

    // Create a new Class that inherits from this class
    _Class.extend = function (extendingProt) {

        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // The dummy class constructor
        var CCClass:any= function() {
            // All construction is actually done in the ctor method
            if (!initializing && typeof this.ctor!=="undefined") {
                this.ctor.apply(this, arguments);
            }
        };

        // Populate our constructed prototype object
        CCClass.prototype = prototype;
        // Enforce the constructor to be what we expect
        CCClass.prototype.constructor = CCClass;
        CCClass.superclass = _super;
        // And make this class extendable
        CCClass.extend = _Class.extend;

        CCClass["__CLASS"] = name;

        extendingProt = (typeof extendingProt==="function" ? extendingProt() : extendingProt);

        // Copy the properties over onto the new prototype
        for (var fname in extendingProt) {


            var isFunc= typeof extendingProt[fname]==='function';
            var overrideIsFunc= typeof prototype[fname]==='function';

            // ctor (wrong) idiom.
            if ( fname==='ctor' ) {

                prototype[fname] = (function (name, fn, superconstructor) {
                    return function () {

                        var tmp = this._super;
                        this._super = function() {
                            superconstructor.apply(this, arguments);
                        };
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(fname, extendingProt[fname], this);


            } else if ( isFunc && overrideIsFunc && /\b_super\b/.test( extendingProt[fname] ) ) {

                // function with overriden function that uses _super in code

                prototype[fname] = (function (name, fn) {
                    return function () {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-Class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(fname, extendingProt[fname]);

            } else {
                // Check if we're overwriting an existing function
                prototype[fname] = extendingProt[fname];
            }
        }


        return CCClass;
    };

    (<any>cc.node.Node).extend =   _Class.extend;
    (<any>cc.node.Sprite).extend = _Class.extend;
    (<any>cc.node.FastSprite).extend = _Class.extend;
    (<any>cc.node.SpriteBatchNode).extend = _Class.extend;
    (<any>cc.node.Scene).extend =  _Class.extend;
    (<any>cc.action.Action).extend = _Class.extend;



    export var Class= _Class;

}